"use strict";
(self.webpackChunk_N_E = self.webpackChunk_N_E || []).push([
  [2918],
  {
    62249: function (_, L, R) {
      let N,
        z,
        F,
        U,
        k,
        Y,
        X,
        Q,
        K,
        J,
        $,
        ee,
        er,
        en,
        ea,
        eo,
        el,
        ec,
        ed,
        eu,
        ep,
        ef,
        ev,
        ex,
        eb,
        ew,
        e_,
        eA,
        eM,
        eE,
        eC,
        eP,
        eD,
        eO,
        eL,
        eR,
        eI,
        eB,
        ez,
        eF,
        eU,
        ek,
        ej,
        eG,
        eV,
        eH,
        eW,
        eY,
        eX,
        eq,
        eQ,
        eZ,
        eK,
        eJ,
        e$,
        e0,
        e2,
        e4,
        e6,
        e8,
        e9,
        e7,
        te,
        tt,
        ti,
        tr,
        tn,
        ta,
        to,
        tl,
        th,
        td,
        tu,
        tp,
        tg,
        tv,
        tx,
        tb,
        tw,
        t_,
        tS,
        tA,
        tM,
        tE,
        tT,
        tC,
        tD,
        tO,
        tL,
        tR,
        tI,
        tB,
        tz,
        tF,
        tU,
        tk,
        tj,
        tG,
        tV,
        tH,
        tW,
        tY,
        tX,
        tq,
        tQ,
        tZ,
        tK,
        tJ;
      R.d(L, {
        M: function () {
          return MU;
        },
      });
      var t$,
        t0,
        t2 = R(34155),
        t4 = R(48764).lW,
        t5 = Object.create,
        t6 = Object.defineProperty,
        t8 = Object.getOwnPropertyDescriptor,
        t9 = Object.getOwnPropertyNames,
        t7 = Object.getPrototypeOf,
        ie = Object.prototype.hasOwnProperty,
        Pf = (_, L) => () => (
          L || _((L = { exports: {} }).exports, L), L.exports
        ),
        bI = (_, L, R, N) => {
          if ((L && "object" == typeof L) || "function" == typeof L)
            for (let z of t9(L))
              ie.call(_, z) ||
                z === R ||
                t6(_, z, {
                  get: () => L[z],
                  enumerable: !(N = t8(L, z)) || N.enumerable,
                });
          return _;
        },
        dd = (_, L, R) => (
          (R = null != _ ? t5(t7(_)) : {}),
          bI(
            !L && _ && _.__esModule
              ? R
              : t6(R, "default", { value: _, enumerable: !0 }),
            _,
          )
        ),
        it = Pf((_, L) => {
          var R;
          (R = function () {
            return (
              (r.importState = function (_) {
                var L = new r();
                return L.importState(_), L;
              }),
              r
            );
            function r() {
              return (function (_) {
                var L,
                  R,
                  N = 0,
                  z = 0,
                  F = 0,
                  U = 1;
                0 == _.length && (_ = [+new Date()]);
                var k =
                  ((L = 4022871197),
                  ((R = function (_) {
                    _ = _.toString();
                    for (var R = 0; R < _.length; R++) {
                      var N = 0.02519603282416938 * (L += _.charCodeAt(R));
                      (L = N >>> 0),
                        (N -= L),
                        (N *= L),
                        (L = N >>> 0),
                        (N -= L),
                        (L += 4294967296 * N);
                    }
                    return (L >>> 0) * 23283064365386963e-26;
                  }).version = "Mash 0.9"),
                  R);
                (N = k(" ")), (z = k(" ")), (F = k(" "));
                for (var Y = 0; Y < _.length; Y++)
                  (N -= k(_[Y])) < 0 && (N += 1),
                    (z -= k(_[Y])) < 0 && (z += 1),
                    (F -= k(_[Y])) < 0 && (F += 1);
                k = null;
                var u = function () {
                  var _ = 2091639 * N + 23283064365386963e-26 * U;
                  return (N = z), (z = F), (F = _ - (U = 0 | _));
                };
                return (
                  (u.next = u),
                  (u.uint32 = function () {
                    return 4294967296 * u();
                  }),
                  (u.fract53 = function () {
                    return u() + ((2097152 * u()) | 0) * 11102230246251565e-32;
                  }),
                  (u.version = "Alea 0.9"),
                  (u.args = _),
                  (u.exportState = function () {
                    return [N, z, F, U];
                  }),
                  (u.importState = function (_) {
                    (N = +_[0] || 0),
                      (z = +_[1] || 0),
                      (F = +_[2] || 0),
                      (U = +_[3] || 0);
                  }),
                  u
                );
              })(Array.prototype.slice.call(arguments));
            }
          }),
            "object" == typeof _
              ? (L.exports = R())
              : "function" == typeof define && define.amd
                ? define(R)
                : (_.Alea = R());
        }),
        ii = Pf((_, L) => {
          var R, N;
          (R = _),
            (N = function (_) {
              (_.SVD = function (_, L, R, N, z) {
                if (
                  ((L = void 0 === L || L),
                  (R = void 0 === R || R),
                  (z = 1e-64 / (N = N || 2220446049250313e-31)),
                  !_)
                )
                  throw TypeError("Matrix a is not defined");
                var F,
                  U,
                  k,
                  Y,
                  X,
                  Q,
                  K,
                  J,
                  $,
                  ee,
                  er,
                  en,
                  ea = _[0].length,
                  eo = _.length;
                if (eo < ea) throw TypeError("Invalid matrix: m < n");
                for (
                  var el = [],
                    ec = [],
                    ed = [],
                    eu = "f" === L ? eo : ea,
                    ep = (ee = K = 0);
                  ep < eo;
                  ep++
                )
                  ec[ep] = Array(eu).fill(0);
                for (ep = 0; ep < ea; ep++) ed[ep] = Array(ea).fill(0);
                var ef,
                  ev = Array(ea).fill(0);
                for (ep = 0; ep < eo; ep++)
                  for (F = 0; F < ea; F++) ec[ep][F] = _[ep][F];
                for (ep = 0; ep < ea; ep++) {
                  for (el[ep] = K, $ = 0, k = ep + 1, F = ep; F < eo; F++)
                    $ += Math.pow(ec[F][ep], 2);
                  if ($ < z) K = 0;
                  else
                    for (
                      J =
                        (Q = ec[ep][ep]) *
                          (K = Q < 0 ? Math.sqrt($) : -Math.sqrt($)) -
                        $,
                        ec[ep][ep] = Q - K,
                        F = k;
                      F < ea;
                      F++
                    ) {
                      for ($ = 0, U = ep; U < eo; U++)
                        $ += ec[U][ep] * ec[U][F];
                      for (Q = $ / J, U = ep; U < eo; U++)
                        ec[U][F] = ec[U][F] + Q * ec[U][ep];
                    }
                  for (ev[ep] = K, $ = 0, F = k; F < ea; F++)
                    $ += Math.pow(ec[ep][F], 2);
                  if ($ < z) K = 0;
                  else {
                    for (
                      J =
                        (Q = ec[ep][ep + 1]) *
                          (K = Q < 0 ? Math.sqrt($) : -Math.sqrt($)) -
                        $,
                        ec[ep][ep + 1] = Q - K,
                        F = k;
                      F < ea;
                      F++
                    )
                      el[F] = ec[ep][F] / J;
                    for (F = k; F < eo; F++) {
                      for ($ = 0, U = k; U < ea; U++) $ += ec[F][U] * ec[ep][U];
                      for (U = k; U < ea; U++) ec[F][U] = ec[F][U] + $ * el[U];
                    }
                  }
                  ee < (er = Math.abs(ev[ep]) + Math.abs(el[ep])) && (ee = er);
                }
                if (R)
                  for (ep = ea - 1; 0 <= ep; ep--) {
                    if (0 !== K) {
                      for (J = ec[ep][ep + 1] * K, F = k; F < ea; F++)
                        ed[F][ep] = ec[ep][F] / J;
                      for (F = k; F < ea; F++) {
                        for ($ = 0, U = k; U < ea; U++)
                          $ += ec[ep][U] * ed[U][F];
                        for (U = k; U < ea; U++)
                          ed[U][F] = ed[U][F] + $ * ed[U][ep];
                      }
                    }
                    for (F = k; F < ea; F++) (ed[ep][F] = 0), (ed[F][ep] = 0);
                    (ed[ep][ep] = 1), (K = el[ep]), (k = ep);
                  }
                if (L) {
                  if ("f" === L)
                    for (ep = ea; ep < eo; ep++) {
                      for (F = ea; F < eo; F++) ec[ep][F] = 0;
                      ec[ep][ep] = 1;
                    }
                  for (ep = ea - 1; 0 <= ep; ep--) {
                    for (k = ep + 1, K = ev[ep], F = k; F < eu; F++)
                      ec[ep][F] = 0;
                    if (0 !== K) {
                      for (J = ec[ep][ep] * K, F = k; F < eu; F++) {
                        for ($ = 0, U = k; U < eo; U++)
                          $ += ec[U][ep] * ec[U][F];
                        for (Q = $ / J, U = ep; U < eo; U++)
                          ec[U][F] = ec[U][F] + Q * ec[U][ep];
                      }
                      for (F = ep; F < eo; F++) ec[F][ep] = ec[F][ep] / K;
                    } else for (F = ep; F < eo; F++) ec[F][ep] = 0;
                    ec[ep][ep] = ec[ep][ep] + 1;
                  }
                }
                for (N *= ee, U = ea - 1; 0 <= U; U--)
                  for (var ex = 0; ex < 50; ex++) {
                    for (ef = !1, k = U; 0 <= k; k--) {
                      if (Math.abs(el[k]) <= N) {
                        ef = !0;
                        break;
                      }
                      if (Math.abs(ev[k - 1]) <= N) break;
                    }
                    if (!ef) {
                      for (
                        X = 0, Y = k - ($ = 1), ep = k;
                        ep < U + 1 &&
                        ((Q = $ * el[ep]),
                        (el[ep] = X * el[ep]),
                        !(Math.abs(Q) <= N));
                        ep++
                      )
                        if (
                          ((K = ev[ep]),
                          (ev[ep] = Math.sqrt(Q * Q + K * K)),
                          (X = K / (J = ev[ep])),
                          ($ = -Q / J),
                          L)
                        )
                          for (F = 0; F < eo; F++)
                            (er = ec[F][Y]),
                              (en = ec[F][ep]),
                              (ec[F][Y] = er * X + en * $),
                              (ec[F][ep] = -er * $ + en * X);
                    }
                    if (((en = ev[U]), k === U)) {
                      if (en < 0 && ((ev[U] = -en), R))
                        for (F = 0; F < ea; F++) ed[F][U] = -ed[F][U];
                      break;
                    }
                    for (
                      ee = ev[k],
                        K = Math.sqrt(
                          (Q =
                            (((er = ev[U - 1]) - en) * (er + en) +
                              ((K = el[U - 1]) - (J = el[U])) * (K + J)) /
                            (2 * J * er)) *
                            Q +
                            1,
                        ),
                        Q =
                          ((ee - en) * (ee + en) +
                            J * (er / (Q < 0 ? Q - K : Q + K) - J)) /
                          ee,
                        ep = k + ($ = X = 1);
                      ep < U + 1;
                      ep++
                    ) {
                      if (
                        ((K = el[ep]),
                        (er = ev[ep]),
                        (J = $ * K),
                        (K *= X),
                        (en = Math.sqrt(Q * Q + J * J)),
                        (Q =
                          ee * (X = Q / (el[ep - 1] = en)) + K * ($ = J / en)),
                        (K = -ee * $ + K * X),
                        (J = er * $),
                        (er *= X),
                        R)
                      )
                        for (F = 0; F < ea; F++)
                          (ee = ed[F][ep - 1]),
                            (en = ed[F][ep]),
                            (ed[F][ep - 1] = ee * X + en * $),
                            (ed[F][ep] = -ee * $ + en * X);
                      if (
                        ((en = Math.sqrt(Q * Q + J * J)),
                        (Q =
                          (X = Q / (ev[ep - 1] = en)) * K + ($ = J / en) * er),
                        (ee = -$ * K + X * er),
                        L)
                      )
                        for (F = 0; F < eo; F++)
                          (er = ec[F][ep - 1]),
                            (en = ec[F][ep]),
                            (ec[F][ep - 1] = er * X + en * $),
                            (ec[F][ep] = -er * $ + en * X);
                    }
                    (el[k] = 0), (el[U] = Q), (ev[U] = ee);
                  }
                for (ep = 0; ep < ea; ep++) ev[ep] < N && (ev[ep] = 0);
                return { u: ec, q: ev, v: ed };
              }),
                (_.VERSION = "1.1.1"),
                Object.defineProperty(_, "__esModule", { value: !0 });
            }),
            "object" == typeof _ && "u" > typeof L
              ? N(_)
              : "function" == typeof define && define.amd
                ? define(["exports"], N)
                : N(
                    ((R =
                      "u" > typeof globalThis ? globalThis : R || self).SVDJS =
                      {}),
                  );
        }),
        ir = Pf((_) => {
          var L, R, N, z, F, U, k, Y, X, Q, K, J, $, ee;
          ((L = function () {
            this.init();
          }).prototype = {
            init: function () {
              var _ = this || R;
              return (
                (_._counter = 1e3),
                (_._html5AudioPool = []),
                (_.html5PoolSize = 10),
                (_._codecs = {}),
                (_._howls = []),
                (_._muted = !1),
                (_._volume = 1),
                (_._canPlayEvent = "canplaythrough"),
                (_._navigator =
                  "u" > typeof window && window.navigator
                    ? window.navigator
                    : null),
                (_.masterGain = null),
                (_.noAudio = !1),
                (_.usingWebAudio = !0),
                (_.autoSuspend = !0),
                (_.ctx = null),
                (_.autoUnlock = !0),
                _._setup(),
                _
              );
            },
            volume: function (_) {
              var L = this || R;
              if (
                ((_ = parseFloat(_)),
                L.ctx || Q(),
                "u" > typeof _ && _ >= 0 && _ <= 1)
              ) {
                if (((L._volume = _), L._muted)) return L;
                L.usingWebAudio &&
                  L.masterGain.gain.setValueAtTime(_, R.ctx.currentTime);
                for (var N = 0; N < L._howls.length; N++)
                  if (!L._howls[N]._webAudio)
                    for (
                      var z = L._howls[N]._getSoundIds(), F = 0;
                      F < z.length;
                      F++
                    ) {
                      var U = L._howls[N]._soundById(z[F]);
                      U && U._node && (U._node.volume = U._volume * _);
                    }
                return L;
              }
              return L._volume;
            },
            mute: function (_) {
              var L = this || R;
              L.ctx || Q(),
                (L._muted = _),
                L.usingWebAudio &&
                  L.masterGain.gain.setValueAtTime(
                    _ ? 0 : L._volume,
                    R.ctx.currentTime,
                  );
              for (var N = 0; N < L._howls.length; N++)
                if (!L._howls[N]._webAudio)
                  for (
                    var z = L._howls[N]._getSoundIds(), F = 0;
                    F < z.length;
                    F++
                  ) {
                    var U = L._howls[N]._soundById(z[F]);
                    U && U._node && (U._node.muted = !!_ || U._muted);
                  }
              return L;
            },
            stop: function () {
              for (var _ = this || R, L = 0; L < _._howls.length; L++)
                _._howls[L].stop();
              return _;
            },
            unload: function () {
              for (var _ = this || R, L = _._howls.length - 1; L >= 0; L--)
                _._howls[L].unload();
              return (
                _.usingWebAudio &&
                  _.ctx &&
                  "u" > typeof _.ctx.close &&
                  (_.ctx.close(), (_.ctx = null), Q()),
                _
              );
            },
            codecs: function (_) {
              return (this || R)._codecs[_.replace(/^x-/, "")];
            },
            _setup: function () {
              var _ = this || R;
              if (
                ((_.state = (_.ctx && _.ctx.state) || "suspended"),
                _._autoSuspend(),
                !_.usingWebAudio)
              ) {
                if ("u" > typeof Audio)
                  try {
                    var L = new Audio();
                    typeof L.oncanplaythrough > "u" &&
                      (_._canPlayEvent = "canplay");
                  } catch {
                    _.noAudio = !0;
                  }
                else _.noAudio = !0;
              }
              try {
                var L = new Audio();
                L.muted && (_.noAudio = !0);
              } catch {}
              return _.noAudio || _._setupCodecs(), _;
            },
            _setupCodecs: function () {
              var _ = this || R,
                L = null;
              try {
                L = "u" > typeof Audio ? new Audio() : null;
              } catch {
                return _;
              }
              if (!L || "function" != typeof L.canPlayType) return _;
              var N = L.canPlayType("audio/mpeg;").replace(/^no$/, ""),
                z = _._navigator ? _._navigator.userAgent : "",
                F = z.match(/OPR\/([0-6].)/g),
                U = F && 33 > parseInt(F[0].split("/")[1], 10),
                k = -1 !== z.indexOf("Safari") && -1 === z.indexOf("Chrome"),
                Y = z.match(/Version\/(.*?) /),
                X = k && Y && 15 > parseInt(Y[1], 10);
              return (
                (_._codecs = {
                  mp3: !!(
                    !U &&
                    (N || L.canPlayType("audio/mp3;").replace(/^no$/, ""))
                  ),
                  mpeg: !!N,
                  opus: !!L.canPlayType('audio/ogg; codecs="opus"').replace(
                    /^no$/,
                    "",
                  ),
                  ogg: !!L.canPlayType('audio/ogg; codecs="vorbis"').replace(
                    /^no$/,
                    "",
                  ),
                  oga: !!L.canPlayType('audio/ogg; codecs="vorbis"').replace(
                    /^no$/,
                    "",
                  ),
                  wav: !!(
                    L.canPlayType('audio/wav; codecs="1"') ||
                    L.canPlayType("audio/wav")
                  ).replace(/^no$/, ""),
                  aac: !!L.canPlayType("audio/aac;").replace(/^no$/, ""),
                  caf: !!L.canPlayType("audio/x-caf;").replace(/^no$/, ""),
                  m4a: !!(
                    L.canPlayType("audio/x-m4a;") ||
                    L.canPlayType("audio/m4a;") ||
                    L.canPlayType("audio/aac;")
                  ).replace(/^no$/, ""),
                  m4b: !!(
                    L.canPlayType("audio/x-m4b;") ||
                    L.canPlayType("audio/m4b;") ||
                    L.canPlayType("audio/aac;")
                  ).replace(/^no$/, ""),
                  mp4: !!(
                    L.canPlayType("audio/x-mp4;") ||
                    L.canPlayType("audio/mp4;") ||
                    L.canPlayType("audio/aac;")
                  ).replace(/^no$/, ""),
                  weba: !!(
                    !X &&
                    L.canPlayType('audio/webm; codecs="vorbis"').replace(
                      /^no$/,
                      "",
                    )
                  ),
                  webm: !!(
                    !X &&
                    L.canPlayType('audio/webm; codecs="vorbis"').replace(
                      /^no$/,
                      "",
                    )
                  ),
                  dolby: !!L.canPlayType('audio/mp4; codecs="ec-3"').replace(
                    /^no$/,
                    "",
                  ),
                  flac: !!(
                    L.canPlayType("audio/x-flac;") ||
                    L.canPlayType("audio/flac;")
                  ).replace(/^no$/, ""),
                }),
                _
              );
            },
            _unlockAudio: function () {
              var _ = this || R;
              if (!(_._audioUnlocked || !_.ctx)) {
                (_._audioUnlocked = !1),
                  (_.autoUnlock = !1),
                  _._mobileUnloaded ||
                    44100 === _.ctx.sampleRate ||
                    ((_._mobileUnloaded = !0), _.unload()),
                  (_._scratchBuffer = _.ctx.createBuffer(1, 1, 22050));
                var d = function (L) {
                  for (; _._html5AudioPool.length < _.html5PoolSize; )
                    try {
                      var R = new Audio();
                      (R._unlocked = !0), _._releaseHtml5Audio(R);
                    } catch {
                      _.noAudio = !0;
                      break;
                    }
                  for (var N = 0; N < _._howls.length; N++)
                    if (!_._howls[N]._webAudio)
                      for (
                        var z = _._howls[N]._getSoundIds(), F = 0;
                        F < z.length;
                        F++
                      ) {
                        var U = _._howls[N]._soundById(z[F]);
                        U &&
                          U._node &&
                          !U._node._unlocked &&
                          ((U._node._unlocked = !0), U._node.load());
                      }
                  _._autoResume();
                  var k = _.ctx.createBufferSource();
                  (k.buffer = _._scratchBuffer),
                    k.connect(_.ctx.destination),
                    typeof k.start > "u" ? k.noteOn(0) : k.start(0),
                    "function" == typeof _.ctx.resume && _.ctx.resume(),
                    (k.onended = function () {
                      k.disconnect(0),
                        (_._audioUnlocked = !0),
                        document.removeEventListener("touchstart", d, !0),
                        document.removeEventListener("touchend", d, !0),
                        document.removeEventListener("click", d, !0),
                        document.removeEventListener("keydown", d, !0);
                      for (var L = 0; L < _._howls.length; L++)
                        _._howls[L]._emit("unlock");
                    });
                };
                return (
                  document.addEventListener("touchstart", d, !0),
                  document.addEventListener("touchend", d, !0),
                  document.addEventListener("click", d, !0),
                  document.addEventListener("keydown", d, !0),
                  _
                );
              }
            },
            _obtainHtml5Audio: function () {
              var _ = this || R;
              if (_._html5AudioPool.length) return _._html5AudioPool.pop();
              var L = new Audio().play();
              return (
                L &&
                  "u" > typeof Promise &&
                  (L instanceof Promise || "function" == typeof L.then) &&
                  L.catch(function () {
                    console.warn(
                      "HTML5 Audio pool exhausted, returning potentially locked audio object.",
                    );
                  }),
                new Audio()
              );
            },
            _releaseHtml5Audio: function (_) {
              var L = this || R;
              return _._unlocked && L._html5AudioPool.push(_), L;
            },
            _autoSuspend: function () {
              var _ = this;
              if (
                !(
                  !_.autoSuspend ||
                  !_.ctx ||
                  typeof _.ctx.suspend > "u" ||
                  !R.usingWebAudio
                )
              ) {
                for (var L = 0; L < _._howls.length; L++)
                  if (_._howls[L]._webAudio) {
                    for (var N = 0; N < _._howls[L]._sounds.length; N++)
                      if (!_._howls[L]._sounds[N]._paused) return _;
                  }
                return (
                  _._suspendTimer && clearTimeout(_._suspendTimer),
                  (_._suspendTimer = setTimeout(function () {
                    if (_.autoSuspend) {
                      (_._suspendTimer = null), (_.state = "suspending");
                      var f = function () {
                        (_.state = "suspended"),
                          _._resumeAfterSuspend &&
                            (delete _._resumeAfterSuspend, _._autoResume());
                      };
                      _.ctx.suspend().then(f, f);
                    }
                  }, 3e4)),
                  _
                );
              }
            },
            _autoResume: function () {
              var _ = this;
              if (!(!_.ctx || typeof _.ctx.resume > "u" || !R.usingWebAudio))
                return (
                  "running" === _.state &&
                  "interrupted" !== _.ctx.state &&
                  _._suspendTimer
                    ? (clearTimeout(_._suspendTimer), (_._suspendTimer = null))
                    : "suspended" === _.state ||
                        ("running" === _.state && "interrupted" === _.ctx.state)
                      ? (_.ctx.resume().then(function () {
                          _.state = "running";
                          for (var L = 0; L < _._howls.length; L++)
                            _._howls[L]._emit("resume");
                        }),
                        _._suspendTimer &&
                          (clearTimeout(_._suspendTimer),
                          (_._suspendTimer = null)))
                      : "suspending" === _.state &&
                        (_._resumeAfterSuspend = !0),
                  _
                );
            },
          }),
            (R = new L()),
            ((N = function (_) {
              if (!_.src || 0 === _.src.length) {
                console.error(
                  "An array of source files must be passed with any new Howl.",
                );
                return;
              }
              this.init(_);
            }).prototype = {
              init: function (_) {
                var L = this;
                return (
                  R.ctx || Q(),
                  (L._autoplay = _.autoplay || !1),
                  (L._format =
                    "string" != typeof _.format ? _.format : [_.format]),
                  (L._html5 = _.html5 || !1),
                  (L._muted = _.mute || !1),
                  (L._loop = _.loop || !1),
                  (L._pool = _.pool || 5),
                  (L._preload =
                    ("boolean" != typeof _.preload &&
                      "metadata" !== _.preload) ||
                    _.preload),
                  (L._rate = _.rate || 1),
                  (L._sprite = _.sprite || {}),
                  (L._src = "string" != typeof _.src ? _.src : [_.src]),
                  (L._volume = void 0 !== _.volume ? _.volume : 1),
                  (L._xhr = {
                    method: _.xhr && _.xhr.method ? _.xhr.method : "GET",
                    headers: _.xhr && _.xhr.headers ? _.xhr.headers : null,
                    withCredentials:
                      !!_.xhr &&
                      !!_.xhr.withCredentials &&
                      _.xhr.withCredentials,
                  }),
                  (L._duration = 0),
                  (L._state = "unloaded"),
                  (L._sounds = []),
                  (L._endTimers = {}),
                  (L._queue = []),
                  (L._playLock = !1),
                  (L._onend = _.onend ? [{ fn: _.onend }] : []),
                  (L._onfade = _.onfade ? [{ fn: _.onfade }] : []),
                  (L._onload = _.onload ? [{ fn: _.onload }] : []),
                  (L._onloaderror = _.onloaderror
                    ? [{ fn: _.onloaderror }]
                    : []),
                  (L._onplayerror = _.onplayerror
                    ? [{ fn: _.onplayerror }]
                    : []),
                  (L._onpause = _.onpause ? [{ fn: _.onpause }] : []),
                  (L._onplay = _.onplay ? [{ fn: _.onplay }] : []),
                  (L._onstop = _.onstop ? [{ fn: _.onstop }] : []),
                  (L._onmute = _.onmute ? [{ fn: _.onmute }] : []),
                  (L._onvolume = _.onvolume ? [{ fn: _.onvolume }] : []),
                  (L._onrate = _.onrate ? [{ fn: _.onrate }] : []),
                  (L._onseek = _.onseek ? [{ fn: _.onseek }] : []),
                  (L._onunlock = _.onunlock ? [{ fn: _.onunlock }] : []),
                  (L._onresume = []),
                  (L._webAudio = R.usingWebAudio && !L._html5),
                  "u" > typeof R.ctx &&
                    R.ctx &&
                    R.autoUnlock &&
                    R._unlockAudio(),
                  R._howls.push(L),
                  L._autoplay &&
                    L._queue.push({
                      event: "play",
                      action: function () {
                        L.play();
                      },
                    }),
                  L._preload && "none" !== L._preload && L.load(),
                  L
                );
              },
              load: function () {
                var _,
                  L,
                  N = null;
                if (R.noAudio) {
                  this._emit("loaderror", null, "No audio support.");
                  return;
                }
                "string" == typeof this._src && (this._src = [this._src]);
                for (var F = 0; F < this._src.length; F++) {
                  if (this._format && this._format[F]) _ = this._format[F];
                  else {
                    if ("string" != typeof (L = this._src[F])) {
                      this._emit(
                        "loaderror",
                        null,
                        "Non-string found in selected audio sources - ignoring.",
                      );
                      continue;
                    }
                    (_ = /^data:audio\/([^;,]+);/i.exec(L)) ||
                      (_ = /\.([^.]+)$/.exec(L.split("?", 1)[0])),
                      _ && (_ = _[1].toLowerCase());
                  }
                  if (
                    (_ ||
                      console.warn(
                        'No file extension was found. Consider using the "format" property or specify an extension.',
                      ),
                    _ && R.codecs(_))
                  ) {
                    N = this._src[F];
                    break;
                  }
                }
                if (!N) {
                  this._emit(
                    "loaderror",
                    null,
                    "No codec support for selected audio sources.",
                  );
                  return;
                }
                return (
                  (this._src = N),
                  (this._state = "loading"),
                  "https:" === window.location.protocol &&
                    "http:" === N.slice(0, 5) &&
                    ((this._html5 = !0), (this._webAudio = !1)),
                  new z(this),
                  this._webAudio && U(this),
                  this
                );
              },
              play: function (_, L) {
                var N = this,
                  z = null;
                if ("number" == typeof _) (z = _), (_ = null);
                else {
                  if (
                    "string" == typeof _ &&
                    "loaded" === N._state &&
                    !N._sprite[_]
                  )
                    return null;
                  if (typeof _ > "u" && ((_ = "__default"), !N._playLock)) {
                    for (var F = 0, U = 0; U < N._sounds.length; U++)
                      N._sounds[U]._paused &&
                        !N._sounds[U]._ended &&
                        (F++, (z = N._sounds[U]._id));
                    1 === F ? (_ = null) : (z = null);
                  }
                }
                var k = z ? N._soundById(z) : N._inactiveSound();
                if (!k) return null;
                if (
                  (z && !_ && (_ = k._sprite || "__default"),
                  "loaded" !== N._state)
                ) {
                  (k._sprite = _), (k._ended = !1);
                  var Y = k._id;
                  return (
                    N._queue.push({
                      event: "play",
                      action: function () {
                        N.play(Y);
                      },
                    }),
                    Y
                  );
                }
                if (z && !k._paused) return L || N._loadQueue("play"), k._id;
                N._webAudio && R._autoResume();
                var X = Math.max(
                    0,
                    k._seek > 0 ? k._seek : N._sprite[_][0] / 1e3,
                  ),
                  Q = Math.max(
                    0,
                    (N._sprite[_][0] + N._sprite[_][1]) / 1e3 - X,
                  ),
                  K = (1e3 * Q) / Math.abs(k._rate),
                  J = N._sprite[_][0] / 1e3,
                  $ = (N._sprite[_][0] + N._sprite[_][1]) / 1e3;
                (k._sprite = _), (k._ended = !1);
                var T = function () {
                  (k._paused = !1),
                    (k._seek = X),
                    (k._start = J),
                    (k._stop = $),
                    (k._loop = !!(k._loop || N._sprite[_][2]));
                };
                if (X >= $) {
                  N._ended(k);
                  return;
                }
                var ee = k._node;
                if (N._webAudio) {
                  var E = function () {
                    (N._playLock = !1), T(), N._refreshBuffer(k);
                    var _ = k._muted || N._muted ? 0 : k._volume;
                    ee.gain.setValueAtTime(_, R.ctx.currentTime),
                      (k._playStart = R.ctx.currentTime),
                      typeof ee.bufferSource.start > "u"
                        ? k._loop
                          ? ee.bufferSource.noteGrainOn(0, X, 86400)
                          : ee.bufferSource.noteGrainOn(0, X, Q)
                        : k._loop
                          ? ee.bufferSource.start(0, X, 86400)
                          : ee.bufferSource.start(0, X, Q),
                      K !== 1 / 0 &&
                        (N._endTimers[k._id] = setTimeout(
                          N._ended.bind(N, k),
                          K,
                        )),
                      L ||
                        setTimeout(function () {
                          N._emit("play", k._id), N._loadQueue();
                        }, 0);
                  };
                  "running" === R.state && "interrupted" !== R.ctx.state
                    ? E()
                    : ((N._playLock = !0),
                      N.once("resume", E),
                      N._clearTimer(k._id));
                } else {
                  var M = function () {
                    (ee.currentTime = X),
                      (ee.muted = k._muted || N._muted || R._muted || ee.muted),
                      (ee.volume = k._volume * R.volume()),
                      (ee.playbackRate = k._rate);
                    try {
                      var z = ee.play();
                      if (
                        (z &&
                        "u" > typeof Promise &&
                        (z instanceof Promise || "function" == typeof z.then)
                          ? ((N._playLock = !0),
                            T(),
                            z
                              .then(function () {
                                (N._playLock = !1),
                                  (ee._unlocked = !0),
                                  L ? N._loadQueue() : N._emit("play", k._id);
                              })
                              .catch(function () {
                                (N._playLock = !1),
                                  N._emit(
                                    "playerror",
                                    k._id,
                                    "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction.",
                                  ),
                                  (k._ended = !0),
                                  (k._paused = !0);
                              }))
                          : L ||
                            ((N._playLock = !1), T(), N._emit("play", k._id)),
                        (ee.playbackRate = k._rate),
                        ee.paused)
                      ) {
                        N._emit(
                          "playerror",
                          k._id,
                          "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction.",
                        );
                        return;
                      }
                      "__default" !== _ || k._loop
                        ? (N._endTimers[k._id] = setTimeout(
                            N._ended.bind(N, k),
                            K,
                          ))
                        : ((N._endTimers[k._id] = function () {
                            N._ended(k),
                              ee.removeEventListener(
                                "ended",
                                N._endTimers[k._id],
                                !1,
                              );
                          }),
                          ee.addEventListener(
                            "ended",
                            N._endTimers[k._id],
                            !1,
                          ));
                    } catch (_) {
                      N._emit("playerror", k._id, _);
                    }
                  };
                  "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA" ===
                    ee.src && ((ee.src = N._src), ee.load());
                  var er =
                    (window && window.ejecta) ||
                    (!ee.readyState && R._navigator.isCocoonJS);
                  if (ee.readyState >= 3 || er) M();
                  else {
                    (N._playLock = !0), (N._state = "loading");
                    var P = function () {
                      (N._state = "loaded"),
                        M(),
                        ee.removeEventListener(R._canPlayEvent, P, !1);
                    };
                    ee.addEventListener(R._canPlayEvent, P, !1),
                      N._clearTimer(k._id);
                  }
                }
                return k._id;
              },
              pause: function (_) {
                var L = this;
                if ("loaded" !== L._state || L._playLock)
                  return (
                    L._queue.push({
                      event: "pause",
                      action: function () {
                        L.pause(_);
                      },
                    }),
                    L
                  );
                for (var R = L._getSoundIds(_), N = 0; N < R.length; N++) {
                  L._clearTimer(R[N]);
                  var z = L._soundById(R[N]);
                  if (
                    z &&
                    !z._paused &&
                    ((z._seek = L.seek(R[N])),
                    (z._rateSeek = 0),
                    (z._paused = !0),
                    L._stopFade(R[N]),
                    z._node)
                  ) {
                    if (L._webAudio) {
                      if (!z._node.bufferSource) continue;
                      typeof z._node.bufferSource.stop > "u"
                        ? z._node.bufferSource.noteOff(0)
                        : z._node.bufferSource.stop(0),
                        L._cleanBuffer(z._node);
                    } else
                      (isNaN(z._node.duration) && z._node.duration !== 1 / 0) ||
                        z._node.pause();
                  }
                  arguments[1] || L._emit("pause", z ? z._id : null);
                }
                return L;
              },
              stop: function (_, L) {
                var R = this;
                if ("loaded" !== R._state || R._playLock)
                  return (
                    R._queue.push({
                      event: "stop",
                      action: function () {
                        R.stop(_);
                      },
                    }),
                    R
                  );
                for (var N = R._getSoundIds(_), z = 0; z < N.length; z++) {
                  R._clearTimer(N[z]);
                  var F = R._soundById(N[z]);
                  F &&
                    ((F._seek = F._start || 0),
                    (F._rateSeek = 0),
                    (F._paused = !0),
                    (F._ended = !0),
                    R._stopFade(N[z]),
                    F._node &&
                      (R._webAudio
                        ? F._node.bufferSource &&
                          (typeof F._node.bufferSource.stop > "u"
                            ? F._node.bufferSource.noteOff(0)
                            : F._node.bufferSource.stop(0),
                          R._cleanBuffer(F._node))
                        : (isNaN(F._node.duration) &&
                            F._node.duration !== 1 / 0) ||
                          ((F._node.currentTime = F._start || 0),
                          F._node.pause(),
                          F._node.duration === 1 / 0 &&
                            R._clearSound(F._node))),
                    L || R._emit("stop", F._id));
                }
                return R;
              },
              mute: function (_, L) {
                var N = this;
                if ("loaded" !== N._state || N._playLock)
                  return (
                    N._queue.push({
                      event: "mute",
                      action: function () {
                        N.mute(_, L);
                      },
                    }),
                    N
                  );
                if (typeof L > "u") {
                  if ("boolean" != typeof _) return N._muted;
                  N._muted = _;
                }
                for (var z = N._getSoundIds(L), F = 0; F < z.length; F++) {
                  var U = N._soundById(z[F]);
                  U &&
                    ((U._muted = _),
                    U._interval && N._stopFade(U._id),
                    N._webAudio && U._node
                      ? U._node.gain.setValueAtTime(
                          _ ? 0 : U._volume,
                          R.ctx.currentTime,
                        )
                      : U._node && (U._node.muted = !!R._muted || _),
                    N._emit("mute", U._id));
                }
                return N;
              },
              volume: function () {
                var _,
                  L,
                  N,
                  z = this,
                  F = arguments;
                if (0 === F.length) return z._volume;
                if (
                  (1 === F.length || (2 === F.length && typeof F[1] > "u")
                    ? z._getSoundIds().indexOf(F[0]) >= 0
                      ? (N = parseInt(F[0], 10))
                      : (L = parseFloat(F[0]))
                    : F.length >= 2 &&
                      ((L = parseFloat(F[0])), (N = parseInt(F[1], 10))),
                  !("u" > typeof L) || !(L >= 0) || !(L <= 1))
                )
                  return (_ = N ? z._soundById(N) : z._sounds[0])
                    ? _._volume
                    : 0;
                if ("loaded" !== z._state || z._playLock)
                  return (
                    z._queue.push({
                      event: "volume",
                      action: function () {
                        z.volume.apply(z, F);
                      },
                    }),
                    z
                  );
                typeof N > "u" && (z._volume = L), (N = z._getSoundIds(N));
                for (var U = 0; U < N.length; U++)
                  (_ = z._soundById(N[U])) &&
                    ((_._volume = L),
                    F[2] || z._stopFade(N[U]),
                    z._webAudio && _._node && !_._muted
                      ? _._node.gain.setValueAtTime(L, R.ctx.currentTime)
                      : _._node &&
                        !_._muted &&
                        (_._node.volume = L * R.volume()),
                    z._emit("volume", _._id));
                return z;
              },
              fade: function (_, L, N, z) {
                var F = this;
                if ("loaded" !== F._state || F._playLock)
                  return (
                    F._queue.push({
                      event: "fade",
                      action: function () {
                        F.fade(_, L, N, z);
                      },
                    }),
                    F
                  );
                (_ = Math.min(Math.max(0, parseFloat(_)), 1)),
                  (L = Math.min(Math.max(0, parseFloat(L)), 1)),
                  (N = parseFloat(N)),
                  F.volume(_, z);
                for (var U = F._getSoundIds(z), k = 0; k < U.length; k++) {
                  var Y = F._soundById(U[k]);
                  if (Y) {
                    if ((z || F._stopFade(U[k]), F._webAudio && !Y._muted)) {
                      var X = R.ctx.currentTime,
                        Q = X + N / 1e3;
                      (Y._volume = _),
                        Y._node.gain.setValueAtTime(_, X),
                        Y._node.gain.linearRampToValueAtTime(L, Q);
                    }
                    F._startFadeInterval(Y, _, L, N, U[k], typeof z > "u");
                  }
                }
                return F;
              },
              _startFadeInterval: function (_, L, R, N, z, F) {
                var U = this,
                  k = L,
                  Y = R - L,
                  X = Math.abs(Y / 0.01),
                  Q = Math.max(4, X > 0 ? N / X : N),
                  K = Date.now();
                (_._fadeTo = R),
                  (_._interval = setInterval(function () {
                    var z = (Date.now() - K) / N;
                    (K = Date.now()),
                      (k += Y * z),
                      (k = Math.round(100 * k) / 100),
                      (k = Y < 0 ? Math.max(R, k) : Math.min(R, k)),
                      U._webAudio ? (_._volume = k) : U.volume(k, _._id, !0),
                      F && (U._volume = k),
                      ((R < L && k <= R) || (R > L && k >= R)) &&
                        (clearInterval(_._interval),
                        (_._interval = null),
                        (_._fadeTo = null),
                        U.volume(R, _._id),
                        U._emit("fade", _._id));
                  }, Q));
              },
              _stopFade: function (_) {
                var L = this._soundById(_);
                return (
                  L &&
                    L._interval &&
                    (this._webAudio &&
                      L._node.gain.cancelScheduledValues(R.ctx.currentTime),
                    clearInterval(L._interval),
                    (L._interval = null),
                    this.volume(L._fadeTo, _),
                    (L._fadeTo = null),
                    this._emit("fade", _)),
                  this
                );
              },
              loop: function () {
                var _,
                  L,
                  R,
                  N = arguments;
                if (0 === N.length) return this._loop;
                if (1 === N.length) {
                  if ("boolean" != typeof N[0])
                    return (
                      !!(R = this._soundById(parseInt(N[0], 10))) && R._loop
                    );
                  (_ = N[0]), (this._loop = _);
                } else 2 === N.length && ((_ = N[0]), (L = parseInt(N[1], 10)));
                for (var z = this._getSoundIds(L), F = 0; F < z.length; F++)
                  (R = this._soundById(z[F])) &&
                    ((R._loop = _),
                    this._webAudio &&
                      R._node &&
                      R._node.bufferSource &&
                      ((R._node.bufferSource.loop = _),
                      _ &&
                        ((R._node.bufferSource.loopStart = R._start || 0),
                        (R._node.bufferSource.loopEnd = R._stop),
                        this.playing(z[F]) &&
                          (this.pause(z[F], !0), this.play(z[F], !0)))));
                return this;
              },
              rate: function () {
                var _,
                  L,
                  N,
                  z = this,
                  F = arguments;
                if (
                  (0 === F.length
                    ? (N = z._sounds[0]._id)
                    : 1 === F.length
                      ? z._getSoundIds().indexOf(F[0]) >= 0
                        ? (N = parseInt(F[0], 10))
                        : (L = parseFloat(F[0]))
                      : 2 === F.length &&
                        ((L = parseFloat(F[0])), (N = parseInt(F[1], 10))),
                  "number" != typeof L)
                )
                  return (_ = z._soundById(N)) ? _._rate : z._rate;
                if ("loaded" !== z._state || z._playLock)
                  return (
                    z._queue.push({
                      event: "rate",
                      action: function () {
                        z.rate.apply(z, F);
                      },
                    }),
                    z
                  );
                typeof N > "u" && (z._rate = L), (N = z._getSoundIds(N));
                for (var U = 0; U < N.length; U++)
                  if ((_ = z._soundById(N[U]))) {
                    z.playing(N[U]) &&
                      ((_._rateSeek = z.seek(N[U])),
                      (_._playStart = z._webAudio
                        ? R.ctx.currentTime
                        : _._playStart)),
                      (_._rate = L),
                      z._webAudio && _._node && _._node.bufferSource
                        ? _._node.bufferSource.playbackRate.setValueAtTime(
                            L,
                            R.ctx.currentTime,
                          )
                        : _._node && (_._node.playbackRate = L);
                    var k = z.seek(N[U]),
                      Y =
                        (1e3 *
                          ((z._sprite[_._sprite][0] + z._sprite[_._sprite][1]) /
                            1e3 -
                            k)) /
                        Math.abs(_._rate);
                    (z._endTimers[N[U]] || !_._paused) &&
                      (z._clearTimer(N[U]),
                      (z._endTimers[N[U]] = setTimeout(
                        z._ended.bind(z, _),
                        Y,
                      ))),
                      z._emit("rate", _._id);
                  }
                return z;
              },
              seek: function () {
                var _,
                  L,
                  N = this,
                  z = arguments;
                if (
                  (0 === z.length
                    ? N._sounds.length && (L = N._sounds[0]._id)
                    : 1 === z.length
                      ? N._getSoundIds().indexOf(z[0]) >= 0
                        ? (L = parseInt(z[0], 10))
                        : N._sounds.length &&
                          ((L = N._sounds[0]._id), (_ = parseFloat(z[0])))
                      : 2 === z.length &&
                        ((_ = parseFloat(z[0])), (L = parseInt(z[1], 10))),
                  typeof L > "u")
                )
                  return 0;
                if (
                  "number" == typeof _ &&
                  ("loaded" !== N._state || N._playLock)
                )
                  return (
                    N._queue.push({
                      event: "seek",
                      action: function () {
                        N.seek.apply(N, z);
                      },
                    }),
                    N
                  );
                var F = N._soundById(L);
                if (F) {
                  if ("number" == typeof _ && _ >= 0) {
                    var U = N.playing(L);
                    U && N.pause(L, !0),
                      (F._seek = _),
                      (F._ended = !1),
                      N._clearTimer(L),
                      N._webAudio ||
                        !F._node ||
                        isNaN(F._node.duration) ||
                        (F._node.currentTime = _);
                    var v = function () {
                      U && N.play(L, !0), N._emit("seek", L);
                    };
                    if (U && !N._webAudio) {
                      var x = function () {
                        N._playLock ? setTimeout(x, 0) : v();
                      };
                      setTimeout(x, 0);
                    } else v();
                  } else {
                    if (!N._webAudio) return F._node.currentTime;
                    var k = N.playing(L) ? R.ctx.currentTime - F._playStart : 0,
                      Y = F._rateSeek ? F._rateSeek - F._seek : 0;
                    return F._seek + (Y + k * Math.abs(F._rate));
                  }
                }
                return N;
              },
              playing: function (_) {
                if ("number" == typeof _) {
                  var L = this._soundById(_);
                  return !!L && !L._paused;
                }
                for (var R = 0; R < this._sounds.length; R++)
                  if (!this._sounds[R]._paused) return !0;
                return !1;
              },
              duration: function (_) {
                var L = this._duration,
                  R = this._soundById(_);
                return R && (L = this._sprite[R._sprite][1] / 1e3), L;
              },
              state: function () {
                return this._state;
              },
              unload: function () {
                for (var _ = this, L = _._sounds, N = 0; N < L.length; N++)
                  L[N]._paused || _.stop(L[N]._id),
                    _._webAudio ||
                      (_._clearSound(L[N]._node),
                      L[N]._node.removeEventListener(
                        "error",
                        L[N]._errorFn,
                        !1,
                      ),
                      L[N]._node.removeEventListener(
                        R._canPlayEvent,
                        L[N]._loadFn,
                        !1,
                      ),
                      L[N]._node.removeEventListener("ended", L[N]._endFn, !1),
                      R._releaseHtml5Audio(L[N]._node)),
                    delete L[N]._node,
                    _._clearTimer(L[N]._id);
                var z = R._howls.indexOf(_);
                z >= 0 && R._howls.splice(z, 1);
                var U = !0;
                for (N = 0; N < R._howls.length; N++)
                  if (
                    R._howls[N]._src === _._src ||
                    _._src.indexOf(R._howls[N]._src) >= 0
                  ) {
                    U = !1;
                    break;
                  }
                return (
                  F && U && delete F[_._src],
                  (R.noAudio = !1),
                  (_._state = "unloaded"),
                  (_._sounds = []),
                  (_ = null),
                  null
                );
              },
              on: function (_, L, R, N) {
                var z = this["_on" + _];
                return (
                  "function" == typeof L &&
                    z.push(N ? { id: R, fn: L, once: N } : { id: R, fn: L }),
                  this
                );
              },
              off: function (_, L, R) {
                var N = this["_on" + _],
                  z = 0;
                if (("number" == typeof L && ((R = L), (L = null)), L || R))
                  for (z = 0; z < N.length; z++) {
                    var F = R === N[z].id;
                    if ((L === N[z].fn && F) || (!L && F)) {
                      N.splice(z, 1);
                      break;
                    }
                  }
                else if (_) this["_on" + _] = [];
                else {
                  var U = Object.keys(this);
                  for (z = 0; z < U.length; z++)
                    0 === U[z].indexOf("_on") &&
                      Array.isArray(this[U[z]]) &&
                      (this[U[z]] = []);
                }
                return this;
              },
              once: function (_, L, R) {
                return this.on(_, L, R, 1), this;
              },
              _emit: function (_, L, R) {
                for (var N = this["_on" + _], z = N.length - 1; z >= 0; z--)
                  (!N[z].id || N[z].id === L || "load" === _) &&
                    (setTimeout(
                      function (_) {
                        _.call(this, L, R);
                      }.bind(this, N[z].fn),
                      0,
                    ),
                    N[z].once && this.off(_, N[z].fn, N[z].id));
                return this._loadQueue(_), this;
              },
              _loadQueue: function (_) {
                if (this._queue.length > 0) {
                  var L = this._queue[0];
                  L.event === _ && (this._queue.shift(), this._loadQueue()),
                    _ || L.action();
                }
                return this;
              },
              _ended: function (_) {
                var L = _._sprite;
                if (
                  !this._webAudio &&
                  _._node &&
                  !_._node.paused &&
                  !_._node.ended &&
                  _._node.currentTime < _._stop
                )
                  return setTimeout(this._ended.bind(this, _), 100), this;
                var N = !!(_._loop || this._sprite[L][2]);
                if (
                  (this._emit("end", _._id),
                  !this._webAudio && N && this.stop(_._id, !0).play(_._id),
                  this._webAudio && N)
                ) {
                  this._emit("play", _._id),
                    (_._seek = _._start || 0),
                    (_._rateSeek = 0),
                    (_._playStart = R.ctx.currentTime);
                  var z = ((_._stop - _._start) * 1e3) / Math.abs(_._rate);
                  this._endTimers[_._id] = setTimeout(
                    this._ended.bind(this, _),
                    z,
                  );
                }
                return (
                  this._webAudio &&
                    !N &&
                    ((_._paused = !0),
                    (_._ended = !0),
                    (_._seek = _._start || 0),
                    (_._rateSeek = 0),
                    this._clearTimer(_._id),
                    this._cleanBuffer(_._node),
                    R._autoSuspend()),
                  this._webAudio || N || this.stop(_._id, !0),
                  this
                );
              },
              _clearTimer: function (_) {
                if (this._endTimers[_]) {
                  if ("function" != typeof this._endTimers[_])
                    clearTimeout(this._endTimers[_]);
                  else {
                    var L = this._soundById(_);
                    L &&
                      L._node &&
                      L._node.removeEventListener(
                        "ended",
                        this._endTimers[_],
                        !1,
                      );
                  }
                  delete this._endTimers[_];
                }
                return this;
              },
              _soundById: function (_) {
                for (var L = 0; L < this._sounds.length; L++)
                  if (_ === this._sounds[L]._id) return this._sounds[L];
                return null;
              },
              _inactiveSound: function () {
                this._drain();
                for (var _ = 0; _ < this._sounds.length; _++)
                  if (this._sounds[_]._ended) return this._sounds[_].reset();
                return new z(this);
              },
              _drain: function () {
                var _ = this._pool,
                  L = 0,
                  R = 0;
                if (!(this._sounds.length < _)) {
                  for (R = 0; R < this._sounds.length; R++)
                    this._sounds[R]._ended && L++;
                  for (R = this._sounds.length - 1; R >= 0; R--) {
                    if (L <= _) return;
                    this._sounds[R]._ended &&
                      (this._webAudio &&
                        this._sounds[R]._node &&
                        this._sounds[R]._node.disconnect(0),
                      this._sounds.splice(R, 1),
                      L--);
                  }
                }
              },
              _getSoundIds: function (_) {
                if (!(typeof _ > "u")) return [_];
                for (var L = [], R = 0; R < this._sounds.length; R++)
                  L.push(this._sounds[R]._id);
                return L;
              },
              _refreshBuffer: function (_) {
                return (
                  (_._node.bufferSource = R.ctx.createBufferSource()),
                  (_._node.bufferSource.buffer = F[this._src]),
                  _._panner
                    ? _._node.bufferSource.connect(_._panner)
                    : _._node.bufferSource.connect(_._node),
                  (_._node.bufferSource.loop = _._loop),
                  _._loop &&
                    ((_._node.bufferSource.loopStart = _._start || 0),
                    (_._node.bufferSource.loopEnd = _._stop || 0)),
                  _._node.bufferSource.playbackRate.setValueAtTime(
                    _._rate,
                    R.ctx.currentTime,
                  ),
                  this
                );
              },
              _cleanBuffer: function (_) {
                var L =
                  R._navigator && R._navigator.vendor.indexOf("Apple") >= 0;
                if (
                  R._scratchBuffer &&
                  _.bufferSource &&
                  ((_.bufferSource.onended = null),
                  _.bufferSource.disconnect(0),
                  L)
                )
                  try {
                    _.bufferSource.buffer = R._scratchBuffer;
                  } catch {}
                return (_.bufferSource = null), this;
              },
              _clearSound: function (_) {
                /MSIE |Trident\//.test(
                  R._navigator && R._navigator.userAgent,
                ) ||
                  (_.src =
                    "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA");
              },
            }),
            ((z = function (_) {
              (this._parent = _), this.init();
            }).prototype = {
              init: function () {
                var _ = this._parent;
                return (
                  (this._muted = _._muted),
                  (this._loop = _._loop),
                  (this._volume = _._volume),
                  (this._rate = _._rate),
                  (this._seek = 0),
                  (this._paused = !0),
                  (this._ended = !0),
                  (this._sprite = "__default"),
                  (this._id = ++R._counter),
                  _._sounds.push(this),
                  this.create(),
                  this
                );
              },
              create: function () {
                var _ = this._parent,
                  L =
                    R._muted || this._muted || this._parent._muted
                      ? 0
                      : this._volume;
                return (
                  _._webAudio
                    ? ((this._node =
                        typeof R.ctx.createGain > "u"
                          ? R.ctx.createGainNode()
                          : R.ctx.createGain()),
                      this._node.gain.setValueAtTime(L, R.ctx.currentTime),
                      (this._node.paused = !0),
                      this._node.connect(R.masterGain))
                    : R.noAudio ||
                      ((this._node = R._obtainHtml5Audio()),
                      (this._errorFn = this._errorListener.bind(this)),
                      this._node.addEventListener("error", this._errorFn, !1),
                      (this._loadFn = this._loadListener.bind(this)),
                      this._node.addEventListener(
                        R._canPlayEvent,
                        this._loadFn,
                        !1,
                      ),
                      (this._endFn = this._endListener.bind(this)),
                      this._node.addEventListener("ended", this._endFn, !1),
                      (this._node.src = _._src),
                      (this._node.preload =
                        !0 === _._preload ? "auto" : _._preload),
                      (this._node.volume = L * R.volume()),
                      this._node.load()),
                  this
                );
              },
              reset: function () {
                var _ = this._parent;
                return (
                  (this._muted = _._muted),
                  (this._loop = _._loop),
                  (this._volume = _._volume),
                  (this._rate = _._rate),
                  (this._seek = 0),
                  (this._rateSeek = 0),
                  (this._paused = !0),
                  (this._ended = !0),
                  (this._sprite = "__default"),
                  (this._id = ++R._counter),
                  this
                );
              },
              _errorListener: function () {
                this._parent._emit(
                  "loaderror",
                  this._id,
                  this._node.error ? this._node.error.code : 0,
                ),
                  this._node.removeEventListener("error", this._errorFn, !1);
              },
              _loadListener: function () {
                var _ = this._parent;
                (_._duration = Math.ceil(10 * this._node.duration) / 10),
                  0 === Object.keys(_._sprite).length &&
                    (_._sprite = { __default: [0, 1e3 * _._duration] }),
                  "loaded" !== _._state &&
                    ((_._state = "loaded"), _._emit("load"), _._loadQueue()),
                  this._node.removeEventListener(
                    R._canPlayEvent,
                    this._loadFn,
                    !1,
                  );
              },
              _endListener: function () {
                var _ = this._parent;
                _._duration === 1 / 0 &&
                  ((_._duration = Math.ceil(10 * this._node.duration) / 10),
                  _._sprite.__default[1] === 1 / 0 &&
                    (_._sprite.__default[1] = 1e3 * _._duration),
                  _._ended(this)),
                  this._node.removeEventListener("ended", this._endFn, !1);
              },
            }),
            (F = {}),
            (U = function (_) {
              var L = _._src;
              if (F[L]) {
                (_._duration = F[L].duration), X(_);
                return;
              }
              if (/^data:[^;]+;base64,/.test(L)) {
                for (
                  var R = atob(L.split(",")[1]),
                    N = new Uint8Array(R.length),
                    z = 0;
                  z < R.length;
                  ++z
                )
                  N[z] = R.charCodeAt(z);
                Y(N.buffer, _);
              } else {
                var U = new XMLHttpRequest();
                U.open(_._xhr.method, L, !0),
                  (U.withCredentials = _._xhr.withCredentials),
                  (U.responseType = "arraybuffer"),
                  _._xhr.headers &&
                    Object.keys(_._xhr.headers).forEach(function (L) {
                      U.setRequestHeader(L, _._xhr.headers[L]);
                    }),
                  (U.onload = function () {
                    var L = (U.status + "")[0];
                    if ("0" !== L && "2" !== L && "3" !== L) {
                      _._emit(
                        "loaderror",
                        null,
                        "Failed loading audio file with status: " +
                          U.status +
                          ".",
                      );
                      return;
                    }
                    Y(U.response, _);
                  }),
                  (U.onerror = function () {
                    _._webAudio &&
                      ((_._html5 = !0),
                      (_._webAudio = !1),
                      (_._sounds = []),
                      delete F[L],
                      _.load());
                  }),
                  k(U);
              }
            }),
            (k = function (_) {
              try {
                _.send();
              } catch {
                _.onerror();
              }
            }),
            (Y = function (_, L) {
              var h = function () {
                  L._emit("loaderror", null, "Decoding audio data failed.");
                },
                f = function (_) {
                  _ && L._sounds.length > 0 ? ((F[L._src] = _), X(L, _)) : h();
                };
              "u" > typeof Promise && 1 === R.ctx.decodeAudioData.length
                ? R.ctx.decodeAudioData(_).then(f).catch(h)
                : R.ctx.decodeAudioData(_, f, h);
            }),
            (X = function (_, L) {
              L && !_._duration && (_._duration = L.duration),
                0 === Object.keys(_._sprite).length &&
                  (_._sprite = { __default: [0, 1e3 * _._duration] }),
                "loaded" !== _._state &&
                  ((_._state = "loaded"), _._emit("load"), _._loadQueue());
            }),
            (Q = function () {
              if (R.usingWebAudio) {
                try {
                  "u" > typeof AudioContext
                    ? (R.ctx = new AudioContext())
                    : "u" > typeof webkitAudioContext
                      ? (R.ctx = new webkitAudioContext())
                      : (R.usingWebAudio = !1);
                } catch {
                  R.usingWebAudio = !1;
                }
                R.ctx || (R.usingWebAudio = !1);
                var _ = /iP(hone|od|ad)/.test(
                    R._navigator && R._navigator.platform,
                  ),
                  L =
                    R._navigator &&
                    R._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/),
                  N = L ? parseInt(L[1], 10) : null;
                if (_ && N && N < 9) {
                  var z = /safari/.test(
                    R._navigator && R._navigator.userAgent.toLowerCase(),
                  );
                  R._navigator && !z && (R.usingWebAudio = !1);
                }
                R.usingWebAudio &&
                  ((R.masterGain =
                    typeof R.ctx.createGain > "u"
                      ? R.ctx.createGainNode()
                      : R.ctx.createGain()),
                  R.masterGain.gain.setValueAtTime(
                    R._muted ? 0 : R._volume,
                    R.ctx.currentTime,
                  ),
                  R.masterGain.connect(R.ctx.destination)),
                  R._setup();
              }
            }),
            "function" == typeof define &&
              define.amd &&
              define([], function () {
                return { Howler: R, Howl: N };
              }),
            "u" > typeof _ && ((_.Howler = R), (_.Howl = N)),
            "u" > typeof global
              ? ((global.HowlerGlobal = L),
                (global.Howler = R),
                (global.Howl = N),
                (global.Sound = z))
              : "u" > typeof window &&
                ((window.HowlerGlobal = L),
                (window.Howler = R),
                (window.Howl = N),
                (window.Sound = z)),
            (HowlerGlobal.prototype._pos = [0, 0, 0]),
            (HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0]),
            (HowlerGlobal.prototype.stereo = function (_) {
              if (!this.ctx || !this.ctx.listener) return this;
              for (var L = this._howls.length - 1; L >= 0; L--)
                this._howls[L].stereo(_);
              return this;
            }),
            (HowlerGlobal.prototype.pos = function (_, L, R) {
              return this.ctx && this.ctx.listener
                ? ((L = "number" != typeof L ? this._pos[1] : L),
                  (R = "number" != typeof R ? this._pos[2] : R),
                  "number" != typeof _)
                  ? this._pos
                  : ((this._pos = [_, L, R]),
                    "u" > typeof this.ctx.listener.positionX
                      ? (this.ctx.listener.positionX.setTargetAtTime(
                          this._pos[0],
                          Howler.ctx.currentTime,
                          0.1,
                        ),
                        this.ctx.listener.positionY.setTargetAtTime(
                          this._pos[1],
                          Howler.ctx.currentTime,
                          0.1,
                        ),
                        this.ctx.listener.positionZ.setTargetAtTime(
                          this._pos[2],
                          Howler.ctx.currentTime,
                          0.1,
                        ))
                      : this.ctx.listener.setPosition(
                          this._pos[0],
                          this._pos[1],
                          this._pos[2],
                        ),
                    this)
                : this;
            }),
            (HowlerGlobal.prototype.orientation = function (_, L, R, N, z, F) {
              if (!this.ctx || !this.ctx.listener) return this;
              var U = this._orientation;
              return ((L = "number" != typeof L ? U[1] : L),
              (R = "number" != typeof R ? U[2] : R),
              (N = "number" != typeof N ? U[3] : N),
              (z = "number" != typeof z ? U[4] : z),
              (F = "number" != typeof F ? U[5] : F),
              "number" != typeof _)
                ? U
                : ((this._orientation = [_, L, R, N, z, F]),
                  "u" > typeof this.ctx.listener.forwardX
                    ? (this.ctx.listener.forwardX.setTargetAtTime(
                        _,
                        Howler.ctx.currentTime,
                        0.1,
                      ),
                      this.ctx.listener.forwardY.setTargetAtTime(
                        L,
                        Howler.ctx.currentTime,
                        0.1,
                      ),
                      this.ctx.listener.forwardZ.setTargetAtTime(
                        R,
                        Howler.ctx.currentTime,
                        0.1,
                      ),
                      this.ctx.listener.upX.setTargetAtTime(
                        N,
                        Howler.ctx.currentTime,
                        0.1,
                      ),
                      this.ctx.listener.upY.setTargetAtTime(
                        z,
                        Howler.ctx.currentTime,
                        0.1,
                      ),
                      this.ctx.listener.upZ.setTargetAtTime(
                        F,
                        Howler.ctx.currentTime,
                        0.1,
                      ))
                    : this.ctx.listener.setOrientation(_, L, R, N, z, F),
                  this);
            }),
            (Howl.prototype.init =
              ((K = Howl.prototype.init),
              function (_) {
                return (
                  (this._orientation = _.orientation || [1, 0, 0]),
                  (this._stereo = _.stereo || null),
                  (this._pos = _.pos || null),
                  (this._pannerAttr = {
                    coneInnerAngle:
                      "u" > typeof _.coneInnerAngle ? _.coneInnerAngle : 360,
                    coneOuterAngle:
                      "u" > typeof _.coneOuterAngle ? _.coneOuterAngle : 360,
                    coneOuterGain:
                      "u" > typeof _.coneOuterGain ? _.coneOuterGain : 0,
                    distanceModel:
                      "u" > typeof _.distanceModel
                        ? _.distanceModel
                        : "inverse",
                    maxDistance:
                      "u" > typeof _.maxDistance ? _.maxDistance : 1e4,
                    panningModel:
                      "u" > typeof _.panningModel ? _.panningModel : "HRTF",
                    refDistance: "u" > typeof _.refDistance ? _.refDistance : 1,
                    rolloffFactor:
                      "u" > typeof _.rolloffFactor ? _.rolloffFactor : 1,
                  }),
                  (this._onstereo = _.onstereo ? [{ fn: _.onstereo }] : []),
                  (this._onpos = _.onpos ? [{ fn: _.onpos }] : []),
                  (this._onorientation = _.onorientation
                    ? [{ fn: _.onorientation }]
                    : []),
                  K.call(this, _)
                );
              })),
            (Howl.prototype.stereo = function (_, L) {
              var R = this;
              if (!R._webAudio) return R;
              if ("loaded" !== R._state)
                return (
                  R._queue.push({
                    event: "stereo",
                    action: function () {
                      R.stereo(_, L);
                    },
                  }),
                  R
                );
              var N =
                typeof Howler.ctx.createStereoPanner > "u"
                  ? "spatial"
                  : "stereo";
              if (typeof L > "u") {
                if ("number" != typeof _) return R._stereo;
                (R._stereo = _), (R._pos = [_, 0, 0]);
              }
              for (var z = R._getSoundIds(L), F = 0; F < z.length; F++) {
                var U = R._soundById(z[F]);
                if (U) {
                  if ("number" != typeof _) return U._stereo;
                  (U._stereo = _),
                    (U._pos = [_, 0, 0]),
                    U._node &&
                      ((U._pannerAttr.panningModel = "equalpower"),
                      (U._panner && U._panner.pan) || ee(U, N),
                      "spatial" === N
                        ? "u" > typeof U._panner.positionX
                          ? (U._panner.positionX.setValueAtTime(
                              _,
                              Howler.ctx.currentTime,
                            ),
                            U._panner.positionY.setValueAtTime(
                              0,
                              Howler.ctx.currentTime,
                            ),
                            U._panner.positionZ.setValueAtTime(
                              0,
                              Howler.ctx.currentTime,
                            ))
                          : U._panner.setPosition(_, 0, 0)
                        : U._panner.pan.setValueAtTime(
                            _,
                            Howler.ctx.currentTime,
                          )),
                    R._emit("stereo", U._id);
                }
              }
              return R;
            }),
            (Howl.prototype.pos = function (_, L, R, N) {
              var z = this;
              if (!z._webAudio) return z;
              if ("loaded" !== z._state)
                return (
                  z._queue.push({
                    event: "pos",
                    action: function () {
                      z.pos(_, L, R, N);
                    },
                  }),
                  z
                );
              if (
                ((L = "number" != typeof L ? 0 : L),
                (R = "number" != typeof R ? -0.5 : R),
                typeof N > "u")
              ) {
                if ("number" != typeof _) return z._pos;
                z._pos = [_, L, R];
              }
              for (var F = z._getSoundIds(N), U = 0; U < F.length; U++) {
                var k = z._soundById(F[U]);
                if (k) {
                  if ("number" != typeof _) return k._pos;
                  (k._pos = [_, L, R]),
                    k._node &&
                      ((!k._panner || k._panner.pan) && ee(k, "spatial"),
                      "u" > typeof k._panner.positionX
                        ? (k._panner.positionX.setValueAtTime(
                            _,
                            Howler.ctx.currentTime,
                          ),
                          k._panner.positionY.setValueAtTime(
                            L,
                            Howler.ctx.currentTime,
                          ),
                          k._panner.positionZ.setValueAtTime(
                            R,
                            Howler.ctx.currentTime,
                          ))
                        : k._panner.setPosition(_, L, R)),
                    z._emit("pos", k._id);
                }
              }
              return z;
            }),
            (Howl.prototype.orientation = function (_, L, R, N) {
              var z = this;
              if (!z._webAudio) return z;
              if ("loaded" !== z._state)
                return (
                  z._queue.push({
                    event: "orientation",
                    action: function () {
                      z.orientation(_, L, R, N);
                    },
                  }),
                  z
                );
              if (
                ((L = "number" != typeof L ? z._orientation[1] : L),
                (R = "number" != typeof R ? z._orientation[2] : R),
                typeof N > "u")
              ) {
                if ("number" != typeof _) return z._orientation;
                z._orientation = [_, L, R];
              }
              for (var F = z._getSoundIds(N), U = 0; U < F.length; U++) {
                var k = z._soundById(F[U]);
                if (k) {
                  if ("number" != typeof _) return k._orientation;
                  (k._orientation = [_, L, R]),
                    k._node &&
                      (k._panner ||
                        (k._pos || (k._pos = z._pos || [0, 0, -0.5]),
                        ee(k, "spatial")),
                      "u" > typeof k._panner.orientationX
                        ? (k._panner.orientationX.setValueAtTime(
                            _,
                            Howler.ctx.currentTime,
                          ),
                          k._panner.orientationY.setValueAtTime(
                            L,
                            Howler.ctx.currentTime,
                          ),
                          k._panner.orientationZ.setValueAtTime(
                            R,
                            Howler.ctx.currentTime,
                          ))
                        : k._panner.setOrientation(_, L, R)),
                    z._emit("orientation", k._id);
                }
              }
              return z;
            }),
            (Howl.prototype.pannerAttr = function () {
              var _,
                L,
                R,
                N = arguments;
              if (!this._webAudio) return this;
              if (0 === N.length) return this._pannerAttr;
              if (1 === N.length) {
                if ("object" != typeof N[0])
                  return (R = this._soundById(parseInt(N[0], 10)))
                    ? R._pannerAttr
                    : this._pannerAttr;
                (_ = N[0]),
                  typeof L > "u" &&
                    (_.pannerAttr ||
                      (_.pannerAttr = {
                        coneInnerAngle: _.coneInnerAngle,
                        coneOuterAngle: _.coneOuterAngle,
                        coneOuterGain: _.coneOuterGain,
                        distanceModel: _.distanceModel,
                        maxDistance: _.maxDistance,
                        refDistance: _.refDistance,
                        rolloffFactor: _.rolloffFactor,
                        panningModel: _.panningModel,
                      }),
                    (this._pannerAttr = {
                      coneInnerAngle:
                        "u" > typeof _.pannerAttr.coneInnerAngle
                          ? _.pannerAttr.coneInnerAngle
                          : this._coneInnerAngle,
                      coneOuterAngle:
                        "u" > typeof _.pannerAttr.coneOuterAngle
                          ? _.pannerAttr.coneOuterAngle
                          : this._coneOuterAngle,
                      coneOuterGain:
                        "u" > typeof _.pannerAttr.coneOuterGain
                          ? _.pannerAttr.coneOuterGain
                          : this._coneOuterGain,
                      distanceModel:
                        "u" > typeof _.pannerAttr.distanceModel
                          ? _.pannerAttr.distanceModel
                          : this._distanceModel,
                      maxDistance:
                        "u" > typeof _.pannerAttr.maxDistance
                          ? _.pannerAttr.maxDistance
                          : this._maxDistance,
                      refDistance:
                        "u" > typeof _.pannerAttr.refDistance
                          ? _.pannerAttr.refDistance
                          : this._refDistance,
                      rolloffFactor:
                        "u" > typeof _.pannerAttr.rolloffFactor
                          ? _.pannerAttr.rolloffFactor
                          : this._rolloffFactor,
                      panningModel:
                        "u" > typeof _.pannerAttr.panningModel
                          ? _.pannerAttr.panningModel
                          : this._panningModel,
                    }));
              } else 2 === N.length && ((_ = N[0]), (L = parseInt(N[1], 10)));
              for (var z = this._getSoundIds(L), F = 0; F < z.length; F++)
                if ((R = this._soundById(z[F]))) {
                  var U = R._pannerAttr;
                  U = {
                    coneInnerAngle:
                      "u" > typeof _.coneInnerAngle
                        ? _.coneInnerAngle
                        : U.coneInnerAngle,
                    coneOuterAngle:
                      "u" > typeof _.coneOuterAngle
                        ? _.coneOuterAngle
                        : U.coneOuterAngle,
                    coneOuterGain:
                      "u" > typeof _.coneOuterGain
                        ? _.coneOuterGain
                        : U.coneOuterGain,
                    distanceModel:
                      "u" > typeof _.distanceModel
                        ? _.distanceModel
                        : U.distanceModel,
                    maxDistance:
                      "u" > typeof _.maxDistance
                        ? _.maxDistance
                        : U.maxDistance,
                    refDistance:
                      "u" > typeof _.refDistance
                        ? _.refDistance
                        : U.refDistance,
                    rolloffFactor:
                      "u" > typeof _.rolloffFactor
                        ? _.rolloffFactor
                        : U.rolloffFactor,
                    panningModel:
                      "u" > typeof _.panningModel
                        ? _.panningModel
                        : U.panningModel,
                  };
                  var k = R._panner;
                  k
                    ? ((k.coneInnerAngle = U.coneInnerAngle),
                      (k.coneOuterAngle = U.coneOuterAngle),
                      (k.coneOuterGain = U.coneOuterGain),
                      (k.distanceModel = U.distanceModel),
                      (k.maxDistance = U.maxDistance),
                      (k.refDistance = U.refDistance),
                      (k.rolloffFactor = U.rolloffFactor),
                      (k.panningModel = U.panningModel))
                    : (R._pos || (R._pos = this._pos || [0, 0, -0.5]),
                      ee(R, "spatial"));
                }
              return this;
            }),
            (Sound.prototype.init =
              ((J = Sound.prototype.init),
              function () {
                var _ = this._parent;
                (this._orientation = _._orientation),
                  (this._stereo = _._stereo),
                  (this._pos = _._pos),
                  (this._pannerAttr = _._pannerAttr),
                  J.call(this),
                  this._stereo
                    ? _.stereo(this._stereo)
                    : this._pos &&
                      _.pos(this._pos[0], this._pos[1], this._pos[2], this._id);
              })),
            (Sound.prototype.reset =
              (($ = Sound.prototype.reset),
              function () {
                var _ = this._parent;
                return (
                  (this._orientation = _._orientation),
                  (this._stereo = _._stereo),
                  (this._pos = _._pos),
                  (this._pannerAttr = _._pannerAttr),
                  this._stereo
                    ? _.stereo(this._stereo)
                    : this._pos
                      ? _.pos(
                          this._pos[0],
                          this._pos[1],
                          this._pos[2],
                          this._id,
                        )
                      : this._panner &&
                        (this._panner.disconnect(0),
                        (this._panner = void 0),
                        _._refreshBuffer(this)),
                  $.call(this)
                );
              })),
            (ee = function (_, L) {
              "spatial" === (L = L || "spatial")
                ? ((_._panner = Howler.ctx.createPanner()),
                  (_._panner.coneInnerAngle = _._pannerAttr.coneInnerAngle),
                  (_._panner.coneOuterAngle = _._pannerAttr.coneOuterAngle),
                  (_._panner.coneOuterGain = _._pannerAttr.coneOuterGain),
                  (_._panner.distanceModel = _._pannerAttr.distanceModel),
                  (_._panner.maxDistance = _._pannerAttr.maxDistance),
                  (_._panner.refDistance = _._pannerAttr.refDistance),
                  (_._panner.rolloffFactor = _._pannerAttr.rolloffFactor),
                  (_._panner.panningModel = _._pannerAttr.panningModel),
                  "u" > typeof _._panner.positionX
                    ? (_._panner.positionX.setValueAtTime(
                        _._pos[0],
                        Howler.ctx.currentTime,
                      ),
                      _._panner.positionY.setValueAtTime(
                        _._pos[1],
                        Howler.ctx.currentTime,
                      ),
                      _._panner.positionZ.setValueAtTime(
                        _._pos[2],
                        Howler.ctx.currentTime,
                      ))
                    : _._panner.setPosition(_._pos[0], _._pos[1], _._pos[2]),
                  "u" > typeof _._panner.orientationX
                    ? (_._panner.orientationX.setValueAtTime(
                        _._orientation[0],
                        Howler.ctx.currentTime,
                      ),
                      _._panner.orientationY.setValueAtTime(
                        _._orientation[1],
                        Howler.ctx.currentTime,
                      ),
                      _._panner.orientationZ.setValueAtTime(
                        _._orientation[2],
                        Howler.ctx.currentTime,
                      ))
                    : _._panner.setOrientation(
                        _._orientation[0],
                        _._orientation[1],
                        _._orientation[2],
                      ))
                : ((_._panner = Howler.ctx.createStereoPanner()),
                  _._panner.pan.setValueAtTime(
                    _._stereo,
                    Howler.ctx.currentTime,
                  )),
                _._panner.connect(_._node),
                _._paused || _._parent.pause(_._id, !0).play(_._id, !0);
            });
        }),
        is = Pf((_, L) => {
          L.exports = function (_, L) {
            for (var R = _.split("."), N = L.split("."), z = 0; z < 3; z++) {
              var F = Number(R[z]),
                U = Number(N[z]);
              if (F > U) return 1;
              if (U > F) return -1;
              if (!isNaN(F) && isNaN(U)) return 1;
              if (isNaN(F) && !isNaN(U)) return -1;
            }
            return 0;
          };
        }),
        ih = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 },
        id = "srgb",
        iu = "srgb-linear",
        ip = "300 es",
        ig = class {
          addEventListener(_, L) {
            void 0 === this._listeners && (this._listeners = {});
            let R = this._listeners;
            void 0 === R[_] && (R[_] = []),
              -1 === R[_].indexOf(L) && R[_].push(L);
          }
          hasEventListener(_, L) {
            if (void 0 === this._listeners) return !1;
            let R = this._listeners;
            return void 0 !== R[_] && -1 !== R[_].indexOf(L);
          }
          removeEventListener(_, L) {
            if (void 0 === this._listeners) return;
            let R = this._listeners[_];
            if (void 0 !== R) {
              let _ = R.indexOf(L);
              -1 !== _ && R.splice(_, 1);
            }
          }
          dispatchEvent(_) {
            if (void 0 === this._listeners) return;
            let L = this._listeners[_.type];
            if (void 0 !== L) {
              _.target = this;
              let R = L.slice(0);
              for (let L = 0, N = R.length; L < N; L++) R[L].call(this, _);
              _.target = null;
            }
          }
        },
        iy = [
          "00",
          "01",
          "02",
          "03",
          "04",
          "05",
          "06",
          "07",
          "08",
          "09",
          "0a",
          "0b",
          "0c",
          "0d",
          "0e",
          "0f",
          "10",
          "11",
          "12",
          "13",
          "14",
          "15",
          "16",
          "17",
          "18",
          "19",
          "1a",
          "1b",
          "1c",
          "1d",
          "1e",
          "1f",
          "20",
          "21",
          "22",
          "23",
          "24",
          "25",
          "26",
          "27",
          "28",
          "29",
          "2a",
          "2b",
          "2c",
          "2d",
          "2e",
          "2f",
          "30",
          "31",
          "32",
          "33",
          "34",
          "35",
          "36",
          "37",
          "38",
          "39",
          "3a",
          "3b",
          "3c",
          "3d",
          "3e",
          "3f",
          "40",
          "41",
          "42",
          "43",
          "44",
          "45",
          "46",
          "47",
          "48",
          "49",
          "4a",
          "4b",
          "4c",
          "4d",
          "4e",
          "4f",
          "50",
          "51",
          "52",
          "53",
          "54",
          "55",
          "56",
          "57",
          "58",
          "59",
          "5a",
          "5b",
          "5c",
          "5d",
          "5e",
          "5f",
          "60",
          "61",
          "62",
          "63",
          "64",
          "65",
          "66",
          "67",
          "68",
          "69",
          "6a",
          "6b",
          "6c",
          "6d",
          "6e",
          "6f",
          "70",
          "71",
          "72",
          "73",
          "74",
          "75",
          "76",
          "77",
          "78",
          "79",
          "7a",
          "7b",
          "7c",
          "7d",
          "7e",
          "7f",
          "80",
          "81",
          "82",
          "83",
          "84",
          "85",
          "86",
          "87",
          "88",
          "89",
          "8a",
          "8b",
          "8c",
          "8d",
          "8e",
          "8f",
          "90",
          "91",
          "92",
          "93",
          "94",
          "95",
          "96",
          "97",
          "98",
          "99",
          "9a",
          "9b",
          "9c",
          "9d",
          "9e",
          "9f",
          "a0",
          "a1",
          "a2",
          "a3",
          "a4",
          "a5",
          "a6",
          "a7",
          "a8",
          "a9",
          "aa",
          "ab",
          "ac",
          "ad",
          "ae",
          "af",
          "b0",
          "b1",
          "b2",
          "b3",
          "b4",
          "b5",
          "b6",
          "b7",
          "b8",
          "b9",
          "ba",
          "bb",
          "bc",
          "bd",
          "be",
          "bf",
          "c0",
          "c1",
          "c2",
          "c3",
          "c4",
          "c5",
          "c6",
          "c7",
          "c8",
          "c9",
          "ca",
          "cb",
          "cc",
          "cd",
          "ce",
          "cf",
          "d0",
          "d1",
          "d2",
          "d3",
          "d4",
          "d5",
          "d6",
          "d7",
          "d8",
          "d9",
          "da",
          "db",
          "dc",
          "dd",
          "de",
          "df",
          "e0",
          "e1",
          "e2",
          "e3",
          "e4",
          "e5",
          "e6",
          "e7",
          "e8",
          "e9",
          "ea",
          "eb",
          "ec",
          "ed",
          "ee",
          "ef",
          "f0",
          "f1",
          "f2",
          "f3",
          "f4",
          "f5",
          "f6",
          "f7",
          "f8",
          "f9",
          "fa",
          "fb",
          "fc",
          "fd",
          "fe",
          "ff",
        ],
        ix = 1234567,
        iw = Math.PI / 180,
        i_ = 180 / Math.PI;
      function es() {
        let _ = (4294967295 * Math.random()) | 0,
          L = (4294967295 * Math.random()) | 0,
          R = (4294967295 * Math.random()) | 0,
          N = (4294967295 * Math.random()) | 0;
        return (
          iy[255 & _] +
          iy[(_ >> 8) & 255] +
          iy[(_ >> 16) & 255] +
          iy[(_ >> 24) & 255] +
          "-" +
          iy[255 & L] +
          iy[(L >> 8) & 255] +
          "-" +
          iy[((L >> 16) & 15) | 64] +
          iy[(L >> 24) & 255] +
          "-" +
          iy[(63 & R) | 128] +
          iy[(R >> 8) & 255] +
          "-" +
          iy[(R >> 16) & 255] +
          iy[(R >> 24) & 255] +
          iy[255 & N] +
          iy[(N >> 8) & 255] +
          iy[(N >> 16) & 255] +
          iy[(N >> 24) & 255]
        ).toLowerCase();
      }
      function _n(_, L, R) {
        return Math.max(L, Math.min(R, _));
      }
      function g0(_, L) {
        return ((_ % L) + L) % L;
      }
      function Ad(_, L, R) {
        return (1 - R) * _ + R * L;
      }
      function Bv(_) {
        return (_ & (_ - 1)) == 0 && 0 !== _;
      }
      function op(_) {
        return Math.pow(2, Math.floor(Math.log(_) / Math.LN2));
      }
      function zs(_, L) {
        switch (L.constructor) {
          case Float32Array:
            return _;
          case Uint16Array:
            return _ / 65535;
          case Uint8Array:
            return _ / 255;
          case Int16Array:
            return Math.max(_ / 32767, -1);
          case Int8Array:
            return Math.max(_ / 127, -1);
          default:
            throw Error("Invalid component type.");
        }
      }
      function Rt(_, L) {
        switch (L.constructor) {
          case Float32Array:
            return _;
          case Uint16Array:
            return Math.round(65535 * _);
          case Uint8Array:
            return Math.round(255 * _);
          case Int16Array:
            return Math.round(32767 * _);
          case Int8Array:
            return Math.round(127 * _);
          default:
            throw Error("Invalid component type.");
        }
      }
      var iE = Object.freeze({
          __proto__: null,
          DEG2RAD: iw,
          RAD2DEG: i_,
          ceilPowerOfTwo: function (_) {
            return Math.pow(2, Math.ceil(Math.log(_) / Math.LN2));
          },
          clamp: _n,
          damp: function (_, L, R, N) {
            return Ad(_, L, 1 - Math.exp(-R * N));
          },
          degToRad: function (_) {
            return _ * iw;
          },
          denormalize: zs,
          euclideanModulo: g0,
          floorPowerOfTwo: op,
          generateUUID: es,
          inverseLerp: function (_, L, R) {
            return _ !== L ? (R - _) / (L - _) : 0;
          },
          isPowerOfTwo: Bv,
          lerp: Ad,
          mapLinear: function (_, L, R, N, z) {
            return N + ((_ - L) * (z - N)) / (R - L);
          },
          normalize: Rt,
          pingpong: function (_, L = 1) {
            return L - Math.abs(g0(_, 2 * L) - L);
          },
          radToDeg: function (_) {
            return _ * i_;
          },
          randFloat: function (_, L) {
            return _ + Math.random() * (L - _);
          },
          randFloatSpread: function (_) {
            return _ * (0.5 - Math.random());
          },
          randInt: function (_, L) {
            return _ + Math.floor(Math.random() * (L - _ + 1));
          },
          seededRandom: function (_) {
            void 0 !== _ && (ix = _);
            let L = (ix += 1831565813);
            return (
              (L = Math.imul(L ^ (L >>> 15), 1 | L)),
              (((L ^= L + Math.imul(L ^ (L >>> 7), 61 | L)) ^ (L >>> 14)) >>>
                0) /
                4294967296
            );
          },
          setQuaternionFromProperEuler: function (_, L, R, N, z) {
            let F = Math.cos,
              U = Math.sin,
              k = F(R / 2),
              Y = U(R / 2),
              X = F((L + N) / 2),
              Q = U((L + N) / 2),
              K = F((L - N) / 2),
              J = U((L - N) / 2),
              $ = F((N - L) / 2),
              ee = U((N - L) / 2);
            switch (z) {
              case "XYX":
                _.set(k * Q, Y * K, Y * J, k * X);
                break;
              case "YZY":
                _.set(Y * J, k * Q, Y * K, k * X);
                break;
              case "ZXZ":
                _.set(Y * K, Y * J, k * Q, k * X);
                break;
              case "XZX":
                _.set(k * Q, Y * ee, Y * $, k * X);
                break;
              case "YXY":
                _.set(Y * $, k * Q, Y * ee, k * X);
                break;
              case "ZYZ":
                _.set(Y * ee, Y * $, k * Q, k * X);
                break;
              default:
                console.warn(
                  "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
                    z,
                );
            }
          },
          smootherstep: function (_, L, R) {
            return _ <= L
              ? 0
              : _ >= R
                ? 1
                : (_ = (_ - L) / (R - L)) * _ * _ * (_ * (6 * _ - 15) + 10);
          },
          smoothstep: function (_, L, R) {
            return _ <= L
              ? 0
              : _ >= R
                ? 1
                : (_ = (_ - L) / (R - L)) * _ * (3 - 2 * _);
          },
        }),
        iT = class {
          constructor(_ = 0, L = 0) {
            (iT.prototype.isVector2 = !0), (this.x = _), (this.y = L);
          }
          get width() {
            return this.x;
          }
          set width(_) {
            this.x = _;
          }
          get height() {
            return this.y;
          }
          set height(_) {
            this.y = _;
          }
          set(_, L) {
            return (this.x = _), (this.y = L), this;
          }
          setScalar(_) {
            return (this.x = _), (this.y = _), this;
          }
          setX(_) {
            return (this.x = _), this;
          }
          setY(_) {
            return (this.y = _), this;
          }
          setComponent(_, L) {
            switch (_) {
              case 0:
                this.x = L;
                break;
              case 1:
                this.y = L;
                break;
              default:
                throw Error("index is out of range: " + _);
            }
            return this;
          }
          getComponent(_) {
            switch (_) {
              case 0:
                return this.x;
              case 1:
                return this.y;
              default:
                throw Error("index is out of range: " + _);
            }
          }
          clone() {
            return new this.constructor(this.x, this.y);
          }
          copy(_) {
            return (this.x = _.x), (this.y = _.y), this;
          }
          add(_) {
            return (this.x += _.x), (this.y += _.y), this;
          }
          addScalar(_) {
            return (this.x += _), (this.y += _), this;
          }
          addVectors(_, L) {
            return (this.x = _.x + L.x), (this.y = _.y + L.y), this;
          }
          addScaledVector(_, L) {
            return (this.x += _.x * L), (this.y += _.y * L), this;
          }
          sub(_) {
            return (this.x -= _.x), (this.y -= _.y), this;
          }
          subScalar(_) {
            return (this.x -= _), (this.y -= _), this;
          }
          subVectors(_, L) {
            return (this.x = _.x - L.x), (this.y = _.y - L.y), this;
          }
          multiply(_) {
            return (this.x *= _.x), (this.y *= _.y), this;
          }
          multiplyScalar(_) {
            return (this.x *= _), (this.y *= _), this;
          }
          divide(_) {
            return (this.x /= _.x), (this.y /= _.y), this;
          }
          divideScalar(_) {
            return this.multiplyScalar(1 / _);
          }
          applyMatrix3(_) {
            let L = this.x,
              R = this.y,
              N = _.elements;
            return (
              (this.x = N[0] * L + N[3] * R + N[6]),
              (this.y = N[1] * L + N[4] * R + N[7]),
              this
            );
          }
          min(_) {
            return (
              (this.x = Math.min(this.x, _.x)),
              (this.y = Math.min(this.y, _.y)),
              this
            );
          }
          max(_) {
            return (
              (this.x = Math.max(this.x, _.x)),
              (this.y = Math.max(this.y, _.y)),
              this
            );
          }
          clamp(_, L) {
            return (
              (this.x = Math.max(_.x, Math.min(L.x, this.x))),
              (this.y = Math.max(_.y, Math.min(L.y, this.y))),
              this
            );
          }
          clampScalar(_, L) {
            return (
              (this.x = Math.max(_, Math.min(L, this.x))),
              (this.y = Math.max(_, Math.min(L, this.y))),
              this
            );
          }
          clampLength(_, L) {
            let R = this.length();
            return this.divideScalar(R || 1).multiplyScalar(
              Math.max(_, Math.min(L, R)),
            );
          }
          floor() {
            return (
              (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this
            );
          }
          ceil() {
            return (
              (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this
            );
          }
          round() {
            return (
              (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this
            );
          }
          roundToZero() {
            return (
              (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
              (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
              this
            );
          }
          negate() {
            return (this.x = -this.x), (this.y = -this.y), this;
          }
          dot(_) {
            return this.x * _.x + this.y * _.y;
          }
          cross(_) {
            return this.x * _.y - this.y * _.x;
          }
          lengthSq() {
            return this.x * this.x + this.y * this.y;
          }
          length() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
          }
          manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y);
          }
          normalize() {
            return this.divideScalar(this.length() || 1);
          }
          angle() {
            return Math.atan2(-this.y, -this.x) + Math.PI;
          }
          distanceTo(_) {
            return Math.sqrt(this.distanceToSquared(_));
          }
          distanceToSquared(_) {
            let L = this.x - _.x,
              R = this.y - _.y;
            return L * L + R * R;
          }
          manhattanDistanceTo(_) {
            return Math.abs(this.x - _.x) + Math.abs(this.y - _.y);
          }
          setLength(_) {
            return this.normalize().multiplyScalar(_);
          }
          lerp(_, L) {
            return (
              (this.x += (_.x - this.x) * L),
              (this.y += (_.y - this.y) * L),
              this
            );
          }
          lerpVectors(_, L, R) {
            return (
              (this.x = _.x + (L.x - _.x) * R),
              (this.y = _.y + (L.y - _.y) * R),
              this
            );
          }
          equals(_) {
            return _.x === this.x && _.y === this.y;
          }
          fromArray(_, L = 0) {
            return (this.x = _[L]), (this.y = _[L + 1]), this;
          }
          toArray(_ = [], L = 0) {
            return (_[L] = this.x), (_[L + 1] = this.y), _;
          }
          fromBufferAttribute(_, L) {
            return (this.x = _.getX(L)), (this.y = _.getY(L)), this;
          }
          rotateAround(_, L) {
            let R = Math.cos(L),
              N = Math.sin(L),
              z = this.x - _.x,
              F = this.y - _.y;
            return (
              (this.x = z * R - F * N + _.x),
              (this.y = z * N + F * R + _.y),
              this
            );
          }
          random() {
            return (this.x = Math.random()), (this.y = Math.random()), this;
          }
          *[Symbol.iterator]() {
            yield this.x, yield this.y;
          }
        },
        iC = class {
          constructor() {
            (iC.prototype.isMatrix3 = !0),
              (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]);
          }
          set(_, L, R, N, z, F, U, k, Y) {
            let X = this.elements;
            return (
              (X[0] = _),
              (X[1] = N),
              (X[2] = U),
              (X[3] = L),
              (X[4] = z),
              (X[5] = k),
              (X[6] = R),
              (X[7] = F),
              (X[8] = Y),
              this
            );
          }
          identity() {
            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
          }
          copy(_) {
            let L = this.elements,
              R = _.elements;
            return (
              (L[0] = R[0]),
              (L[1] = R[1]),
              (L[2] = R[2]),
              (L[3] = R[3]),
              (L[4] = R[4]),
              (L[5] = R[5]),
              (L[6] = R[6]),
              (L[7] = R[7]),
              (L[8] = R[8]),
              this
            );
          }
          extractBasis(_, L, R) {
            return (
              _.setFromMatrix3Column(this, 0),
              L.setFromMatrix3Column(this, 1),
              R.setFromMatrix3Column(this, 2),
              this
            );
          }
          setFromMatrix4(_) {
            let L = _.elements;
            return (
              this.set(L[0], L[4], L[8], L[1], L[5], L[9], L[2], L[6], L[10]),
              this
            );
          }
          multiply(_) {
            return this.multiplyMatrices(this, _);
          }
          premultiply(_) {
            return this.multiplyMatrices(_, this);
          }
          multiplyMatrices(_, L) {
            let R = _.elements,
              N = L.elements,
              z = this.elements,
              F = R[0],
              U = R[3],
              k = R[6],
              Y = R[1],
              X = R[4],
              Q = R[7],
              K = R[2],
              J = R[5],
              $ = R[8],
              ee = N[0],
              er = N[3],
              en = N[6],
              ea = N[1],
              eo = N[4],
              el = N[7],
              ec = N[2],
              ed = N[5],
              eu = N[8];
            return (
              (z[0] = F * ee + U * ea + k * ec),
              (z[3] = F * er + U * eo + k * ed),
              (z[6] = F * en + U * el + k * eu),
              (z[1] = Y * ee + X * ea + Q * ec),
              (z[4] = Y * er + X * eo + Q * ed),
              (z[7] = Y * en + X * el + Q * eu),
              (z[2] = K * ee + J * ea + $ * ec),
              (z[5] = K * er + J * eo + $ * ed),
              (z[8] = K * en + J * el + $ * eu),
              this
            );
          }
          multiplyScalar(_) {
            let L = this.elements;
            return (
              (L[0] *= _),
              (L[3] *= _),
              (L[6] *= _),
              (L[1] *= _),
              (L[4] *= _),
              (L[7] *= _),
              (L[2] *= _),
              (L[5] *= _),
              (L[8] *= _),
              this
            );
          }
          determinant() {
            let _ = this.elements,
              L = _[0],
              R = _[1],
              N = _[2],
              z = _[3],
              F = _[4],
              U = _[5],
              k = _[6],
              Y = _[7],
              X = _[8];
            return (
              L * F * X -
              L * U * Y -
              R * z * X +
              R * U * k +
              N * z * Y -
              N * F * k
            );
          }
          invert() {
            let _ = this.elements,
              L = _[0],
              R = _[1],
              N = _[2],
              z = _[3],
              F = _[4],
              U = _[5],
              k = _[6],
              Y = _[7],
              X = _[8],
              Q = X * F - U * Y,
              K = U * k - X * z,
              J = Y * z - F * k,
              $ = L * Q + R * K + N * J;
            if (0 === $) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
            let ee = 1 / $;
            return (
              (_[0] = Q * ee),
              (_[1] = (N * Y - X * R) * ee),
              (_[2] = (U * R - N * F) * ee),
              (_[3] = K * ee),
              (_[4] = (X * L - N * k) * ee),
              (_[5] = (N * z - U * L) * ee),
              (_[6] = J * ee),
              (_[7] = (R * k - Y * L) * ee),
              (_[8] = (F * L - R * z) * ee),
              this
            );
          }
          transpose() {
            let _,
              L = this.elements;
            return (
              (_ = L[1]),
              (L[1] = L[3]),
              (L[3] = _),
              (_ = L[2]),
              (L[2] = L[6]),
              (L[6] = _),
              (_ = L[5]),
              (L[5] = L[7]),
              (L[7] = _),
              this
            );
          }
          getNormalMatrix(_) {
            return this.setFromMatrix4(_).invert().transpose();
          }
          transposeIntoArray(_) {
            let L = this.elements;
            return (
              (_[0] = L[0]),
              (_[1] = L[3]),
              (_[2] = L[6]),
              (_[3] = L[1]),
              (_[4] = L[4]),
              (_[5] = L[7]),
              (_[6] = L[2]),
              (_[7] = L[5]),
              (_[8] = L[8]),
              this
            );
          }
          setUvTransform(_, L, R, N, z, F, U) {
            let k = Math.cos(z),
              Y = Math.sin(z);
            return (
              this.set(
                R * k,
                R * Y,
                -R * (k * F + Y * U) + F + _,
                -N * Y,
                N * k,
                -N * (-Y * F + k * U) + U + L,
                0,
                0,
                1,
              ),
              this
            );
          }
          scale(_, L) {
            return this.premultiply(iP.makeScale(_, L)), this;
          }
          rotate(_) {
            return this.premultiply(iP.makeRotation(-_)), this;
          }
          translate(_, L) {
            return this.premultiply(iP.makeTranslation(_, L)), this;
          }
          makeTranslation(_, L) {
            return this.set(1, 0, _, 0, 1, L, 0, 0, 1), this;
          }
          makeRotation(_) {
            let L = Math.cos(_),
              R = Math.sin(_);
            return this.set(L, -R, 0, R, L, 0, 0, 0, 1), this;
          }
          makeScale(_, L) {
            return this.set(_, 0, 0, 0, L, 0, 0, 0, 1), this;
          }
          equals(_) {
            let L = this.elements,
              R = _.elements;
            for (let _ = 0; _ < 9; _++) if (L[_] !== R[_]) return !1;
            return !0;
          }
          fromArray(_, L = 0) {
            for (let R = 0; R < 9; R++) this.elements[R] = _[R + L];
            return this;
          }
          toArray(_ = [], L = 0) {
            let R = this.elements;
            return (
              (_[L] = R[0]),
              (_[L + 1] = R[1]),
              (_[L + 2] = R[2]),
              (_[L + 3] = R[3]),
              (_[L + 4] = R[4]),
              (_[L + 5] = R[5]),
              (_[L + 6] = R[6]),
              (_[L + 7] = R[7]),
              (_[L + 8] = R[8]),
              _
            );
          }
          clone() {
            return new this.constructor().fromArray(this.elements);
          }
        },
        iP = new iC();
      function N1(_) {
        for (let L = _.length - 1; L >= 0; --L) if (_[L] >= 65535) return !0;
        return !1;
      }
      var iD = {
        Int8Array,
        Uint8Array,
        Uint8ClampedArray,
        Int16Array,
        Uint16Array,
        Int32Array,
        Uint32Array,
        Float32Array,
        Float64Array,
      };
      function If(_, L) {
        return new iD[_](L);
      }
      function ap(_) {
        return document.createElementNS("http://www.w3.org/1999/xhtml", _);
      }
      function Ta(_) {
        return _ < 0.04045
          ? 0.0773993808 * _
          : Math.pow(0.9478672986 * _ + 0.0521327014, 2.4);
      }
      function rp(_) {
        return _ < 0.0031308 ? 12.92 * _ : 1.055 * Math.pow(_, 0.41666) - 0.055;
      }
      var iO = { [id]: { [iu]: Ta }, [iu]: { [id]: rp } },
        iL = {
          legacyMode: !0,
          get workingColorSpace() {
            return iu;
          },
          set workingColorSpace(r) {
            console.warn(
              "THREE.ColorManagement: .workingColorSpace is readonly.",
            );
          },
          convert: function (_, L, R) {
            if (this.legacyMode || L === R || !L || !R) return _;
            if (iO[L] && void 0 !== iO[L][R]) {
              let N = iO[L][R];
              return (_.r = N(_.r)), (_.g = N(_.g)), (_.b = N(_.b)), _;
            }
            throw Error("Unsupported color space conversion.");
          },
          fromWorkingColorSpace: function (_, L) {
            return this.convert(_, this.workingColorSpace, L);
          },
          toWorkingColorSpace: function (_, L) {
            return this.convert(_, L, this.workingColorSpace);
          },
        },
        iR = {
          aliceblue: 15792383,
          antiquewhite: 16444375,
          aqua: 65535,
          aquamarine: 8388564,
          azure: 15794175,
          beige: 16119260,
          bisque: 16770244,
          black: 0,
          blanchedalmond: 16772045,
          blue: 255,
          blueviolet: 9055202,
          brown: 10824234,
          burlywood: 14596231,
          cadetblue: 6266528,
          chartreuse: 8388352,
          chocolate: 13789470,
          coral: 16744272,
          cornflowerblue: 6591981,
          cornsilk: 16775388,
          crimson: 14423100,
          cyan: 65535,
          darkblue: 139,
          darkcyan: 35723,
          darkgoldenrod: 12092939,
          darkgray: 11119017,
          darkgreen: 25600,
          darkgrey: 11119017,
          darkkhaki: 12433259,
          darkmagenta: 9109643,
          darkolivegreen: 5597999,
          darkorange: 16747520,
          darkorchid: 10040012,
          darkred: 9109504,
          darksalmon: 15308410,
          darkseagreen: 9419919,
          darkslateblue: 4734347,
          darkslategray: 3100495,
          darkslategrey: 3100495,
          darkturquoise: 52945,
          darkviolet: 9699539,
          deeppink: 16716947,
          deepskyblue: 49151,
          dimgray: 6908265,
          dimgrey: 6908265,
          dodgerblue: 2003199,
          firebrick: 11674146,
          floralwhite: 16775920,
          forestgreen: 2263842,
          fuchsia: 16711935,
          gainsboro: 14474460,
          ghostwhite: 16316671,
          gold: 16766720,
          goldenrod: 14329120,
          gray: 8421504,
          green: 32768,
          greenyellow: 11403055,
          grey: 8421504,
          honeydew: 15794160,
          hotpink: 16738740,
          indianred: 13458524,
          indigo: 4915330,
          ivory: 16777200,
          khaki: 15787660,
          lavender: 15132410,
          lavenderblush: 16773365,
          lawngreen: 8190976,
          lemonchiffon: 16775885,
          lightblue: 11393254,
          lightcoral: 15761536,
          lightcyan: 14745599,
          lightgoldenrodyellow: 16448210,
          lightgray: 13882323,
          lightgreen: 9498256,
          lightgrey: 13882323,
          lightpink: 16758465,
          lightsalmon: 16752762,
          lightseagreen: 2142890,
          lightskyblue: 8900346,
          lightslategray: 7833753,
          lightslategrey: 7833753,
          lightsteelblue: 11584734,
          lightyellow: 16777184,
          lime: 65280,
          limegreen: 3329330,
          linen: 16445670,
          magenta: 16711935,
          maroon: 8388608,
          mediumaquamarine: 6737322,
          mediumblue: 205,
          mediumorchid: 12211667,
          mediumpurple: 9662683,
          mediumseagreen: 3978097,
          mediumslateblue: 8087790,
          mediumspringgreen: 64154,
          mediumturquoise: 4772300,
          mediumvioletred: 13047173,
          midnightblue: 1644912,
          mintcream: 16121850,
          mistyrose: 16770273,
          moccasin: 16770229,
          navajowhite: 16768685,
          navy: 128,
          oldlace: 16643558,
          olive: 8421376,
          olivedrab: 7048739,
          orange: 16753920,
          orangered: 16729344,
          orchid: 14315734,
          palegoldenrod: 15657130,
          palegreen: 10025880,
          paleturquoise: 11529966,
          palevioletred: 14381203,
          papayawhip: 16773077,
          peachpuff: 16767673,
          peru: 13468991,
          pink: 16761035,
          plum: 14524637,
          powderblue: 11591910,
          purple: 8388736,
          rebeccapurple: 6697881,
          red: 16711680,
          rosybrown: 12357519,
          royalblue: 4286945,
          saddlebrown: 9127187,
          salmon: 16416882,
          sandybrown: 16032864,
          seagreen: 3050327,
          seashell: 16774638,
          sienna: 10506797,
          silver: 12632256,
          skyblue: 8900331,
          slateblue: 6970061,
          slategray: 7372944,
          slategrey: 7372944,
          snow: 16775930,
          springgreen: 65407,
          steelblue: 4620980,
          tan: 13808780,
          teal: 32896,
          thistle: 14204888,
          tomato: 16737095,
          turquoise: 4251856,
          violet: 15631086,
          wheat: 16113331,
          white: 16777215,
          whitesmoke: 16119285,
          yellow: 16776960,
          yellowgreen: 10145074,
        },
        iI = { r: 0, g: 0, b: 0 },
        iB = { h: 0, s: 0, l: 0 },
        iN = { h: 0, s: 0, l: 0 };
      function rv(_, L, R) {
        return (
          R < 0 && (R += 1),
          R > 1 && (R -= 1),
          R < 1 / 6
            ? _ + (L - _) * 6 * R
            : R < 0.5
              ? L
              : R < 2 / 3
                ? _ + (L - _) * 6 * (2 / 3 - R)
                : _
        );
      }
      function Of(_, L) {
        return (L.r = _.r), (L.g = _.g), (L.b = _.b), L;
      }
      var iz = class {
        constructor(_, L, R) {
          return (
            (this.isColor = !0),
            (this.r = 1),
            (this.g = 1),
            (this.b = 1),
            void 0 === L && void 0 === R ? this.set(_) : this.setRGB(_, L, R)
          );
        }
        set(_) {
          return (
            _ && _.isColor
              ? this.copy(_)
              : "number" == typeof _
                ? this.setHex(_)
                : "string" == typeof _ && this.setStyle(_),
            this
          );
        }
        setScalar(_) {
          return (this.r = _), (this.g = _), (this.b = _), this;
        }
        setHex(_, L = id) {
          return (
            (_ = Math.floor(_)),
            (this.r = ((_ >> 16) & 255) / 255),
            (this.g = ((_ >> 8) & 255) / 255),
            (this.b = (255 & _) / 255),
            iL.toWorkingColorSpace(this, L),
            this
          );
        }
        setRGB(_, L, R, N = iL.workingColorSpace) {
          return (
            (this.r = _),
            (this.g = L),
            (this.b = R),
            iL.toWorkingColorSpace(this, N),
            this
          );
        }
        setHSL(_, L, R, N = iL.workingColorSpace) {
          if (((_ = g0(_, 1)), (L = _n(L, 0, 1)), (R = _n(R, 0, 1)), 0 === L))
            this.r = this.g = this.b = R;
          else {
            let N = R <= 0.5 ? R * (1 + L) : R + L - R * L,
              z = 2 * R - N;
            (this.r = rv(z, N, _ + 1 / 3)),
              (this.g = rv(z, N, _)),
              (this.b = rv(z, N, _ - 1 / 3));
          }
          return iL.toWorkingColorSpace(this, N), this;
        }
        setStyle(_, L = id) {
          let R;
          function n(L) {
            void 0 !== L &&
              1 > parseFloat(L) &&
              console.warn(
                "THREE.Color: Alpha component of " + _ + " will be ignored.",
              );
          }
          if ((R = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(_))) {
            let _,
              N = R[1],
              z = R[2];
            switch (N) {
              case "rgb":
              case "rgba":
                if (
                  (_ =
                    /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                      z,
                    ))
                )
                  return (
                    (this.r = Math.min(255, parseInt(_[1], 10)) / 255),
                    (this.g = Math.min(255, parseInt(_[2], 10)) / 255),
                    (this.b = Math.min(255, parseInt(_[3], 10)) / 255),
                    iL.toWorkingColorSpace(this, L),
                    n(_[4]),
                    this
                  );
                if (
                  (_ =
                    /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                      z,
                    ))
                )
                  return (
                    (this.r = Math.min(100, parseInt(_[1], 10)) / 100),
                    (this.g = Math.min(100, parseInt(_[2], 10)) / 100),
                    (this.b = Math.min(100, parseInt(_[3], 10)) / 100),
                    iL.toWorkingColorSpace(this, L),
                    n(_[4]),
                    this
                  );
                break;
              case "hsl":
              case "hsla":
                if (
                  (_ =
                    /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                      z,
                    ))
                ) {
                  let R = parseFloat(_[1]) / 360,
                    N = parseFloat(_[2]) / 100,
                    z = parseFloat(_[3]) / 100;
                  return n(_[4]), this.setHSL(R, N, z, L);
                }
            }
          } else if ((R = /^\#([A-Fa-f\d]+)$/.exec(_))) {
            let _ = R[1],
              N = _.length;
            if (3 === N)
              return (
                (this.r = parseInt(_.charAt(0) + _.charAt(0), 16) / 255),
                (this.g = parseInt(_.charAt(1) + _.charAt(1), 16) / 255),
                (this.b = parseInt(_.charAt(2) + _.charAt(2), 16) / 255),
                iL.toWorkingColorSpace(this, L),
                this
              );
            if (6 === N)
              return (
                (this.r = parseInt(_.charAt(0) + _.charAt(1), 16) / 255),
                (this.g = parseInt(_.charAt(2) + _.charAt(3), 16) / 255),
                (this.b = parseInt(_.charAt(4) + _.charAt(5), 16) / 255),
                iL.toWorkingColorSpace(this, L),
                this
              );
          }
          return _ && _.length > 0 ? this.setColorName(_, L) : this;
        }
        setColorName(_, L = id) {
          let R = iR[_.toLowerCase()];
          return (
            void 0 !== R
              ? this.setHex(R, L)
              : console.warn("THREE.Color: Unknown color " + _),
            this
          );
        }
        clone() {
          return new this.constructor(this.r, this.g, this.b);
        }
        copy(_) {
          return (this.r = _.r), (this.g = _.g), (this.b = _.b), this;
        }
        copySRGBToLinear(_) {
          return (
            (this.r = Ta(_.r)), (this.g = Ta(_.g)), (this.b = Ta(_.b)), this
          );
        }
        copyLinearToSRGB(_) {
          return (
            (this.r = rp(_.r)), (this.g = rp(_.g)), (this.b = rp(_.b)), this
          );
        }
        convertSRGBToLinear() {
          return this.copySRGBToLinear(this), this;
        }
        convertLinearToSRGB() {
          return this.copyLinearToSRGB(this), this;
        }
        getHex(_ = id) {
          return (
            iL.fromWorkingColorSpace(Of(this, iI), _),
            (_n(255 * iI.r, 0, 255) << 16) ^
              (_n(255 * iI.g, 0, 255) << 8) ^
              (_n(255 * iI.b, 0, 255) << 0)
          );
        }
        getHexString(_ = id) {
          return ("000000" + this.getHex(_).toString(16)).slice(-6);
        }
        getHSL(_, L = iL.workingColorSpace) {
          iL.fromWorkingColorSpace(Of(this, iI), L);
          let R = iI.r,
            N = iI.g,
            z = iI.b,
            F = Math.max(R, N, z),
            U = Math.min(R, N, z),
            k,
            Y,
            X = (U + F) / 2;
          if (U === F) (k = 0), (Y = 0);
          else {
            let _ = F - U;
            switch (((Y = X <= 0.5 ? _ / (F + U) : _ / (2 - F - U)), F)) {
              case R:
                k = (N - z) / _ + (N < z ? 6 : 0);
                break;
              case N:
                k = (z - R) / _ + 2;
                break;
              case z:
                k = (R - N) / _ + 4;
            }
            k /= 6;
          }
          return (_.h = k), (_.s = Y), (_.l = X), _;
        }
        getRGB(_, L = iL.workingColorSpace) {
          return (
            iL.fromWorkingColorSpace(Of(this, iI), L),
            (_.r = iI.r),
            (_.g = iI.g),
            (_.b = iI.b),
            _
          );
        }
        getStyle(_ = id) {
          return (
            iL.fromWorkingColorSpace(Of(this, iI), _),
            _ !== id
              ? `color(${_} ${iI.r} ${iI.g} ${iI.b})`
              : `rgb(${(255 * iI.r) | 0},${(255 * iI.g) | 0},${
                  (255 * iI.b) | 0
                })`
          );
        }
        offsetHSL(_, L, R) {
          return (
            this.getHSL(iB),
            (iB.h += _),
            (iB.s += L),
            (iB.l += R),
            this.setHSL(iB.h, iB.s, iB.l),
            this
          );
        }
        add(_) {
          return (this.r += _.r), (this.g += _.g), (this.b += _.b), this;
        }
        addColors(_, L) {
          return (
            (this.r = _.r + L.r),
            (this.g = _.g + L.g),
            (this.b = _.b + L.b),
            this
          );
        }
        addScalar(_) {
          return (this.r += _), (this.g += _), (this.b += _), this;
        }
        sub(_) {
          return (
            (this.r = Math.max(0, this.r - _.r)),
            (this.g = Math.max(0, this.g - _.g)),
            (this.b = Math.max(0, this.b - _.b)),
            this
          );
        }
        multiply(_) {
          return (this.r *= _.r), (this.g *= _.g), (this.b *= _.b), this;
        }
        multiplyScalar(_) {
          return (this.r *= _), (this.g *= _), (this.b *= _), this;
        }
        lerp(_, L) {
          return (
            (this.r += (_.r - this.r) * L),
            (this.g += (_.g - this.g) * L),
            (this.b += (_.b - this.b) * L),
            this
          );
        }
        lerpColors(_, L, R) {
          return (
            (this.r = _.r + (L.r - _.r) * R),
            (this.g = _.g + (L.g - _.g) * R),
            (this.b = _.b + (L.b - _.b) * R),
            this
          );
        }
        lerpHSL(_, L) {
          this.getHSL(iB), _.getHSL(iN);
          let R = Ad(iB.h, iN.h, L),
            N = Ad(iB.s, iN.s, L),
            z = Ad(iB.l, iN.l, L);
          return this.setHSL(R, N, z), this;
        }
        equals(_) {
          return _.r === this.r && _.g === this.g && _.b === this.b;
        }
        fromArray(_, L = 0) {
          return (
            (this.r = _[L]), (this.g = _[L + 1]), (this.b = _[L + 2]), this
          );
        }
        toArray(_ = [], L = 0) {
          return (_[L] = this.r), (_[L + 1] = this.g), (_[L + 2] = this.b), _;
        }
        fromBufferAttribute(_, L) {
          return (
            (this.r = _.getX(L)),
            (this.g = _.getY(L)),
            (this.b = _.getZ(L)),
            this
          );
        }
        toJSON() {
          return this.getHex();
        }
        *[Symbol.iterator]() {
          yield this.r, yield this.g, yield this.b;
        }
      };
      iz.NAMES = iR;
      var iF,
        iU = class {
          static getDataURL(_) {
            let L;
            if (/^data:/i.test(_.src) || typeof HTMLCanvasElement > "u")
              return _.src;
            if (_ instanceof HTMLCanvasElement) L = _;
            else {
              void 0 === iF && (iF = ap("canvas")),
                (iF.width = _.width),
                (iF.height = _.height);
              let R = iF.getContext("2d");
              _ instanceof ImageData
                ? R.putImageData(_, 0, 0)
                : R.drawImage(_, 0, 0, _.width, _.height),
                (L = iF);
            }
            return L.width > 2048 || L.height > 2048
              ? (console.warn(
                  "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
                  _,
                ),
                L.toDataURL("image/jpeg", 0.6))
              : L.toDataURL("image/png");
          }
          static sRGBToLinear(_) {
            if (
              ("u" > typeof HTMLImageElement &&
                _ instanceof HTMLImageElement) ||
              ("u" > typeof HTMLCanvasElement &&
                _ instanceof HTMLCanvasElement) ||
              ("u" > typeof ImageBitmap && _ instanceof ImageBitmap)
            ) {
              let L = ap("canvas");
              (L.width = _.width), (L.height = _.height);
              let R = L.getContext("2d");
              R.drawImage(_, 0, 0, _.width, _.height);
              let N = R.getImageData(0, 0, _.width, _.height),
                z = N.data;
              for (let _ = 0; _ < z.length; _++) z[_] = 255 * Ta(z[_] / 255);
              return R.putImageData(N, 0, 0), L;
            }
            if (!_.data)
              return (
                console.warn(
                  "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.",
                ),
                _
              );
            {
              let L = _.data.slice(0);
              for (let _ = 0; _ < L.length; _++)
                L instanceof Uint8Array || L instanceof Uint8ClampedArray
                  ? (L[_] = Math.floor(255 * Ta(L[_] / 255)))
                  : (L[_] = Ta(L[_]));
              return { data: L, width: _.width, height: _.height };
            }
          }
        },
        ik = class {
          constructor(_ = null) {
            (this.isSource = !0),
              (this.uuid = es()),
              (this.data = _),
              (this.version = 0);
          }
          set needsUpdate(_) {
            !0 === _ && this.version++;
          }
          toJSON(_) {
            let L = void 0 === _ || "string" == typeof _;
            if (!L && void 0 !== _.images[this.uuid])
              return _.images[this.uuid];
            let R = { uuid: this.uuid, url: "" },
              N = this.data;
            if (null !== N) {
              let _;
              if (Array.isArray(N)) {
                _ = [];
                for (let L = 0, R = N.length; L < R; L++)
                  N[L].isDataTexture
                    ? _.push(iv(N[L].image))
                    : _.push(iv(N[L]));
              } else _ = iv(N);
              R.url = _;
            }
            return L || (_.images[this.uuid] = R), R;
          }
        };
      function iv(_) {
        return ("u" > typeof HTMLImageElement &&
          _ instanceof HTMLImageElement) ||
          ("u" > typeof HTMLCanvasElement && _ instanceof HTMLCanvasElement) ||
          ("u" > typeof ImageBitmap && _ instanceof ImageBitmap)
          ? iU.getDataURL(_)
          : _.data
            ? {
                data: Array.from(_.data),
                width: _.width,
                height: _.height,
                type: _.data.constructor.name,
              }
            : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
      }
      var ij = 0,
        iG = class extends ig {
          constructor(
            _ = iG.DEFAULT_IMAGE,
            L = iG.DEFAULT_MAPPING,
            R = 1001,
            N = 1001,
            z = 1006,
            F = 1008,
            U = 1023,
            k = 1009,
            Y = iG.DEFAULT_ANISOTROPY,
            X = 3e3,
          ) {
            super(),
              (this.isTexture = !0),
              Object.defineProperty(this, "id", { value: ij++ }),
              (this.uuid = es()),
              (this.name = ""),
              (this.source = new ik(_)),
              (this.mipmaps = []),
              (this.mapping = L),
              (this.wrapS = R),
              (this.wrapT = N),
              (this.magFilter = z),
              (this.minFilter = F),
              (this.anisotropy = Y),
              (this.format = U),
              (this.internalFormat = null),
              (this.type = k),
              (this.offset = new iT(0, 0)),
              (this.repeat = new iT(1, 1)),
              (this.center = new iT(0, 0)),
              (this.rotation = 0),
              (this.matrixAutoUpdate = !0),
              (this.matrix = new iC()),
              (this.generateMipmaps = !0),
              (this.premultiplyAlpha = !1),
              (this.flipY = !0),
              (this.unpackAlignment = 4),
              (this.encoding = X),
              (this.userData = {}),
              (this.version = 0),
              (this.onUpdate = null),
              (this.isRenderTargetTexture = !1),
              (this.needsPMREMUpdate = !1);
          }
          get image() {
            return this.source.data;
          }
          set image(_) {
            this.source.data = _;
          }
          updateMatrix() {
            this.matrix.setUvTransform(
              this.offset.x,
              this.offset.y,
              this.repeat.x,
              this.repeat.y,
              this.rotation,
              this.center.x,
              this.center.y,
            );
          }
          clone() {
            return new this.constructor().copy(this);
          }
          copy(_) {
            return (
              (this.name = _.name),
              (this.source = _.source),
              (this.mipmaps = _.mipmaps.slice(0)),
              (this.mapping = _.mapping),
              (this.wrapS = _.wrapS),
              (this.wrapT = _.wrapT),
              (this.magFilter = _.magFilter),
              (this.minFilter = _.minFilter),
              (this.anisotropy = _.anisotropy),
              (this.format = _.format),
              (this.internalFormat = _.internalFormat),
              (this.type = _.type),
              this.offset.copy(_.offset),
              this.repeat.copy(_.repeat),
              this.center.copy(_.center),
              (this.rotation = _.rotation),
              (this.matrixAutoUpdate = _.matrixAutoUpdate),
              this.matrix.copy(_.matrix),
              (this.generateMipmaps = _.generateMipmaps),
              (this.premultiplyAlpha = _.premultiplyAlpha),
              (this.flipY = _.flipY),
              (this.unpackAlignment = _.unpackAlignment),
              (this.encoding = _.encoding),
              (this.userData = JSON.parse(JSON.stringify(_.userData))),
              (this.needsUpdate = !0),
              this
            );
          }
          toJSON(_) {
            let L = void 0 === _ || "string" == typeof _;
            if (!L && void 0 !== _.textures[this.uuid])
              return _.textures[this.uuid];
            let R = {
              metadata: {
                version: 4.5,
                type: "Texture",
                generator: "Texture.toJSON",
              },
              uuid: this.uuid,
              name: this.name,
              image: this.source.toJSON(_).uuid,
              mapping: this.mapping,
              repeat: [this.repeat.x, this.repeat.y],
              offset: [this.offset.x, this.offset.y],
              center: [this.center.x, this.center.y],
              rotation: this.rotation,
              wrap: [this.wrapS, this.wrapT],
              format: this.format,
              type: this.type,
              encoding: this.encoding,
              minFilter: this.minFilter,
              magFilter: this.magFilter,
              anisotropy: this.anisotropy,
              flipY: this.flipY,
              generateMipmaps: this.generateMipmaps,
              premultiplyAlpha: this.premultiplyAlpha,
              unpackAlignment: this.unpackAlignment,
            };
            return (
              Object.keys(this.userData).length > 0 &&
                (R.userData = this.userData),
              L || (_.textures[this.uuid] = R),
              R
            );
          }
          dispose() {
            this.dispatchEvent({ type: "dispose" });
          }
          transformUv(_) {
            if (300 !== this.mapping) return _;
            if ((_.applyMatrix3(this.matrix), _.x < 0 || _.x > 1))
              switch (this.wrapS) {
                case 1e3:
                  _.x = _.x - Math.floor(_.x);
                  break;
                case 1001:
                  _.x = _.x < 0 ? 0 : 1;
                  break;
                case 1002:
                  1 === Math.abs(Math.floor(_.x) % 2)
                    ? (_.x = Math.ceil(_.x) - _.x)
                    : (_.x = _.x - Math.floor(_.x));
              }
            if (_.y < 0 || _.y > 1)
              switch (this.wrapT) {
                case 1e3:
                  _.y = _.y - Math.floor(_.y);
                  break;
                case 1001:
                  _.y = _.y < 0 ? 0 : 1;
                  break;
                case 1002:
                  1 === Math.abs(Math.floor(_.y) % 2)
                    ? (_.y = Math.ceil(_.y) - _.y)
                    : (_.y = _.y - Math.floor(_.y));
              }
            return this.flipY && (_.y = 1 - _.y), _;
          }
          set needsUpdate(_) {
            !0 === _ && (this.version++, (this.source.needsUpdate = !0));
          }
        };
      (iG.DEFAULT_IMAGE = null),
        (iG.DEFAULT_MAPPING = 300),
        (iG.DEFAULT_ANISOTROPY = 1);
      var iV = class {
          constructor(_ = 0, L = 0, R = 0, N = 1) {
            (iV.prototype.isVector4 = !0),
              (this.x = _),
              (this.y = L),
              (this.z = R),
              (this.w = N);
          }
          get width() {
            return this.z;
          }
          set width(_) {
            this.z = _;
          }
          get height() {
            return this.w;
          }
          set height(_) {
            this.w = _;
          }
          set(_, L, R, N) {
            return (this.x = _), (this.y = L), (this.z = R), (this.w = N), this;
          }
          setScalar(_) {
            return (this.x = _), (this.y = _), (this.z = _), (this.w = _), this;
          }
          setX(_) {
            return (this.x = _), this;
          }
          setY(_) {
            return (this.y = _), this;
          }
          setZ(_) {
            return (this.z = _), this;
          }
          setW(_) {
            return (this.w = _), this;
          }
          setComponent(_, L) {
            switch (_) {
              case 0:
                this.x = L;
                break;
              case 1:
                this.y = L;
                break;
              case 2:
                this.z = L;
                break;
              case 3:
                this.w = L;
                break;
              default:
                throw Error("index is out of range: " + _);
            }
            return this;
          }
          getComponent(_) {
            switch (_) {
              case 0:
                return this.x;
              case 1:
                return this.y;
              case 2:
                return this.z;
              case 3:
                return this.w;
              default:
                throw Error("index is out of range: " + _);
            }
          }
          clone() {
            return new this.constructor(this.x, this.y, this.z, this.w);
          }
          copy(_) {
            return (
              (this.x = _.x),
              (this.y = _.y),
              (this.z = _.z),
              (this.w = void 0 !== _.w ? _.w : 1),
              this
            );
          }
          add(_) {
            return (
              (this.x += _.x),
              (this.y += _.y),
              (this.z += _.z),
              (this.w += _.w),
              this
            );
          }
          addScalar(_) {
            return (
              (this.x += _), (this.y += _), (this.z += _), (this.w += _), this
            );
          }
          addVectors(_, L) {
            return (
              (this.x = _.x + L.x),
              (this.y = _.y + L.y),
              (this.z = _.z + L.z),
              (this.w = _.w + L.w),
              this
            );
          }
          addScaledVector(_, L) {
            return (
              (this.x += _.x * L),
              (this.y += _.y * L),
              (this.z += _.z * L),
              (this.w += _.w * L),
              this
            );
          }
          sub(_) {
            return (
              (this.x -= _.x),
              (this.y -= _.y),
              (this.z -= _.z),
              (this.w -= _.w),
              this
            );
          }
          subScalar(_) {
            return (
              (this.x -= _), (this.y -= _), (this.z -= _), (this.w -= _), this
            );
          }
          subVectors(_, L) {
            return (
              (this.x = _.x - L.x),
              (this.y = _.y - L.y),
              (this.z = _.z - L.z),
              (this.w = _.w - L.w),
              this
            );
          }
          multiply(_) {
            return (
              (this.x *= _.x),
              (this.y *= _.y),
              (this.z *= _.z),
              (this.w *= _.w),
              this
            );
          }
          multiplyScalar(_) {
            return (
              (this.x *= _), (this.y *= _), (this.z *= _), (this.w *= _), this
            );
          }
          applyMatrix4(_) {
            let L = this.x,
              R = this.y,
              N = this.z,
              z = this.w,
              F = _.elements;
            return (
              (this.x = F[0] * L + F[4] * R + F[8] * N + F[12] * z),
              (this.y = F[1] * L + F[5] * R + F[9] * N + F[13] * z),
              (this.z = F[2] * L + F[6] * R + F[10] * N + F[14] * z),
              (this.w = F[3] * L + F[7] * R + F[11] * N + F[15] * z),
              this
            );
          }
          divideScalar(_) {
            return this.multiplyScalar(1 / _);
          }
          setAxisAngleFromQuaternion(_) {
            this.w = 2 * Math.acos(_.w);
            let L = Math.sqrt(1 - _.w * _.w);
            return (
              L < 1e-4
                ? ((this.x = 1), (this.y = 0), (this.z = 0))
                : ((this.x = _.x / L), (this.y = _.y / L), (this.z = _.z / L)),
              this
            );
          }
          setAxisAngleFromRotationMatrix(_) {
            let L,
              R,
              N,
              z,
              F = _.elements,
              U = F[0],
              k = F[4],
              Y = F[8],
              X = F[1],
              Q = F[5],
              K = F[9],
              J = F[2],
              $ = F[6],
              ee = F[10];
            if (
              0.01 > Math.abs(k - X) &&
              0.01 > Math.abs(Y - J) &&
              0.01 > Math.abs(K - $)
            ) {
              if (
                0.1 > Math.abs(k + X) &&
                0.1 > Math.abs(Y + J) &&
                0.1 > Math.abs(K + $) &&
                0.1 > Math.abs(U + Q + ee - 3)
              )
                return this.set(1, 0, 0, 0), this;
              L = Math.PI;
              let _ = (U + 1) / 2,
                F = (Q + 1) / 2,
                er = (ee + 1) / 2,
                en = (k + X) / 4,
                ea = (Y + J) / 4,
                eo = (K + $) / 4;
              return (
                _ > F && _ > er
                  ? _ < 0.01
                    ? ((R = 0), (N = 0.707106781), (z = 0.707106781))
                    : ((N = en / (R = Math.sqrt(_))), (z = ea / R))
                  : F > er
                    ? F < 0.01
                      ? ((R = 0.707106781), (N = 0), (z = 0.707106781))
                      : ((R = en / (N = Math.sqrt(F))), (z = eo / N))
                    : er < 0.01
                      ? ((R = 0.707106781), (N = 0.707106781), (z = 0))
                      : ((R = ea / (z = Math.sqrt(er))), (N = eo / z)),
                this.set(R, N, z, L),
                this
              );
            }
            let er = Math.sqrt(
              ($ - K) * ($ - K) + (Y - J) * (Y - J) + (X - k) * (X - k),
            );
            return (
              0.001 > Math.abs(er) && (er = 1),
              (this.x = ($ - K) / er),
              (this.y = (Y - J) / er),
              (this.z = (X - k) / er),
              (this.w = Math.acos((U + Q + ee - 1) / 2)),
              this
            );
          }
          min(_) {
            return (
              (this.x = Math.min(this.x, _.x)),
              (this.y = Math.min(this.y, _.y)),
              (this.z = Math.min(this.z, _.z)),
              (this.w = Math.min(this.w, _.w)),
              this
            );
          }
          max(_) {
            return (
              (this.x = Math.max(this.x, _.x)),
              (this.y = Math.max(this.y, _.y)),
              (this.z = Math.max(this.z, _.z)),
              (this.w = Math.max(this.w, _.w)),
              this
            );
          }
          clamp(_, L) {
            return (
              (this.x = Math.max(_.x, Math.min(L.x, this.x))),
              (this.y = Math.max(_.y, Math.min(L.y, this.y))),
              (this.z = Math.max(_.z, Math.min(L.z, this.z))),
              (this.w = Math.max(_.w, Math.min(L.w, this.w))),
              this
            );
          }
          clampScalar(_, L) {
            return (
              (this.x = Math.max(_, Math.min(L, this.x))),
              (this.y = Math.max(_, Math.min(L, this.y))),
              (this.z = Math.max(_, Math.min(L, this.z))),
              (this.w = Math.max(_, Math.min(L, this.w))),
              this
            );
          }
          clampLength(_, L) {
            let R = this.length();
            return this.divideScalar(R || 1).multiplyScalar(
              Math.max(_, Math.min(L, R)),
            );
          }
          floor() {
            return (
              (this.x = Math.floor(this.x)),
              (this.y = Math.floor(this.y)),
              (this.z = Math.floor(this.z)),
              (this.w = Math.floor(this.w)),
              this
            );
          }
          ceil() {
            return (
              (this.x = Math.ceil(this.x)),
              (this.y = Math.ceil(this.y)),
              (this.z = Math.ceil(this.z)),
              (this.w = Math.ceil(this.w)),
              this
            );
          }
          round() {
            return (
              (this.x = Math.round(this.x)),
              (this.y = Math.round(this.y)),
              (this.z = Math.round(this.z)),
              (this.w = Math.round(this.w)),
              this
            );
          }
          roundToZero() {
            return (
              (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
              (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
              (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
              (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
              this
            );
          }
          negate() {
            return (
              (this.x = -this.x),
              (this.y = -this.y),
              (this.z = -this.z),
              (this.w = -this.w),
              this
            );
          }
          dot(_) {
            return this.x * _.x + this.y * _.y + this.z * _.z + this.w * _.w;
          }
          lengthSq() {
            return (
              this.x * this.x +
              this.y * this.y +
              this.z * this.z +
              this.w * this.w
            );
          }
          length() {
            return Math.sqrt(
              this.x * this.x +
                this.y * this.y +
                this.z * this.z +
                this.w * this.w,
            );
          }
          manhattanLength() {
            return (
              Math.abs(this.x) +
              Math.abs(this.y) +
              Math.abs(this.z) +
              Math.abs(this.w)
            );
          }
          normalize() {
            return this.divideScalar(this.length() || 1);
          }
          setLength(_) {
            return this.normalize().multiplyScalar(_);
          }
          lerp(_, L) {
            return (
              (this.x += (_.x - this.x) * L),
              (this.y += (_.y - this.y) * L),
              (this.z += (_.z - this.z) * L),
              (this.w += (_.w - this.w) * L),
              this
            );
          }
          lerpVectors(_, L, R) {
            return (
              (this.x = _.x + (L.x - _.x) * R),
              (this.y = _.y + (L.y - _.y) * R),
              (this.z = _.z + (L.z - _.z) * R),
              (this.w = _.w + (L.w - _.w) * R),
              this
            );
          }
          equals(_) {
            return (
              _.x === this.x &&
              _.y === this.y &&
              _.z === this.z &&
              _.w === this.w
            );
          }
          fromArray(_, L = 0) {
            return (
              (this.x = _[L]),
              (this.y = _[L + 1]),
              (this.z = _[L + 2]),
              (this.w = _[L + 3]),
              this
            );
          }
          toArray(_ = [], L = 0) {
            return (
              (_[L] = this.x),
              (_[L + 1] = this.y),
              (_[L + 2] = this.z),
              (_[L + 3] = this.w),
              _
            );
          }
          fromBufferAttribute(_, L) {
            return (
              (this.x = _.getX(L)),
              (this.y = _.getY(L)),
              (this.z = _.getZ(L)),
              (this.w = _.getW(L)),
              this
            );
          }
          random() {
            return (
              (this.x = Math.random()),
              (this.y = Math.random()),
              (this.z = Math.random()),
              (this.w = Math.random()),
              this
            );
          }
          *[Symbol.iterator]() {
            yield this.x, yield this.y, yield this.z, yield this.w;
          }
        },
        iH = class extends ig {
          constructor(_ = 1, L = 1, R = {}) {
            super(),
              (this.isWebGLRenderTarget = !0),
              (this.width = _),
              (this.height = L),
              (this.depth = 1),
              (this.scissor = new iV(0, 0, _, L)),
              (this.scissorTest = !1),
              (this.viewport = new iV(0, 0, _, L)),
              (this.texture = new iG(
                { width: _, height: L, depth: 1 },
                R.mapping,
                R.wrapS,
                R.wrapT,
                R.magFilter,
                R.minFilter,
                R.format,
                R.type,
                R.anisotropy,
                R.encoding,
              )),
              (this.texture.isRenderTargetTexture = !0),
              (this.texture.flipY = !1),
              (this.texture.generateMipmaps =
                void 0 !== R.generateMipmaps && R.generateMipmaps),
              (this.texture.internalFormat =
                void 0 !== R.internalFormat ? R.internalFormat : null),
              (this.texture.minFilter =
                void 0 !== R.minFilter ? R.minFilter : 1006),
              (this.depthBuffer = void 0 === R.depthBuffer || R.depthBuffer),
              (this.stencilBuffer =
                void 0 !== R.stencilBuffer && R.stencilBuffer),
              (this.depthTexture =
                void 0 !== R.depthTexture ? R.depthTexture : null),
              (this.samples = void 0 !== R.samples ? R.samples : 0);
          }
          setSize(_, L, R = 1) {
            (this.width !== _ || this.height !== L || this.depth !== R) &&
              ((this.width = _),
              (this.height = L),
              (this.depth = R),
              (this.texture.image.width = _),
              (this.texture.image.height = L),
              (this.texture.image.depth = R),
              this.dispose()),
              this.viewport.set(0, 0, _, L),
              this.scissor.set(0, 0, _, L);
          }
          clone() {
            return new this.constructor().copy(this);
          }
          copy(_) {
            (this.width = _.width),
              (this.height = _.height),
              (this.depth = _.depth),
              this.viewport.copy(_.viewport),
              (this.texture = _.texture.clone()),
              (this.texture.isRenderTargetTexture = !0);
            let L = Object.assign({}, _.texture.image);
            return (
              (this.texture.source = new ik(L)),
              (this.depthBuffer = _.depthBuffer),
              (this.stencilBuffer = _.stencilBuffer),
              null !== _.depthTexture &&
                (this.depthTexture = _.depthTexture.clone()),
              (this.samples = _.samples),
              this
            );
          }
          dispose() {
            this.dispatchEvent({ type: "dispose" });
          }
        },
        iW = class extends iG {
          constructor(_ = null, L = 1, R = 1, N = 1) {
            super(null),
              (this.isDataArrayTexture = !0),
              (this.image = { data: _, width: L, height: R, depth: N }),
              (this.magFilter = 1003),
              (this.minFilter = 1003),
              (this.wrapR = 1001),
              (this.generateMipmaps = !1),
              (this.flipY = !1),
              (this.unpackAlignment = 1);
          }
        },
        iY = class extends iG {
          constructor(_ = null, L = 1, R = 1, N = 1) {
            super(null),
              (this.isData3DTexture = !0),
              (this.image = { data: _, width: L, height: R, depth: N }),
              (this.magFilter = 1003),
              (this.minFilter = 1003),
              (this.wrapR = 1001),
              (this.generateMipmaps = !1),
              (this.flipY = !1),
              (this.unpackAlignment = 1);
          }
        },
        iX = class {
          constructor(_ = 0, L = 0, R = 0, N = 1) {
            (this.isQuaternion = !0),
              (this._x = _),
              (this._y = L),
              (this._z = R),
              (this._w = N);
          }
          static slerpFlat(_, L, R, N, z, F, U) {
            let k = R[N + 0],
              Y = R[N + 1],
              X = R[N + 2],
              Q = R[N + 3],
              K = z[F + 0],
              J = z[F + 1],
              $ = z[F + 2],
              ee = z[F + 3];
            if (0 === U) {
              (_[L + 0] = k), (_[L + 1] = Y), (_[L + 2] = X), (_[L + 3] = Q);
              return;
            }
            if (1 === U) {
              (_[L + 0] = K), (_[L + 1] = J), (_[L + 2] = $), (_[L + 3] = ee);
              return;
            }
            if (Q !== ee || k !== K || Y !== J || X !== $) {
              let _ = 1 - U,
                L = k * K + Y * J + X * $ + Q * ee,
                R = L >= 0 ? 1 : -1,
                N = 1 - L * L;
              if (N > Number.EPSILON) {
                let z = Math.sqrt(N),
                  F = Math.atan2(z, L * R);
                (_ = Math.sin(_ * F) / z), (U = Math.sin(U * F) / z);
              }
              let z = U * R;
              if (
                ((k = k * _ + K * z),
                (Y = Y * _ + J * z),
                (X = X * _ + $ * z),
                (Q = Q * _ + ee * z),
                _ === 1 - U)
              ) {
                let _ = 1 / Math.sqrt(k * k + Y * Y + X * X + Q * Q);
                (k *= _), (Y *= _), (X *= _), (Q *= _);
              }
            }
            (_[L] = k), (_[L + 1] = Y), (_[L + 2] = X), (_[L + 3] = Q);
          }
          static multiplyQuaternionsFlat(_, L, R, N, z, F) {
            let U = R[N],
              k = R[N + 1],
              Y = R[N + 2],
              X = R[N + 3],
              Q = z[F],
              K = z[F + 1],
              J = z[F + 2],
              $ = z[F + 3];
            return (
              (_[L] = U * $ + X * Q + k * J - Y * K),
              (_[L + 1] = k * $ + X * K + Y * Q - U * J),
              (_[L + 2] = Y * $ + X * J + U * K - k * Q),
              (_[L + 3] = X * $ - U * Q - k * K - Y * J),
              _
            );
          }
          get x() {
            return this._x;
          }
          set x(_) {
            (this._x = _), this._onChangeCallback();
          }
          get y() {
            return this._y;
          }
          set y(_) {
            (this._y = _), this._onChangeCallback();
          }
          get z() {
            return this._z;
          }
          set z(_) {
            (this._z = _), this._onChangeCallback();
          }
          get w() {
            return this._w;
          }
          set w(_) {
            (this._w = _), this._onChangeCallback();
          }
          set(_, L, R, N) {
            return (
              (this._x = _),
              (this._y = L),
              (this._z = R),
              (this._w = N),
              this._onChangeCallback(),
              this
            );
          }
          clone() {
            return new this.constructor(this._x, this._y, this._z, this._w);
          }
          copy(_) {
            return (
              (this._x = _.x),
              (this._y = _.y),
              (this._z = _.z),
              (this._w = _.w),
              this._onChangeCallback(),
              this
            );
          }
          setFromEuler(_, L) {
            let R = _._x,
              N = _._y,
              z = _._z,
              F = _._order,
              U = Math.cos,
              k = Math.sin,
              Y = U(R / 2),
              X = U(N / 2),
              Q = U(z / 2),
              K = k(R / 2),
              J = k(N / 2),
              $ = k(z / 2);
            switch (F) {
              case "XYZ":
                (this._x = K * X * Q + Y * J * $),
                  (this._y = Y * J * Q - K * X * $),
                  (this._z = Y * X * $ + K * J * Q),
                  (this._w = Y * X * Q - K * J * $);
                break;
              case "YXZ":
                (this._x = K * X * Q + Y * J * $),
                  (this._y = Y * J * Q - K * X * $),
                  (this._z = Y * X * $ - K * J * Q),
                  (this._w = Y * X * Q + K * J * $);
                break;
              case "ZXY":
                (this._x = K * X * Q - Y * J * $),
                  (this._y = Y * J * Q + K * X * $),
                  (this._z = Y * X * $ + K * J * Q),
                  (this._w = Y * X * Q - K * J * $);
                break;
              case "ZYX":
                (this._x = K * X * Q - Y * J * $),
                  (this._y = Y * J * Q + K * X * $),
                  (this._z = Y * X * $ - K * J * Q),
                  (this._w = Y * X * Q + K * J * $);
                break;
              case "YZX":
                (this._x = K * X * Q + Y * J * $),
                  (this._y = Y * J * Q + K * X * $),
                  (this._z = Y * X * $ - K * J * Q),
                  (this._w = Y * X * Q - K * J * $);
                break;
              case "XZY":
                (this._x = K * X * Q - Y * J * $),
                  (this._y = Y * J * Q - K * X * $),
                  (this._z = Y * X * $ + K * J * Q),
                  (this._w = Y * X * Q + K * J * $);
                break;
              default:
                console.warn(
                  "THREE.Quaternion: .setFromEuler() encountered an unknown order: " +
                    F,
                );
            }
            return !1 !== L && this._onChangeCallback(), this;
          }
          setFromAxisAngle(_, L) {
            let R = L / 2,
              N = Math.sin(R);
            return (
              (this._x = _.x * N),
              (this._y = _.y * N),
              (this._z = _.z * N),
              (this._w = Math.cos(R)),
              this._onChangeCallback(),
              this
            );
          }
          setFromRotationMatrix(_) {
            let L = _.elements,
              R = L[0],
              N = L[4],
              z = L[8],
              F = L[1],
              U = L[5],
              k = L[9],
              Y = L[2],
              X = L[6],
              Q = L[10],
              K = R + U + Q;
            if (K > 0) {
              let _ = 0.5 / Math.sqrt(K + 1);
              (this._w = 0.25 / _),
                (this._x = (X - k) * _),
                (this._y = (z - Y) * _),
                (this._z = (F - N) * _);
            } else if (R > U && R > Q) {
              let _ = 2 * Math.sqrt(1 + R - U - Q);
              (this._w = (X - k) / _),
                (this._x = 0.25 * _),
                (this._y = (N + F) / _),
                (this._z = (z + Y) / _);
            } else if (U > Q) {
              let _ = 2 * Math.sqrt(1 + U - R - Q);
              (this._w = (z - Y) / _),
                (this._x = (N + F) / _),
                (this._y = 0.25 * _),
                (this._z = (k + X) / _);
            } else {
              let _ = 2 * Math.sqrt(1 + Q - R - U);
              (this._w = (F - N) / _),
                (this._x = (z + Y) / _),
                (this._y = (k + X) / _),
                (this._z = 0.25 * _);
            }
            return this._onChangeCallback(), this;
          }
          setFromUnitVectors(_, L) {
            let R = _.dot(L) + 1;
            return (
              R < Number.EPSILON
                ? ((R = 0),
                  Math.abs(_.x) > Math.abs(_.z)
                    ? ((this._x = -_.y), (this._y = _.x), (this._z = 0))
                    : ((this._x = 0), (this._y = -_.z), (this._z = _.y)))
                : ((this._x = _.y * L.z - _.z * L.y),
                  (this._y = _.z * L.x - _.x * L.z),
                  (this._z = _.x * L.y - _.y * L.x)),
              (this._w = R),
              this.normalize()
            );
          }
          angleTo(_) {
            return 2 * Math.acos(Math.abs(_n(this.dot(_), -1, 1)));
          }
          rotateTowards(_, L) {
            let R = this.angleTo(_);
            if (0 === R) return this;
            let N = Math.min(1, L / R);
            return this.slerp(_, N), this;
          }
          identity() {
            return this.set(0, 0, 0, 1);
          }
          invert() {
            return this.conjugate();
          }
          conjugate() {
            return (
              (this._x *= -1),
              (this._y *= -1),
              (this._z *= -1),
              this._onChangeCallback(),
              this
            );
          }
          dot(_) {
            return (
              this._x * _._x + this._y * _._y + this._z * _._z + this._w * _._w
            );
          }
          lengthSq() {
            return (
              this._x * this._x +
              this._y * this._y +
              this._z * this._z +
              this._w * this._w
            );
          }
          length() {
            return Math.sqrt(
              this._x * this._x +
                this._y * this._y +
                this._z * this._z +
                this._w * this._w,
            );
          }
          normalize() {
            let _ = this.length();
            return (
              0 === _
                ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
                : ((_ = 1 / _),
                  (this._x = this._x * _),
                  (this._y = this._y * _),
                  (this._z = this._z * _),
                  (this._w = this._w * _)),
              this._onChangeCallback(),
              this
            );
          }
          multiply(_) {
            return this.multiplyQuaternions(this, _);
          }
          premultiply(_) {
            return this.multiplyQuaternions(_, this);
          }
          multiplyQuaternions(_, L) {
            let R = _._x,
              N = _._y,
              z = _._z,
              F = _._w,
              U = L._x,
              k = L._y,
              Y = L._z,
              X = L._w;
            return (
              (this._x = R * X + F * U + N * Y - z * k),
              (this._y = N * X + F * k + z * U - R * Y),
              (this._z = z * X + F * Y + R * k - N * U),
              (this._w = F * X - R * U - N * k - z * Y),
              this._onChangeCallback(),
              this
            );
          }
          slerp(_, L) {
            if (0 === L) return this;
            if (1 === L) return this.copy(_);
            let R = this._x,
              N = this._y,
              z = this._z,
              F = this._w,
              U = F * _._w + R * _._x + N * _._y + z * _._z;
            if (
              (U < 0
                ? ((this._w = -_._w),
                  (this._x = -_._x),
                  (this._y = -_._y),
                  (this._z = -_._z),
                  (U = -U))
                : this.copy(_),
              U >= 1)
            )
              return (
                (this._w = F), (this._x = R), (this._y = N), (this._z = z), this
              );
            let k = 1 - U * U;
            if (k <= Number.EPSILON) {
              let _ = 1 - L;
              return (
                (this._w = _ * F + L * this._w),
                (this._x = _ * R + L * this._x),
                (this._y = _ * N + L * this._y),
                (this._z = _ * z + L * this._z),
                this.normalize(),
                this._onChangeCallback(),
                this
              );
            }
            let Y = Math.sqrt(k),
              X = Math.atan2(Y, U),
              Q = Math.sin((1 - L) * X) / Y,
              K = Math.sin(L * X) / Y;
            return (
              (this._w = F * Q + this._w * K),
              (this._x = R * Q + this._x * K),
              (this._y = N * Q + this._y * K),
              (this._z = z * Q + this._z * K),
              this._onChangeCallback(),
              this
            );
          }
          slerpQuaternions(_, L, R) {
            return this.copy(_).slerp(L, R);
          }
          random() {
            let _ = Math.random(),
              L = Math.sqrt(1 - _),
              R = Math.sqrt(_),
              N = 2 * Math.PI * Math.random(),
              z = 2 * Math.PI * Math.random();
            return this.set(
              L * Math.cos(N),
              R * Math.sin(z),
              R * Math.cos(z),
              L * Math.sin(N),
            );
          }
          equals(_) {
            return (
              _._x === this._x &&
              _._y === this._y &&
              _._z === this._z &&
              _._w === this._w
            );
          }
          fromArray(_, L = 0) {
            return (
              (this._x = _[L]),
              (this._y = _[L + 1]),
              (this._z = _[L + 2]),
              (this._w = _[L + 3]),
              this._onChangeCallback(),
              this
            );
          }
          toArray(_ = [], L = 0) {
            return (
              (_[L] = this._x),
              (_[L + 1] = this._y),
              (_[L + 2] = this._z),
              (_[L + 3] = this._w),
              _
            );
          }
          fromBufferAttribute(_, L) {
            return (
              (this._x = _.getX(L)),
              (this._y = _.getY(L)),
              (this._z = _.getZ(L)),
              (this._w = _.getW(L)),
              this
            );
          }
          _onChange(_) {
            return (this._onChangeCallback = _), this;
          }
          _onChangeCallback() {}
          *[Symbol.iterator]() {
            yield this._x, yield this._y, yield this._z, yield this._w;
          }
        },
        iq = class {
          constructor(_ = 0, L = 0, R = 0) {
            (iq.prototype.isVector3 = !0),
              (this.x = _),
              (this.y = L),
              (this.z = R);
          }
          set(_, L, R) {
            return (
              void 0 === R && (R = this.z),
              (this.x = _),
              (this.y = L),
              (this.z = R),
              this
            );
          }
          setScalar(_) {
            return (this.x = _), (this.y = _), (this.z = _), this;
          }
          setX(_) {
            return (this.x = _), this;
          }
          setY(_) {
            return (this.y = _), this;
          }
          setZ(_) {
            return (this.z = _), this;
          }
          setComponent(_, L) {
            switch (_) {
              case 0:
                this.x = L;
                break;
              case 1:
                this.y = L;
                break;
              case 2:
                this.z = L;
                break;
              default:
                throw Error("index is out of range: " + _);
            }
            return this;
          }
          getComponent(_) {
            switch (_) {
              case 0:
                return this.x;
              case 1:
                return this.y;
              case 2:
                return this.z;
              default:
                throw Error("index is out of range: " + _);
            }
          }
          clone() {
            return new this.constructor(this.x, this.y, this.z);
          }
          copy(_) {
            return (this.x = _.x), (this.y = _.y), (this.z = _.z), this;
          }
          add(_) {
            return (this.x += _.x), (this.y += _.y), (this.z += _.z), this;
          }
          addScalar(_) {
            return (this.x += _), (this.y += _), (this.z += _), this;
          }
          addVectors(_, L) {
            return (
              (this.x = _.x + L.x),
              (this.y = _.y + L.y),
              (this.z = _.z + L.z),
              this
            );
          }
          addScaledVector(_, L) {
            return (
              (this.x += _.x * L),
              (this.y += _.y * L),
              (this.z += _.z * L),
              this
            );
          }
          sub(_) {
            return (this.x -= _.x), (this.y -= _.y), (this.z -= _.z), this;
          }
          subScalar(_) {
            return (this.x -= _), (this.y -= _), (this.z -= _), this;
          }
          subVectors(_, L) {
            return (
              (this.x = _.x - L.x),
              (this.y = _.y - L.y),
              (this.z = _.z - L.z),
              this
            );
          }
          multiply(_) {
            return (this.x *= _.x), (this.y *= _.y), (this.z *= _.z), this;
          }
          multiplyScalar(_) {
            return (this.x *= _), (this.y *= _), (this.z *= _), this;
          }
          multiplyVectors(_, L) {
            return (
              (this.x = _.x * L.x),
              (this.y = _.y * L.y),
              (this.z = _.z * L.z),
              this
            );
          }
          applyEuler(_) {
            return this.applyQuaternion(iZ.setFromEuler(_));
          }
          applyAxisAngle(_, L) {
            return this.applyQuaternion(iZ.setFromAxisAngle(_, L));
          }
          applyMatrix3(_) {
            let L = this.x,
              R = this.y,
              N = this.z,
              z = _.elements;
            return (
              (this.x = z[0] * L + z[3] * R + z[6] * N),
              (this.y = z[1] * L + z[4] * R + z[7] * N),
              (this.z = z[2] * L + z[5] * R + z[8] * N),
              this
            );
          }
          applyNormalMatrix(_) {
            return this.applyMatrix3(_).normalize();
          }
          applyMatrix4(_) {
            let L = this.x,
              R = this.y,
              N = this.z,
              z = _.elements,
              F = 1 / (z[3] * L + z[7] * R + z[11] * N + z[15]);
            return (
              (this.x = (z[0] * L + z[4] * R + z[8] * N + z[12]) * F),
              (this.y = (z[1] * L + z[5] * R + z[9] * N + z[13]) * F),
              (this.z = (z[2] * L + z[6] * R + z[10] * N + z[14]) * F),
              this
            );
          }
          applyQuaternion(_) {
            let L = this.x,
              R = this.y,
              N = this.z,
              z = _.x,
              F = _.y,
              U = _.z,
              k = _.w,
              Y = k * L + F * N - U * R,
              X = k * R + U * L - z * N,
              Q = k * N + z * R - F * L,
              K = -z * L - F * R - U * N;
            return (
              (this.x = Y * k + -(K * z) + -(X * U) - -(Q * F)),
              (this.y = X * k + -(K * F) + -(Q * z) - -(Y * U)),
              (this.z = Q * k + -(K * U) + -(Y * F) - -(X * z)),
              this
            );
          }
          project(_) {
            return this.applyMatrix4(_.matrixWorldInverse).applyMatrix4(
              _.projectionMatrix,
            );
          }
          unproject(_) {
            return this.applyMatrix4(_.projectionMatrixInverse).applyMatrix4(
              _.matrixWorld,
            );
          }
          transformDirection(_) {
            let L = this.x,
              R = this.y,
              N = this.z,
              z = _.elements;
            return (
              (this.x = z[0] * L + z[4] * R + z[8] * N),
              (this.y = z[1] * L + z[5] * R + z[9] * N),
              (this.z = z[2] * L + z[6] * R + z[10] * N),
              this.normalize()
            );
          }
          divide(_) {
            return (this.x /= _.x), (this.y /= _.y), (this.z /= _.z), this;
          }
          divideScalar(_) {
            return this.multiplyScalar(1 / _);
          }
          min(_) {
            return (
              (this.x = Math.min(this.x, _.x)),
              (this.y = Math.min(this.y, _.y)),
              (this.z = Math.min(this.z, _.z)),
              this
            );
          }
          max(_) {
            return (
              (this.x = Math.max(this.x, _.x)),
              (this.y = Math.max(this.y, _.y)),
              (this.z = Math.max(this.z, _.z)),
              this
            );
          }
          clamp(_, L) {
            return (
              (this.x = Math.max(_.x, Math.min(L.x, this.x))),
              (this.y = Math.max(_.y, Math.min(L.y, this.y))),
              (this.z = Math.max(_.z, Math.min(L.z, this.z))),
              this
            );
          }
          clampScalar(_, L) {
            return (
              (this.x = Math.max(_, Math.min(L, this.x))),
              (this.y = Math.max(_, Math.min(L, this.y))),
              (this.z = Math.max(_, Math.min(L, this.z))),
              this
            );
          }
          clampLength(_, L) {
            let R = this.length();
            return this.divideScalar(R || 1).multiplyScalar(
              Math.max(_, Math.min(L, R)),
            );
          }
          floor() {
            return (
              (this.x = Math.floor(this.x)),
              (this.y = Math.floor(this.y)),
              (this.z = Math.floor(this.z)),
              this
            );
          }
          ceil() {
            return (
              (this.x = Math.ceil(this.x)),
              (this.y = Math.ceil(this.y)),
              (this.z = Math.ceil(this.z)),
              this
            );
          }
          round() {
            return (
              (this.x = Math.round(this.x)),
              (this.y = Math.round(this.y)),
              (this.z = Math.round(this.z)),
              this
            );
          }
          roundToZero() {
            return (
              (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
              (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
              (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
              this
            );
          }
          negate() {
            return (
              (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this
            );
          }
          dot(_) {
            return this.x * _.x + this.y * _.y + this.z * _.z;
          }
          lengthSq() {
            return this.x * this.x + this.y * this.y + this.z * this.z;
          }
          length() {
            return Math.sqrt(
              this.x * this.x + this.y * this.y + this.z * this.z,
            );
          }
          manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
          }
          normalize() {
            return this.divideScalar(this.length() || 1);
          }
          setLength(_) {
            return this.normalize().multiplyScalar(_);
          }
          lerp(_, L) {
            return (
              (this.x += (_.x - this.x) * L),
              (this.y += (_.y - this.y) * L),
              (this.z += (_.z - this.z) * L),
              this
            );
          }
          lerpVectors(_, L, R) {
            return (
              (this.x = _.x + (L.x - _.x) * R),
              (this.y = _.y + (L.y - _.y) * R),
              (this.z = _.z + (L.z - _.z) * R),
              this
            );
          }
          cross(_) {
            return this.crossVectors(this, _);
          }
          crossVectors(_, L) {
            let R = _.x,
              N = _.y,
              z = _.z,
              F = L.x,
              U = L.y,
              k = L.z;
            return (
              (this.x = N * k - z * U),
              (this.y = z * F - R * k),
              (this.z = R * U - N * F),
              this
            );
          }
          projectOnVector(_) {
            let L = _.lengthSq();
            if (0 === L) return this.set(0, 0, 0);
            let R = _.dot(this) / L;
            return this.copy(_).multiplyScalar(R);
          }
          projectOnPlane(_) {
            return iQ.copy(this).projectOnVector(_), this.sub(iQ);
          }
          reflect(_) {
            return this.sub(iQ.copy(_).multiplyScalar(2 * this.dot(_)));
          }
          angleTo(_) {
            let L = Math.sqrt(this.lengthSq() * _.lengthSq());
            return 0 === L
              ? Math.PI / 2
              : Math.acos(_n(this.dot(_) / L, -1, 1));
          }
          distanceTo(_) {
            return Math.sqrt(this.distanceToSquared(_));
          }
          distanceToSquared(_) {
            let L = this.x - _.x,
              R = this.y - _.y,
              N = this.z - _.z;
            return L * L + R * R + N * N;
          }
          manhattanDistanceTo(_) {
            return (
              Math.abs(this.x - _.x) +
              Math.abs(this.y - _.y) +
              Math.abs(this.z - _.z)
            );
          }
          setFromSpherical(_) {
            return this.setFromSphericalCoords(_.radius, _.phi, _.theta);
          }
          setFromSphericalCoords(_, L, R) {
            let N = Math.sin(L) * _;
            return (
              (this.x = N * Math.sin(R)),
              (this.y = Math.cos(L) * _),
              (this.z = N * Math.cos(R)),
              this
            );
          }
          setFromCylindrical(_) {
            return this.setFromCylindricalCoords(_.radius, _.theta, _.y);
          }
          setFromCylindricalCoords(_, L, R) {
            return (
              (this.x = _ * Math.sin(L)),
              (this.y = R),
              (this.z = _ * Math.cos(L)),
              this
            );
          }
          setFromMatrixPosition(_) {
            let L = _.elements;
            return (this.x = L[12]), (this.y = L[13]), (this.z = L[14]), this;
          }
          setFromMatrixScale(_) {
            let L = this.setFromMatrixColumn(_, 0).length(),
              R = this.setFromMatrixColumn(_, 1).length(),
              N = this.setFromMatrixColumn(_, 2).length();
            return (this.x = L), (this.y = R), (this.z = N), this;
          }
          setFromMatrixColumn(_, L) {
            return this.fromArray(_.elements, 4 * L);
          }
          setFromMatrix3Column(_, L) {
            return this.fromArray(_.elements, 3 * L);
          }
          setFromEuler(_) {
            return (this.x = _._x), (this.y = _._y), (this.z = _._z), this;
          }
          equals(_) {
            return _.x === this.x && _.y === this.y && _.z === this.z;
          }
          fromArray(_, L = 0) {
            return (
              (this.x = _[L]), (this.y = _[L + 1]), (this.z = _[L + 2]), this
            );
          }
          toArray(_ = [], L = 0) {
            return (_[L] = this.x), (_[L + 1] = this.y), (_[L + 2] = this.z), _;
          }
          fromBufferAttribute(_, L) {
            return (
              (this.x = _.getX(L)),
              (this.y = _.getY(L)),
              (this.z = _.getZ(L)),
              this
            );
          }
          random() {
            return (
              (this.x = Math.random()),
              (this.y = Math.random()),
              (this.z = Math.random()),
              this
            );
          }
          randomDirection() {
            let _ = (Math.random() - 0.5) * 2,
              L = Math.random() * Math.PI * 2,
              R = Math.sqrt(1 - _ ** 2);
            return (
              (this.x = R * Math.cos(L)),
              (this.y = R * Math.sin(L)),
              (this.z = _),
              this
            );
          }
          *[Symbol.iterator]() {
            yield this.x, yield this.y, yield this.z;
          }
        },
        iQ = new iq(),
        iZ = new iX(),
        iK = class {
          constructor(
            _ = new iq(1 / 0, 1 / 0, 1 / 0),
            L = new iq(-1 / 0, -1 / 0, -1 / 0),
          ) {
            (this.isBox3 = !0), (this.min = _), (this.max = L);
          }
          set(_, L) {
            return this.min.copy(_), this.max.copy(L), this;
          }
          setFromArray(_) {
            let L = 1 / 0,
              R = 1 / 0,
              N = 1 / 0,
              z = -1 / 0,
              F = -1 / 0,
              U = -1 / 0;
            for (let k = 0, Y = _.length; k < Y; k += 3) {
              let Y = _[k],
                X = _[k + 1],
                Q = _[k + 2];
              Y < L && (L = Y),
                X < R && (R = X),
                Q < N && (N = Q),
                Y > z && (z = Y),
                X > F && (F = X),
                Q > U && (U = Q);
            }
            return this.min.set(L, R, N), this.max.set(z, F, U), this;
          }
          setFromBufferAttribute(_) {
            let L = 1 / 0,
              R = 1 / 0,
              N = 1 / 0,
              z = -1 / 0,
              F = -1 / 0,
              U = -1 / 0;
            for (let k = 0, Y = _.count; k < Y; k++) {
              let Y = _.getX(k),
                X = _.getY(k),
                Q = _.getZ(k);
              Y < L && (L = Y),
                X < R && (R = X),
                Q < N && (N = Q),
                Y > z && (z = Y),
                X > F && (F = X),
                Q > U && (U = Q);
            }
            return this.min.set(L, R, N), this.max.set(z, F, U), this;
          }
          setFromPoints(_) {
            this.makeEmpty();
            for (let L = 0, R = _.length; L < R; L++) this.expandByPoint(_[L]);
            return this;
          }
          setFromCenterAndSize(_, L) {
            let R = i$.copy(L).multiplyScalar(0.5);
            return this.min.copy(_).sub(R), this.max.copy(_).add(R), this;
          }
          setFromObject(_, L = !1) {
            return this.makeEmpty(), this.expandByObject(_, L);
          }
          clone() {
            return new this.constructor().copy(this);
          }
          copy(_) {
            return this.min.copy(_.min), this.max.copy(_.max), this;
          }
          makeEmpty() {
            return (
              (this.min.x = this.min.y = this.min.z = 1 / 0),
              (this.max.x = this.max.y = this.max.z = -1 / 0),
              this
            );
          }
          isEmpty() {
            return (
              this.max.x < this.min.x ||
              this.max.y < this.min.y ||
              this.max.z < this.min.z
            );
          }
          getCenter(_) {
            return this.isEmpty()
              ? _.set(0, 0, 0)
              : _.addVectors(this.min, this.max).multiplyScalar(0.5);
          }
          getSize(_) {
            return this.isEmpty()
              ? _.set(0, 0, 0)
              : _.subVectors(this.max, this.min);
          }
          expandByPoint(_) {
            return this.min.min(_), this.max.max(_), this;
          }
          expandByVector(_) {
            return this.min.sub(_), this.max.add(_), this;
          }
          expandByScalar(_) {
            return this.min.addScalar(-_), this.max.addScalar(_), this;
          }
          expandByObject(_, L = !1) {
            _.updateWorldMatrix(!1, !1);
            let R = _.geometry;
            if (void 0 !== R) {
              if (
                L &&
                null != R.attributes &&
                void 0 !== R.attributes.position
              ) {
                let L = R.attributes.position;
                for (let R = 0, N = L.count; R < N; R++)
                  i$.fromBufferAttribute(L, R).applyMatrix4(_.matrixWorld),
                    this.expandByPoint(i$);
              } else
                null === R.boundingBox && R.computeBoundingBox(),
                  i0.copy(R.boundingBox),
                  i0.applyMatrix4(_.matrixWorld),
                  this.union(i0);
            }
            let N = _.children;
            for (let _ = 0, R = N.length; _ < R; _++)
              this.expandByObject(N[_], L);
            return this;
          }
          containsPoint(_) {
            return !(
              _.x < this.min.x ||
              _.x > this.max.x ||
              _.y < this.min.y ||
              _.y > this.max.y ||
              _.z < this.min.z ||
              _.z > this.max.z
            );
          }
          containsBox(_) {
            return (
              this.min.x <= _.min.x &&
              _.max.x <= this.max.x &&
              this.min.y <= _.min.y &&
              _.max.y <= this.max.y &&
              this.min.z <= _.min.z &&
              _.max.z <= this.max.z
            );
          }
          getParameter(_, L) {
            return L.set(
              (_.x - this.min.x) / (this.max.x - this.min.x),
              (_.y - this.min.y) / (this.max.y - this.min.y),
              (_.z - this.min.z) / (this.max.z - this.min.z),
            );
          }
          intersectsBox(_) {
            return !(
              _.max.x < this.min.x ||
              _.min.x > this.max.x ||
              _.max.y < this.min.y ||
              _.min.y > this.max.y ||
              _.max.z < this.min.z ||
              _.min.z > this.max.z
            );
          }
          intersectsSphere(_) {
            return (
              this.clampPoint(_.center, i$),
              i$.distanceToSquared(_.center) <= _.radius * _.radius
            );
          }
          intersectsPlane(_) {
            let L, R;
            return (
              _.normal.x > 0
                ? ((L = _.normal.x * this.min.x), (R = _.normal.x * this.max.x))
                : ((L = _.normal.x * this.max.x),
                  (R = _.normal.x * this.min.x)),
              _.normal.y > 0
                ? ((L += _.normal.y * this.min.y),
                  (R += _.normal.y * this.max.y))
                : ((L += _.normal.y * this.max.y),
                  (R += _.normal.y * this.min.y)),
              _.normal.z > 0
                ? ((L += _.normal.z * this.min.z),
                  (R += _.normal.z * this.max.z))
                : ((L += _.normal.z * this.max.z),
                  (R += _.normal.z * this.min.z)),
              L <= -_.constant && R >= -_.constant
            );
          }
          intersectsTriangle(_) {
            if (this.isEmpty()) return !1;
            this.getCenter(i7),
              rt.subVectors(this.max, i7),
              i2.subVectors(_.a, i7),
              i4.subVectors(_.b, i7),
              i5.subVectors(_.c, i7),
              i6.subVectors(i4, i2),
              i8.subVectors(i5, i4),
              i9.subVectors(i2, i5);
            let L = [
              0,
              -i6.z,
              i6.y,
              0,
              -i8.z,
              i8.y,
              0,
              -i9.z,
              i9.y,
              i6.z,
              0,
              -i6.x,
              i8.z,
              0,
              -i8.x,
              i9.z,
              0,
              -i9.x,
              -i6.y,
              i6.x,
              0,
              -i8.y,
              i8.x,
              0,
              -i9.y,
              i9.x,
              0,
            ];
            return (
              !!(
                av(L, i2, i4, i5, rt) &&
                av((L = [1, 0, 0, 0, 1, 0, 0, 0, 1]), i2, i4, i5, rt)
              ) &&
              (ri.crossVectors(i6, i8),
              av((L = [ri.x, ri.y, ri.z]), i2, i4, i5, rt))
            );
          }
          clampPoint(_, L) {
            return L.copy(_).clamp(this.min, this.max);
          }
          distanceToPoint(_) {
            return i$.copy(_).clamp(this.min, this.max).sub(_).length();
          }
          getBoundingSphere(_) {
            return (
              this.getCenter(_.center),
              (_.radius = 0.5 * this.getSize(i$).length()),
              _
            );
          }
          intersect(_) {
            return (
              this.min.max(_.min),
              this.max.min(_.max),
              this.isEmpty() && this.makeEmpty(),
              this
            );
          }
          union(_) {
            return this.min.min(_.min), this.max.max(_.max), this;
          }
          applyMatrix4(_) {
            return (
              this.isEmpty() ||
                (iJ[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(_),
                iJ[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(_),
                iJ[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(_),
                iJ[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(_),
                iJ[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(_),
                iJ[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(_),
                iJ[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(_),
                iJ[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(_),
                this.setFromPoints(iJ)),
              this
            );
          }
          translate(_) {
            return this.min.add(_), this.max.add(_), this;
          }
          equals(_) {
            return _.min.equals(this.min) && _.max.equals(this.max);
          }
        },
        iJ = [
          new iq(),
          new iq(),
          new iq(),
          new iq(),
          new iq(),
          new iq(),
          new iq(),
          new iq(),
        ],
        i$ = new iq(),
        i0 = new iK(),
        i2 = new iq(),
        i4 = new iq(),
        i5 = new iq(),
        i6 = new iq(),
        i8 = new iq(),
        i9 = new iq(),
        i7 = new iq(),
        rt = new iq(),
        ri = new iq(),
        rr = new iq();
      function av(_, L, R, N, z) {
        for (let F = 0, U = _.length - 3; F <= U; F += 3) {
          rr.fromArray(_, F);
          let U =
              z.x * Math.abs(rr.x) +
              z.y * Math.abs(rr.y) +
              z.z * Math.abs(rr.z),
            k = L.dot(rr),
            Y = R.dot(rr),
            X = N.dot(rr);
          if (Math.max(-Math.max(k, Y, X), Math.min(k, Y, X)) > U) return !1;
        }
        return !0;
      }
      var rs = new iK(),
        rn = new iq(),
        ra = new iq(),
        ro = class {
          constructor(_ = new iq(), L = -1) {
            (this.center = _), (this.radius = L);
          }
          set(_, L) {
            return this.center.copy(_), (this.radius = L), this;
          }
          setFromPoints(_, L) {
            let R = this.center;
            void 0 !== L ? R.copy(L) : rs.setFromPoints(_).getCenter(R);
            let N = 0;
            for (let L = 0, z = _.length; L < z; L++)
              N = Math.max(N, R.distanceToSquared(_[L]));
            return (this.radius = Math.sqrt(N)), this;
          }
          copy(_) {
            return this.center.copy(_.center), (this.radius = _.radius), this;
          }
          isEmpty() {
            return this.radius < 0;
          }
          makeEmpty() {
            return this.center.set(0, 0, 0), (this.radius = -1), this;
          }
          containsPoint(_) {
            return (
              _.distanceToSquared(this.center) <= this.radius * this.radius
            );
          }
          distanceToPoint(_) {
            return _.distanceTo(this.center) - this.radius;
          }
          intersectsSphere(_) {
            let L = this.radius + _.radius;
            return _.center.distanceToSquared(this.center) <= L * L;
          }
          intersectsBox(_) {
            return _.intersectsSphere(this);
          }
          intersectsPlane(_) {
            return Math.abs(_.distanceToPoint(this.center)) <= this.radius;
          }
          clampPoint(_, L) {
            let R = this.center.distanceToSquared(_);
            return (
              L.copy(_),
              R > this.radius * this.radius &&
                (L.sub(this.center).normalize(),
                L.multiplyScalar(this.radius).add(this.center)),
              L
            );
          }
          getBoundingBox(_) {
            return (
              this.isEmpty()
                ? _.makeEmpty()
                : (_.set(this.center, this.center),
                  _.expandByScalar(this.radius)),
              _
            );
          }
          applyMatrix4(_) {
            return (
              this.center.applyMatrix4(_),
              (this.radius = this.radius * _.getMaxScaleOnAxis()),
              this
            );
          }
          translate(_) {
            return this.center.add(_), this;
          }
          expandByPoint(_) {
            if (this.isEmpty())
              return this.center.copy(_), (this.radius = 0), this;
            rn.subVectors(_, this.center);
            let L = rn.lengthSq();
            if (L > this.radius * this.radius) {
              let _ = Math.sqrt(L),
                R = (_ - this.radius) * 0.5;
              this.center.addScaledVector(rn, R / _), (this.radius += R);
            }
            return this;
          }
          union(_) {
            return (
              _.isEmpty() ||
                (this.isEmpty()
                  ? this.copy(_)
                  : !0 === this.center.equals(_.center)
                    ? (this.radius = Math.max(this.radius, _.radius))
                    : (ra.subVectors(_.center, this.center).setLength(_.radius),
                      this.expandByPoint(rn.copy(_.center).add(ra)),
                      this.expandByPoint(rn.copy(_.center).sub(ra)))),
              this
            );
          }
          equals(_) {
            return _.center.equals(this.center) && _.radius === this.radius;
          }
          clone() {
            return new this.constructor().copy(this);
          }
        },
        rl = new iq(),
        rh = new iq(),
        rd = new iq(),
        ru = new iq(),
        rf = new iq(),
        rg = new iq(),
        ry = new iq(),
        rx = class {
          constructor(_ = new iq(), L = new iq(0, 0, -1)) {
            (this.origin = _), (this.direction = L);
          }
          set(_, L) {
            return this.origin.copy(_), this.direction.copy(L), this;
          }
          copy(_) {
            return (
              this.origin.copy(_.origin), this.direction.copy(_.direction), this
            );
          }
          at(_, L) {
            return L.copy(this.direction).multiplyScalar(_).add(this.origin);
          }
          lookAt(_) {
            return this.direction.copy(_).sub(this.origin).normalize(), this;
          }
          recast(_) {
            return this.origin.copy(this.at(_, rl)), this;
          }
          closestPointToPoint(_, L) {
            L.subVectors(_, this.origin);
            let R = L.dot(this.direction);
            return R < 0
              ? L.copy(this.origin)
              : L.copy(this.direction).multiplyScalar(R).add(this.origin);
          }
          distanceToPoint(_) {
            return Math.sqrt(this.distanceSqToPoint(_));
          }
          distanceSqToPoint(_) {
            let L = rl.subVectors(_, this.origin).dot(this.direction);
            return L < 0
              ? this.origin.distanceToSquared(_)
              : (rl.copy(this.direction).multiplyScalar(L).add(this.origin),
                rl.distanceToSquared(_));
          }
          distanceSqToSegment(_, L, R, N) {
            rh.copy(_).add(L).multiplyScalar(0.5),
              rd.copy(L).sub(_).normalize(),
              ru.copy(this.origin).sub(rh);
            let z = 0.5 * _.distanceTo(L),
              F = -this.direction.dot(rd),
              U = ru.dot(this.direction),
              k = -ru.dot(rd),
              Y = ru.lengthSq(),
              X = Math.abs(1 - F * F),
              Q,
              K,
              J,
              $;
            if (X > 0) {
              if (((Q = F * k - U), (K = F * U - k), ($ = z * X), Q >= 0)) {
                if (K >= -$) {
                  if (K <= $) {
                    let _ = 1 / X;
                    (Q *= _),
                      (K *= _),
                      (J =
                        Q * (Q + F * K + 2 * U) + K * (F * Q + K + 2 * k) + Y);
                  } else
                    J =
                      -(Q = Math.max(0, -(F * (K = z) + U))) * Q +
                      K * (K + 2 * k) +
                      Y;
                } else
                  J =
                    -(Q = Math.max(0, -(F * (K = -z) + U))) * Q +
                    K * (K + 2 * k) +
                    Y;
              } else
                K <= -$
                  ? ((K =
                      (Q = Math.max(0, -(-F * z + U))) > 0
                        ? -z
                        : Math.min(Math.max(-z, -k), z)),
                    (J = -Q * Q + K * (K + 2 * k) + Y))
                  : K <= $
                    ? ((Q = 0),
                      (J =
                        (K = Math.min(Math.max(-z, -k), z)) * (K + 2 * k) + Y))
                    : ((K =
                        (Q = Math.max(0, -(F * z + U))) > 0
                          ? z
                          : Math.min(Math.max(-z, -k), z)),
                      (J = -Q * Q + K * (K + 2 * k) + Y));
            } else
              (K = F > 0 ? -z : z),
                (J =
                  -(Q = Math.max(0, -(F * K + U))) * Q + K * (K + 2 * k) + Y);
            return (
              R && R.copy(this.direction).multiplyScalar(Q).add(this.origin),
              N && N.copy(rd).multiplyScalar(K).add(rh),
              J
            );
          }
          intersectSphere(_, L) {
            rl.subVectors(_.center, this.origin);
            let R = rl.dot(this.direction),
              N = rl.dot(rl) - R * R,
              z = _.radius * _.radius;
            if (N > z) return null;
            let F = Math.sqrt(z - N),
              U = R - F,
              k = R + F;
            return U < 0 && k < 0
              ? null
              : U < 0
                ? this.at(k, L)
                : this.at(U, L);
          }
          intersectsSphere(_) {
            return this.distanceSqToPoint(_.center) <= _.radius * _.radius;
          }
          distanceToPlane(_) {
            let L = _.normal.dot(this.direction);
            if (0 === L) return 0 === _.distanceToPoint(this.origin) ? 0 : null;
            let R = -(this.origin.dot(_.normal) + _.constant) / L;
            return R >= 0 ? R : null;
          }
          intersectPlane(_, L) {
            let R = this.distanceToPlane(_);
            return null === R ? null : this.at(R, L);
          }
          intersectsPlane(_) {
            let L = _.distanceToPoint(this.origin);
            return 0 === L || _.normal.dot(this.direction) * L < 0;
          }
          intersectBox(_, L) {
            let R,
              N,
              z,
              F,
              U,
              k,
              Y = 1 / this.direction.x,
              X = 1 / this.direction.y,
              Q = 1 / this.direction.z,
              K = this.origin;
            return (
              Y >= 0
                ? ((R = (_.min.x - K.x) * Y), (N = (_.max.x - K.x) * Y))
                : ((R = (_.max.x - K.x) * Y), (N = (_.min.x - K.x) * Y)),
              X >= 0
                ? ((z = (_.min.y - K.y) * X), (F = (_.max.y - K.y) * X))
                : ((z = (_.max.y - K.y) * X), (F = (_.min.y - K.y) * X)),
              R > F ||
              z > N ||
              ((z > R || isNaN(R)) && (R = z),
              (F < N || isNaN(N)) && (N = F),
              Q >= 0
                ? ((U = (_.min.z - K.z) * Q), (k = (_.max.z - K.z) * Q))
                : ((U = (_.max.z - K.z) * Q), (k = (_.min.z - K.z) * Q)),
              R > k || U > N) ||
              ((U > R || R != R) && (R = U),
              (k < N || N != N) && (N = k),
              N < 0)
                ? null
                : this.at(R >= 0 ? R : N, L)
            );
          }
          intersectsBox(_) {
            return null !== this.intersectBox(_, rl);
          }
          intersectTriangle(_, L, R, N, z) {
            rf.subVectors(L, _), rg.subVectors(R, _), ry.crossVectors(rf, rg);
            let F = this.direction.dot(ry),
              U;
            if (F > 0) {
              if (N) return null;
              U = 1;
            } else {
              if (!(F < 0)) return null;
              (U = -1), (F = -F);
            }
            ru.subVectors(this.origin, _);
            let k = U * this.direction.dot(rg.crossVectors(ru, rg));
            if (k < 0) return null;
            let Y = U * this.direction.dot(rf.cross(ru));
            if (Y < 0 || k + Y > F) return null;
            let X = -U * ru.dot(ry);
            return X < 0 ? null : this.at(X / F, z);
          }
          applyMatrix4(_) {
            return (
              this.origin.applyMatrix4(_),
              this.direction.transformDirection(_),
              this
            );
          }
          equals(_) {
            return (
              _.origin.equals(this.origin) && _.direction.equals(this.direction)
            );
          }
          clone() {
            return new this.constructor().copy(this);
          }
        },
        rw = class {
          constructor() {
            (rw.prototype.isMatrix4 = !0),
              (this.elements = [
                1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1,
              ]);
          }
          set(_, L, R, N, z, F, U, k, Y, X, Q, K, J, $, ee, er) {
            let en = this.elements;
            return (
              (en[0] = _),
              (en[4] = L),
              (en[8] = R),
              (en[12] = N),
              (en[1] = z),
              (en[5] = F),
              (en[9] = U),
              (en[13] = k),
              (en[2] = Y),
              (en[6] = X),
              (en[10] = Q),
              (en[14] = K),
              (en[3] = J),
              (en[7] = $),
              (en[11] = ee),
              (en[15] = er),
              this
            );
          }
          identity() {
            return (
              this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            );
          }
          clone() {
            return new rw().fromArray(this.elements);
          }
          copy(_) {
            let L = this.elements,
              R = _.elements;
            return (
              (L[0] = R[0]),
              (L[1] = R[1]),
              (L[2] = R[2]),
              (L[3] = R[3]),
              (L[4] = R[4]),
              (L[5] = R[5]),
              (L[6] = R[6]),
              (L[7] = R[7]),
              (L[8] = R[8]),
              (L[9] = R[9]),
              (L[10] = R[10]),
              (L[11] = R[11]),
              (L[12] = R[12]),
              (L[13] = R[13]),
              (L[14] = R[14]),
              (L[15] = R[15]),
              this
            );
          }
          copyPosition(_) {
            let L = this.elements,
              R = _.elements;
            return (L[12] = R[12]), (L[13] = R[13]), (L[14] = R[14]), this;
          }
          setFromMatrix3(_) {
            let L = _.elements;
            return (
              this.set(
                L[0],
                L[3],
                L[6],
                0,
                L[1],
                L[4],
                L[7],
                0,
                L[2],
                L[5],
                L[8],
                0,
                0,
                0,
                0,
                1,
              ),
              this
            );
          }
          extractBasis(_, L, R) {
            return (
              _.setFromMatrixColumn(this, 0),
              L.setFromMatrixColumn(this, 1),
              R.setFromMatrixColumn(this, 2),
              this
            );
          }
          makeBasis(_, L, R) {
            return (
              this.set(
                _.x,
                L.x,
                R.x,
                0,
                _.y,
                L.y,
                R.y,
                0,
                _.z,
                L.z,
                R.z,
                0,
                0,
                0,
                0,
                1,
              ),
              this
            );
          }
          extractRotation(_) {
            let L = this.elements,
              R = _.elements,
              N = 1 / r_.setFromMatrixColumn(_, 0).length(),
              z = 1 / r_.setFromMatrixColumn(_, 1).length(),
              F = 1 / r_.setFromMatrixColumn(_, 2).length();
            return (
              (L[0] = R[0] * N),
              (L[1] = R[1] * N),
              (L[2] = R[2] * N),
              (L[3] = 0),
              (L[4] = R[4] * z),
              (L[5] = R[5] * z),
              (L[6] = R[6] * z),
              (L[7] = 0),
              (L[8] = R[8] * F),
              (L[9] = R[9] * F),
              (L[10] = R[10] * F),
              (L[11] = 0),
              (L[12] = 0),
              (L[13] = 0),
              (L[14] = 0),
              (L[15] = 1),
              this
            );
          }
          makeRotationFromEuler(_) {
            let L = this.elements,
              R = _.x,
              N = _.y,
              z = _.z,
              F = Math.cos(R),
              U = Math.sin(R),
              k = Math.cos(N),
              Y = Math.sin(N),
              X = Math.cos(z),
              Q = Math.sin(z);
            if ("XYZ" === _.order) {
              let _ = F * X,
                R = F * Q,
                N = U * X,
                z = U * Q;
              (L[0] = k * X),
                (L[4] = -k * Q),
                (L[8] = Y),
                (L[1] = R + N * Y),
                (L[5] = _ - z * Y),
                (L[9] = -U * k),
                (L[2] = z - _ * Y),
                (L[6] = N + R * Y),
                (L[10] = F * k);
            } else if ("YXZ" === _.order) {
              let _ = k * X,
                R = k * Q,
                N = Y * X,
                z = Y * Q;
              (L[0] = _ + z * U),
                (L[4] = N * U - R),
                (L[8] = F * Y),
                (L[1] = F * Q),
                (L[5] = F * X),
                (L[9] = -U),
                (L[2] = R * U - N),
                (L[6] = z + _ * U),
                (L[10] = F * k);
            } else if ("ZXY" === _.order) {
              let _ = k * X,
                R = k * Q,
                N = Y * X,
                z = Y * Q;
              (L[0] = _ - z * U),
                (L[4] = -F * Q),
                (L[8] = N + R * U),
                (L[1] = R + N * U),
                (L[5] = F * X),
                (L[9] = z - _ * U),
                (L[2] = -F * Y),
                (L[6] = U),
                (L[10] = F * k);
            } else if ("ZYX" === _.order) {
              let _ = F * X,
                R = F * Q,
                N = U * X,
                z = U * Q;
              (L[0] = k * X),
                (L[4] = N * Y - R),
                (L[8] = _ * Y + z),
                (L[1] = k * Q),
                (L[5] = z * Y + _),
                (L[9] = R * Y - N),
                (L[2] = -Y),
                (L[6] = U * k),
                (L[10] = F * k);
            } else if ("YZX" === _.order) {
              let _ = F * k,
                R = F * Y,
                N = U * k,
                z = U * Y;
              (L[0] = k * X),
                (L[4] = z - _ * Q),
                (L[8] = N * Q + R),
                (L[1] = Q),
                (L[5] = F * X),
                (L[9] = -U * X),
                (L[2] = -Y * X),
                (L[6] = R * Q + N),
                (L[10] = _ - z * Q);
            } else if ("XZY" === _.order) {
              let _ = F * k,
                R = F * Y,
                N = U * k,
                z = U * Y;
              (L[0] = k * X),
                (L[4] = -Q),
                (L[8] = Y * X),
                (L[1] = _ * Q + z),
                (L[5] = F * X),
                (L[9] = R * Q - N),
                (L[2] = N * Q - R),
                (L[6] = U * X),
                (L[10] = z * Q + _);
            }
            return (
              (L[3] = 0),
              (L[7] = 0),
              (L[11] = 0),
              (L[12] = 0),
              (L[13] = 0),
              (L[14] = 0),
              (L[15] = 1),
              this
            );
          }
          makeRotationFromQuaternion(_) {
            return this.compose(rE, _, rP);
          }
          lookAt(_, L, R) {
            let N = this.elements;
            return (
              rL.subVectors(_, L),
              0 === rL.lengthSq() && (rL.z = 1),
              rL.normalize(),
              rD.crossVectors(R, rL),
              0 === rD.lengthSq() &&
                (1 === Math.abs(R.z) ? (rL.x += 1e-4) : (rL.z += 1e-4),
                rL.normalize(),
                rD.crossVectors(R, rL)),
              rD.normalize(),
              rO.crossVectors(rL, rD),
              (N[0] = rD.x),
              (N[4] = rO.x),
              (N[8] = rL.x),
              (N[1] = rD.y),
              (N[5] = rO.y),
              (N[9] = rL.y),
              (N[2] = rD.z),
              (N[6] = rO.z),
              (N[10] = rL.z),
              this
            );
          }
          multiply(_) {
            return this.multiplyMatrices(this, _);
          }
          premultiply(_) {
            return this.multiplyMatrices(_, this);
          }
          multiplyMatrices(_, L) {
            let R = _.elements,
              N = L.elements,
              z = this.elements,
              F = R[0],
              U = R[4],
              k = R[8],
              Y = R[12],
              X = R[1],
              Q = R[5],
              K = R[9],
              J = R[13],
              $ = R[2],
              ee = R[6],
              er = R[10],
              en = R[14],
              ea = R[3],
              eo = R[7],
              el = R[11],
              ec = R[15],
              ed = N[0],
              eu = N[4],
              ep = N[8],
              ef = N[12],
              ev = N[1],
              ex = N[5],
              eb = N[9],
              ew = N[13],
              e_ = N[2],
              eA = N[6],
              eM = N[10],
              eE = N[14],
              eC = N[3],
              eP = N[7],
              eD = N[11],
              eO = N[15];
            return (
              (z[0] = F * ed + U * ev + k * e_ + Y * eC),
              (z[4] = F * eu + U * ex + k * eA + Y * eP),
              (z[8] = F * ep + U * eb + k * eM + Y * eD),
              (z[12] = F * ef + U * ew + k * eE + Y * eO),
              (z[1] = X * ed + Q * ev + K * e_ + J * eC),
              (z[5] = X * eu + Q * ex + K * eA + J * eP),
              (z[9] = X * ep + Q * eb + K * eM + J * eD),
              (z[13] = X * ef + Q * ew + K * eE + J * eO),
              (z[2] = $ * ed + ee * ev + er * e_ + en * eC),
              (z[6] = $ * eu + ee * ex + er * eA + en * eP),
              (z[10] = $ * ep + ee * eb + er * eM + en * eD),
              (z[14] = $ * ef + ee * ew + er * eE + en * eO),
              (z[3] = ea * ed + eo * ev + el * e_ + ec * eC),
              (z[7] = ea * eu + eo * ex + el * eA + ec * eP),
              (z[11] = ea * ep + eo * eb + el * eM + ec * eD),
              (z[15] = ea * ef + eo * ew + el * eE + ec * eO),
              this
            );
          }
          multiplyScalar(_) {
            let L = this.elements;
            return (
              (L[0] *= _),
              (L[4] *= _),
              (L[8] *= _),
              (L[12] *= _),
              (L[1] *= _),
              (L[5] *= _),
              (L[9] *= _),
              (L[13] *= _),
              (L[2] *= _),
              (L[6] *= _),
              (L[10] *= _),
              (L[14] *= _),
              (L[3] *= _),
              (L[7] *= _),
              (L[11] *= _),
              (L[15] *= _),
              this
            );
          }
          determinant() {
            let _ = this.elements,
              L = _[0],
              R = _[4],
              N = _[8],
              z = _[12],
              F = _[1],
              U = _[5],
              k = _[9],
              Y = _[13],
              X = _[2],
              Q = _[6],
              K = _[10],
              J = _[14];
            return (
              _[3] *
                (+z * k * Q -
                  N * Y * Q -
                  z * U * K +
                  R * Y * K +
                  N * U * J -
                  R * k * J) +
              _[7] *
                (+L * k * J -
                  L * Y * K +
                  z * F * K -
                  N * F * J +
                  N * Y * X -
                  z * k * X) +
              _[11] *
                (+L * Y * Q -
                  L * U * J -
                  z * F * Q +
                  R * F * J +
                  z * U * X -
                  R * Y * X) +
              _[15] *
                (-N * U * X -
                  L * k * Q +
                  L * U * K +
                  N * F * Q -
                  R * F * K +
                  R * k * X)
            );
          }
          transpose() {
            let _ = this.elements,
              L;
            return (
              (L = _[1]),
              (_[1] = _[4]),
              (_[4] = L),
              (L = _[2]),
              (_[2] = _[8]),
              (_[8] = L),
              (L = _[6]),
              (_[6] = _[9]),
              (_[9] = L),
              (L = _[3]),
              (_[3] = _[12]),
              (_[12] = L),
              (L = _[7]),
              (_[7] = _[13]),
              (_[13] = L),
              (L = _[11]),
              (_[11] = _[14]),
              (_[14] = L),
              this
            );
          }
          setPosition(_, L, R) {
            let N = this.elements;
            return (
              _.isVector3
                ? ((N[12] = _.x), (N[13] = _.y), (N[14] = _.z))
                : ((N[12] = _), (N[13] = L), (N[14] = R)),
              this
            );
          }
          invert() {
            let _ = this.elements,
              L = _[0],
              R = _[1],
              N = _[2],
              z = _[3],
              F = _[4],
              U = _[5],
              k = _[6],
              Y = _[7],
              X = _[8],
              Q = _[9],
              K = _[10],
              J = _[11],
              $ = _[12],
              ee = _[13],
              er = _[14],
              en = _[15],
              ea =
                Q * er * Y -
                ee * K * Y +
                ee * k * J -
                U * er * J -
                Q * k * en +
                U * K * en,
              eo =
                $ * K * Y -
                X * er * Y -
                $ * k * J +
                F * er * J +
                X * k * en -
                F * K * en,
              el =
                X * ee * Y -
                $ * Q * Y +
                $ * U * J -
                F * ee * J -
                X * U * en +
                F * Q * en,
              ec =
                $ * Q * k -
                X * ee * k -
                $ * U * K +
                F * ee * K +
                X * U * er -
                F * Q * er,
              ed = L * ea + R * eo + N * el + z * ec;
            if (0 === ed)
              return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
            let eu = 1 / ed;
            return (
              (_[0] = ea * eu),
              (_[1] =
                (ee * K * z -
                  Q * er * z -
                  ee * N * J +
                  R * er * J +
                  Q * N * en -
                  R * K * en) *
                eu),
              (_[2] =
                (U * er * z -
                  ee * k * z +
                  ee * N * Y -
                  R * er * Y -
                  U * N * en +
                  R * k * en) *
                eu),
              (_[3] =
                (Q * k * z -
                  U * K * z -
                  Q * N * Y +
                  R * K * Y +
                  U * N * J -
                  R * k * J) *
                eu),
              (_[4] = eo * eu),
              (_[5] =
                (X * er * z -
                  $ * K * z +
                  $ * N * J -
                  L * er * J -
                  X * N * en +
                  L * K * en) *
                eu),
              (_[6] =
                ($ * k * z -
                  F * er * z -
                  $ * N * Y +
                  L * er * Y +
                  F * N * en -
                  L * k * en) *
                eu),
              (_[7] =
                (F * K * z -
                  X * k * z +
                  X * N * Y -
                  L * K * Y -
                  F * N * J +
                  L * k * J) *
                eu),
              (_[8] = el * eu),
              (_[9] =
                ($ * Q * z -
                  X * ee * z -
                  $ * R * J +
                  L * ee * J +
                  X * R * en -
                  L * Q * en) *
                eu),
              (_[10] =
                (F * ee * z -
                  $ * U * z +
                  $ * R * Y -
                  L * ee * Y -
                  F * R * en +
                  L * U * en) *
                eu),
              (_[11] =
                (X * U * z -
                  F * Q * z -
                  X * R * Y +
                  L * Q * Y +
                  F * R * J -
                  L * U * J) *
                eu),
              (_[12] = ec * eu),
              (_[13] =
                (X * ee * N -
                  $ * Q * N +
                  $ * R * K -
                  L * ee * K -
                  X * R * er +
                  L * Q * er) *
                eu),
              (_[14] =
                ($ * U * N -
                  F * ee * N -
                  $ * R * k +
                  L * ee * k +
                  F * R * er -
                  L * U * er) *
                eu),
              (_[15] =
                (F * Q * N -
                  X * U * N +
                  X * R * k -
                  L * Q * k -
                  F * R * K +
                  L * U * K) *
                eu),
              this
            );
          }
          scale(_) {
            let L = this.elements,
              R = _.x,
              N = _.y,
              z = _.z;
            return (
              (L[0] *= R),
              (L[4] *= N),
              (L[8] *= z),
              (L[1] *= R),
              (L[5] *= N),
              (L[9] *= z),
              (L[2] *= R),
              (L[6] *= N),
              (L[10] *= z),
              (L[3] *= R),
              (L[7] *= N),
              (L[11] *= z),
              this
            );
          }
          getMaxScaleOnAxis() {
            let _ = this.elements;
            return Math.sqrt(
              Math.max(
                _[0] * _[0] + _[1] * _[1] + _[2] * _[2],
                _[4] * _[4] + _[5] * _[5] + _[6] * _[6],
                _[8] * _[8] + _[9] * _[9] + _[10] * _[10],
              ),
            );
          }
          makeTranslation(_, L, R) {
            return (
              this.set(1, 0, 0, _, 0, 1, 0, L, 0, 0, 1, R, 0, 0, 0, 1), this
            );
          }
          makeRotationX(_) {
            let L = Math.cos(_),
              R = Math.sin(_);
            return (
              this.set(1, 0, 0, 0, 0, L, -R, 0, 0, R, L, 0, 0, 0, 0, 1), this
            );
          }
          makeRotationY(_) {
            let L = Math.cos(_),
              R = Math.sin(_);
            return (
              this.set(L, 0, R, 0, 0, 1, 0, 0, -R, 0, L, 0, 0, 0, 0, 1), this
            );
          }
          makeRotationZ(_) {
            let L = Math.cos(_),
              R = Math.sin(_);
            return (
              this.set(L, -R, 0, 0, R, L, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            );
          }
          makeRotationAxis(_, L) {
            let R = Math.cos(L),
              N = Math.sin(L),
              z = 1 - R,
              F = _.x,
              U = _.y,
              k = _.z,
              Y = z * F,
              X = z * U;
            return (
              this.set(
                Y * F + R,
                Y * U - N * k,
                Y * k + N * U,
                0,
                Y * U + N * k,
                X * U + R,
                X * k - N * F,
                0,
                Y * k - N * U,
                X * k + N * F,
                z * k * k + R,
                0,
                0,
                0,
                0,
                1,
              ),
              this
            );
          }
          makeScale(_, L, R) {
            return (
              this.set(_, 0, 0, 0, 0, L, 0, 0, 0, 0, R, 0, 0, 0, 0, 1), this
            );
          }
          makeShear(_, L, R, N, z, F) {
            return (
              this.set(1, R, z, 0, _, 1, F, 0, L, N, 1, 0, 0, 0, 0, 1), this
            );
          }
          compose(_, L, R) {
            let N = this.elements,
              z = L._x,
              F = L._y,
              U = L._z,
              k = L._w,
              Y = z + z,
              X = F + F,
              Q = U + U,
              K = z * Y,
              J = z * X,
              $ = z * Q,
              ee = F * X,
              er = F * Q,
              en = U * Q,
              ea = k * Y,
              eo = k * X,
              el = k * Q,
              ec = R.x,
              ed = R.y,
              eu = R.z;
            return (
              (N[0] = (1 - (ee + en)) * ec),
              (N[1] = (J + el) * ec),
              (N[2] = ($ - eo) * ec),
              (N[3] = 0),
              (N[4] = (J - el) * ed),
              (N[5] = (1 - (K + en)) * ed),
              (N[6] = (er + ea) * ed),
              (N[7] = 0),
              (N[8] = ($ + eo) * eu),
              (N[9] = (er - ea) * eu),
              (N[10] = (1 - (K + ee)) * eu),
              (N[11] = 0),
              (N[12] = _.x),
              (N[13] = _.y),
              (N[14] = _.z),
              (N[15] = 1),
              this
            );
          }
          decompose(_, L, R) {
            let N = this.elements,
              z = r_.set(N[0], N[1], N[2]).length(),
              F = r_.set(N[4], N[5], N[6]).length(),
              U = r_.set(N[8], N[9], N[10]).length();
            0 > this.determinant() && (z = -z),
              (_.x = N[12]),
              (_.y = N[13]),
              (_.z = N[14]),
              rM.copy(this);
            let k = 1 / z,
              Y = 1 / F,
              X = 1 / U;
            return (
              (rM.elements[0] *= k),
              (rM.elements[1] *= k),
              (rM.elements[2] *= k),
              (rM.elements[4] *= Y),
              (rM.elements[5] *= Y),
              (rM.elements[6] *= Y),
              (rM.elements[8] *= X),
              (rM.elements[9] *= X),
              (rM.elements[10] *= X),
              L.setFromRotationMatrix(rM),
              (R.x = z),
              (R.y = F),
              (R.z = U),
              this
            );
          }
          makePerspective(_, L, R, N, z, F) {
            let U = this.elements;
            return (
              (U[0] = (2 * z) / (L - _)),
              (U[4] = 0),
              (U[8] = (L + _) / (L - _)),
              (U[12] = 0),
              (U[1] = 0),
              (U[5] = (2 * z) / (R - N)),
              (U[9] = (R + N) / (R - N)),
              (U[13] = 0),
              (U[2] = 0),
              (U[6] = 0),
              (U[10] = -(F + z) / (F - z)),
              (U[14] = (-2 * F * z) / (F - z)),
              (U[3] = 0),
              (U[7] = 0),
              (U[11] = -1),
              (U[15] = 0),
              this
            );
          }
          makeOrthographic(_, L, R, N, z, F) {
            let U = this.elements,
              k = 1 / (L - _),
              Y = 1 / (R - N),
              X = 1 / (F - z);
            return (
              (U[0] = 2 * k),
              (U[4] = 0),
              (U[8] = 0),
              (U[12] = -((L + _) * k)),
              (U[1] = 0),
              (U[5] = 2 * Y),
              (U[9] = 0),
              (U[13] = -((R + N) * Y)),
              (U[2] = 0),
              (U[6] = 0),
              (U[10] = -2 * X),
              (U[14] = -((F + z) * X)),
              (U[3] = 0),
              (U[7] = 0),
              (U[11] = 0),
              (U[15] = 1),
              this
            );
          }
          equals(_) {
            let L = this.elements,
              R = _.elements;
            for (let _ = 0; _ < 16; _++) if (L[_] !== R[_]) return !1;
            return !0;
          }
          fromArray(_, L = 0) {
            for (let R = 0; R < 16; R++) this.elements[R] = _[R + L];
            return this;
          }
          toArray(_ = [], L = 0) {
            let R = this.elements;
            return (
              (_[L] = R[0]),
              (_[L + 1] = R[1]),
              (_[L + 2] = R[2]),
              (_[L + 3] = R[3]),
              (_[L + 4] = R[4]),
              (_[L + 5] = R[5]),
              (_[L + 6] = R[6]),
              (_[L + 7] = R[7]),
              (_[L + 8] = R[8]),
              (_[L + 9] = R[9]),
              (_[L + 10] = R[10]),
              (_[L + 11] = R[11]),
              (_[L + 12] = R[12]),
              (_[L + 13] = R[13]),
              (_[L + 14] = R[14]),
              (_[L + 15] = R[15]),
              _
            );
          }
        },
        r_ = new iq(),
        rM = new rw(),
        rE = new iq(0, 0, 0),
        rP = new iq(1, 1, 1),
        rD = new iq(),
        rO = new iq(),
        rL = new iq(),
        rR = new rw(),
        rB = new iX(),
        rN = class {
          constructor(_ = 0, L = 0, R = 0, N = rN.DEFAULT_ORDER) {
            (this.isEuler = !0),
              (this._x = _),
              (this._y = L),
              (this._z = R),
              (this._order = N);
          }
          get x() {
            return this._x;
          }
          set x(_) {
            (this._x = _), this._onChangeCallback();
          }
          get y() {
            return this._y;
          }
          set y(_) {
            (this._y = _), this._onChangeCallback();
          }
          get z() {
            return this._z;
          }
          set z(_) {
            (this._z = _), this._onChangeCallback();
          }
          get order() {
            return this._order;
          }
          set order(_) {
            (this._order = _), this._onChangeCallback();
          }
          set(_, L, R, N = this._order) {
            return (
              (this._x = _),
              (this._y = L),
              (this._z = R),
              (this._order = N),
              this._onChangeCallback(),
              this
            );
          }
          clone() {
            return new this.constructor(this._x, this._y, this._z, this._order);
          }
          copy(_) {
            return (
              (this._x = _._x),
              (this._y = _._y),
              (this._z = _._z),
              (this._order = _._order),
              this._onChangeCallback(),
              this
            );
          }
          setFromRotationMatrix(_, L = this._order, R = !0) {
            let N = _.elements,
              z = N[0],
              F = N[4],
              U = N[8],
              k = N[1],
              Y = N[5],
              X = N[9],
              Q = N[2],
              K = N[6],
              J = N[10];
            switch (L) {
              case "XYZ":
                (this._y = Math.asin(_n(U, -1, 1))),
                  0.9999999 > Math.abs(U)
                    ? ((this._x = Math.atan2(-X, J)),
                      (this._z = Math.atan2(-F, z)))
                    : ((this._x = Math.atan2(K, Y)), (this._z = 0));
                break;
              case "YXZ":
                (this._x = Math.asin(-_n(X, -1, 1))),
                  0.9999999 > Math.abs(X)
                    ? ((this._y = Math.atan2(U, J)),
                      (this._z = Math.atan2(k, Y)))
                    : ((this._y = Math.atan2(-Q, z)), (this._z = 0));
                break;
              case "ZXY":
                (this._x = Math.asin(_n(K, -1, 1))),
                  0.9999999 > Math.abs(K)
                    ? ((this._y = Math.atan2(-Q, J)),
                      (this._z = Math.atan2(-F, Y)))
                    : ((this._y = 0), (this._z = Math.atan2(k, z)));
                break;
              case "ZYX":
                (this._y = Math.asin(-_n(Q, -1, 1))),
                  0.9999999 > Math.abs(Q)
                    ? ((this._x = Math.atan2(K, J)),
                      (this._z = Math.atan2(k, z)))
                    : ((this._x = 0), (this._z = Math.atan2(-F, Y)));
                break;
              case "YZX":
                (this._z = Math.asin(_n(k, -1, 1))),
                  0.9999999 > Math.abs(k)
                    ? ((this._x = Math.atan2(-X, Y)),
                      (this._y = Math.atan2(-Q, z)))
                    : ((this._x = 0), (this._y = Math.atan2(U, J)));
                break;
              case "XZY":
                (this._z = Math.asin(-_n(F, -1, 1))),
                  0.9999999 > Math.abs(F)
                    ? ((this._x = Math.atan2(K, Y)),
                      (this._y = Math.atan2(U, z)))
                    : ((this._x = Math.atan2(-X, J)), (this._y = 0));
                break;
              default:
                console.warn(
                  "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
                    L,
                );
            }
            return (
              (this._order = L), !0 === R && this._onChangeCallback(), this
            );
          }
          setFromQuaternion(_, L, R) {
            return (
              rR.makeRotationFromQuaternion(_),
              this.setFromRotationMatrix(rR, L, R)
            );
          }
          setFromVector3(_, L = this._order) {
            return this.set(_.x, _.y, _.z, L);
          }
          reorder(_) {
            return rB.setFromEuler(this), this.setFromQuaternion(rB, _);
          }
          equals(_) {
            return (
              _._x === this._x &&
              _._y === this._y &&
              _._z === this._z &&
              _._order === this._order
            );
          }
          fromArray(_) {
            return (
              (this._x = _[0]),
              (this._y = _[1]),
              (this._z = _[2]),
              void 0 !== _[3] && (this._order = _[3]),
              this._onChangeCallback(),
              this
            );
          }
          toArray(_ = [], L = 0) {
            return (
              (_[L] = this._x),
              (_[L + 1] = this._y),
              (_[L + 2] = this._z),
              (_[L + 3] = this._order),
              _
            );
          }
          _onChange(_) {
            return (this._onChangeCallback = _), this;
          }
          _onChangeCallback() {}
          *[Symbol.iterator]() {
            yield this._x, yield this._y, yield this._z, yield this._order;
          }
        };
      rN.DEFAULT_ORDER = "XYZ";
      var rz = class {
          constructor() {
            this.mask = 1;
          }
          set(_) {
            this.mask = ((1 << _) | 0) >>> 0;
          }
          enable(_) {
            this.mask |= (1 << _) | 0;
          }
          enableAll() {
            this.mask = -1;
          }
          toggle(_) {
            this.mask ^= (1 << _) | 0;
          }
          disable(_) {
            this.mask &= ~((1 << _) | 0);
          }
          disableAll() {
            this.mask = 0;
          }
          test(_) {
            return (this.mask & _.mask) != 0;
          }
          isEnabled(_) {
            return (this.mask & ((1 << _) | 0)) != 0;
          }
        },
        rF = 0,
        rU = new iq(),
        rk = new iX(),
        rj = new rw(),
        rG = new iq(),
        rV = new iq(),
        rH = new iq(),
        rW = new iX(),
        rY = new iq(1, 0, 0),
        rX = new iq(0, 1, 0),
        rq = new iq(0, 0, 1),
        rQ = { type: "added" },
        rZ = { type: "removed" },
        rK = class extends ig {
          constructor() {
            super(),
              (this.isObject3D = !0),
              Object.defineProperty(this, "id", { value: rF++ }),
              (this.uuid = es()),
              (this.name = ""),
              (this.type = "Object3D"),
              (this.parent = null),
              (this.children = []),
              (this.up = rK.DEFAULT_UP.clone());
            let _ = new iq(),
              L = new rN(),
              R = new iX(),
              N = new iq(1, 1, 1);
            L._onChange(function () {
              R.setFromEuler(L, !1);
            }),
              R._onChange(function () {
                L.setFromQuaternion(R, void 0, !1);
              }),
              Object.defineProperties(this, {
                position: { configurable: !0, enumerable: !0, value: _ },
                rotation: { configurable: !0, enumerable: !0, value: L },
                quaternion: { configurable: !0, enumerable: !0, value: R },
                scale: { configurable: !0, enumerable: !0, value: N },
                modelViewMatrix: { value: new rw() },
                normalMatrix: { value: new iC() },
              }),
              (this.matrix = new rw()),
              (this.matrixWorld = new rw()),
              (this.matrixAutoUpdate = rK.DEFAULT_MATRIX_AUTO_UPDATE),
              (this.matrixWorldNeedsUpdate = !1),
              (this.matrixWorldAutoUpdate =
                rK.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
              (this.layers = new rz()),
              (this.visible = !0),
              (this.castShadow = !1),
              (this.receiveShadow = !1),
              (this.frustumCulled = !0),
              (this.renderOrder = 0),
              (this.animations = []),
              (this.userData = {});
          }
          onBeforeRender() {}
          onAfterRender() {}
          applyMatrix4(_) {
            this.matrixAutoUpdate && this.updateMatrix(),
              this.matrix.premultiply(_),
              this.matrix.decompose(this.position, this.quaternion, this.scale);
          }
          applyQuaternion(_) {
            return this.quaternion.premultiply(_), this;
          }
          setRotationFromAxisAngle(_, L) {
            this.quaternion.setFromAxisAngle(_, L);
          }
          setRotationFromEuler(_) {
            this.quaternion.setFromEuler(_, !0);
          }
          setRotationFromMatrix(_) {
            this.quaternion.setFromRotationMatrix(_);
          }
          setRotationFromQuaternion(_) {
            this.quaternion.copy(_);
          }
          rotateOnAxis(_, L) {
            return (
              rk.setFromAxisAngle(_, L), this.quaternion.multiply(rk), this
            );
          }
          rotateOnWorldAxis(_, L) {
            return (
              rk.setFromAxisAngle(_, L), this.quaternion.premultiply(rk), this
            );
          }
          rotateX(_) {
            return this.rotateOnAxis(rY, _);
          }
          rotateY(_) {
            return this.rotateOnAxis(rX, _);
          }
          rotateZ(_) {
            return this.rotateOnAxis(rq, _);
          }
          translateOnAxis(_, L) {
            return (
              rU.copy(_).applyQuaternion(this.quaternion),
              this.position.add(rU.multiplyScalar(L)),
              this
            );
          }
          translateX(_) {
            return this.translateOnAxis(rY, _);
          }
          translateY(_) {
            return this.translateOnAxis(rX, _);
          }
          translateZ(_) {
            return this.translateOnAxis(rq, _);
          }
          localToWorld(_) {
            return (
              this.updateWorldMatrix(!0, !1), _.applyMatrix4(this.matrixWorld)
            );
          }
          worldToLocal(_) {
            return (
              this.updateWorldMatrix(!0, !1),
              _.applyMatrix4(rj.copy(this.matrixWorld).invert())
            );
          }
          lookAt(_, L, R) {
            _.isVector3 ? rG.copy(_) : rG.set(_, L, R);
            let N = this.parent;
            this.updateWorldMatrix(!0, !1),
              rV.setFromMatrixPosition(this.matrixWorld),
              this.isCamera || this.isLight
                ? rj.lookAt(rV, rG, this.up)
                : rj.lookAt(rG, rV, this.up),
              this.quaternion.setFromRotationMatrix(rj),
              N &&
                (rj.extractRotation(N.matrixWorld),
                rk.setFromRotationMatrix(rj),
                this.quaternion.premultiply(rk.invert()));
          }
          add(_) {
            if (arguments.length > 1) {
              for (let _ = 0; _ < arguments.length; _++) this.add(arguments[_]);
              return this;
            }
            return (
              _ === this
                ? console.error(
                    "THREE.Object3D.add: object can't be added as a child of itself.",
                    _,
                  )
                : _ && _.isObject3D
                  ? (null !== _.parent && _.parent.remove(_),
                    (_.parent = this),
                    this.children.push(_),
                    _.dispatchEvent(rQ))
                  : console.error(
                      "THREE.Object3D.add: object not an instance of THREE.Object3D.",
                      _,
                    ),
              this
            );
          }
          remove(_) {
            if (arguments.length > 1) {
              for (let _ = 0; _ < arguments.length; _++)
                this.remove(arguments[_]);
              return this;
            }
            let L = this.children.indexOf(_);
            return (
              -1 !== L &&
                ((_.parent = null),
                this.children.splice(L, 1),
                _.dispatchEvent(rZ)),
              this
            );
          }
          removeFromParent() {
            let _ = this.parent;
            return null !== _ && _.remove(this), this;
          }
          clear() {
            for (let _ = 0; _ < this.children.length; _++) {
              let L = this.children[_];
              (L.parent = null), L.dispatchEvent(rZ);
            }
            return (this.children.length = 0), this;
          }
          attach(_) {
            return (
              this.updateWorldMatrix(!0, !1),
              rj.copy(this.matrixWorld).invert(),
              null !== _.parent &&
                (_.parent.updateWorldMatrix(!0, !1),
                rj.multiply(_.parent.matrixWorld)),
              _.applyMatrix4(rj),
              this.add(_),
              _.updateWorldMatrix(!1, !0),
              this
            );
          }
          getObjectById(_) {
            return this.getObjectByProperty("id", _);
          }
          getObjectByName(_) {
            return this.getObjectByProperty("name", _);
          }
          getObjectByProperty(_, L) {
            if (this[_] === L) return this;
            for (let R = 0, N = this.children.length; R < N; R++) {
              let N = this.children[R].getObjectByProperty(_, L);
              if (void 0 !== N) return N;
            }
          }
          getObjectsByProperty(_, L) {
            let R = [];
            this[_] === L && R.push(this);
            for (let N = 0, z = this.children.length; N < z; N++) {
              let z = this.children[N].getObjectsByProperty(_, L);
              z.length > 0 && (R = R.concat(z));
            }
            return R;
          }
          getWorldPosition(_) {
            return (
              this.updateWorldMatrix(!0, !1),
              _.setFromMatrixPosition(this.matrixWorld)
            );
          }
          getWorldQuaternion(_) {
            return (
              this.updateWorldMatrix(!0, !1),
              this.matrixWorld.decompose(rV, _, rH),
              _
            );
          }
          getWorldScale(_) {
            return (
              this.updateWorldMatrix(!0, !1),
              this.matrixWorld.decompose(rV, rW, _),
              _
            );
          }
          getWorldDirection(_) {
            this.updateWorldMatrix(!0, !1);
            let L = this.matrixWorld.elements;
            return _.set(L[8], L[9], L[10]).normalize();
          }
          raycast() {}
          traverse(_) {
            _(this);
            let L = this.children;
            for (let R = 0, N = L.length; R < N; R++) L[R].traverse(_);
          }
          traverseVisible(_) {
            if (!1 === this.visible) return;
            _(this);
            let L = this.children;
            for (let R = 0, N = L.length; R < N; R++) L[R].traverseVisible(_);
          }
          traverseAncestors(_) {
            let L = this.parent;
            null !== L && (_(L), L.traverseAncestors(_));
          }
          updateMatrix() {
            this.matrix.compose(this.position, this.quaternion, this.scale),
              (this.matrixWorldNeedsUpdate = !0);
          }
          updateMatrixWorld(_) {
            this.matrixAutoUpdate && this.updateMatrix(),
              (this.matrixWorldNeedsUpdate || _) &&
                (null === this.parent
                  ? this.matrixWorld.copy(this.matrix)
                  : this.matrixWorld.multiplyMatrices(
                      this.parent.matrixWorld,
                      this.matrix,
                    ),
                (this.matrixWorldNeedsUpdate = !1),
                (_ = !0));
            let L = this.children;
            for (let R = 0, N = L.length; R < N; R++) {
              let N = L[R];
              (!0 === N.matrixWorldAutoUpdate || !0 === _) &&
                N.updateMatrixWorld(_);
            }
          }
          updateWorldMatrix(_, L) {
            let R = this.parent;
            if (
              (!0 === _ &&
                null !== R &&
                !0 === R.matrixWorldAutoUpdate &&
                R.updateWorldMatrix(!0, !1),
              this.matrixAutoUpdate && this.updateMatrix(),
              null === this.parent
                ? this.matrixWorld.copy(this.matrix)
                : this.matrixWorld.multiplyMatrices(
                    this.parent.matrixWorld,
                    this.matrix,
                  ),
              !0 === L)
            ) {
              let _ = this.children;
              for (let L = 0, R = _.length; L < R; L++) {
                let R = _[L];
                !0 === R.matrixWorldAutoUpdate && R.updateWorldMatrix(!1, !0);
              }
            }
          }
          toJSON(_) {
            let L = void 0 === _ || "string" == typeof _,
              R = {};
            L &&
              ((_ = {
                geometries: {},
                materials: {},
                textures: {},
                images: {},
                shapes: {},
                skeletons: {},
                animations: {},
                nodes: {},
              }),
              (R.metadata = {
                version: 4.5,
                type: "Object",
                generator: "Object3D.toJSON",
              }));
            let N = {};
            function s(L, R) {
              return void 0 === L[R.uuid] && (L[R.uuid] = R.toJSON(_)), R.uuid;
            }
            if (
              ((N.uuid = this.uuid),
              (N.type = this.type),
              "" !== this.name && (N.name = this.name),
              !0 === this.castShadow && (N.castShadow = !0),
              !0 === this.receiveShadow && (N.receiveShadow = !0),
              !1 === this.visible && (N.visible = !1),
              !1 === this.frustumCulled && (N.frustumCulled = !1),
              0 !== this.renderOrder && (N.renderOrder = this.renderOrder),
              Object.keys(this.userData).length > 0 &&
                (N.userData = this.userData),
              (N.layers = this.layers.mask),
              (N.matrix = this.matrix.toArray()),
              !1 === this.matrixAutoUpdate && (N.matrixAutoUpdate = !1),
              this.isInstancedMesh &&
                ((N.type = "InstancedMesh"),
                (N.count = this.count),
                (N.instanceMatrix = this.instanceMatrix.toJSON()),
                null !== this.instanceColor &&
                  (N.instanceColor = this.instanceColor.toJSON())),
              this.isScene)
            )
              this.background &&
                (this.background.isColor
                  ? (N.background = this.background.toJSON())
                  : this.background.isTexture &&
                    (N.background = this.background.toJSON(_).uuid)),
                this.environment &&
                  this.environment.isTexture &&
                  !0 !== this.environment.isRenderTargetTexture &&
                  (N.environment = this.environment.toJSON(_).uuid);
            else if (this.isMesh || this.isLine || this.isPoints) {
              N.geometry = s(_.geometries, this.geometry);
              let L = this.geometry.parameters;
              if (void 0 !== L && void 0 !== L.shapes) {
                let R = L.shapes;
                if (Array.isArray(R))
                  for (let L = 0, N = R.length; L < N; L++) {
                    let N = R[L];
                    s(_.shapes, N);
                  }
                else s(_.shapes, R);
              }
            }
            if (
              (this.isSkinnedMesh &&
                ((N.bindMode = this.bindMode),
                (N.bindMatrix = this.bindMatrix.toArray()),
                void 0 !== this.skeleton &&
                  (s(_.skeletons, this.skeleton),
                  (N.skeleton = this.skeleton.uuid))),
              void 0 !== this.material)
            ) {
              if (Array.isArray(this.material)) {
                let L = [];
                for (let R = 0, N = this.material.length; R < N; R++)
                  L.push(s(_.materials, this.material[R]));
                N.material = L;
              } else N.material = s(_.materials, this.material);
            }
            if (this.children.length > 0) {
              N.children = [];
              for (let L = 0; L < this.children.length; L++)
                N.children.push(this.children[L].toJSON(_).object);
            }
            if (this.animations.length > 0) {
              N.animations = [];
              for (let L = 0; L < this.animations.length; L++) {
                let R = this.animations[L];
                N.animations.push(s(_.animations, R));
              }
            }
            if (L) {
              let L = o(_.geometries),
                N = o(_.materials),
                z = o(_.textures),
                F = o(_.images),
                U = o(_.shapes),
                k = o(_.skeletons),
                Y = o(_.animations),
                X = o(_.nodes);
              L.length > 0 && (R.geometries = L),
                N.length > 0 && (R.materials = N),
                z.length > 0 && (R.textures = z),
                F.length > 0 && (R.images = F),
                U.length > 0 && (R.shapes = U),
                k.length > 0 && (R.skeletons = k),
                Y.length > 0 && (R.animations = Y),
                X.length > 0 && (R.nodes = X);
            }
            return (R.object = N), R;
            function o(_) {
              let L = [];
              for (let R in _) {
                let N = _[R];
                delete N.metadata, L.push(N);
              }
              return L;
            }
          }
          clone(_) {
            return new this.constructor().copy(this, _);
          }
          copy(_, L = !0) {
            if (
              ((this.name = _.name),
              this.up.copy(_.up),
              this.position.copy(_.position),
              (this.rotation.order = _.rotation.order),
              this.quaternion.copy(_.quaternion),
              this.scale.copy(_.scale),
              this.matrix.copy(_.matrix),
              this.matrixWorld.copy(_.matrixWorld),
              (this.matrixAutoUpdate = _.matrixAutoUpdate),
              (this.matrixWorldNeedsUpdate = _.matrixWorldNeedsUpdate),
              (this.matrixWorldAutoUpdate = _.matrixWorldAutoUpdate),
              (this.layers.mask = _.layers.mask),
              (this.visible = _.visible),
              (this.castShadow = _.castShadow),
              (this.receiveShadow = _.receiveShadow),
              (this.frustumCulled = _.frustumCulled),
              (this.renderOrder = _.renderOrder),
              (this.userData = JSON.parse(JSON.stringify(_.userData))),
              !0 === L)
            )
              for (let L = 0; L < _.children.length; L++) {
                let R = _.children[L];
                this.add(R.clone());
              }
            return this;
          }
        };
      (rK.DEFAULT_UP = new iq(0, 1, 0)),
        (rK.DEFAULT_MATRIX_AUTO_UPDATE = !0),
        (rK.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0);
      var rJ = new iq(),
        r$ = new iq(),
        r0 = new iq(),
        r2 = new iq(),
        r4 = new iq(),
        r5 = new iq(),
        r6 = new iq(),
        r8 = new iq(),
        r9 = new iq(),
        r7 = new iq(),
        se = class {
          constructor(_ = new iq(), L = new iq(), R = new iq()) {
            (this.a = _), (this.b = L), (this.c = R);
          }
          static getNormal(_, L, R, N) {
            N.subVectors(R, L), rJ.subVectors(_, L), N.cross(rJ);
            let z = N.lengthSq();
            return z > 0 ? N.multiplyScalar(1 / Math.sqrt(z)) : N.set(0, 0, 0);
          }
          static getBarycoord(_, L, R, N, z) {
            rJ.subVectors(N, L), r$.subVectors(R, L), r0.subVectors(_, L);
            let F = rJ.dot(rJ),
              U = rJ.dot(r$),
              k = rJ.dot(r0),
              Y = r$.dot(r$),
              X = r$.dot(r0),
              Q = F * Y - U * U;
            if (0 === Q) return z.set(-2, -1, -1);
            let K = 1 / Q,
              J = (Y * k - U * X) * K,
              $ = (F * X - U * k) * K;
            return z.set(1 - J - $, $, J);
          }
          static containsPoint(_, L, R, N) {
            return (
              this.getBarycoord(_, L, R, N, r2),
              r2.x >= 0 && r2.y >= 0 && r2.x + r2.y <= 1
            );
          }
          static getUV(_, L, R, N, z, F, U, k) {
            return (
              this.getBarycoord(_, L, R, N, r2),
              k.set(0, 0),
              k.addScaledVector(z, r2.x),
              k.addScaledVector(F, r2.y),
              k.addScaledVector(U, r2.z),
              k
            );
          }
          static isFrontFacing(_, L, R, N) {
            return (
              rJ.subVectors(R, L), r$.subVectors(_, L), 0 > rJ.cross(r$).dot(N)
            );
          }
          set(_, L, R) {
            return this.a.copy(_), this.b.copy(L), this.c.copy(R), this;
          }
          setFromPointsAndIndices(_, L, R, N) {
            return (
              this.a.copy(_[L]), this.b.copy(_[R]), this.c.copy(_[N]), this
            );
          }
          setFromAttributeAndIndices(_, L, R, N) {
            return (
              this.a.fromBufferAttribute(_, L),
              this.b.fromBufferAttribute(_, R),
              this.c.fromBufferAttribute(_, N),
              this
            );
          }
          clone() {
            return new this.constructor().copy(this);
          }
          copy(_) {
            return this.a.copy(_.a), this.b.copy(_.b), this.c.copy(_.c), this;
          }
          getArea() {
            return (
              rJ.subVectors(this.c, this.b),
              r$.subVectors(this.a, this.b),
              0.5 * rJ.cross(r$).length()
            );
          }
          getMidpoint(_) {
            return _.addVectors(this.a, this.b)
              .add(this.c)
              .multiplyScalar(1 / 3);
          }
          getNormal(_) {
            return se.getNormal(this.a, this.b, this.c, _);
          }
          getPlane(_) {
            return _.setFromCoplanarPoints(this.a, this.b, this.c);
          }
          getBarycoord(_, L) {
            return se.getBarycoord(_, this.a, this.b, this.c, L);
          }
          getUV(_, L, R, N, z) {
            return se.getUV(_, this.a, this.b, this.c, L, R, N, z);
          }
          containsPoint(_) {
            return se.containsPoint(_, this.a, this.b, this.c);
          }
          isFrontFacing(_) {
            return se.isFrontFacing(this.a, this.b, this.c, _);
          }
          intersectsBox(_) {
            return _.intersectsTriangle(this);
          }
          closestPointToPoint(_, L) {
            let R = this.a,
              N = this.b,
              z = this.c,
              F,
              U;
            r4.subVectors(N, R), r5.subVectors(z, R), r8.subVectors(_, R);
            let k = r4.dot(r8),
              Y = r5.dot(r8);
            if (k <= 0 && Y <= 0) return L.copy(R);
            r9.subVectors(_, N);
            let X = r4.dot(r9),
              Q = r5.dot(r9);
            if (X >= 0 && Q <= X) return L.copy(N);
            let K = k * Q - X * Y;
            if (K <= 0 && k >= 0 && X <= 0)
              return (F = k / (k - X)), L.copy(R).addScaledVector(r4, F);
            r7.subVectors(_, z);
            let J = r4.dot(r7),
              $ = r5.dot(r7);
            if ($ >= 0 && J <= $) return L.copy(z);
            let ee = J * Y - k * $;
            if (ee <= 0 && Y >= 0 && $ <= 0)
              return (U = Y / (Y - $)), L.copy(R).addScaledVector(r5, U);
            let er = X * $ - J * Q;
            if (er <= 0 && Q - X >= 0 && J - $ >= 0)
              return (
                r6.subVectors(z, N),
                (U = (Q - X) / (Q - X + (J - $))),
                L.copy(N).addScaledVector(r6, U)
              );
            let en = 1 / (er + ee + K);
            return (
              (F = ee * en),
              (U = K * en),
              L.copy(R).addScaledVector(r4, F).addScaledVector(r5, U)
            );
          }
          equals(_) {
            return (
              _.a.equals(this.a) && _.b.equals(this.b) && _.c.equals(this.c)
            );
          }
        },
        st = 0,
        sr = class extends ig {
          constructor() {
            super(),
              (this.isMaterial = !0),
              Object.defineProperty(this, "id", { value: st++ }),
              (this.uuid = es()),
              (this.name = ""),
              (this.type = "Material"),
              (this.blending = 1),
              (this.side = 0),
              (this.vertexColors = !1),
              (this.opacity = 1),
              (this.transparent = !1),
              (this.blendSrc = 204),
              (this.blendDst = 205),
              (this.blendEquation = 100),
              (this.blendSrcAlpha = null),
              (this.blendDstAlpha = null),
              (this.blendEquationAlpha = null),
              (this.depthFunc = 3),
              (this.depthTest = !0),
              (this.depthWrite = !0),
              (this.stencilWriteMask = 255),
              (this.stencilFunc = 519),
              (this.stencilRef = 0),
              (this.stencilFuncMask = 255),
              (this.stencilFail = 7680),
              (this.stencilZFail = 7680),
              (this.stencilZPass = 7680),
              (this.stencilWrite = !1),
              (this.clippingPlanes = null),
              (this.clipIntersection = !1),
              (this.clipShadows = !1),
              (this.shadowSide = null),
              (this.colorWrite = !0),
              (this.precision = null),
              (this.polygonOffset = !1),
              (this.polygonOffsetFactor = 0),
              (this.polygonOffsetUnits = 0),
              (this.dithering = !1),
              (this.alphaToCoverage = !1),
              (this.premultipliedAlpha = !1),
              (this.forceSinglePass = !1),
              (this.visible = !0),
              (this.toneMapped = !0),
              (this.userData = {}),
              (this.version = 0),
              (this._alphaTest = 0);
          }
          get alphaTest() {
            return this._alphaTest;
          }
          set alphaTest(_) {
            this._alphaTest > 0 != _ > 0 && this.version++,
              (this._alphaTest = _);
          }
          onBuild() {}
          onBeforeRender() {}
          onBeforeCompile() {}
          customProgramCacheKey() {
            return this.onBeforeCompile.toString();
          }
          setValues(_) {
            if (void 0 !== _)
              for (let L in _) {
                let R = _[L];
                if (void 0 === R) {
                  console.warn(
                    "THREE.Material: '" + L + "' parameter is undefined.",
                  );
                  continue;
                }
                let N = this[L];
                if (void 0 === N) {
                  console.warn(
                    "THREE." +
                      this.type +
                      ": '" +
                      L +
                      "' is not a property of this material.",
                  );
                  continue;
                }
                N && N.isColor
                  ? N.set(R)
                  : N && N.isVector3 && R && R.isVector3
                    ? N.copy(R)
                    : (this[L] = R);
              }
          }
          toJSON(_) {
            let L = void 0 === _ || "string" == typeof _;
            L && (_ = { textures: {}, images: {} });
            let R = {
              metadata: {
                version: 4.5,
                type: "Material",
                generator: "Material.toJSON",
              },
            };
            function i(_) {
              let L = [];
              for (let R in _) {
                let N = _[R];
                delete N.metadata, L.push(N);
              }
              return L;
            }
            if (
              ((R.uuid = this.uuid),
              (R.type = this.type),
              "" !== this.name && (R.name = this.name),
              this.color &&
                this.color.isColor &&
                (R.color = this.color.getHex()),
              void 0 !== this.roughness && (R.roughness = this.roughness),
              void 0 !== this.metalness && (R.metalness = this.metalness),
              void 0 !== this.sheen && (R.sheen = this.sheen),
              this.sheenColor &&
                this.sheenColor.isColor &&
                (R.sheenColor = this.sheenColor.getHex()),
              void 0 !== this.sheenRoughness &&
                (R.sheenRoughness = this.sheenRoughness),
              this.emissive &&
                this.emissive.isColor &&
                (R.emissive = this.emissive.getHex()),
              this.emissiveIntensity &&
                1 !== this.emissiveIntensity &&
                (R.emissiveIntensity = this.emissiveIntensity),
              this.specular &&
                this.specular.isColor &&
                (R.specular = this.specular.getHex()),
              void 0 !== this.specularIntensity &&
                (R.specularIntensity = this.specularIntensity),
              this.specularColor &&
                this.specularColor.isColor &&
                (R.specularColor = this.specularColor.getHex()),
              void 0 !== this.shininess && (R.shininess = this.shininess),
              void 0 !== this.clearcoat && (R.clearcoat = this.clearcoat),
              void 0 !== this.clearcoatRoughness &&
                (R.clearcoatRoughness = this.clearcoatRoughness),
              this.clearcoatMap &&
                this.clearcoatMap.isTexture &&
                (R.clearcoatMap = this.clearcoatMap.toJSON(_).uuid),
              this.clearcoatRoughnessMap &&
                this.clearcoatRoughnessMap.isTexture &&
                (R.clearcoatRoughnessMap =
                  this.clearcoatRoughnessMap.toJSON(_).uuid),
              this.clearcoatNormalMap &&
                this.clearcoatNormalMap.isTexture &&
                ((R.clearcoatNormalMap =
                  this.clearcoatNormalMap.toJSON(_).uuid),
                (R.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
              void 0 !== this.iridescence && (R.iridescence = this.iridescence),
              void 0 !== this.iridescenceIOR &&
                (R.iridescenceIOR = this.iridescenceIOR),
              void 0 !== this.iridescenceThicknessRange &&
                (R.iridescenceThicknessRange = this.iridescenceThicknessRange),
              this.iridescenceMap &&
                this.iridescenceMap.isTexture &&
                (R.iridescenceMap = this.iridescenceMap.toJSON(_).uuid),
              this.iridescenceThicknessMap &&
                this.iridescenceThicknessMap.isTexture &&
                (R.iridescenceThicknessMap =
                  this.iridescenceThicknessMap.toJSON(_).uuid),
              this.map &&
                this.map.isTexture &&
                (R.map = this.map.toJSON(_).uuid),
              this.matcap &&
                this.matcap.isTexture &&
                (R.matcap = this.matcap.toJSON(_).uuid),
              this.alphaMap &&
                this.alphaMap.isTexture &&
                (R.alphaMap = this.alphaMap.toJSON(_).uuid),
              this.lightMap &&
                this.lightMap.isTexture &&
                ((R.lightMap = this.lightMap.toJSON(_).uuid),
                (R.lightMapIntensity = this.lightMapIntensity)),
              this.aoMap &&
                this.aoMap.isTexture &&
                ((R.aoMap = this.aoMap.toJSON(_).uuid),
                (R.aoMapIntensity = this.aoMapIntensity)),
              this.bumpMap &&
                this.bumpMap.isTexture &&
                ((R.bumpMap = this.bumpMap.toJSON(_).uuid),
                (R.bumpScale = this.bumpScale)),
              this.normalMap &&
                this.normalMap.isTexture &&
                ((R.normalMap = this.normalMap.toJSON(_).uuid),
                (R.normalMapType = this.normalMapType),
                (R.normalScale = this.normalScale.toArray())),
              this.displacementMap &&
                this.displacementMap.isTexture &&
                ((R.displacementMap = this.displacementMap.toJSON(_).uuid),
                (R.displacementScale = this.displacementScale),
                (R.displacementBias = this.displacementBias)),
              this.roughnessMap &&
                this.roughnessMap.isTexture &&
                (R.roughnessMap = this.roughnessMap.toJSON(_).uuid),
              this.metalnessMap &&
                this.metalnessMap.isTexture &&
                (R.metalnessMap = this.metalnessMap.toJSON(_).uuid),
              this.emissiveMap &&
                this.emissiveMap.isTexture &&
                (R.emissiveMap = this.emissiveMap.toJSON(_).uuid),
              this.specularMap &&
                this.specularMap.isTexture &&
                (R.specularMap = this.specularMap.toJSON(_).uuid),
              this.specularIntensityMap &&
                this.specularIntensityMap.isTexture &&
                (R.specularIntensityMap =
                  this.specularIntensityMap.toJSON(_).uuid),
              this.specularColorMap &&
                this.specularColorMap.isTexture &&
                (R.specularColorMap = this.specularColorMap.toJSON(_).uuid),
              this.envMap &&
                this.envMap.isTexture &&
                ((R.envMap = this.envMap.toJSON(_).uuid),
                void 0 !== this.combine && (R.combine = this.combine)),
              void 0 !== this.envMapIntensity &&
                (R.envMapIntensity = this.envMapIntensity),
              void 0 !== this.reflectivity &&
                (R.reflectivity = this.reflectivity),
              void 0 !== this.refractionRatio &&
                (R.refractionRatio = this.refractionRatio),
              this.gradientMap &&
                this.gradientMap.isTexture &&
                (R.gradientMap = this.gradientMap.toJSON(_).uuid),
              void 0 !== this.transmission &&
                (R.transmission = this.transmission),
              this.transmissionMap &&
                this.transmissionMap.isTexture &&
                (R.transmissionMap = this.transmissionMap.toJSON(_).uuid),
              void 0 !== this.thickness && (R.thickness = this.thickness),
              this.thicknessMap &&
                this.thicknessMap.isTexture &&
                (R.thicknessMap = this.thicknessMap.toJSON(_).uuid),
              void 0 !== this.attenuationDistance &&
                this.attenuationDistance !== 1 / 0 &&
                (R.attenuationDistance = this.attenuationDistance),
              void 0 !== this.attenuationColor &&
                (R.attenuationColor = this.attenuationColor.getHex()),
              void 0 !== this.size && (R.size = this.size),
              null !== this.shadowSide && (R.shadowSide = this.shadowSide),
              void 0 !== this.sizeAttenuation &&
                (R.sizeAttenuation = this.sizeAttenuation),
              1 !== this.blending && (R.blending = this.blending),
              0 !== this.side && (R.side = this.side),
              this.vertexColors && (R.vertexColors = !0),
              this.opacity < 1 && (R.opacity = this.opacity),
              !0 === this.transparent && (R.transparent = this.transparent),
              (R.depthFunc = this.depthFunc),
              (R.depthTest = this.depthTest),
              (R.depthWrite = this.depthWrite),
              (R.colorWrite = this.colorWrite),
              (R.stencilWrite = this.stencilWrite),
              (R.stencilWriteMask = this.stencilWriteMask),
              (R.stencilFunc = this.stencilFunc),
              (R.stencilRef = this.stencilRef),
              (R.stencilFuncMask = this.stencilFuncMask),
              (R.stencilFail = this.stencilFail),
              (R.stencilZFail = this.stencilZFail),
              (R.stencilZPass = this.stencilZPass),
              void 0 !== this.rotation &&
                0 !== this.rotation &&
                (R.rotation = this.rotation),
              !0 === this.polygonOffset && (R.polygonOffset = !0),
              0 !== this.polygonOffsetFactor &&
                (R.polygonOffsetFactor = this.polygonOffsetFactor),
              0 !== this.polygonOffsetUnits &&
                (R.polygonOffsetUnits = this.polygonOffsetUnits),
              void 0 !== this.linewidth &&
                1 !== this.linewidth &&
                (R.linewidth = this.linewidth),
              void 0 !== this.dashSize && (R.dashSize = this.dashSize),
              void 0 !== this.gapSize && (R.gapSize = this.gapSize),
              void 0 !== this.scale && (R.scale = this.scale),
              !0 === this.dithering && (R.dithering = !0),
              this.alphaTest > 0 && (R.alphaTest = this.alphaTest),
              !0 === this.alphaToCoverage &&
                (R.alphaToCoverage = this.alphaToCoverage),
              !0 === this.premultipliedAlpha &&
                (R.premultipliedAlpha = this.premultipliedAlpha),
              !0 === this.forceSinglePass &&
                (R.forceSinglePass = this.forceSinglePass),
              !0 === this.wireframe && (R.wireframe = this.wireframe),
              this.wireframeLinewidth > 1 &&
                (R.wireframeLinewidth = this.wireframeLinewidth),
              "round" !== this.wireframeLinecap &&
                (R.wireframeLinecap = this.wireframeLinecap),
              "round" !== this.wireframeLinejoin &&
                (R.wireframeLinejoin = this.wireframeLinejoin),
              !0 === this.flatShading && (R.flatShading = this.flatShading),
              !1 === this.visible && (R.visible = !1),
              !1 === this.toneMapped && (R.toneMapped = !1),
              !1 === this.fog && (R.fog = !1),
              Object.keys(this.userData).length > 0 &&
                (R.userData = this.userData),
              L)
            ) {
              let L = i(_.textures),
                N = i(_.images);
              L.length > 0 && (R.textures = L), N.length > 0 && (R.images = N);
            }
            return R;
          }
          clone() {
            return new this.constructor().copy(this);
          }
          copy(_) {
            (this.name = _.name),
              (this.blending = _.blending),
              (this.side = _.side),
              (this.vertexColors = _.vertexColors),
              (this.opacity = _.opacity),
              (this.transparent = _.transparent),
              (this.blendSrc = _.blendSrc),
              (this.blendDst = _.blendDst),
              (this.blendEquation = _.blendEquation),
              (this.blendSrcAlpha = _.blendSrcAlpha),
              (this.blendDstAlpha = _.blendDstAlpha),
              (this.blendEquationAlpha = _.blendEquationAlpha),
              (this.depthFunc = _.depthFunc),
              (this.depthTest = _.depthTest),
              (this.depthWrite = _.depthWrite),
              (this.stencilWriteMask = _.stencilWriteMask),
              (this.stencilFunc = _.stencilFunc),
              (this.stencilRef = _.stencilRef),
              (this.stencilFuncMask = _.stencilFuncMask),
              (this.stencilFail = _.stencilFail),
              (this.stencilZFail = _.stencilZFail),
              (this.stencilZPass = _.stencilZPass),
              (this.stencilWrite = _.stencilWrite);
            let L = _.clippingPlanes,
              R = null;
            if (null !== L) {
              let _ = L.length;
              R = Array(_);
              for (let N = 0; N !== _; ++N) R[N] = L[N].clone();
            }
            return (
              (this.clippingPlanes = R),
              (this.clipIntersection = _.clipIntersection),
              (this.clipShadows = _.clipShadows),
              (this.shadowSide = _.shadowSide),
              (this.colorWrite = _.colorWrite),
              (this.precision = _.precision),
              (this.polygonOffset = _.polygonOffset),
              (this.polygonOffsetFactor = _.polygonOffsetFactor),
              (this.polygonOffsetUnits = _.polygonOffsetUnits),
              (this.dithering = _.dithering),
              (this.alphaTest = _.alphaTest),
              (this.alphaToCoverage = _.alphaToCoverage),
              (this.premultipliedAlpha = _.premultipliedAlpha),
              (this.forceSinglePass = _.forceSinglePass),
              (this.visible = _.visible),
              (this.toneMapped = _.toneMapped),
              (this.userData = JSON.parse(JSON.stringify(_.userData))),
              this
            );
          }
          dispose() {
            this.dispatchEvent({ type: "dispose" });
          }
          set needsUpdate(_) {
            !0 === _ && this.version++;
          }
        },
        ss = class extends sr {
          constructor(_) {
            super(),
              (this.isMeshBasicMaterial = !0),
              (this.type = "MeshBasicMaterial"),
              (this.color = new iz(16777215)),
              (this.map = null),
              (this.lightMap = null),
              (this.lightMapIntensity = 1),
              (this.aoMap = null),
              (this.aoMapIntensity = 1),
              (this.specularMap = null),
              (this.alphaMap = null),
              (this.envMap = null),
              (this.combine = 0),
              (this.reflectivity = 1),
              (this.refractionRatio = 0.98),
              (this.wireframe = !1),
              (this.wireframeLinewidth = 1),
              (this.wireframeLinecap = "round"),
              (this.wireframeLinejoin = "round"),
              (this.fog = !0),
              this.setValues(_);
          }
          copy(_) {
            return (
              super.copy(_),
              this.color.copy(_.color),
              (this.map = _.map),
              (this.lightMap = _.lightMap),
              (this.lightMapIntensity = _.lightMapIntensity),
              (this.aoMap = _.aoMap),
              (this.aoMapIntensity = _.aoMapIntensity),
              (this.specularMap = _.specularMap),
              (this.alphaMap = _.alphaMap),
              (this.envMap = _.envMap),
              (this.combine = _.combine),
              (this.reflectivity = _.reflectivity),
              (this.refractionRatio = _.refractionRatio),
              (this.wireframe = _.wireframe),
              (this.wireframeLinewidth = _.wireframeLinewidth),
              (this.wireframeLinecap = _.wireframeLinecap),
              (this.wireframeLinejoin = _.wireframeLinejoin),
              (this.fog = _.fog),
              this
            );
          }
        },
        sa = new iq(),
        sl = new iT(),
        sh = class {
          constructor(_, L, R = !1) {
            if (Array.isArray(_))
              throw TypeError(
                "THREE.BufferAttribute: array should be a Typed Array.",
              );
            (this.isBufferAttribute = !0),
              (this.name = ""),
              (this.array = _),
              (this.itemSize = L),
              (this.count = void 0 !== _ ? _.length / L : 0),
              (this.normalized = R),
              (this.usage = 35044),
              (this.updateRange = { offset: 0, count: -1 }),
              (this.version = 0);
          }
          onUploadCallback() {}
          set needsUpdate(_) {
            !0 === _ && this.version++;
          }
          setUsage(_) {
            return (this.usage = _), this;
          }
          copy(_) {
            return (
              (this.name = _.name),
              (this.array = new _.array.constructor(_.array)),
              (this.itemSize = _.itemSize),
              (this.count = _.count),
              (this.normalized = _.normalized),
              (this.usage = _.usage),
              this
            );
          }
          copyAt(_, L, R) {
            (_ *= this.itemSize), (R *= L.itemSize);
            for (let N = 0, z = this.itemSize; N < z; N++)
              this.array[_ + N] = L.array[R + N];
            return this;
          }
          copyArray(_) {
            return this.array.set(_), this;
          }
          applyMatrix3(_) {
            if (2 === this.itemSize)
              for (let L = 0, R = this.count; L < R; L++)
                sl.fromBufferAttribute(this, L),
                  sl.applyMatrix3(_),
                  this.setXY(L, sl.x, sl.y);
            else if (3 === this.itemSize)
              for (let L = 0, R = this.count; L < R; L++)
                sa.fromBufferAttribute(this, L),
                  sa.applyMatrix3(_),
                  this.setXYZ(L, sa.x, sa.y, sa.z);
            return this;
          }
          applyMatrix4(_) {
            for (let L = 0, R = this.count; L < R; L++)
              sa.fromBufferAttribute(this, L),
                sa.applyMatrix4(_),
                this.setXYZ(L, sa.x, sa.y, sa.z);
            return this;
          }
          applyNormalMatrix(_) {
            for (let L = 0, R = this.count; L < R; L++)
              sa.fromBufferAttribute(this, L),
                sa.applyNormalMatrix(_),
                this.setXYZ(L, sa.x, sa.y, sa.z);
            return this;
          }
          transformDirection(_) {
            for (let L = 0, R = this.count; L < R; L++)
              sa.fromBufferAttribute(this, L),
                sa.transformDirection(_),
                this.setXYZ(L, sa.x, sa.y, sa.z);
            return this;
          }
          set(_, L = 0) {
            return this.array.set(_, L), this;
          }
          getX(_) {
            let L = this.array[_ * this.itemSize];
            return this.normalized && (L = zs(L, this.array)), L;
          }
          setX(_, L) {
            return (
              this.normalized && (L = Rt(L, this.array)),
              (this.array[_ * this.itemSize] = L),
              this
            );
          }
          getY(_) {
            let L = this.array[_ * this.itemSize + 1];
            return this.normalized && (L = zs(L, this.array)), L;
          }
          setY(_, L) {
            return (
              this.normalized && (L = Rt(L, this.array)),
              (this.array[_ * this.itemSize + 1] = L),
              this
            );
          }
          getZ(_) {
            let L = this.array[_ * this.itemSize + 2];
            return this.normalized && (L = zs(L, this.array)), L;
          }
          setZ(_, L) {
            return (
              this.normalized && (L = Rt(L, this.array)),
              (this.array[_ * this.itemSize + 2] = L),
              this
            );
          }
          getW(_) {
            let L = this.array[_ * this.itemSize + 3];
            return this.normalized && (L = zs(L, this.array)), L;
          }
          setW(_, L) {
            return (
              this.normalized && (L = Rt(L, this.array)),
              (this.array[_ * this.itemSize + 3] = L),
              this
            );
          }
          setXY(_, L, R) {
            return (
              (_ *= this.itemSize),
              this.normalized &&
                ((L = Rt(L, this.array)), (R = Rt(R, this.array))),
              (this.array[_ + 0] = L),
              (this.array[_ + 1] = R),
              this
            );
          }
          setXYZ(_, L, R, N) {
            return (
              (_ *= this.itemSize),
              this.normalized &&
                ((L = Rt(L, this.array)),
                (R = Rt(R, this.array)),
                (N = Rt(N, this.array))),
              (this.array[_ + 0] = L),
              (this.array[_ + 1] = R),
              (this.array[_ + 2] = N),
              this
            );
          }
          setXYZW(_, L, R, N, z) {
            return (
              (_ *= this.itemSize),
              this.normalized &&
                ((L = Rt(L, this.array)),
                (R = Rt(R, this.array)),
                (N = Rt(N, this.array)),
                (z = Rt(z, this.array))),
              (this.array[_ + 0] = L),
              (this.array[_ + 1] = R),
              (this.array[_ + 2] = N),
              (this.array[_ + 3] = z),
              this
            );
          }
          onUpload(_) {
            return (this.onUploadCallback = _), this;
          }
          clone() {
            return new this.constructor(this.array, this.itemSize).copy(this);
          }
          toJSON() {
            let _ = {
              itemSize: this.itemSize,
              type: this.array.constructor.name,
              array: Array.from(this.array),
              normalized: this.normalized,
            };
            return (
              "" !== this.name && (_.name = this.name),
              35044 !== this.usage && (_.usage = this.usage),
              (0 !== this.updateRange.offset ||
                -1 !== this.updateRange.count) &&
                (_.updateRange = this.updateRange),
              _
            );
          }
          copyColorsArray() {
            console.error(
              "THREE.BufferAttribute: copyColorsArray() was removed in r144.",
            );
          }
          copyVector2sArray() {
            console.error(
              "THREE.BufferAttribute: copyVector2sArray() was removed in r144.",
            );
          }
          copyVector3sArray() {
            console.error(
              "THREE.BufferAttribute: copyVector3sArray() was removed in r144.",
            );
          }
          copyVector4sArray() {
            console.error(
              "THREE.BufferAttribute: copyVector4sArray() was removed in r144.",
            );
          }
        },
        sd = class extends sh {
          constructor(_, L, R) {
            super(new Uint16Array(_), L, R);
          }
        },
        sp = class extends sh {
          constructor(_, L, R) {
            super(new Uint32Array(_), L, R);
          }
        },
        sf = class extends sh {
          constructor(_, L, R) {
            super(new Uint16Array(_), L, R),
              (this.isFloat16BufferAttribute = !0);
          }
        },
        sv = class extends sh {
          constructor(_, L, R) {
            super(new Float32Array(_), L, R);
          }
        },
        sy = 0,
        sx = new rw(),
        sb = new rK(),
        sw = new iq(),
        sM = new iK(),
        sE = new iK(),
        sC = new iq(),
        sP = class extends ig {
          constructor() {
            super(),
              (this.isBufferGeometry = !0),
              Object.defineProperty(this, "id", { value: sy++ }),
              (this.uuid = es()),
              (this.name = ""),
              (this.type = "BufferGeometry"),
              (this.index = null),
              (this.attributes = {}),
              (this.morphAttributes = {}),
              (this.morphTargetsRelative = !1),
              (this.groups = []),
              (this.boundingBox = null),
              (this.boundingSphere = null),
              (this.drawRange = { start: 0, count: 1 / 0 }),
              (this.userData = {});
          }
          getIndex() {
            return this.index;
          }
          setIndex(_) {
            return (
              Array.isArray(_)
                ? (this.index = new (N1(_) ? sp : sd)(_, 1))
                : (this.index = _),
              this
            );
          }
          getAttribute(_) {
            return this.attributes[_];
          }
          setAttribute(_, L) {
            return (this.attributes[_] = L), this;
          }
          deleteAttribute(_) {
            return delete this.attributes[_], this;
          }
          hasAttribute(_) {
            return void 0 !== this.attributes[_];
          }
          addGroup(_, L, R = 0) {
            this.groups.push({ start: _, count: L, materialIndex: R });
          }
          clearGroups() {
            this.groups = [];
          }
          setDrawRange(_, L) {
            (this.drawRange.start = _), (this.drawRange.count = L);
          }
          applyMatrix4(_) {
            let L = this.attributes.position;
            void 0 !== L && (L.applyMatrix4(_), (L.needsUpdate = !0));
            let R = this.attributes.normal;
            if (void 0 !== R) {
              let L = new iC().getNormalMatrix(_);
              R.applyNormalMatrix(L), (R.needsUpdate = !0);
            }
            let N = this.attributes.tangent;
            return (
              void 0 !== N && (N.transformDirection(_), (N.needsUpdate = !0)),
              null !== this.boundingBox && this.computeBoundingBox(),
              null !== this.boundingSphere && this.computeBoundingSphere(),
              this
            );
          }
          applyQuaternion(_) {
            return (
              sx.makeRotationFromQuaternion(_), this.applyMatrix4(sx), this
            );
          }
          rotateX(_) {
            return sx.makeRotationX(_), this.applyMatrix4(sx), this;
          }
          rotateY(_) {
            return sx.makeRotationY(_), this.applyMatrix4(sx), this;
          }
          rotateZ(_) {
            return sx.makeRotationZ(_), this.applyMatrix4(sx), this;
          }
          translate(_, L, R) {
            return sx.makeTranslation(_, L, R), this.applyMatrix4(sx), this;
          }
          scale(_, L, R) {
            return sx.makeScale(_, L, R), this.applyMatrix4(sx), this;
          }
          lookAt(_) {
            return (
              sb.lookAt(_),
              sb.updateMatrix(),
              this.applyMatrix4(sb.matrix),
              this
            );
          }
          center() {
            return (
              this.computeBoundingBox(),
              this.boundingBox.getCenter(sw).negate(),
              this.translate(sw.x, sw.y, sw.z),
              this
            );
          }
          setFromPoints(_) {
            let L = [];
            for (let R = 0, N = _.length; R < N; R++) {
              let N = _[R];
              L.push(N.x, N.y, N.z || 0);
            }
            return this.setAttribute("position", new sv(L, 3)), this;
          }
          computeBoundingBox() {
            null === this.boundingBox && (this.boundingBox = new iK());
            let _ = this.attributes.position,
              L = this.morphAttributes.position;
            if (_ && _.isGLBufferAttribute) {
              console.error(
                'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
                this,
              ),
                this.boundingBox.set(
                  new iq(-1 / 0, -1 / 0, -1 / 0),
                  new iq(1 / 0, 1 / 0, 1 / 0),
                );
              return;
            }
            if (void 0 !== _) {
              if ((this.boundingBox.setFromBufferAttribute(_), L))
                for (let _ = 0, R = L.length; _ < R; _++) {
                  let R = L[_];
                  sM.setFromBufferAttribute(R),
                    this.morphTargetsRelative
                      ? (sC.addVectors(this.boundingBox.min, sM.min),
                        this.boundingBox.expandByPoint(sC),
                        sC.addVectors(this.boundingBox.max, sM.max),
                        this.boundingBox.expandByPoint(sC))
                      : (this.boundingBox.expandByPoint(sM.min),
                        this.boundingBox.expandByPoint(sM.max));
                }
            } else this.boundingBox.makeEmpty();
            (isNaN(this.boundingBox.min.x) ||
              isNaN(this.boundingBox.min.y) ||
              isNaN(this.boundingBox.min.z)) &&
              console.error(
                'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
                this,
              );
          }
          computeBoundingSphere() {
            null === this.boundingSphere && (this.boundingSphere = new ro());
            let _ = this.attributes.position,
              L = this.morphAttributes.position;
            if (_ && _.isGLBufferAttribute) {
              console.error(
                'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
                this,
              ),
                this.boundingSphere.set(new iq(), 1 / 0);
              return;
            }
            if (_) {
              let R = this.boundingSphere.center;
              if ((sM.setFromBufferAttribute(_), L))
                for (let _ = 0, R = L.length; _ < R; _++) {
                  let R = L[_];
                  sE.setFromBufferAttribute(R),
                    this.morphTargetsRelative
                      ? (sC.addVectors(sM.min, sE.min),
                        sM.expandByPoint(sC),
                        sC.addVectors(sM.max, sE.max),
                        sM.expandByPoint(sC))
                      : (sM.expandByPoint(sE.min), sM.expandByPoint(sE.max));
                }
              sM.getCenter(R);
              let N = 0;
              for (let L = 0, z = _.count; L < z; L++)
                sC.fromBufferAttribute(_, L),
                  (N = Math.max(N, R.distanceToSquared(sC)));
              if (L)
                for (let z = 0, F = L.length; z < F; z++) {
                  let F = L[z],
                    U = this.morphTargetsRelative;
                  for (let L = 0, z = F.count; L < z; L++)
                    sC.fromBufferAttribute(F, L),
                      U && (sw.fromBufferAttribute(_, L), sC.add(sw)),
                      (N = Math.max(N, R.distanceToSquared(sC)));
                }
              (this.boundingSphere.radius = Math.sqrt(N)),
                isNaN(this.boundingSphere.radius) &&
                  console.error(
                    'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
                    this,
                  );
            }
          }
          computeTangents() {
            let _ = this.index,
              L = this.attributes;
            if (
              null === _ ||
              void 0 === L.position ||
              void 0 === L.normal ||
              void 0 === L.uv
            ) {
              console.error(
                "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)",
              );
              return;
            }
            let R = _.array,
              N = L.position.array,
              z = L.normal.array,
              F = L.uv.array,
              U = N.length / 3;
            !1 === this.hasAttribute("tangent") &&
              this.setAttribute("tangent", new sh(new Float32Array(4 * U), 4));
            let k = this.getAttribute("tangent").array,
              Y = [],
              X = [];
            for (let _ = 0; _ < U; _++) (Y[_] = new iq()), (X[_] = new iq());
            let Q = new iq(),
              K = new iq(),
              J = new iq(),
              $ = new iT(),
              ee = new iT(),
              er = new iT(),
              en = new iq(),
              ea = new iq(),
              eo = this.groups;
            0 === eo.length && (eo = [{ start: 0, count: R.length }]);
            for (let _ = 0, L = eo.length; _ < L; ++_) {
              let L = eo[_],
                z = L.start,
                U = L.count;
              for (let _ = z, L = z + U; _ < L; _ += 3)
                !(function (_, L, R) {
                  Q.fromArray(N, 3 * _),
                    K.fromArray(N, 3 * L),
                    J.fromArray(N, 3 * R),
                    $.fromArray(F, 2 * _),
                    ee.fromArray(F, 2 * L),
                    er.fromArray(F, 2 * R),
                    K.sub(Q),
                    J.sub(Q),
                    ee.sub($),
                    er.sub($);
                  let z = 1 / (ee.x * er.y - er.x * ee.y);
                  isFinite(z) &&
                    (en
                      .copy(K)
                      .multiplyScalar(er.y)
                      .addScaledVector(J, -ee.y)
                      .multiplyScalar(z),
                    ea
                      .copy(J)
                      .multiplyScalar(ee.x)
                      .addScaledVector(K, -er.x)
                      .multiplyScalar(z),
                    Y[_].add(en),
                    Y[L].add(en),
                    Y[R].add(en),
                    X[_].add(ea),
                    X[L].add(ea),
                    X[R].add(ea));
                })(R[_ + 0], R[_ + 1], R[_ + 2]);
            }
            let el = new iq(),
              ec = new iq(),
              ed = new iq(),
              eu = new iq();
            function E(_) {
              ed.fromArray(z, 3 * _), eu.copy(ed);
              let L = Y[_];
              el.copy(L),
                el.sub(ed.multiplyScalar(ed.dot(L))).normalize(),
                ec.crossVectors(eu, L);
              let R = 0 > ec.dot(X[_]) ? -1 : 1;
              (k[4 * _] = el.x),
                (k[4 * _ + 1] = el.y),
                (k[4 * _ + 2] = el.z),
                (k[4 * _ + 3] = R);
            }
            for (let _ = 0, L = eo.length; _ < L; ++_) {
              let L = eo[_],
                N = L.start,
                z = L.count;
              for (let _ = N, L = N + z; _ < L; _ += 3)
                E(R[_ + 0]), E(R[_ + 1]), E(R[_ + 2]);
            }
          }
          computeVertexNormals() {
            let _ = this.index,
              L = this.getAttribute("position");
            if (void 0 !== L) {
              let R = this.getAttribute("normal");
              if (void 0 === R)
                (R = new sh(new Float32Array(3 * L.count), 3)),
                  this.setAttribute("normal", R);
              else
                for (let _ = 0, L = R.count; _ < L; _++) R.setXYZ(_, 0, 0, 0);
              let N = new iq(),
                z = new iq(),
                F = new iq(),
                U = new iq(),
                k = new iq(),
                Y = new iq(),
                X = new iq(),
                Q = new iq();
              if (_)
                for (let K = 0, J = _.count; K < J; K += 3) {
                  let J = _.getX(K + 0),
                    $ = _.getX(K + 1),
                    ee = _.getX(K + 2);
                  N.fromBufferAttribute(L, J),
                    z.fromBufferAttribute(L, $),
                    F.fromBufferAttribute(L, ee),
                    X.subVectors(F, z),
                    Q.subVectors(N, z),
                    X.cross(Q),
                    U.fromBufferAttribute(R, J),
                    k.fromBufferAttribute(R, $),
                    Y.fromBufferAttribute(R, ee),
                    U.add(X),
                    k.add(X),
                    Y.add(X),
                    R.setXYZ(J, U.x, U.y, U.z),
                    R.setXYZ($, k.x, k.y, k.z),
                    R.setXYZ(ee, Y.x, Y.y, Y.z);
                }
              else
                for (let _ = 0, U = L.count; _ < U; _ += 3)
                  N.fromBufferAttribute(L, _ + 0),
                    z.fromBufferAttribute(L, _ + 1),
                    F.fromBufferAttribute(L, _ + 2),
                    X.subVectors(F, z),
                    Q.subVectors(N, z),
                    X.cross(Q),
                    R.setXYZ(_ + 0, X.x, X.y, X.z),
                    R.setXYZ(_ + 1, X.x, X.y, X.z),
                    R.setXYZ(_ + 2, X.x, X.y, X.z);
              this.normalizeNormals(), (R.needsUpdate = !0);
            }
          }
          merge() {
            return (
              console.error(
                "THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeBufferGeometries() instead.",
              ),
              this
            );
          }
          normalizeNormals() {
            let _ = this.attributes.normal;
            for (let L = 0, R = _.count; L < R; L++)
              sC.fromBufferAttribute(_, L),
                sC.normalize(),
                _.setXYZ(L, sC.x, sC.y, sC.z);
          }
          toNonIndexed() {
            function t(_, L) {
              let R = _.array,
                N = _.itemSize,
                z = _.normalized,
                F = new R.constructor(L.length * N),
                U = 0,
                k = 0;
              for (let z = 0, Y = L.length; z < Y; z++) {
                U = _.isInterleavedBufferAttribute
                  ? L[z] * _.data.stride + _.offset
                  : L[z] * N;
                for (let _ = 0; _ < N; _++) F[k++] = R[U++];
              }
              return new sh(F, N, z);
            }
            if (null === this.index)
              return (
                console.warn(
                  "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.",
                ),
                this
              );
            let _ = new sP(),
              L = this.index.array,
              R = this.attributes;
            for (let N in R) {
              let z = t(R[N], L);
              _.setAttribute(N, z);
            }
            let N = this.morphAttributes;
            for (let R in N) {
              let z = [],
                F = N[R];
              for (let _ = 0, R = F.length; _ < R; _++) {
                let R = t(F[_], L);
                z.push(R);
              }
              _.morphAttributes[R] = z;
            }
            _.morphTargetsRelative = this.morphTargetsRelative;
            let z = this.groups;
            for (let L = 0, R = z.length; L < R; L++) {
              let R = z[L];
              _.addGroup(R.start, R.count, R.materialIndex);
            }
            return _;
          }
          toJSON() {
            let _ = {
              metadata: {
                version: 4.5,
                type: "BufferGeometry",
                generator: "BufferGeometry.toJSON",
              },
            };
            if (
              ((_.uuid = this.uuid),
              (_.type = this.type),
              "" !== this.name && (_.name = this.name),
              Object.keys(this.userData).length > 0 &&
                (_.userData = this.userData),
              void 0 !== this.parameters)
            ) {
              let L = this.parameters;
              for (let R in L) void 0 !== L[R] && (_[R] = L[R]);
              return _;
            }
            _.data = { attributes: {} };
            let L = this.index;
            null !== L &&
              (_.data.index = {
                type: L.array.constructor.name,
                array: Array.prototype.slice.call(L.array),
              });
            let R = this.attributes;
            for (let L in R) {
              let N = R[L];
              _.data.attributes[L] = N.toJSON(_.data);
            }
            let N = {},
              z = !1;
            for (let L in this.morphAttributes) {
              let R = this.morphAttributes[L],
                F = [];
              for (let L = 0, N = R.length; L < N; L++) {
                let N = R[L];
                F.push(N.toJSON(_.data));
              }
              F.length > 0 && ((N[L] = F), (z = !0));
            }
            z &&
              ((_.data.morphAttributes = N),
              (_.data.morphTargetsRelative = this.morphTargetsRelative));
            let F = this.groups;
            F.length > 0 && (_.data.groups = JSON.parse(JSON.stringify(F)));
            let U = this.boundingSphere;
            return (
              null !== U &&
                (_.data.boundingSphere = {
                  center: U.center.toArray(),
                  radius: U.radius,
                }),
              _
            );
          }
          clone() {
            return new this.constructor().copy(this);
          }
          copy(_) {
            (this.index = null),
              (this.attributes = {}),
              (this.morphAttributes = {}),
              (this.groups = []),
              (this.boundingBox = null),
              (this.boundingSphere = null);
            let L = {};
            this.name = _.name;
            let R = _.index;
            null !== R && this.setIndex(R.clone(L));
            let N = _.attributes;
            for (let _ in N) {
              let R = N[_];
              this.setAttribute(_, R.clone(L));
            }
            let z = _.morphAttributes;
            for (let _ in z) {
              let R = [],
                N = z[_];
              for (let _ = 0, z = N.length; _ < z; _++) R.push(N[_].clone(L));
              this.morphAttributes[_] = R;
            }
            this.morphTargetsRelative = _.morphTargetsRelative;
            let F = _.groups;
            for (let _ = 0, L = F.length; _ < L; _++) {
              let L = F[_];
              this.addGroup(L.start, L.count, L.materialIndex);
            }
            let U = _.boundingBox;
            null !== U && (this.boundingBox = U.clone());
            let k = _.boundingSphere;
            return (
              null !== k && (this.boundingSphere = k.clone()),
              (this.drawRange.start = _.drawRange.start),
              (this.drawRange.count = _.drawRange.count),
              (this.userData = _.userData),
              void 0 !== _.parameters &&
                (this.parameters = Object.assign({}, _.parameters)),
              this
            );
          }
          dispose() {
            this.dispatchEvent({ type: "dispose" });
          }
        },
        sD = new rw(),
        sO = new rx(),
        sL = new ro(),
        sR = new iq(),
        sI = new iq(),
        sB = new iq(),
        sz = new iq(),
        sF = new iq(),
        sU = new iT(),
        sk = new iT(),
        sj = new iT(),
        sG = new iq(),
        sV = new iq(),
        sH = class extends rK {
          constructor(_ = new sP(), L = new ss()) {
            super(),
              (this.isMesh = !0),
              (this.type = "Mesh"),
              (this.geometry = _),
              (this.material = L),
              this.updateMorphTargets();
          }
          copy(_, L) {
            return (
              super.copy(_, L),
              void 0 !== _.morphTargetInfluences &&
                (this.morphTargetInfluences = _.morphTargetInfluences.slice()),
              void 0 !== _.morphTargetDictionary &&
                (this.morphTargetDictionary = Object.assign(
                  {},
                  _.morphTargetDictionary,
                )),
              (this.material = _.material),
              (this.geometry = _.geometry),
              this
            );
          }
          updateMorphTargets() {
            let _ = this.geometry.morphAttributes,
              L = Object.keys(_);
            if (L.length > 0) {
              let R = _[L[0]];
              if (void 0 !== R) {
                (this.morphTargetInfluences = []),
                  (this.morphTargetDictionary = {});
                for (let _ = 0, L = R.length; _ < L; _++) {
                  let L = R[_].name || String(_);
                  this.morphTargetInfluences.push(0),
                    (this.morphTargetDictionary[L] = _);
                }
              }
            }
          }
          getVertexPosition(_, L) {
            let R = this.geometry,
              N = R.attributes.position,
              z = R.morphAttributes.position,
              F = R.morphTargetsRelative;
            L.fromBufferAttribute(N, _);
            let U = this.morphTargetInfluences;
            if (z && U) {
              sF.set(0, 0, 0);
              for (let R = 0, N = z.length; R < N; R++) {
                let N = U[R],
                  k = z[R];
                0 !== N &&
                  (sz.fromBufferAttribute(k, _),
                  F
                    ? sF.addScaledVector(sz, N)
                    : sF.addScaledVector(sz.sub(L), N));
              }
              L.add(sF);
            }
            return this.isSkinnedMesh && this.boneTransform(_, L), L;
          }
          raycast(_, L) {
            let R = this.geometry,
              N = this.material,
              z = this.matrixWorld;
            if (
              void 0 === N ||
              (null === R.boundingSphere && R.computeBoundingSphere(),
              sL.copy(R.boundingSphere),
              sL.applyMatrix4(z),
              !1 === _.ray.intersectsSphere(sL)) ||
              (sD.copy(z).invert(),
              sO.copy(_.ray).applyMatrix4(sD),
              null !== R.boundingBox && !1 === sO.intersectsBox(R.boundingBox))
            )
              return;
            let F,
              U = R.index,
              k = R.attributes.position,
              Y = R.attributes.uv,
              X = R.attributes.uv2,
              Q = R.groups,
              K = R.drawRange;
            if (null !== U) {
              if (Array.isArray(N))
                for (let R = 0, z = Q.length; R < z; R++) {
                  let z = Q[R],
                    k = N[z.materialIndex],
                    J = Math.max(z.start, K.start),
                    $ = Math.min(
                      U.count,
                      Math.min(z.start + z.count, K.start + K.count),
                    );
                  for (let R = J; R < $; R += 3)
                    (F = jf(
                      this,
                      k,
                      _,
                      sO,
                      Y,
                      X,
                      U.getX(R),
                      U.getX(R + 1),
                      U.getX(R + 2),
                    )) &&
                      ((F.faceIndex = Math.floor(R / 3)),
                      (F.face.materialIndex = z.materialIndex),
                      L.push(F));
                }
              else {
                let R = Math.max(0, K.start),
                  z = Math.min(U.count, K.start + K.count);
                for (let k = R; k < z; k += 3)
                  (F = jf(
                    this,
                    N,
                    _,
                    sO,
                    Y,
                    X,
                    U.getX(k),
                    U.getX(k + 1),
                    U.getX(k + 2),
                  )) && ((F.faceIndex = Math.floor(k / 3)), L.push(F));
              }
            } else if (void 0 !== k) {
              if (Array.isArray(N))
                for (let R = 0, z = Q.length; R < z; R++) {
                  let z = Q[R],
                    U = N[z.materialIndex],
                    J = Math.max(z.start, K.start),
                    $ = Math.min(
                      k.count,
                      Math.min(z.start + z.count, K.start + K.count),
                    );
                  for (let R = J; R < $; R += 3)
                    (F = jf(this, U, _, sO, Y, X, R, R + 1, R + 2)) &&
                      ((F.faceIndex = Math.floor(R / 3)),
                      (F.face.materialIndex = z.materialIndex),
                      L.push(F));
                }
              else {
                let R = Math.max(0, K.start),
                  z = Math.min(k.count, K.start + K.count);
                for (let U = R; U < z; U += 3)
                  (F = jf(this, N, _, sO, Y, X, U, U + 1, U + 2)) &&
                    ((F.faceIndex = Math.floor(U / 3)), L.push(F));
              }
            }
          }
        };
      function jf(_, L, R, N, z, F, U, k, Y) {
        _.getVertexPosition(U, sR),
          _.getVertexPosition(k, sI),
          _.getVertexPosition(Y, sB);
        let X = (function (_, L, R, N, z, F, U, k) {
          if (
            null ===
            (1 === L.side
              ? N.intersectTriangle(U, F, z, !0, k)
              : N.intersectTriangle(z, F, U, 0 === L.side, k))
          )
            return null;
          sV.copy(k), sV.applyMatrix4(_.matrixWorld);
          let Y = R.ray.origin.distanceTo(sV);
          return Y < R.near || Y > R.far
            ? null
            : { distance: Y, point: sV.clone(), object: _ };
        })(_, L, R, N, sR, sI, sB, sG);
        if (X) {
          z &&
            (sU.fromBufferAttribute(z, U),
            sk.fromBufferAttribute(z, k),
            sj.fromBufferAttribute(z, Y),
            (X.uv = se.getUV(sG, sR, sI, sB, sU, sk, sj, new iT()))),
            F &&
              (sU.fromBufferAttribute(F, U),
              sk.fromBufferAttribute(F, k),
              sj.fromBufferAttribute(F, Y),
              (X.uv2 = se.getUV(sG, sR, sI, sB, sU, sk, sj, new iT())));
          let _ = { a: U, b: k, c: Y, normal: new iq(), materialIndex: 0 };
          se.getNormal(sR, sI, sB, _.normal), (X.face = _);
        }
        return X;
      }
      var sW = class extends sP {
        constructor(_ = 1, L = 1, R = 1, N = 1, z = 1, F = 1) {
          super(),
            (this.type = "BoxGeometry"),
            (this.parameters = {
              width: _,
              height: L,
              depth: R,
              widthSegments: N,
              heightSegments: z,
              depthSegments: F,
            });
          let U = this;
          (N = Math.floor(N)), (z = Math.floor(z));
          let k = [],
            Y = [],
            X = [],
            Q = [],
            K = 0,
            J = 0;
          function g(_, L, R, N, z, F, $, ee, er, en, ea) {
            let eo = F / er,
              el = $ / en,
              ec = F / 2,
              ed = $ / 2,
              eu = ee / 2,
              ep = er + 1,
              ef = en + 1,
              ev = 0,
              ex = 0,
              eb = new iq();
            for (let F = 0; F < ef; F++) {
              let U = F * el - ed;
              for (let k = 0; k < ep; k++) {
                let K = k * eo - ec;
                (eb[_] = K * N),
                  (eb[L] = U * z),
                  (eb[R] = eu),
                  Y.push(eb.x, eb.y, eb.z),
                  (eb[_] = 0),
                  (eb[L] = 0),
                  (eb[R] = ee > 0 ? 1 : -1),
                  X.push(eb.x, eb.y, eb.z),
                  Q.push(k / er),
                  Q.push(1 - F / en),
                  (ev += 1);
              }
            }
            for (let _ = 0; _ < en; _++)
              for (let L = 0; L < er; L++) {
                let R = K + L + ep * _,
                  N = K + L + ep * (_ + 1),
                  z = K + (L + 1) + ep * (_ + 1),
                  F = K + (L + 1) + ep * _;
                k.push(R, N, F), k.push(N, z, F), (ex += 6);
              }
            U.addGroup(J, ex, ea), (J += ex), (K += ev);
          }
          g("z", "y", "x", -1, -1, R, L, _, (F = Math.floor(F)), z, 0),
            g("z", "y", "x", 1, -1, R, L, -_, F, z, 1),
            g("x", "z", "y", 1, 1, _, R, L, N, F, 2),
            g("x", "z", "y", 1, -1, _, R, -L, N, F, 3),
            g("x", "y", "z", 1, -1, _, L, R, N, z, 4),
            g("x", "y", "z", -1, -1, _, L, -R, N, z, 5),
            this.setIndex(k),
            this.setAttribute("position", new sv(Y, 3)),
            this.setAttribute("normal", new sv(X, 3)),
            this.setAttribute("uv", new sv(Q, 2));
        }
        static fromJSON(_) {
          return new sW(
            _.width,
            _.height,
            _.depth,
            _.widthSegments,
            _.heightSegments,
            _.depthSegments,
          );
        }
      };
      function Ul(_) {
        let L = {};
        for (let R in _)
          for (let N in ((L[R] = {}), _[R])) {
            let z = _[R][N];
            z &&
            (z.isColor ||
              z.isMatrix3 ||
              z.isMatrix4 ||
              z.isVector2 ||
              z.isVector3 ||
              z.isVector4 ||
              z.isTexture ||
              z.isQuaternion)
              ? (L[R][N] = z.clone())
              : Array.isArray(z)
                ? (L[R][N] = z.slice())
                : (L[R][N] = z);
          }
        return L;
      }
      function dr(_) {
        let L = {};
        for (let R = 0; R < _.length; R++) {
          let N = Ul(_[R]);
          for (let _ in N) L[_] = N[_];
        }
        return L;
      }
      function F1(_) {
        return null === _.getRenderTarget() && 3001 === _.outputEncoding
          ? id
          : iu;
      }
      var sY = { clone: Ul, merge: dr },
        sX = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
        sq = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`,
        sQ = class extends sr {
          constructor(_) {
            super(),
              (this.isShaderMaterial = !0),
              (this.type = "ShaderMaterial"),
              (this.defines = {}),
              (this.uniforms = {}),
              (this.uniformsGroups = []),
              (this.vertexShader = sX),
              (this.fragmentShader = sq),
              (this.linewidth = 1),
              (this.wireframe = !1),
              (this.wireframeLinewidth = 1),
              (this.fog = !1),
              (this.lights = !1),
              (this.clipping = !1),
              (this.extensions = {
                derivatives: !1,
                fragDepth: !1,
                drawBuffers: !1,
                shaderTextureLOD: !1,
              }),
              (this.defaultAttributeValues = {
                color: [1, 1, 1],
                uv: [0, 0],
                uv2: [0, 0],
              }),
              (this.index0AttributeName = void 0),
              (this.uniformsNeedUpdate = !1),
              (this.glslVersion = null),
              void 0 !== _ && this.setValues(_);
          }
          copy(_) {
            return (
              super.copy(_),
              (this.fragmentShader = _.fragmentShader),
              (this.vertexShader = _.vertexShader),
              (this.uniforms = Ul(_.uniforms)),
              (this.uniformsGroups = (function (_) {
                let L = [];
                for (let R = 0; R < _.length; R++) L.push(_[R].clone());
                return L;
              })(_.uniformsGroups)),
              (this.defines = Object.assign({}, _.defines)),
              (this.wireframe = _.wireframe),
              (this.wireframeLinewidth = _.wireframeLinewidth),
              (this.fog = _.fog),
              (this.lights = _.lights),
              (this.clipping = _.clipping),
              (this.extensions = Object.assign({}, _.extensions)),
              (this.glslVersion = _.glslVersion),
              this
            );
          }
          toJSON(_) {
            let L = super.toJSON(_);
            for (let R in ((L.glslVersion = this.glslVersion),
            (L.uniforms = {}),
            this.uniforms)) {
              let N = this.uniforms[R].value;
              N && N.isTexture
                ? (L.uniforms[R] = { type: "t", value: N.toJSON(_).uuid })
                : N && N.isColor
                  ? (L.uniforms[R] = { type: "c", value: N.getHex() })
                  : N && N.isVector2
                    ? (L.uniforms[R] = { type: "v2", value: N.toArray() })
                    : N && N.isVector3
                      ? (L.uniforms[R] = { type: "v3", value: N.toArray() })
                      : N && N.isVector4
                        ? (L.uniforms[R] = { type: "v4", value: N.toArray() })
                        : N && N.isMatrix3
                          ? (L.uniforms[R] = { type: "m3", value: N.toArray() })
                          : N && N.isMatrix4
                            ? (L.uniforms[R] = {
                                type: "m4",
                                value: N.toArray(),
                              })
                            : (L.uniforms[R] = { value: N });
            }
            Object.keys(this.defines).length > 0 && (L.defines = this.defines),
              (L.vertexShader = this.vertexShader),
              (L.fragmentShader = this.fragmentShader);
            let R = {};
            for (let _ in this.extensions)
              !0 === this.extensions[_] && (R[_] = !0);
            return Object.keys(R).length > 0 && (L.extensions = R), L;
          }
        },
        sZ = class extends rK {
          constructor() {
            super(),
              (this.isCamera = !0),
              (this.type = "Camera"),
              (this.matrixWorldInverse = new rw()),
              (this.projectionMatrix = new rw()),
              (this.projectionMatrixInverse = new rw());
          }
          copy(_, L) {
            return (
              super.copy(_, L),
              this.matrixWorldInverse.copy(_.matrixWorldInverse),
              this.projectionMatrix.copy(_.projectionMatrix),
              this.projectionMatrixInverse.copy(_.projectionMatrixInverse),
              this
            );
          }
          getWorldDirection(_) {
            this.updateWorldMatrix(!0, !1);
            let L = this.matrixWorld.elements;
            return _.set(-L[8], -L[9], -L[10]).normalize();
          }
          updateMatrixWorld(_) {
            super.updateMatrixWorld(_),
              this.matrixWorldInverse.copy(this.matrixWorld).invert();
          }
          updateWorldMatrix(_, L) {
            super.updateWorldMatrix(_, L),
              this.matrixWorldInverse.copy(this.matrixWorld).invert();
          }
          clone() {
            return new this.constructor().copy(this);
          }
        },
        sK = class extends sZ {
          constructor(_ = 50, L = 1, R = 0.1, N = 2e3) {
            super(),
              (this.isPerspectiveCamera = !0),
              (this.type = "PerspectiveCamera"),
              (this.fov = _),
              (this.zoom = 1),
              (this.near = R),
              (this.far = N),
              (this.focus = 10),
              (this.aspect = L),
              (this.view = null),
              (this.filmGauge = 35),
              (this.filmOffset = 0),
              this.updateProjectionMatrix();
          }
          copy(_, L) {
            return (
              super.copy(_, L),
              (this.fov = _.fov),
              (this.zoom = _.zoom),
              (this.near = _.near),
              (this.far = _.far),
              (this.focus = _.focus),
              (this.aspect = _.aspect),
              (this.view = null === _.view ? null : Object.assign({}, _.view)),
              (this.filmGauge = _.filmGauge),
              (this.filmOffset = _.filmOffset),
              this
            );
          }
          setFocalLength(_) {
            let L = (0.5 * this.getFilmHeight()) / _;
            (this.fov = 2 * i_ * Math.atan(L)), this.updateProjectionMatrix();
          }
          getFocalLength() {
            let _ = Math.tan(0.5 * iw * this.fov);
            return (0.5 * this.getFilmHeight()) / _;
          }
          getEffectiveFOV() {
            return (
              2 * i_ * Math.atan(Math.tan(0.5 * iw * this.fov) / this.zoom)
            );
          }
          getFilmWidth() {
            return this.filmGauge * Math.min(this.aspect, 1);
          }
          getFilmHeight() {
            return this.filmGauge / Math.max(this.aspect, 1);
          }
          setViewOffset(_, L, R, N, z, F) {
            (this.aspect = _ / L),
              null === this.view &&
                (this.view = {
                  enabled: !0,
                  fullWidth: 1,
                  fullHeight: 1,
                  offsetX: 0,
                  offsetY: 0,
                  width: 1,
                  height: 1,
                }),
              (this.view.enabled = !0),
              (this.view.fullWidth = _),
              (this.view.fullHeight = L),
              (this.view.offsetX = R),
              (this.view.offsetY = N),
              (this.view.width = z),
              (this.view.height = F),
              this.updateProjectionMatrix();
          }
          clearViewOffset() {
            null !== this.view && (this.view.enabled = !1),
              this.updateProjectionMatrix();
          }
          updateProjectionMatrix() {
            let _ = this.near,
              L = (_ * Math.tan(0.5 * iw * this.fov)) / this.zoom,
              R = 2 * L,
              N = this.aspect * R,
              z = -0.5 * N,
              F = this.view;
            if (null !== this.view && this.view.enabled) {
              let _ = F.fullWidth,
                U = F.fullHeight;
              (z += (F.offsetX * N) / _),
                (L -= (F.offsetY * R) / U),
                (N *= F.width / _),
                (R *= F.height / U);
            }
            let U = this.filmOffset;
            0 !== U && (z += (_ * U) / this.getFilmWidth()),
              this.projectionMatrix.makePerspective(
                z,
                z + N,
                L,
                L - R,
                _,
                this.far,
              ),
              this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
          }
          toJSON(_) {
            let L = super.toJSON(_);
            return (
              (L.object.fov = this.fov),
              (L.object.zoom = this.zoom),
              (L.object.near = this.near),
              (L.object.far = this.far),
              (L.object.focus = this.focus),
              (L.object.aspect = this.aspect),
              null !== this.view &&
                (L.object.view = Object.assign({}, this.view)),
              (L.object.filmGauge = this.filmGauge),
              (L.object.filmOffset = this.filmOffset),
              L
            );
          }
        },
        sJ = class extends rK {
          constructor(_, L, R) {
            super(), (this.type = "CubeCamera"), (this.renderTarget = R);
            let N = new sK(-90, 1, _, L);
            (N.layers = this.layers),
              N.up.set(0, 1, 0),
              N.lookAt(1, 0, 0),
              this.add(N);
            let z = new sK(-90, 1, _, L);
            (z.layers = this.layers),
              z.up.set(0, 1, 0),
              z.lookAt(-1, 0, 0),
              this.add(z);
            let F = new sK(-90, 1, _, L);
            (F.layers = this.layers),
              F.up.set(0, 0, -1),
              F.lookAt(0, 1, 0),
              this.add(F);
            let U = new sK(-90, 1, _, L);
            (U.layers = this.layers),
              U.up.set(0, 0, 1),
              U.lookAt(0, -1, 0),
              this.add(U);
            let k = new sK(-90, 1, _, L);
            (k.layers = this.layers),
              k.up.set(0, 1, 0),
              k.lookAt(0, 0, 1),
              this.add(k);
            let Y = new sK(-90, 1, _, L);
            (Y.layers = this.layers),
              Y.up.set(0, 1, 0),
              Y.lookAt(0, 0, -1),
              this.add(Y);
          }
          update(_, L) {
            null === this.parent && this.updateMatrixWorld();
            let R = this.renderTarget,
              [N, z, F, U, k, Y] = this.children,
              X = _.getRenderTarget(),
              Q = _.toneMapping,
              K = _.xr.enabled;
            (_.toneMapping = 0), (_.xr.enabled = !1);
            let J = R.texture.generateMipmaps;
            (R.texture.generateMipmaps = !1),
              _.setRenderTarget(R, 0),
              _.render(L, N),
              _.setRenderTarget(R, 1),
              _.render(L, z),
              _.setRenderTarget(R, 2),
              _.render(L, F),
              _.setRenderTarget(R, 3),
              _.render(L, U),
              _.setRenderTarget(R, 4),
              _.render(L, k),
              (R.texture.generateMipmaps = J),
              _.setRenderTarget(R, 5),
              _.render(L, Y),
              _.setRenderTarget(X),
              (_.toneMapping = Q),
              (_.xr.enabled = K),
              (R.texture.needsPMREMUpdate = !0);
          }
        },
        s$ = class extends iG {
          constructor(_, L, R, N, z, F, U, k, Y, X) {
            super(
              (_ = void 0 !== _ ? _ : []),
              (L = void 0 !== L ? L : 301),
              R,
              N,
              z,
              F,
              U,
              k,
              Y,
              X,
            ),
              (this.isCubeTexture = !0),
              (this.flipY = !1);
          }
          get images() {
            return this.image;
          }
          set images(_) {
            this.image = _;
          }
        },
        s0 = class extends iH {
          constructor(_ = 1, L = {}) {
            super(_, _, L), (this.isWebGLCubeRenderTarget = !0);
            let R = { width: _, height: _, depth: 1 },
              N = [R, R, R, R, R, R];
            (this.texture = new s$(
              N,
              L.mapping,
              L.wrapS,
              L.wrapT,
              L.magFilter,
              L.minFilter,
              L.format,
              L.type,
              L.anisotropy,
              L.encoding,
            )),
              (this.texture.isRenderTargetTexture = !0),
              (this.texture.generateMipmaps =
                void 0 !== L.generateMipmaps && L.generateMipmaps),
              (this.texture.minFilter =
                void 0 !== L.minFilter ? L.minFilter : 1006);
          }
          fromEquirectangularTexture(_, L) {
            (this.texture.type = L.type),
              (this.texture.encoding = L.encoding),
              (this.texture.generateMipmaps = L.generateMipmaps),
              (this.texture.minFilter = L.minFilter),
              (this.texture.magFilter = L.magFilter);
            let R = {
                uniforms: { tEquirect: { value: null } },
                vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
                fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`,
              },
              N = new sW(5, 5, 5),
              z = new sQ({
                name: "CubemapFromEquirect",
                uniforms: Ul(R.uniforms),
                vertexShader: R.vertexShader,
                fragmentShader: R.fragmentShader,
                side: 1,
                blending: 0,
              });
            z.uniforms.tEquirect.value = L;
            let F = new sH(N, z),
              U = L.minFilter;
            return (
              1008 === L.minFilter && (L.minFilter = 1006),
              new sJ(1, 10, this).update(_, F),
              (L.minFilter = U),
              F.geometry.dispose(),
              F.material.dispose(),
              this
            );
          }
          clear(_, L, R, N) {
            let z = _.getRenderTarget();
            for (let z = 0; z < 6; z++)
              _.setRenderTarget(this, z), _.clear(L, R, N);
            _.setRenderTarget(z);
          }
        },
        s2 = new iq(),
        s4 = new iq(),
        s5 = new iC(),
        s6 = class {
          constructor(_ = new iq(1, 0, 0), L = 0) {
            (this.isPlane = !0), (this.normal = _), (this.constant = L);
          }
          set(_, L) {
            return this.normal.copy(_), (this.constant = L), this;
          }
          setComponents(_, L, R, N) {
            return this.normal.set(_, L, R), (this.constant = N), this;
          }
          setFromNormalAndCoplanarPoint(_, L) {
            return (
              this.normal.copy(_), (this.constant = -L.dot(this.normal)), this
            );
          }
          setFromCoplanarPoints(_, L, R) {
            let N = s2.subVectors(R, L).cross(s4.subVectors(_, L)).normalize();
            return this.setFromNormalAndCoplanarPoint(N, _), this;
          }
          copy(_) {
            return (
              this.normal.copy(_.normal), (this.constant = _.constant), this
            );
          }
          normalize() {
            let _ = 1 / this.normal.length();
            return this.normal.multiplyScalar(_), (this.constant *= _), this;
          }
          negate() {
            return (this.constant *= -1), this.normal.negate(), this;
          }
          distanceToPoint(_) {
            return this.normal.dot(_) + this.constant;
          }
          distanceToSphere(_) {
            return this.distanceToPoint(_.center) - _.radius;
          }
          projectPoint(_, L) {
            return L.copy(this.normal)
              .multiplyScalar(-this.distanceToPoint(_))
              .add(_);
          }
          intersectLine(_, L) {
            let R = _.delta(s2),
              N = this.normal.dot(R);
            if (0 === N)
              return 0 === this.distanceToPoint(_.start)
                ? L.copy(_.start)
                : null;
            let z = -(_.start.dot(this.normal) + this.constant) / N;
            return z < 0 || z > 1
              ? null
              : L.copy(R).multiplyScalar(z).add(_.start);
          }
          intersectsLine(_) {
            let L = this.distanceToPoint(_.start),
              R = this.distanceToPoint(_.end);
            return (L < 0 && R > 0) || (R < 0 && L > 0);
          }
          intersectsBox(_) {
            return _.intersectsPlane(this);
          }
          intersectsSphere(_) {
            return _.intersectsPlane(this);
          }
          coplanarPoint(_) {
            return _.copy(this.normal).multiplyScalar(-this.constant);
          }
          applyMatrix4(_, L) {
            let R = L || s5.getNormalMatrix(_),
              N = this.coplanarPoint(s2).applyMatrix4(_),
              z = this.normal.applyMatrix3(R).normalize();
            return (this.constant = -N.dot(z)), this;
          }
          translate(_) {
            return (this.constant -= _.dot(this.normal)), this;
          }
          equals(_) {
            return _.normal.equals(this.normal) && _.constant === this.constant;
          }
          clone() {
            return new this.constructor().copy(this);
          }
        },
        s8 = new ro(),
        s9 = new iq(),
        s7 = class {
          constructor(
            _ = new s6(),
            L = new s6(),
            R = new s6(),
            N = new s6(),
            z = new s6(),
            F = new s6(),
          ) {
            this.planes = [_, L, R, N, z, F];
          }
          set(_, L, R, N, z, F) {
            let U = this.planes;
            return (
              U[0].copy(_),
              U[1].copy(L),
              U[2].copy(R),
              U[3].copy(N),
              U[4].copy(z),
              U[5].copy(F),
              this
            );
          }
          copy(_) {
            let L = this.planes;
            for (let R = 0; R < 6; R++) L[R].copy(_.planes[R]);
            return this;
          }
          setFromProjectionMatrix(_) {
            let L = this.planes,
              R = _.elements,
              N = R[0],
              z = R[1],
              F = R[2],
              U = R[3],
              k = R[4],
              Y = R[5],
              X = R[6],
              Q = R[7],
              K = R[8],
              J = R[9],
              $ = R[10],
              ee = R[11],
              er = R[12],
              en = R[13],
              ea = R[14],
              eo = R[15];
            return (
              L[0].setComponents(U - N, Q - k, ee - K, eo - er).normalize(),
              L[1].setComponents(U + N, Q + k, ee + K, eo + er).normalize(),
              L[2].setComponents(U + z, Q + Y, ee + J, eo + en).normalize(),
              L[3].setComponents(U - z, Q - Y, ee - J, eo - en).normalize(),
              L[4].setComponents(U - F, Q - X, ee - $, eo - ea).normalize(),
              L[5].setComponents(U + F, Q + X, ee + $, eo + ea).normalize(),
              this
            );
          }
          intersectsObject(_) {
            let L = _.geometry;
            return (
              null === L.boundingSphere && L.computeBoundingSphere(),
              s8.copy(L.boundingSphere).applyMatrix4(_.matrixWorld),
              this.intersectsSphere(s8)
            );
          }
          intersectsSprite(_) {
            return (
              s8.center.set(0, 0, 0),
              (s8.radius = 0.7071067811865476),
              s8.applyMatrix4(_.matrixWorld),
              this.intersectsSphere(s8)
            );
          }
          intersectsSphere(_) {
            let L = this.planes,
              R = _.center,
              N = -_.radius;
            for (let _ = 0; _ < 6; _++)
              if (L[_].distanceToPoint(R) < N) return !1;
            return !0;
          }
          intersectsBox(_) {
            let L = this.planes;
            for (let R = 0; R < 6; R++) {
              let N = L[R];
              if (
                ((s9.x = N.normal.x > 0 ? _.max.x : _.min.x),
                (s9.y = N.normal.y > 0 ? _.max.y : _.min.y),
                (s9.z = N.normal.z > 0 ? _.max.z : _.min.z),
                0 > N.distanceToPoint(s9))
              )
                return !1;
            }
            return !0;
          }
          containsPoint(_) {
            let L = this.planes;
            for (let R = 0; R < 6; R++)
              if (0 > L[R].distanceToPoint(_)) return !1;
            return !0;
          }
          clone() {
            return new this.constructor().copy(this);
          }
        };
      function U1() {
        let _ = null,
          L = !1,
          R = null,
          N = null;
        function i(L, z) {
          R(L, z), (N = _.requestAnimationFrame(i));
        }
        return {
          start: function () {
            !0 !== L &&
              null !== R &&
              ((N = _.requestAnimationFrame(i)), (L = !0));
          },
          stop: function () {
            _.cancelAnimationFrame(N), (L = !1);
          },
          setAnimationLoop: function (_) {
            R = _;
          },
          setContext: function (L) {
            _ = L;
          },
        };
      }
      function jD(_, L) {
        let R = L.isWebGL2,
          N = new WeakMap();
        return {
          get: function (_) {
            return _.isInterleavedBufferAttribute && (_ = _.data), N.get(_);
          },
          remove: function (L) {
            L.isInterleavedBufferAttribute && (L = L.data);
            let R = N.get(L);
            R && (_.deleteBuffer(R.buffer), N.delete(L));
          },
          update: function (L, z) {
            var F, U;
            let k, Y;
            if (L.isGLBufferAttribute) {
              let _ = N.get(L);
              (!_ || _.version < L.version) &&
                N.set(L, {
                  buffer: L.buffer,
                  type: L.type,
                  bytesPerElement: L.elementSize,
                  version: L.version,
                });
              return;
            }
            L.isInterleavedBufferAttribute && (L = L.data);
            let X = N.get(L);
            void 0 === X
              ? N.set(
                  L,
                  (function (L, N) {
                    let z,
                      F = L.array,
                      U = L.usage,
                      k = _.createBuffer();
                    if (
                      (_.bindBuffer(N, k),
                      _.bufferData(N, F, U),
                      L.onUploadCallback(),
                      F instanceof Float32Array)
                    )
                      z = 5126;
                    else if (F instanceof Uint16Array) {
                      if (L.isFloat16BufferAttribute) {
                        if (R) z = 5131;
                        else
                          throw Error(
                            "THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.",
                          );
                      } else z = 5123;
                    } else if (F instanceof Int16Array) z = 5122;
                    else if (F instanceof Uint32Array) z = 5125;
                    else if (F instanceof Int32Array) z = 5124;
                    else if (F instanceof Int8Array) z = 5120;
                    else if (F instanceof Uint8Array) z = 5121;
                    else if (F instanceof Uint8ClampedArray) z = 5121;
                    else
                      throw Error(
                        "THREE.WebGLAttributes: Unsupported buffer data format: " +
                          F,
                      );
                    return {
                      buffer: k,
                      type: z,
                      bytesPerElement: F.BYTES_PER_ELEMENT,
                      version: L.version,
                    };
                  })(L, z),
                )
              : X.version < L.version &&
                ((F = X.buffer),
                (k = (U = L).array),
                (Y = U.updateRange),
                _.bindBuffer(z, F),
                -1 === Y.count
                  ? _.bufferSubData(z, 0, k)
                  : (R
                      ? _.bufferSubData(
                          z,
                          Y.offset * k.BYTES_PER_ELEMENT,
                          k,
                          Y.offset,
                          Y.count,
                        )
                      : _.bufferSubData(
                          z,
                          Y.offset * k.BYTES_PER_ELEMENT,
                          k.subarray(Y.offset, Y.offset + Y.count),
                        ),
                    (Y.count = -1)),
                U.onUploadCallback(),
                (X.version = L.version));
          },
        };
      }
      var ne = class extends sP {
          constructor(_ = 1, L = 1, R = 1, N = 1) {
            super(),
              (this.type = "PlaneGeometry"),
              (this.parameters = {
                width: _,
                height: L,
                widthSegments: R,
                heightSegments: N,
              });
            let z = _ / 2,
              F = L / 2,
              U = Math.floor(R),
              k = Math.floor(N),
              Y = U + 1,
              X = k + 1,
              Q = _ / U,
              K = L / k,
              J = [],
              $ = [],
              ee = [],
              er = [];
            for (let _ = 0; _ < X; _++) {
              let L = _ * K - F;
              for (let R = 0; R < Y; R++) {
                let N = R * Q - z;
                $.push(N, -L, 0),
                  ee.push(0, 0, 1),
                  er.push(R / U),
                  er.push(1 - _ / k);
              }
            }
            for (let _ = 0; _ < k; _++)
              for (let L = 0; L < U; L++) {
                let R = L + Y * _,
                  N = L + Y * (_ + 1),
                  z = L + 1 + Y * (_ + 1),
                  F = L + 1 + Y * _;
                J.push(R, N, F), J.push(N, z, F);
              }
            this.setIndex(J),
              this.setAttribute("position", new sv($, 3)),
              this.setAttribute("normal", new sv(ee, 3)),
              this.setAttribute("uv", new sv(er, 2));
          }
          static fromJSON(_) {
            return new ne(_.width, _.height, _.widthSegments, _.heightSegments);
          }
        },
        nt = {
          alphamap_fragment: `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`,
          alphamap_pars_fragment: `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
          alphatest_fragment: `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,
          alphatest_pars_fragment: `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
          aomap_fragment: `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
          aomap_pars_fragment: `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
          begin_vertex: "vec3 transformed = vec3( position );",
          beginnormal_vertex: `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
          bsdfs: `vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
#ifdef USE_IRIDESCENCE
	vec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif`,
          iridescence_fragment: `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			 return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float R21 = R12;
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
          bumpmap_pars_fragment: `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = dFdx( surf_pos.xyz );
		vec3 vSigmaY = dFdy( surf_pos.xyz );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
          clipping_planes_fragment: `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,
          clipping_planes_pars_fragment: `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
          clipping_planes_pars_vertex: `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
          clipping_planes_vertex: `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
          color_fragment: `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
          color_pars_fragment: `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
          color_pars_vertex: `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,
          color_vertex: `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,
          common: `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`,
          cube_uv_reflection_fragment: `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
          defaultnormal_vertex: `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
          displacementmap_pars_vertex: `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
          displacementmap_vertex: `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`,
          emissivemap_fragment: `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
          emissivemap_pars_fragment: `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
          encodings_fragment:
            "gl_FragColor = linearToOutputTexel( gl_FragColor );",
          encodings_pars_fragment: `vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,
          envmap_fragment: `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
          envmap_common_pars_fragment: `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
          envmap_pars_fragment: `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
          envmap_pars_vertex: `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
          envmap_physical_pars_fragment: `#if defined( USE_ENVMAP )
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`,
          envmap_vertex: `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
          fog_vertex: `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
          fog_pars_vertex: `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
          fog_fragment: `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
          fog_pars_fragment: `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
          gradientmap_pars_fragment: `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
          lightmap_fragment: `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,
          lightmap_pars_fragment: `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
          lights_lambert_fragment: `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
          lights_lambert_pars_fragment: `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
          lights_pars_begin: `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( PHYSICALLY_CORRECT_LIGHTS )
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#else
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
          lights_toon_fragment: `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
          lights_toon_pars_fragment: `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
          lights_phong_fragment: `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
          lights_phong_pars_fragment: `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
          lights_physical_fragment: `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARCOLORMAP
			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEENCOLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEENROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;
	#endif
#endif`,
          lights_physical_pars_fragment: `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	#ifdef USE_IRIDESCENCE
		reflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );
	#else
		reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
          lights_fragment_begin: `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometry.viewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
          lights_fragment_maps: `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
          lights_fragment_end: `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,
          logdepthbuf_fragment: `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
          logdepthbuf_pars_fragment: `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
          logdepthbuf_pars_vertex: `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,
          logdepthbuf_vertex: `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,
          map_fragment: `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
          map_pars_fragment: `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
          map_particle_fragment: `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
          map_particle_pars_fragment: `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
          metalnessmap_fragment: `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
          metalnessmap_pars_fragment: `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
          morphcolor_vertex: `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
          morphnormal_vertex: `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,
          morphtarget_pars_vertex: `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,
          morphtarget_vertex: `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,
          normal_fragment_begin: `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`,
          normal_fragment_maps: `#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
          normal_pars_fragment: `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
          normal_pars_vertex: `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
          normal_vertex: `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
          normalmap_pars_fragment: `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`,
          clearcoat_normal_fragment_begin: `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,
          clearcoat_normal_fragment_maps: `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`,
          clearcoat_pars_fragment: `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`,
          iridescence_pars_fragment: `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
          output_fragment: `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
          packing: `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`,
          premultiplied_alpha_fragment: `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
          project_vertex: `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
          dithering_fragment: `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
          dithering_pars_fragment: `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
          roughnessmap_fragment: `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
          roughnessmap_pars_fragment: `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
          shadowmap_pars_fragment: `#if NUM_SPOT_LIGHT_COORDS > 0
  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
  uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,
          shadowmap_pars_vertex: `#if NUM_SPOT_LIGHT_COORDS > 0
  uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
          shadowmap_vertex: `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
          shadowmask_pars_fragment: `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
          skinbase_vertex: `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
          skinning_pars_vertex: `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`,
          skinning_vertex: `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
          skinnormal_vertex: `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
          specularmap_fragment: `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
          specularmap_pars_fragment: `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
          tonemapping_fragment: `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
          tonemapping_pars_fragment: `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
          transmission_fragment: `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmission.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );
#endif`,
          transmission_pars_fragment: `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		#ifdef texture2DLodEXT
			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#else
			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#endif
	}
	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`,
          uv_pars_fragment: `#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`,
          uv_pars_vertex: `#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`,
          uv_vertex: `#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,
          uv2_pars_fragment: `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,
          uv2_pars_vertex: `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`,
          uv2_vertex: `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`,
          worldpos_vertex: `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`,
          background_vert: `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
          background_frag: `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
          backgroundCube_vert: `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
          backgroundCube_frag: `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
          cube_vert: `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
          cube_frag: `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
          depth_vert: `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
          depth_frag: `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,
          distanceRGBA_vert: `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
          distanceRGBA_frag: `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
          equirect_vert: `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
          equirect_frag: `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
          linedashed_vert: `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
          linedashed_frag: `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
          meshbasic_vert: `#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
          meshbasic_frag: `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
          meshlambert_vert: `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
          meshlambert_frag: `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
          meshmatcap_vert: `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
          meshmatcap_frag: `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
          meshnormal_vert: `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
          meshnormal_frag: `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
          meshphong_vert: `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
          meshphong_frag: `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
          meshphysical_vert: `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
          meshphysical_frag: `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
          meshtoon_vert: `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
          meshtoon_frag: `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
          points_vert: `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
          points_frag: `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
          shadow_vert: `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
          shadow_frag: `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,
          sprite_vert: `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
          sprite_frag: `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,
        },
        ni = {
          common: {
            diffuse: { value: new iz(16777215) },
            opacity: { value: 1 },
            map: { value: null },
            uvTransform: { value: new iC() },
            uv2Transform: { value: new iC() },
            alphaMap: { value: null },
            alphaTest: { value: 0 },
          },
          specularmap: { specularMap: { value: null } },
          envmap: {
            envMap: { value: null },
            flipEnvMap: { value: -1 },
            reflectivity: { value: 1 },
            ior: { value: 1.5 },
            refractionRatio: { value: 0.98 },
          },
          aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } },
          lightmap: {
            lightMap: { value: null },
            lightMapIntensity: { value: 1 },
          },
          emissivemap: { emissiveMap: { value: null } },
          bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } },
          normalmap: {
            normalMap: { value: null },
            normalScale: { value: new iT(1, 1) },
          },
          displacementmap: {
            displacementMap: { value: null },
            displacementScale: { value: 1 },
            displacementBias: { value: 0 },
          },
          roughnessmap: { roughnessMap: { value: null } },
          metalnessmap: { metalnessMap: { value: null } },
          gradientmap: { gradientMap: { value: null } },
          fog: {
            fogDensity: { value: 25e-5 },
            fogNear: { value: 1 },
            fogFar: { value: 2e3 },
            fogColor: { value: new iz(16777215) },
          },
          lights: {
            ambientLightColor: { value: [] },
            lightProbe: { value: [] },
            directionalLights: {
              value: [],
              properties: { direction: {}, color: {} },
            },
            directionalLightShadows: {
              value: [],
              properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
              },
            },
            directionalShadowMap: { value: [] },
            directionalShadowMatrix: { value: [] },
            spotLights: {
              value: [],
              properties: {
                color: {},
                position: {},
                direction: {},
                distance: {},
                coneCos: {},
                penumbraCos: {},
                decay: {},
              },
            },
            spotLightShadows: {
              value: [],
              properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
              },
            },
            spotLightMap: { value: [] },
            spotShadowMap: { value: [] },
            spotLightMatrix: { value: [] },
            pointLights: {
              value: [],
              properties: { color: {}, position: {}, decay: {}, distance: {} },
            },
            pointLightShadows: {
              value: [],
              properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
                shadowCameraNear: {},
                shadowCameraFar: {},
              },
            },
            pointShadowMap: { value: [] },
            pointShadowMatrix: { value: [] },
            hemisphereLights: {
              value: [],
              properties: { direction: {}, skyColor: {}, groundColor: {} },
            },
            rectAreaLights: {
              value: [],
              properties: { color: {}, position: {}, width: {}, height: {} },
            },
            ltc_1: { value: null },
            ltc_2: { value: null },
          },
          points: {
            diffuse: { value: new iz(16777215) },
            opacity: { value: 1 },
            size: { value: 1 },
            scale: { value: 1 },
            map: { value: null },
            alphaMap: { value: null },
            alphaTest: { value: 0 },
            uvTransform: { value: new iC() },
          },
          sprite: {
            diffuse: { value: new iz(16777215) },
            opacity: { value: 1 },
            center: { value: new iT(0.5, 0.5) },
            rotation: { value: 0 },
            map: { value: null },
            alphaMap: { value: null },
            alphaTest: { value: 0 },
            uvTransform: { value: new iC() },
          },
        },
        nr = {
          basic: {
            uniforms: dr([
              ni.common,
              ni.specularmap,
              ni.envmap,
              ni.aomap,
              ni.lightmap,
              ni.fog,
            ]),
            vertexShader: nt.meshbasic_vert,
            fragmentShader: nt.meshbasic_frag,
          },
          lambert: {
            uniforms: dr([
              ni.common,
              ni.specularmap,
              ni.envmap,
              ni.aomap,
              ni.lightmap,
              ni.emissivemap,
              ni.bumpmap,
              ni.normalmap,
              ni.displacementmap,
              ni.fog,
              ni.lights,
              { emissive: { value: new iz(0) } },
            ]),
            vertexShader: nt.meshlambert_vert,
            fragmentShader: nt.meshlambert_frag,
          },
          phong: {
            uniforms: dr([
              ni.common,
              ni.specularmap,
              ni.envmap,
              ni.aomap,
              ni.lightmap,
              ni.emissivemap,
              ni.bumpmap,
              ni.normalmap,
              ni.displacementmap,
              ni.fog,
              ni.lights,
              {
                emissive: { value: new iz(0) },
                specular: { value: new iz(1118481) },
                shininess: { value: 30 },
              },
            ]),
            vertexShader: nt.meshphong_vert,
            fragmentShader: nt.meshphong_frag,
          },
          standard: {
            uniforms: dr([
              ni.common,
              ni.envmap,
              ni.aomap,
              ni.lightmap,
              ni.emissivemap,
              ni.bumpmap,
              ni.normalmap,
              ni.displacementmap,
              ni.roughnessmap,
              ni.metalnessmap,
              ni.fog,
              ni.lights,
              {
                emissive: { value: new iz(0) },
                roughness: { value: 1 },
                metalness: { value: 0 },
                envMapIntensity: { value: 1 },
              },
            ]),
            vertexShader: nt.meshphysical_vert,
            fragmentShader: nt.meshphysical_frag,
          },
          toon: {
            uniforms: dr([
              ni.common,
              ni.aomap,
              ni.lightmap,
              ni.emissivemap,
              ni.bumpmap,
              ni.normalmap,
              ni.displacementmap,
              ni.gradientmap,
              ni.fog,
              ni.lights,
              { emissive: { value: new iz(0) } },
            ]),
            vertexShader: nt.meshtoon_vert,
            fragmentShader: nt.meshtoon_frag,
          },
          matcap: {
            uniforms: dr([
              ni.common,
              ni.bumpmap,
              ni.normalmap,
              ni.displacementmap,
              ni.fog,
              { matcap: { value: null } },
            ]),
            vertexShader: nt.meshmatcap_vert,
            fragmentShader: nt.meshmatcap_frag,
          },
          points: {
            uniforms: dr([ni.points, ni.fog]),
            vertexShader: nt.points_vert,
            fragmentShader: nt.points_frag,
          },
          dashed: {
            uniforms: dr([
              ni.common,
              ni.fog,
              {
                scale: { value: 1 },
                dashSize: { value: 1 },
                totalSize: { value: 2 },
              },
            ]),
            vertexShader: nt.linedashed_vert,
            fragmentShader: nt.linedashed_frag,
          },
          depth: {
            uniforms: dr([ni.common, ni.displacementmap]),
            vertexShader: nt.depth_vert,
            fragmentShader: nt.depth_frag,
          },
          normal: {
            uniforms: dr([
              ni.common,
              ni.bumpmap,
              ni.normalmap,
              ni.displacementmap,
              { opacity: { value: 1 } },
            ]),
            vertexShader: nt.meshnormal_vert,
            fragmentShader: nt.meshnormal_frag,
          },
          sprite: {
            uniforms: dr([ni.sprite, ni.fog]),
            vertexShader: nt.sprite_vert,
            fragmentShader: nt.sprite_frag,
          },
          background: {
            uniforms: {
              uvTransform: { value: new iC() },
              t2D: { value: null },
              backgroundIntensity: { value: 1 },
            },
            vertexShader: nt.background_vert,
            fragmentShader: nt.background_frag,
          },
          backgroundCube: {
            uniforms: {
              envMap: { value: null },
              flipEnvMap: { value: -1 },
              backgroundBlurriness: { value: 0 },
              backgroundIntensity: { value: 1 },
            },
            vertexShader: nt.backgroundCube_vert,
            fragmentShader: nt.backgroundCube_frag,
          },
          cube: {
            uniforms: {
              tCube: { value: null },
              tFlip: { value: -1 },
              opacity: { value: 1 },
            },
            vertexShader: nt.cube_vert,
            fragmentShader: nt.cube_frag,
          },
          equirect: {
            uniforms: { tEquirect: { value: null } },
            vertexShader: nt.equirect_vert,
            fragmentShader: nt.equirect_frag,
          },
          distanceRGBA: {
            uniforms: dr([
              ni.common,
              ni.displacementmap,
              {
                referencePosition: { value: new iq() },
                nearDistance: { value: 1 },
                farDistance: { value: 1e3 },
              },
            ]),
            vertexShader: nt.distanceRGBA_vert,
            fragmentShader: nt.distanceRGBA_frag,
          },
          shadow: {
            uniforms: dr([
              ni.lights,
              ni.fog,
              { color: { value: new iz(0) }, opacity: { value: 1 } },
            ]),
            vertexShader: nt.shadow_vert,
            fragmentShader: nt.shadow_frag,
          },
        };
      nr.physical = {
        uniforms: dr([
          nr.standard.uniforms,
          {
            clearcoat: { value: 0 },
            clearcoatMap: { value: null },
            clearcoatRoughness: { value: 0 },
            clearcoatRoughnessMap: { value: null },
            clearcoatNormalScale: { value: new iT(1, 1) },
            clearcoatNormalMap: { value: null },
            iridescence: { value: 0 },
            iridescenceMap: { value: null },
            iridescenceIOR: { value: 1.3 },
            iridescenceThicknessMinimum: { value: 100 },
            iridescenceThicknessMaximum: { value: 400 },
            iridescenceThicknessMap: { value: null },
            sheen: { value: 0 },
            sheenColor: { value: new iz(0) },
            sheenColorMap: { value: null },
            sheenRoughness: { value: 1 },
            sheenRoughnessMap: { value: null },
            transmission: { value: 0 },
            transmissionMap: { value: null },
            transmissionSamplerSize: { value: new iT() },
            transmissionSamplerMap: { value: null },
            thickness: { value: 0 },
            thicknessMap: { value: null },
            attenuationDistance: { value: 0 },
            attenuationColor: { value: new iz(0) },
            specularIntensity: { value: 1 },
            specularIntensityMap: { value: null },
            specularColor: { value: new iz(1, 1, 1) },
            specularColorMap: { value: null },
          },
        ]),
        vertexShader: nt.meshphysical_vert,
        fragmentShader: nt.meshphysical_frag,
      };
      var nn = { r: 0, b: 0, g: 0 };
      function _R(_, L, R, N, z, F, U) {
        let k = new iz(0),
          Y = !0 === F ? 0 : 1,
          X,
          Q,
          K = null,
          J = 0,
          $ = null;
        function p(L, R) {
          L.getRGB(nn, F1(_)), N.buffers.color.setClear(nn.r, nn.g, nn.b, R, U);
        }
        return {
          getClearColor: function () {
            return k;
          },
          setClearColor: function (_, L = 1) {
            k.set(_), p(k, (Y = L));
          },
          getClearAlpha: function () {
            return Y;
          },
          setClearAlpha: function (_) {
            p(k, (Y = _));
          },
          render: function (N, F) {
            let U = !1,
              ee = !0 === F.isScene ? F.background : null;
            ee &&
              ee.isTexture &&
              (ee = (F.backgroundBlurriness > 0 ? R : L).get(ee));
            let er = _.xr,
              en = er.getSession && er.getSession();
            en && "additive" === en.environmentBlendMode && (ee = null),
              null === ee ? p(k, Y) : ee && ee.isColor && (p(ee, 1), (U = !0)),
              (_.autoClear || U) &&
                _.clear(_.autoClearColor, _.autoClearDepth, _.autoClearStencil),
              ee && (ee.isCubeTexture || 306 === ee.mapping)
                ? (void 0 === Q &&
                    ((Q = new sH(
                      new sW(1, 1, 1),
                      new sQ({
                        name: "BackgroundCubeMaterial",
                        uniforms: Ul(nr.backgroundCube.uniforms),
                        vertexShader: nr.backgroundCube.vertexShader,
                        fragmentShader: nr.backgroundCube.fragmentShader,
                        side: 1,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1,
                      }),
                    )).geometry.deleteAttribute("normal"),
                    Q.geometry.deleteAttribute("uv"),
                    (Q.onBeforeRender = function (_, L, R) {
                      this.matrixWorld.copyPosition(R.matrixWorld);
                    }),
                    Object.defineProperty(Q.material, "envMap", {
                      get: function () {
                        return this.uniforms.envMap.value;
                      },
                    }),
                    z.update(Q)),
                  (Q.material.uniforms.envMap.value = ee),
                  (Q.material.uniforms.flipEnvMap.value =
                    ee.isCubeTexture && !1 === ee.isRenderTargetTexture
                      ? -1
                      : 1),
                  (Q.material.uniforms.backgroundBlurriness.value =
                    F.backgroundBlurriness),
                  (Q.material.uniforms.backgroundIntensity.value =
                    F.backgroundIntensity),
                  (Q.material.toneMapped = 3001 !== ee.encoding),
                  (K !== ee || J !== ee.version || $ !== _.toneMapping) &&
                    ((Q.material.needsUpdate = !0),
                    (K = ee),
                    (J = ee.version),
                    ($ = _.toneMapping)),
                  Q.layers.enableAll(),
                  N.unshift(Q, Q.geometry, Q.material, 0, 0, null))
                : ee &&
                  ee.isTexture &&
                  (void 0 === X &&
                    ((X = new sH(
                      new ne(2, 2),
                      new sQ({
                        name: "BackgroundMaterial",
                        uniforms: Ul(nr.background.uniforms),
                        vertexShader: nr.background.vertexShader,
                        fragmentShader: nr.background.fragmentShader,
                        side: 0,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1,
                      }),
                    )).geometry.deleteAttribute("normal"),
                    Object.defineProperty(X.material, "map", {
                      get: function () {
                        return this.uniforms.t2D.value;
                      },
                    }),
                    z.update(X)),
                  (X.material.uniforms.t2D.value = ee),
                  (X.material.uniforms.backgroundIntensity.value =
                    F.backgroundIntensity),
                  (X.material.toneMapped = 3001 !== ee.encoding),
                  !0 === ee.matrixAutoUpdate && ee.updateMatrix(),
                  X.material.uniforms.uvTransform.value.copy(ee.matrix),
                  (K !== ee || J !== ee.version || $ !== _.toneMapping) &&
                    ((X.material.needsUpdate = !0),
                    (K = ee),
                    (J = ee.version),
                    ($ = _.toneMapping)),
                  X.layers.enableAll(),
                  N.unshift(X, X.geometry, X.material, 0, 0, null));
          },
        };
      }
      function TR(_, L, R, N) {
        let z = _.getParameter(34921),
          F = N.isWebGL2 ? null : L.get("OES_vertex_array_object"),
          U = N.isWebGL2 || null !== F,
          k = {},
          Y = m(null),
          X = Y,
          Q = !1;
        function f(L) {
          return N.isWebGL2 ? _.bindVertexArray(L) : F.bindVertexArrayOES(L);
        }
        function g(L) {
          return N.isWebGL2
            ? _.deleteVertexArray(L)
            : F.deleteVertexArrayOES(L);
        }
        function m(_) {
          let L = [],
            R = [],
            N = [];
          for (let _ = 0; _ < z; _++) (L[_] = 0), (R[_] = 0), (N[_] = 0);
          return {
            geometry: null,
            program: null,
            wireframe: !1,
            newAttributes: L,
            enabledAttributes: R,
            attributeDivisors: N,
            object: _,
            attributes: {},
            index: null,
          };
        }
        function x() {
          let _ = X.newAttributes;
          for (let L = 0, R = _.length; L < R; L++) _[L] = 0;
        }
        function b(_) {
          w(_, 0);
        }
        function w(R, z) {
          let F = X.newAttributes,
            U = X.enabledAttributes,
            k = X.attributeDivisors;
          (F[R] = 1),
            0 === U[R] && (_.enableVertexAttribArray(R), (U[R] = 1)),
            k[R] !== z &&
              ((N.isWebGL2 ? _ : L.get("ANGLE_instanced_arrays"))[
                N.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
              ](R, z),
              (k[R] = z));
        }
        function A() {
          let L = X.newAttributes,
            R = X.enabledAttributes;
          for (let N = 0, z = R.length; N < z; N++)
            R[N] !== L[N] && (_.disableVertexAttribArray(N), (R[N] = 0));
        }
        function T(L, R, z, F, U, k) {
          !0 === N.isWebGL2 && (5124 === z || 5125 === z)
            ? _.vertexAttribIPointer(L, R, z, U, k)
            : _.vertexAttribPointer(L, R, z, F, U, k);
        }
        function P() {
          C(), (Q = !0), X !== Y && f((X = Y).object);
        }
        function C() {
          (Y.geometry = null), (Y.program = null), (Y.wireframe = !1);
        }
        return {
          setup: function (z, Y, K, J, $) {
            let ee = !1;
            if (U) {
              let L, R, U, Q;
              let er =
                ((L = !0 === Y.wireframe),
                void 0 === (R = k[J.id]) && ((R = {}), (k[J.id] = R)),
                void 0 === (U = R[K.id]) && ((U = {}), (R[K.id] = U)),
                void 0 === (Q = U[L]) &&
                  ((Q = m(
                    N.isWebGL2
                      ? _.createVertexArray()
                      : F.createVertexArrayOES(),
                  )),
                  (U[L] = Q)),
                Q);
              X !== er && f((X = er).object),
                (ee = (function (_, L, R, N) {
                  let z = X.attributes,
                    F = L.attributes,
                    U = 0,
                    k = R.getAttributes();
                  for (let L in k)
                    if (k[L].location >= 0) {
                      let R = z[L],
                        N = F[L];
                      if (
                        (void 0 === N &&
                          ("instanceMatrix" === L &&
                            _.instanceMatrix &&
                            (N = _.instanceMatrix),
                          "instanceColor" === L &&
                            _.instanceColor &&
                            (N = _.instanceColor)),
                        void 0 === R ||
                          R.attribute !== N ||
                          (N && R.data !== N.data))
                      )
                        return !0;
                      U++;
                    }
                  return X.attributesNum !== U || X.index !== N;
                })(z, J, K, $)) &&
                  (function (_, L, R, N) {
                    let z = {},
                      F = L.attributes,
                      U = 0,
                      k = R.getAttributes();
                    for (let L in k)
                      if (k[L].location >= 0) {
                        let R = F[L];
                        void 0 === R &&
                          ("instanceMatrix" === L &&
                            _.instanceMatrix &&
                            (R = _.instanceMatrix),
                          "instanceColor" === L &&
                            _.instanceColor &&
                            (R = _.instanceColor));
                        let N = {};
                        (N.attribute = R),
                          R && R.data && (N.data = R.data),
                          (z[L] = N),
                          U++;
                      }
                    (X.attributes = z), (X.attributesNum = U), (X.index = N);
                  })(z, J, K, $);
            } else {
              let _ = !0 === Y.wireframe;
              (X.geometry !== J.id ||
                X.program !== K.id ||
                X.wireframe !== _) &&
                ((X.geometry = J.id),
                (X.program = K.id),
                (X.wireframe = _),
                (ee = !0));
            }
            null !== $ && R.update($, 34963),
              (ee || Q) &&
                ((Q = !1),
                (function (z, F, U, k) {
                  if (
                    !1 === N.isWebGL2 &&
                    (z.isInstancedMesh || k.isInstancedBufferGeometry) &&
                    null === L.get("ANGLE_instanced_arrays")
                  )
                    return;
                  x();
                  let Y = k.attributes,
                    X = U.getAttributes(),
                    Q = F.defaultAttributeValues;
                  for (let L in X) {
                    let N = X[L];
                    if (N.location >= 0) {
                      let F = Y[L];
                      if (
                        (void 0 === F &&
                          ("instanceMatrix" === L &&
                            z.instanceMatrix &&
                            (F = z.instanceMatrix),
                          "instanceColor" === L &&
                            z.instanceColor &&
                            (F = z.instanceColor)),
                        void 0 !== F)
                      ) {
                        let L = F.normalized,
                          U = F.itemSize,
                          Y = R.get(F);
                        if (void 0 === Y) continue;
                        let X = Y.buffer,
                          Q = Y.type,
                          K = Y.bytesPerElement;
                        if (F.isInterleavedBufferAttribute) {
                          let R = F.data,
                            Y = R.stride,
                            J = F.offset;
                          if (R.isInstancedInterleavedBuffer) {
                            for (let _ = 0; _ < N.locationSize; _++)
                              w(N.location + _, R.meshPerAttribute);
                            !0 !== z.isInstancedMesh &&
                              void 0 === k._maxInstanceCount &&
                              (k._maxInstanceCount =
                                R.meshPerAttribute * R.count);
                          } else
                            for (let _ = 0; _ < N.locationSize; _++)
                              b(N.location + _);
                          _.bindBuffer(34962, X);
                          for (let _ = 0; _ < N.locationSize; _++)
                            T(
                              N.location + _,
                              U / N.locationSize,
                              Q,
                              L,
                              Y * K,
                              (J + (U / N.locationSize) * _) * K,
                            );
                        } else {
                          if (F.isInstancedBufferAttribute) {
                            for (let _ = 0; _ < N.locationSize; _++)
                              w(N.location + _, F.meshPerAttribute);
                            !0 !== z.isInstancedMesh &&
                              void 0 === k._maxInstanceCount &&
                              (k._maxInstanceCount =
                                F.meshPerAttribute * F.count);
                          } else
                            for (let _ = 0; _ < N.locationSize; _++)
                              b(N.location + _);
                          _.bindBuffer(34962, X);
                          for (let _ = 0; _ < N.locationSize; _++)
                            T(
                              N.location + _,
                              U / N.locationSize,
                              Q,
                              L,
                              U * K,
                              (U / N.locationSize) * _ * K,
                            );
                        }
                      } else if (void 0 !== Q) {
                        let R = Q[L];
                        if (void 0 !== R)
                          switch (R.length) {
                            case 2:
                              _.vertexAttrib2fv(N.location, R);
                              break;
                            case 3:
                              _.vertexAttrib3fv(N.location, R);
                              break;
                            case 4:
                              _.vertexAttrib4fv(N.location, R);
                              break;
                            default:
                              _.vertexAttrib1fv(N.location, R);
                          }
                      }
                    }
                  }
                  A();
                })(z, Y, K, J),
                null !== $ && _.bindBuffer(34963, R.get($).buffer));
          },
          reset: P,
          resetDefaultState: C,
          dispose: function () {
            for (let _ in (P(), k)) {
              let L = k[_];
              for (let _ in L) {
                let R = L[_];
                for (let _ in R) g(R[_].object), delete R[_];
                delete L[_];
              }
              delete k[_];
            }
          },
          releaseStatesOfGeometry: function (_) {
            if (void 0 === k[_.id]) return;
            let L = k[_.id];
            for (let _ in L) {
              let R = L[_];
              for (let _ in R) g(R[_].object), delete R[_];
              delete L[_];
            }
            delete k[_.id];
          },
          releaseStatesOfProgram: function (_) {
            for (let L in k) {
              let R = k[L];
              if (void 0 === R[_.id]) continue;
              let N = R[_.id];
              for (let _ in N) g(N[_].object), delete N[_];
              delete R[_.id];
            }
          },
          initAttributes: x,
          enableAttribute: b,
          disableUnusedAttributes: A,
        };
      }
      function ER(_, L, R, N) {
        let z = N.isWebGL2,
          F;
        (this.setMode = function (_) {
          F = _;
        }),
          (this.render = function (L, N) {
            _.drawArrays(F, L, N), R.update(N, F, 1);
          }),
          (this.renderInstances = function (N, U, k) {
            let Y, X;
            if (0 !== k) {
              if (z) (Y = _), (X = "drawArraysInstanced");
              else if (
                ((Y = L.get("ANGLE_instanced_arrays")),
                (X = "drawArraysInstancedANGLE"),
                null === Y)
              ) {
                console.error(
                  "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.",
                );
                return;
              }
              Y[X](F, N, U, k), R.update(U, F, k);
            }
          });
      }
      function MR(_, L, R) {
        let N;
        function s(L) {
          if ("highp" === L) {
            if (
              _.getShaderPrecisionFormat(35633, 36338).precision > 0 &&
              _.getShaderPrecisionFormat(35632, 36338).precision > 0
            )
              return "highp";
            L = "mediump";
          }
          return "mediump" === L &&
            _.getShaderPrecisionFormat(35633, 36337).precision > 0 &&
            _.getShaderPrecisionFormat(35632, 36337).precision > 0
            ? "mediump"
            : "lowp";
        }
        let z =
            "u" > typeof WebGL2RenderingContext &&
            _ instanceof WebGL2RenderingContext,
          F = void 0 !== R.precision ? R.precision : "highp",
          U = s(F);
        U !== F &&
          (console.warn(
            "THREE.WebGLRenderer:",
            F,
            "not supported, using",
            U,
            "instead.",
          ),
          (F = U));
        let k = z || L.has("WEBGL_draw_buffers"),
          Y = !0 === R.logarithmicDepthBuffer,
          X = _.getParameter(34930),
          Q = _.getParameter(35660),
          K = _.getParameter(3379),
          J = _.getParameter(34076),
          $ = _.getParameter(34921),
          ee = _.getParameter(36347),
          er = _.getParameter(36348),
          en = _.getParameter(36349),
          ea = Q > 0,
          eo = z || L.has("OES_texture_float"),
          el = z ? _.getParameter(36183) : 0;
        return {
          isWebGL2: z,
          drawBuffers: k,
          getMaxAnisotropy: function () {
            if (void 0 !== N) return N;
            if (!0 === L.has("EXT_texture_filter_anisotropic")) {
              let R = L.get("EXT_texture_filter_anisotropic");
              N = _.getParameter(R.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
            } else N = 0;
            return N;
          },
          getMaxPrecision: s,
          precision: F,
          logarithmicDepthBuffer: Y,
          maxTextures: X,
          maxVertexTextures: Q,
          maxTextureSize: K,
          maxCubemapSize: J,
          maxAttributes: $,
          maxVertexUniforms: ee,
          maxVaryings: er,
          maxFragmentUniforms: en,
          vertexTextures: ea,
          floatFragmentTextures: eo,
          floatVertexTextures: ea && eo,
          maxSamples: el,
        };
      }
      function CR(_) {
        let L = this,
          R = null,
          N = 0,
          z = !1,
          F = !1,
          U = new s6(),
          k = new iC(),
          Y = { value: null, needsUpdate: !1 };
        function c(_, R, N, z) {
          let F = null !== _ ? _.length : 0,
            X = null;
          if (0 !== F) {
            if (((X = Y.value), !0 !== z || null === X)) {
              let L = N + 4 * F,
                z = R.matrixWorldInverse;
              k.getNormalMatrix(z),
                (null === X || X.length < L) && (X = new Float32Array(L));
              for (let L = 0, R = N; L !== F; ++L, R += 4)
                U.copy(_[L]).applyMatrix4(z, k),
                  U.normal.toArray(X, R),
                  (X[R + 3] = U.constant);
            }
            (Y.value = X), (Y.needsUpdate = !0);
          }
          return (L.numPlanes = F), (L.numIntersection = 0), X;
        }
        (this.uniform = Y),
          (this.numPlanes = 0),
          (this.numIntersection = 0),
          (this.init = function (_, L) {
            let R = 0 !== _.length || L || 0 !== N || z;
            return (z = L), (N = _.length), R;
          }),
          (this.beginShadows = function () {
            (F = !0), c(null);
          }),
          (this.endShadows = function () {
            F = !1;
          }),
          (this.setGlobalState = function (_, L) {
            R = c(_, L, 0);
          }),
          (this.setState = function (U, k, X) {
            let Q = U.clippingPlanes,
              K = U.clipIntersection,
              J = U.clipShadows,
              $ = _.get(U);
            if (z && null !== Q && 0 !== Q.length && (!F || J)) {
              let _ = F ? 0 : N,
                L = 4 * _,
                z = $.clippingState || null;
              (Y.value = z), (z = c(Q, k, L, X));
              for (let _ = 0; _ !== L; ++_) z[_] = R[_];
              ($.clippingState = z),
                (this.numIntersection = K ? this.numPlanes : 0),
                (this.numPlanes += _);
            } else
              F
                ? c(null)
                : (Y.value !== R && ((Y.value = R), (Y.needsUpdate = N > 0)),
                  (L.numPlanes = N),
                  (L.numIntersection = 0));
          });
      }
      function PR(_) {
        let L = new WeakMap();
        function e(_, L) {
          return (
            303 === L ? (_.mapping = 301) : 304 === L && (_.mapping = 302), _
          );
        }
        function i(_) {
          let R = _.target;
          R.removeEventListener("dispose", i);
          let N = L.get(R);
          void 0 !== N && (L.delete(R), N.dispose());
        }
        return {
          get: function (R) {
            if (R && R.isTexture && !1 === R.isRenderTargetTexture) {
              let N = R.mapping;
              if (303 === N || 304 === N) {
                if (L.has(R)) return e(L.get(R).texture, R.mapping);
                {
                  let N = R.image;
                  if (!N || !(N.height > 0)) return null;
                  {
                    let z = new s0(N.height / 2);
                    return (
                      z.fromEquirectangularTexture(_, R),
                      L.set(R, z),
                      R.addEventListener("dispose", i),
                      e(z.texture, R.mapping)
                    );
                  }
                }
              }
            }
            return R;
          },
          dispose: function () {
            L = new WeakMap();
          },
        };
      }
      var na = class extends sZ {
          constructor(_ = -1, L = 1, R = 1, N = -1, z = 0.1, F = 2e3) {
            super(),
              (this.isOrthographicCamera = !0),
              (this.type = "OrthographicCamera"),
              (this.zoom = 1),
              (this.view = null),
              (this.left = _),
              (this.right = L),
              (this.top = R),
              (this.bottom = N),
              (this.near = z),
              (this.far = F),
              this.updateProjectionMatrix();
          }
          copy(_, L) {
            return (
              super.copy(_, L),
              (this.left = _.left),
              (this.right = _.right),
              (this.top = _.top),
              (this.bottom = _.bottom),
              (this.near = _.near),
              (this.far = _.far),
              (this.zoom = _.zoom),
              (this.view = null === _.view ? null : Object.assign({}, _.view)),
              this
            );
          }
          setViewOffset(_, L, R, N, z, F) {
            null === this.view &&
              (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1,
              }),
              (this.view.enabled = !0),
              (this.view.fullWidth = _),
              (this.view.fullHeight = L),
              (this.view.offsetX = R),
              (this.view.offsetY = N),
              (this.view.width = z),
              (this.view.height = F),
              this.updateProjectionMatrix();
          }
          clearViewOffset() {
            null !== this.view && (this.view.enabled = !1),
              this.updateProjectionMatrix();
          }
          updateProjectionMatrix() {
            let _ = (this.right - this.left) / (2 * this.zoom),
              L = (this.top - this.bottom) / (2 * this.zoom),
              R = (this.right + this.left) / 2,
              N = (this.top + this.bottom) / 2,
              z = R - _,
              F = R + _,
              U = N + L,
              k = N - L;
            if (null !== this.view && this.view.enabled) {
              let _ =
                  (this.right - this.left) / this.view.fullWidth / this.zoom,
                L = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
              (z += _ * this.view.offsetX),
                (F = z + _ * this.view.width),
                (U -= L * this.view.offsetY),
                (k = U - L * this.view.height);
            }
            this.projectionMatrix.makeOrthographic(
              z,
              F,
              U,
              k,
              this.near,
              this.far,
            ),
              this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
          }
          toJSON(_) {
            let L = super.toJSON(_);
            return (
              (L.object.zoom = this.zoom),
              (L.object.left = this.left),
              (L.object.right = this.right),
              (L.object.top = this.top),
              (L.object.bottom = this.bottom),
              (L.object.near = this.near),
              (L.object.far = this.far),
              null !== this.view &&
                (L.object.view = Object.assign({}, this.view)),
              L
            );
          }
        },
        nl = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
        nh = new na(),
        nc = new iz(),
        nd = null,
        nu = (1 + Math.sqrt(5)) / 2,
        np = 1 / nu,
        nf = [
          new iq(1, 1, 1),
          new iq(-1, 1, 1),
          new iq(1, 1, -1),
          new iq(-1, 1, -1),
          new iq(0, nu, np),
          new iq(0, nu, -np),
          new iq(np, 0, nu),
          new iq(-np, 0, nu),
          new iq(nu, np, 0),
          new iq(-nu, np, 0),
        ],
        nm = class {
          constructor(_) {
            (this._renderer = _),
              (this._pingPongRenderTarget = null),
              (this._lodMax = 0),
              (this._cubeSize = 0),
              (this._lodPlanes = []),
              (this._sizeLods = []),
              (this._sigmas = []),
              (this._blurMaterial = null),
              (this._cubemapMaterial = null),
              (this._equirectMaterial = null),
              this._compileMaterial(this._blurMaterial);
          }
          fromScene(_, L = 0, R = 0.1, N = 100) {
            (nd = this._renderer.getRenderTarget()), this._setSize(256);
            let z = this._allocateTargets();
            return (
              (z.depthBuffer = !0),
              this._sceneToCubeUV(_, R, N, z),
              L > 0 && this._blur(z, 0, 0, L),
              this._applyPMREM(z),
              this._cleanup(z),
              z
            );
          }
          fromEquirectangular(_, L = null) {
            return this._fromTexture(_, L);
          }
          fromCubemap(_, L = null) {
            return this._fromTexture(_, L);
          }
          compileCubemapShader() {
            null === this._cubemapMaterial &&
              ((this._cubemapMaterial = Yw()),
              this._compileMaterial(this._cubemapMaterial));
          }
          compileEquirectangularShader() {
            null === this._equirectMaterial &&
              ((this._equirectMaterial = Xw()),
              this._compileMaterial(this._equirectMaterial));
          }
          dispose() {
            this._dispose(),
              null !== this._cubemapMaterial && this._cubemapMaterial.dispose(),
              null !== this._equirectMaterial &&
                this._equirectMaterial.dispose();
          }
          _setSize(_) {
            (this._lodMax = Math.floor(Math.log2(_))),
              (this._cubeSize = Math.pow(2, this._lodMax));
          }
          _dispose() {
            null !== this._blurMaterial && this._blurMaterial.dispose(),
              null !== this._pingPongRenderTarget &&
                this._pingPongRenderTarget.dispose();
            for (let _ = 0; _ < this._lodPlanes.length; _++)
              this._lodPlanes[_].dispose();
          }
          _cleanup(_) {
            this._renderer.setRenderTarget(nd),
              (_.scissorTest = !1),
              Yf(_, 0, 0, _.width, _.height);
          }
          _fromTexture(_, L) {
            301 === _.mapping || 302 === _.mapping
              ? this._setSize(
                  0 === _.image.length
                    ? 16
                    : _.image[0].width || _.image[0].image.width,
                )
              : this._setSize(_.image.width / 4),
              (nd = this._renderer.getRenderTarget());
            let R = L || this._allocateTargets();
            return (
              this._textureToCubeUV(_, R),
              this._applyPMREM(R),
              this._cleanup(R),
              R
            );
          }
          _allocateTargets() {
            let _ = 3 * Math.max(this._cubeSize, 112),
              L = 4 * this._cubeSize,
              R = {
                magFilter: 1006,
                minFilter: 1006,
                generateMipmaps: !1,
                type: 1016,
                format: 1023,
                encoding: 3e3,
                depthBuffer: !1,
              },
              N = qw(_, L, R);
            if (
              null === this._pingPongRenderTarget ||
              this._pingPongRenderTarget.width !== _ ||
              this._pingPongRenderTarget.height !== L
            ) {
              let N, z;
              null !== this._pingPongRenderTarget && this._dispose(),
                (this._pingPongRenderTarget = qw(_, L, R));
              let { _lodMax: F } = this;
              ({
                sizeLods: this._sizeLods,
                lodPlanes: this._lodPlanes,
                sigmas: this._sigmas,
              } = (function (_) {
                let L = [],
                  R = [],
                  N = [],
                  z = _,
                  F = _ - 4 + 1 + nl.length;
                for (let U = 0; U < F; U++) {
                  let F = Math.pow(2, z);
                  R.push(F);
                  let k = 1 / F;
                  U > _ - 4 ? (k = nl[U - _ + 4 - 1]) : 0 === U && (k = 0),
                    N.push(k);
                  let Y = 1 / (F - 2),
                    X = -Y,
                    Q = 1 + Y,
                    K = [X, X, Q, X, Q, Q, X, X, Q, Q, X, Q],
                    J = new Float32Array(108),
                    $ = new Float32Array(72),
                    ee = new Float32Array(36);
                  for (let _ = 0; _ < 6; _++) {
                    let L = ((_ % 3) * 2) / 3 - 1,
                      R = _ > 2 ? 0 : -1,
                      N = [
                        L,
                        R,
                        0,
                        L + 2 / 3,
                        R,
                        0,
                        L + 2 / 3,
                        R + 1,
                        0,
                        L,
                        R,
                        0,
                        L + 2 / 3,
                        R + 1,
                        0,
                        L,
                        R + 1,
                        0,
                      ];
                    J.set(N, 18 * _), $.set(K, 12 * _);
                    let z = [_, _, _, _, _, _];
                    ee.set(z, 6 * _);
                  }
                  let er = new sP();
                  er.setAttribute("position", new sh(J, 3)),
                    er.setAttribute("uv", new sh($, 2)),
                    er.setAttribute("faceIndex", new sh(ee, 1)),
                    L.push(er),
                    z > 4 && z--;
                }
                return { lodPlanes: L, sizeLods: R, sigmas: N };
              })(F)),
                (this._blurMaterial =
                  ((N = new Float32Array(20)),
                  (z = new iq(0, 1, 0)),
                  new sQ({
                    name: "SphericalGaussianBlur",
                    defines: {
                      n: 20,
                      CUBEUV_TEXEL_WIDTH: 1 / _,
                      CUBEUV_TEXEL_HEIGHT: 1 / L,
                      CUBEUV_MAX_MIP: `${F}.0`,
                    },
                    uniforms: {
                      envMap: { value: null },
                      samples: { value: 1 },
                      weights: { value: N },
                      latitudinal: { value: !1 },
                      dTheta: { value: 0 },
                      mipInt: { value: 0 },
                      poleAxis: { value: z },
                    },
                    vertexShader: y0(),
                    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
                    blending: 0,
                    depthTest: !1,
                    depthWrite: !1,
                  })));
            }
            return N;
          }
          _compileMaterial(_) {
            let L = new sH(this._lodPlanes[0], _);
            this._renderer.compile(L, nh);
          }
          _sceneToCubeUV(_, L, R, N) {
            let z = new sK(90, 1, L, R),
              F = [1, -1, 1, 1, 1, 1],
              U = [1, 1, 1, -1, -1, -1],
              k = this._renderer,
              Y = k.autoClear,
              X = k.toneMapping;
            k.getClearColor(nc), (k.toneMapping = 0), (k.autoClear = !1);
            let Q = new ss({
                name: "PMREM.Background",
                side: 1,
                depthWrite: !1,
                depthTest: !1,
              }),
              K = new sH(new sW(), Q),
              J = !1,
              $ = _.background;
            $
              ? $.isColor && (Q.color.copy($), (_.background = null), (J = !0))
              : (Q.color.copy(nc), (J = !0));
            for (let L = 0; L < 6; L++) {
              let R = L % 3;
              0 === R
                ? (z.up.set(0, F[L], 0), z.lookAt(U[L], 0, 0))
                : 1 === R
                  ? (z.up.set(0, 0, F[L]), z.lookAt(0, U[L], 0))
                  : (z.up.set(0, F[L], 0), z.lookAt(0, 0, U[L]));
              let Y = this._cubeSize;
              Yf(N, R * Y, L > 2 ? Y : 0, Y, Y),
                k.setRenderTarget(N),
                J && k.render(K, z),
                k.render(_, z);
            }
            K.geometry.dispose(),
              K.material.dispose(),
              (k.toneMapping = X),
              (k.autoClear = Y),
              (_.background = $);
          }
          _textureToCubeUV(_, L) {
            let R = this._renderer,
              N = 301 === _.mapping || 302 === _.mapping;
            N
              ? (null === this._cubemapMaterial &&
                  (this._cubemapMaterial = Yw()),
                (this._cubemapMaterial.uniforms.flipEnvMap.value =
                  !1 === _.isRenderTargetTexture ? -1 : 1))
              : null === this._equirectMaterial &&
                (this._equirectMaterial = Xw());
            let z = N ? this._cubemapMaterial : this._equirectMaterial,
              F = new sH(this._lodPlanes[0], z);
            z.uniforms.envMap.value = _;
            let U = this._cubeSize;
            Yf(L, 0, 0, 3 * U, 2 * U), R.setRenderTarget(L), R.render(F, nh);
          }
          _applyPMREM(_) {
            let L = this._renderer,
              R = L.autoClear;
            L.autoClear = !1;
            for (let L = 1; L < this._lodPlanes.length; L++) {
              let R = Math.sqrt(
                  this._sigmas[L] * this._sigmas[L] -
                    this._sigmas[L - 1] * this._sigmas[L - 1],
                ),
                N = nf[(L - 1) % nf.length];
              this._blur(_, L - 1, L, R, N);
            }
            L.autoClear = R;
          }
          _blur(_, L, R, N, z) {
            let F = this._pingPongRenderTarget;
            this._halfBlur(_, F, L, R, N, "latitudinal", z),
              this._halfBlur(F, _, R, R, N, "longitudinal", z);
          }
          _halfBlur(_, L, R, N, z, F, U) {
            let k = this._renderer,
              Y = this._blurMaterial;
            "latitudinal" !== F &&
              "longitudinal" !== F &&
              console.error(
                "blur direction must be either latitudinal or longitudinal!",
              );
            let X = new sH(this._lodPlanes[N], Y),
              Q = Y.uniforms,
              K = this._sizeLods[R] - 1,
              J = isFinite(z) ? Math.PI / (2 * K) : (2 * Math.PI) / 39,
              $ = z / J,
              ee = isFinite(z) ? 1 + Math.floor(3 * $) : 20;
            ee > 20 &&
              console.warn(
                `sigmaRadians, ${z}, is too large and will clip, as it requested ${ee} samples when the maximum is set to 20`,
              );
            let er = [],
              en = 0;
            for (let _ = 0; _ < 20; ++_) {
              let L = _ / $,
                R = Math.exp((-L * L) / 2);
              er.push(R), 0 === _ ? (en += R) : _ < ee && (en += 2 * R);
            }
            for (let _ = 0; _ < er.length; _++) er[_] = er[_] / en;
            (Q.envMap.value = _.texture),
              (Q.samples.value = ee),
              (Q.weights.value = er),
              (Q.latitudinal.value = "latitudinal" === F),
              U && (Q.poleAxis.value = U);
            let { _lodMax: ea } = this;
            (Q.dTheta.value = J), (Q.mipInt.value = ea - R);
            let eo = this._sizeLods[N];
            Yf(
              L,
              3 * eo * (N > ea - 4 ? N - ea + 4 : 0),
              4 * (this._cubeSize - eo),
              3 * eo,
              2 * eo,
            ),
              k.setRenderTarget(L),
              k.render(X, nh);
          }
        };
      function qw(_, L, R) {
        let N = new iH(_, L, R);
        return (
          (N.texture.mapping = 306),
          (N.texture.name = "PMREM.cubeUv"),
          (N.scissorTest = !0),
          N
        );
      }
      function Yf(_, L, R, N, z) {
        _.viewport.set(L, R, N, z), _.scissor.set(L, R, N, z);
      }
      function Xw() {
        return new sQ({
          name: "EquirectangularToCubeUV",
          uniforms: { envMap: { value: null } },
          vertexShader: y0(),
          fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
          blending: 0,
          depthTest: !1,
          depthWrite: !1,
        });
      }
      function Yw() {
        return new sQ({
          name: "CubemapToCubeUV",
          uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
          vertexShader: y0(),
          fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
          blending: 0,
          depthTest: !1,
          depthWrite: !1,
        });
      }
      function y0() {
        return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
      }
      function OR(_) {
        let L = new WeakMap(),
          R = null;
        function s(_) {
          let R = _.target;
          R.removeEventListener("dispose", s);
          let N = L.get(R);
          void 0 !== N && (L.delete(R), N.dispose());
        }
        return {
          get: function (N) {
            if (N && N.isTexture) {
              let z = N.mapping,
                F = 303 === z || 304 === z,
                U = 301 === z || 302 === z;
              if (F || U) {
                if (N.isRenderTargetTexture && !0 === N.needsPMREMUpdate) {
                  N.needsPMREMUpdate = !1;
                  let z = L.get(N);
                  return (
                    null === R && (R = new nm(_)),
                    (z = F ? R.fromEquirectangular(N, z) : R.fromCubemap(N, z)),
                    L.set(N, z),
                    z.texture
                  );
                }
                if (L.has(N)) return L.get(N).texture;
                {
                  let z = N.image;
                  if (
                    !(
                      (F && z && z.height > 0) ||
                      (U &&
                        z &&
                        (function (_) {
                          let L = 0;
                          for (let R = 0; R < 6; R++) void 0 !== _[R] && L++;
                          return 6 === L;
                        })(z))
                    )
                  )
                    return null;
                  {
                    null === R && (R = new nm(_));
                    let z = F ? R.fromEquirectangular(N) : R.fromCubemap(N);
                    return (
                      L.set(N, z), N.addEventListener("dispose", s), z.texture
                    );
                  }
                }
              }
            }
            return N;
          },
          dispose: function () {
            (L = new WeakMap()), null !== R && (R.dispose(), (R = null));
          },
        };
      }
      function LR(_) {
        let L = {};
        function e(R) {
          let N;
          if (void 0 !== L[R]) return L[R];
          switch (R) {
            case "WEBGL_depth_texture":
              N =
                _.getExtension("WEBGL_depth_texture") ||
                _.getExtension("MOZ_WEBGL_depth_texture") ||
                _.getExtension("WEBKIT_WEBGL_depth_texture");
              break;
            case "EXT_texture_filter_anisotropic":
              N =
                _.getExtension("EXT_texture_filter_anisotropic") ||
                _.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
                _.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
              break;
            case "WEBGL_compressed_texture_s3tc":
              N =
                _.getExtension("WEBGL_compressed_texture_s3tc") ||
                _.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
                _.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
              break;
            case "WEBGL_compressed_texture_pvrtc":
              N =
                _.getExtension("WEBGL_compressed_texture_pvrtc") ||
                _.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
              break;
            default:
              N = _.getExtension(R);
          }
          return (L[R] = N), N;
        }
        return {
          has: function (_) {
            return null !== e(_);
          },
          init: function (_) {
            _.isWebGL2
              ? e("EXT_color_buffer_float")
              : (e("WEBGL_depth_texture"),
                e("OES_texture_float"),
                e("OES_texture_half_float"),
                e("OES_texture_half_float_linear"),
                e("OES_standard_derivatives"),
                e("OES_element_index_uint"),
                e("OES_vertex_array_object"),
                e("ANGLE_instanced_arrays")),
              e("OES_texture_float_linear"),
              e("EXT_color_buffer_half_float"),
              e("WEBGL_multisampled_render_to_texture");
          },
          get: function (_) {
            let L = e(_);
            return (
              null === L &&
                console.warn(
                  "THREE.WebGLRenderer: " + _ + " extension not supported.",
                ),
              L
            );
          },
        };
      }
      function RR(_, L, R, N) {
        let z = {},
          F = new WeakMap();
        function o(_) {
          let U = _.target;
          for (let _ in (null !== U.index && L.remove(U.index), U.attributes))
            L.remove(U.attributes[_]);
          U.removeEventListener("dispose", o), delete z[U.id];
          let k = F.get(U);
          k && (L.remove(k), F.delete(U)),
            N.releaseStatesOfGeometry(U),
            !0 === U.isInstancedBufferGeometry && delete U._maxInstanceCount,
            R.memory.geometries--;
        }
        function u(_) {
          let R = [],
            N = _.index,
            z = _.attributes.position,
            U = 0;
          if (null !== N) {
            let _ = N.array;
            U = N.version;
            for (let L = 0, N = _.length; L < N; L += 3) {
              let N = _[L + 0],
                z = _[L + 1],
                F = _[L + 2];
              R.push(N, z, z, F, F, N);
            }
          } else {
            let _ = z.array;
            U = z.version;
            for (let L = 0, N = _.length / 3 - 1; L < N; L += 3) {
              let _ = L + 0,
                N = L + 1,
                z = L + 2;
              R.push(_, N, N, z, z, _);
            }
          }
          let k = new (N1(R) ? sp : sd)(R, 1);
          k.version = U;
          let Y = F.get(_);
          Y && L.remove(Y), F.set(_, k);
        }
        return {
          get: function (_, L) {
            return (
              !0 === z[L.id] ||
                (L.addEventListener("dispose", o),
                (z[L.id] = !0),
                R.memory.geometries++),
              L
            );
          },
          update: function (_) {
            let R = _.attributes;
            for (let _ in R) L.update(R[_], 34962);
            let N = _.morphAttributes;
            for (let _ in N) {
              let R = N[_];
              for (let _ = 0, N = R.length; _ < N; _++) L.update(R[_], 34962);
            }
          },
          getWireframeAttribute: function (_) {
            let L = F.get(_);
            if (L) {
              let R = _.index;
              null !== R && L.version < R.version && u(_);
            } else u(_);
            return F.get(_);
          },
        };
      }
      function NR(_, L, R, N) {
        let z,
          F,
          U = N.isWebGL2,
          k;
        (this.setMode = function (_) {
          k = _;
        }),
          (this.setIndex = function (_) {
            (z = _.type), (F = _.bytesPerElement);
          }),
          (this.render = function (L, N) {
            _.drawElements(k, N, z, L * F), R.update(N, k, 1);
          }),
          (this.renderInstances = function (N, Y, X) {
            let Q, K;
            if (0 !== X) {
              if (U) (Q = _), (K = "drawElementsInstanced");
              else if (
                ((Q = L.get("ANGLE_instanced_arrays")),
                (K = "drawElementsInstancedANGLE"),
                null === Q)
              ) {
                console.error(
                  "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.",
                );
                return;
              }
              Q[K](k, Y, z, N * F, X), R.update(Y, k, X);
            }
          });
      }
      function BR(_) {
        let L = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
        return {
          memory: { geometries: 0, textures: 0 },
          render: L,
          programs: null,
          autoReset: !0,
          reset: function () {
            L.frame++,
              (L.calls = 0),
              (L.triangles = 0),
              (L.points = 0),
              (L.lines = 0);
          },
          update: function (_, R, N) {
            switch ((L.calls++, R)) {
              case 4:
                L.triangles += N * (_ / 3);
                break;
              case 1:
                L.lines += N * (_ / 2);
                break;
              case 3:
                L.lines += N * (_ - 1);
                break;
              case 2:
                L.lines += N * _;
                break;
              case 0:
                L.points += N * _;
                break;
              default:
                console.error("THREE.WebGLInfo: Unknown draw mode:", R);
            }
          },
        };
      }
      function FR(_, L) {
        return _[0] - L[0];
      }
      function UR(_, L) {
        return Math.abs(L[1]) - Math.abs(_[1]);
      }
      function GR(_, L, R) {
        let N = {},
          z = new Float32Array(8),
          F = new WeakMap(),
          U = new iV(),
          k = [];
        for (let _ = 0; _ < 8; _++) k[_] = [_, 0];
        return {
          update: function (Y, X, Q, K) {
            let J = Y.morphTargetInfluences;
            if (!0 === L.isWebGL2) {
              let N =
                  X.morphAttributes.position ||
                  X.morphAttributes.normal ||
                  X.morphAttributes.color,
                z = void 0 !== N ? N.length : 0,
                k = F.get(X);
              if (void 0 === k || k.count !== z) {
                let B = function () {
                  en.dispose(),
                    F.delete(X),
                    X.removeEventListener("dispose", B);
                };
                void 0 !== k && k.texture.dispose();
                let _ = void 0 !== X.morphAttributes.position,
                  R = void 0 !== X.morphAttributes.normal,
                  N = void 0 !== X.morphAttributes.color,
                  Y = X.morphAttributes.position || [],
                  Q = X.morphAttributes.normal || [],
                  K = X.morphAttributes.color || [],
                  J = 0;
                !0 === _ && (J = 1), !0 === R && (J = 2), !0 === N && (J = 3);
                let $ = X.attributes.position.count * J,
                  ee = 1;
                $ > L.maxTextureSize &&
                  ((ee = Math.ceil($ / L.maxTextureSize)),
                  ($ = L.maxTextureSize));
                let er = new Float32Array($ * ee * 4 * z),
                  en = new iW(er, $, ee, z);
                (en.type = 1015), (en.needsUpdate = !0);
                let ea = 4 * J;
                for (let L = 0; L < z; L++) {
                  let z = Y[L],
                    F = Q[L],
                    k = K[L],
                    X = $ * ee * 4 * L;
                  for (let L = 0; L < z.count; L++) {
                    let Y = L * ea;
                    !0 === _ &&
                      (U.fromBufferAttribute(z, L),
                      (er[X + Y + 0] = U.x),
                      (er[X + Y + 1] = U.y),
                      (er[X + Y + 2] = U.z),
                      (er[X + Y + 3] = 0)),
                      !0 === R &&
                        (U.fromBufferAttribute(F, L),
                        (er[X + Y + 4] = U.x),
                        (er[X + Y + 5] = U.y),
                        (er[X + Y + 6] = U.z),
                        (er[X + Y + 7] = 0)),
                      !0 === N &&
                        (U.fromBufferAttribute(k, L),
                        (er[X + Y + 8] = U.x),
                        (er[X + Y + 9] = U.y),
                        (er[X + Y + 10] = U.z),
                        (er[X + Y + 11] = 4 === k.itemSize ? U.w : 1));
                  }
                }
                (k = { count: z, texture: en, size: new iT($, ee) }),
                  F.set(X, k),
                  X.addEventListener("dispose", B);
              }
              let Y = 0;
              for (let _ = 0; _ < J.length; _++) Y += J[_];
              let Q = X.morphTargetsRelative ? 1 : 1 - Y;
              K.getUniforms().setValue(_, "morphTargetBaseInfluence", Q),
                K.getUniforms().setValue(_, "morphTargetInfluences", J),
                K.getUniforms().setValue(
                  _,
                  "morphTargetsTexture",
                  k.texture,
                  R,
                ),
                K.getUniforms().setValue(_, "morphTargetsTextureSize", k.size);
            } else {
              let L = void 0 === J ? 0 : J.length,
                R = N[X.id];
              if (void 0 === R || R.length !== L) {
                R = [];
                for (let _ = 0; _ < L; _++) R[_] = [_, 0];
                N[X.id] = R;
              }
              for (let _ = 0; _ < L; _++) {
                let L = R[_];
                (L[0] = _), (L[1] = J[_]);
              }
              R.sort(UR);
              for (let _ = 0; _ < 8; _++)
                _ < L && R[_][1]
                  ? ((k[_][0] = R[_][0]), (k[_][1] = R[_][1]))
                  : ((k[_][0] = Number.MAX_SAFE_INTEGER), (k[_][1] = 0));
              k.sort(FR);
              let F = X.morphAttributes.position,
                U = X.morphAttributes.normal,
                Y = 0;
              for (let _ = 0; _ < 8; _++) {
                let L = k[_],
                  R = L[0],
                  N = L[1];
                R !== Number.MAX_SAFE_INTEGER && N
                  ? (F &&
                      X.getAttribute("morphTarget" + _) !== F[R] &&
                      X.setAttribute("morphTarget" + _, F[R]),
                    U &&
                      X.getAttribute("morphNormal" + _) !== U[R] &&
                      X.setAttribute("morphNormal" + _, U[R]),
                    (z[_] = N),
                    (Y += N))
                  : (F &&
                      !0 === X.hasAttribute("morphTarget" + _) &&
                      X.deleteAttribute("morphTarget" + _),
                    U &&
                      !0 === X.hasAttribute("morphNormal" + _) &&
                      X.deleteAttribute("morphNormal" + _),
                    (z[_] = 0));
              }
              let Q = X.morphTargetsRelative ? 1 : 1 - Y;
              K.getUniforms().setValue(_, "morphTargetBaseInfluence", Q),
                K.getUniforms().setValue(_, "morphTargetInfluences", z);
            }
          },
        };
      }
      function kR(_, L, R, N) {
        let z = new WeakMap();
        function a(_) {
          let L = _.target;
          L.removeEventListener("dispose", a),
            R.remove(L.instanceMatrix),
            null !== L.instanceColor && R.remove(L.instanceColor);
        }
        return {
          update: function (_) {
            let F = N.render.frame,
              U = _.geometry,
              k = L.get(_, U);
            return (
              z.get(k) !== F && (L.update(k), z.set(k, F)),
              _.isInstancedMesh &&
                (!1 === _.hasEventListener("dispose", a) &&
                  _.addEventListener("dispose", a),
                R.update(_.instanceMatrix, 34962),
                null !== _.instanceColor && R.update(_.instanceColor, 34962)),
              k
            );
          },
          dispose: function () {
            z = new WeakMap();
          },
        };
      }
      var nv = new iG(),
        nw = new iW(),
        n_ = new iY(),
        nS = new s$(),
        nA = [],
        nM = [],
        nE = new Float32Array(16),
        nC = new Float32Array(9),
        nD = new Float32Array(4);
      function tc(_, L, R) {
        let N = _[0];
        if (N <= 0 || N > 0) return _;
        let z = L * R,
          F = nA[z];
        if (
          (void 0 === F && ((F = new Float32Array(z)), (nA[z] = F)), 0 !== L)
        ) {
          N.toArray(F, 0);
          for (let N = 1, z = 0; N !== L; ++N) (z += R), _[N].toArray(F, z);
        }
        return F;
      }
      function En(_, L) {
        if (_.length !== L.length) return !1;
        for (let R = 0, N = _.length; R < N; R++) if (_[R] !== L[R]) return !1;
        return !0;
      }
      function Mn(_, L) {
        for (let R = 0, N = L.length; R < N; R++) _[R] = L[R];
      }
      function Pp(_, L) {
        let R = nM[L];
        void 0 === R && ((R = new Int32Array(L)), (nM[L] = R));
        for (let N = 0; N !== L; ++N) R[N] = _.allocateTextureUnit();
        return R;
      }
      function zR(_, L) {
        let R = this.cache;
        R[0] !== L && (_.uniform1f(this.addr, L), (R[0] = L));
      }
      function VR(_, L) {
        let R = this.cache;
        if (void 0 !== L.x)
          (R[0] !== L.x || R[1] !== L.y) &&
            (_.uniform2f(this.addr, L.x, L.y), (R[0] = L.x), (R[1] = L.y));
        else {
          if (En(R, L)) return;
          _.uniform2fv(this.addr, L), Mn(R, L);
        }
      }
      function HR(_, L) {
        let R = this.cache;
        if (void 0 !== L.x)
          (R[0] !== L.x || R[1] !== L.y || R[2] !== L.z) &&
            (_.uniform3f(this.addr, L.x, L.y, L.z),
            (R[0] = L.x),
            (R[1] = L.y),
            (R[2] = L.z));
        else if (void 0 !== L.r)
          (R[0] !== L.r || R[1] !== L.g || R[2] !== L.b) &&
            (_.uniform3f(this.addr, L.r, L.g, L.b),
            (R[0] = L.r),
            (R[1] = L.g),
            (R[2] = L.b));
        else {
          if (En(R, L)) return;
          _.uniform3fv(this.addr, L), Mn(R, L);
        }
      }
      function WR(_, L) {
        let R = this.cache;
        if (void 0 !== L.x)
          (R[0] !== L.x || R[1] !== L.y || R[2] !== L.z || R[3] !== L.w) &&
            (_.uniform4f(this.addr, L.x, L.y, L.z, L.w),
            (R[0] = L.x),
            (R[1] = L.y),
            (R[2] = L.z),
            (R[3] = L.w));
        else {
          if (En(R, L)) return;
          _.uniform4fv(this.addr, L), Mn(R, L);
        }
      }
      function jR(_, L) {
        let R = this.cache,
          N = L.elements;
        if (void 0 === N) {
          if (En(R, L)) return;
          _.uniformMatrix2fv(this.addr, !1, L), Mn(R, L);
        } else {
          if (En(R, N)) return;
          nD.set(N), _.uniformMatrix2fv(this.addr, !1, nD), Mn(R, N);
        }
      }
      function qR(_, L) {
        let R = this.cache,
          N = L.elements;
        if (void 0 === N) {
          if (En(R, L)) return;
          _.uniformMatrix3fv(this.addr, !1, L), Mn(R, L);
        } else {
          if (En(R, N)) return;
          nC.set(N), _.uniformMatrix3fv(this.addr, !1, nC), Mn(R, N);
        }
      }
      function XR(_, L) {
        let R = this.cache,
          N = L.elements;
        if (void 0 === N) {
          if (En(R, L)) return;
          _.uniformMatrix4fv(this.addr, !1, L), Mn(R, L);
        } else {
          if (En(R, N)) return;
          nE.set(N), _.uniformMatrix4fv(this.addr, !1, nE), Mn(R, N);
        }
      }
      function YR(_, L) {
        let R = this.cache;
        R[0] !== L && (_.uniform1i(this.addr, L), (R[0] = L));
      }
      function KR(_, L) {
        let R = this.cache;
        if (void 0 !== L.x)
          (R[0] !== L.x || R[1] !== L.y) &&
            (_.uniform2i(this.addr, L.x, L.y), (R[0] = L.x), (R[1] = L.y));
        else {
          if (En(R, L)) return;
          _.uniform2iv(this.addr, L), Mn(R, L);
        }
      }
      function ZR(_, L) {
        let R = this.cache;
        if (void 0 !== L.x)
          (R[0] !== L.x || R[1] !== L.y || R[2] !== L.z) &&
            (_.uniform3i(this.addr, L.x, L.y, L.z),
            (R[0] = L.x),
            (R[1] = L.y),
            (R[2] = L.z));
        else {
          if (En(R, L)) return;
          _.uniform3iv(this.addr, L), Mn(R, L);
        }
      }
      function QR(_, L) {
        let R = this.cache;
        if (void 0 !== L.x)
          (R[0] !== L.x || R[1] !== L.y || R[2] !== L.z || R[3] !== L.w) &&
            (_.uniform4i(this.addr, L.x, L.y, L.z, L.w),
            (R[0] = L.x),
            (R[1] = L.y),
            (R[2] = L.z),
            (R[3] = L.w));
        else {
          if (En(R, L)) return;
          _.uniform4iv(this.addr, L), Mn(R, L);
        }
      }
      function JR(_, L) {
        let R = this.cache;
        R[0] !== L && (_.uniform1ui(this.addr, L), (R[0] = L));
      }
      function $R(_, L) {
        let R = this.cache;
        if (void 0 !== L.x)
          (R[0] !== L.x || R[1] !== L.y) &&
            (_.uniform2ui(this.addr, L.x, L.y), (R[0] = L.x), (R[1] = L.y));
        else {
          if (En(R, L)) return;
          _.uniform2uiv(this.addr, L), Mn(R, L);
        }
      }
      function e3(_, L) {
        let R = this.cache;
        if (void 0 !== L.x)
          (R[0] !== L.x || R[1] !== L.y || R[2] !== L.z) &&
            (_.uniform3ui(this.addr, L.x, L.y, L.z),
            (R[0] = L.x),
            (R[1] = L.y),
            (R[2] = L.z));
        else {
          if (En(R, L)) return;
          _.uniform3uiv(this.addr, L), Mn(R, L);
        }
      }
      function t3(_, L) {
        let R = this.cache;
        if (void 0 !== L.x)
          (R[0] !== L.x || R[1] !== L.y || R[2] !== L.z || R[3] !== L.w) &&
            (_.uniform4ui(this.addr, L.x, L.y, L.z, L.w),
            (R[0] = L.x),
            (R[1] = L.y),
            (R[2] = L.z),
            (R[3] = L.w));
        else {
          if (En(R, L)) return;
          _.uniform4uiv(this.addr, L), Mn(R, L);
        }
      }
      function n3(_, L, R) {
        let N = this.cache,
          z = R.allocateTextureUnit();
        N[0] !== z && (_.uniform1i(this.addr, z), (N[0] = z)),
          R.setTexture2D(L || nv, z);
      }
      function r3(_, L, R) {
        let N = this.cache,
          z = R.allocateTextureUnit();
        N[0] !== z && (_.uniform1i(this.addr, z), (N[0] = z)),
          R.setTexture3D(L || n_, z);
      }
      function i3(_, L, R) {
        let N = this.cache,
          z = R.allocateTextureUnit();
        N[0] !== z && (_.uniform1i(this.addr, z), (N[0] = z)),
          R.setTextureCube(L || nS, z);
      }
      function s3(_, L, R) {
        let N = this.cache,
          z = R.allocateTextureUnit();
        N[0] !== z && (_.uniform1i(this.addr, z), (N[0] = z)),
          R.setTexture2DArray(L || nw, z);
      }
      function a3(_, L) {
        _.uniform1fv(this.addr, L);
      }
      function l3(_, L) {
        let R = tc(L, this.size, 2);
        _.uniform2fv(this.addr, R);
      }
      function c3(_, L) {
        let R = tc(L, this.size, 3);
        _.uniform3fv(this.addr, R);
      }
      function u3(_, L) {
        let R = tc(L, this.size, 4);
        _.uniform4fv(this.addr, R);
      }
      function d3(_, L) {
        let R = tc(L, this.size, 4);
        _.uniformMatrix2fv(this.addr, !1, R);
      }
      function h3(_, L) {
        let R = tc(L, this.size, 9);
        _.uniformMatrix3fv(this.addr, !1, R);
      }
      function f3(_, L) {
        let R = tc(L, this.size, 16);
        _.uniformMatrix4fv(this.addr, !1, R);
      }
      function p3(_, L) {
        _.uniform1iv(this.addr, L);
      }
      function m3(_, L) {
        _.uniform2iv(this.addr, L);
      }
      function g3(_, L) {
        _.uniform3iv(this.addr, L);
      }
      function y3(_, L) {
        _.uniform4iv(this.addr, L);
      }
      function v3(_, L) {
        _.uniform1uiv(this.addr, L);
      }
      function x3(_, L) {
        _.uniform2uiv(this.addr, L);
      }
      function b3(_, L) {
        _.uniform3uiv(this.addr, L);
      }
      function S3(_, L) {
        _.uniform4uiv(this.addr, L);
      }
      function w3(_, L, R) {
        let N = this.cache,
          z = L.length,
          F = Pp(R, z);
        En(N, F) || (_.uniform1iv(this.addr, F), Mn(N, F));
        for (let _ = 0; _ !== z; ++_) R.setTexture2D(L[_] || nv, F[_]);
      }
      function A3(_, L, R) {
        let N = this.cache,
          z = L.length,
          F = Pp(R, z);
        En(N, F) || (_.uniform1iv(this.addr, F), Mn(N, F));
        for (let _ = 0; _ !== z; ++_) R.setTexture3D(L[_] || n_, F[_]);
      }
      function _3(_, L, R) {
        let N = this.cache,
          z = L.length,
          F = Pp(R, z);
        En(N, F) || (_.uniform1iv(this.addr, F), Mn(N, F));
        for (let _ = 0; _ !== z; ++_) R.setTextureCube(L[_] || nS, F[_]);
      }
      function T3(_, L, R) {
        let N = this.cache,
          z = L.length,
          F = Pp(R, z);
        En(N, F) || (_.uniform1iv(this.addr, F), Mn(N, F));
        for (let _ = 0; _ !== z; ++_) R.setTexture2DArray(L[_] || nw, F[_]);
      }
      var nO = class {
          constructor(_, L, R) {
            (this.id = _),
              (this.addr = R),
              (this.cache = []),
              (this.setValue = (function (_) {
                switch (_) {
                  case 5126:
                    return zR;
                  case 35664:
                    return VR;
                  case 35665:
                    return HR;
                  case 35666:
                    return WR;
                  case 35674:
                    return jR;
                  case 35675:
                    return qR;
                  case 35676:
                    return XR;
                  case 5124:
                  case 35670:
                    return YR;
                  case 35667:
                  case 35671:
                    return KR;
                  case 35668:
                  case 35672:
                    return ZR;
                  case 35669:
                  case 35673:
                    return QR;
                  case 5125:
                    return JR;
                  case 36294:
                    return $R;
                  case 36295:
                    return e3;
                  case 36296:
                    return t3;
                  case 35678:
                  case 36198:
                  case 36298:
                  case 36306:
                  case 35682:
                    return n3;
                  case 35679:
                  case 36299:
                  case 36307:
                    return r3;
                  case 35680:
                  case 36300:
                  case 36308:
                  case 36293:
                    return i3;
                  case 36289:
                  case 36303:
                  case 36311:
                  case 36292:
                    return s3;
                }
              })(L.type));
          }
        },
        nL = class {
          constructor(_, L, R) {
            (this.id = _),
              (this.addr = R),
              (this.cache = []),
              (this.size = L.size),
              (this.setValue = (function (_) {
                switch (_) {
                  case 5126:
                    return a3;
                  case 35664:
                    return l3;
                  case 35665:
                    return c3;
                  case 35666:
                    return u3;
                  case 35674:
                    return d3;
                  case 35675:
                    return h3;
                  case 35676:
                    return f3;
                  case 5124:
                  case 35670:
                    return p3;
                  case 35667:
                  case 35671:
                    return m3;
                  case 35668:
                  case 35672:
                    return g3;
                  case 35669:
                  case 35673:
                    return y3;
                  case 5125:
                    return v3;
                  case 36294:
                    return x3;
                  case 36295:
                    return b3;
                  case 36296:
                    return S3;
                  case 35678:
                  case 36198:
                  case 36298:
                  case 36306:
                  case 35682:
                    return w3;
                  case 35679:
                  case 36299:
                  case 36307:
                    return A3;
                  case 35680:
                  case 36300:
                  case 36308:
                  case 36293:
                    return _3;
                  case 36289:
                  case 36303:
                  case 36311:
                  case 36292:
                    return T3;
                }
              })(L.type));
          }
        },
        nR = class {
          constructor(_) {
            (this.id = _), (this.seq = []), (this.map = {});
          }
          setValue(_, L, R) {
            let N = this.seq;
            for (let z = 0, F = N.length; z !== F; ++z) {
              let F = N[z];
              F.setValue(_, L[F.id], R);
            }
          }
        },
        nI = /(\w+)(\])?(\[|\.)?/g;
      function e1(_, L) {
        _.seq.push(L), (_.map[L.id] = L);
      }
      var nB = class {
        constructor(_, L) {
          (this.seq = []), (this.map = {});
          let R = _.getProgramParameter(L, 35718);
          for (let N = 0; N < R; ++N) {
            let R = _.getActiveUniform(L, N),
              z = _.getUniformLocation(L, R.name);
            !(function (_, L, R) {
              let N = _.name,
                z = N.length;
              for (nI.lastIndex = 0; ; ) {
                let F = nI.exec(N),
                  U = nI.lastIndex,
                  k = F[1],
                  Y = "]" === F[2],
                  X = F[3];
                if (
                  (Y && (k |= 0), void 0 === X || ("[" === X && U + 2 === z))
                ) {
                  e1(R, void 0 === X ? new nO(k, _, L) : new nL(k, _, L));
                  break;
                }
                {
                  let _ = R.map[k];
                  void 0 === _ && e1(R, (_ = new nR(k))), (R = _);
                }
              }
            })(R, z, this);
          }
        }
        setValue(_, L, R, N) {
          let z = this.map[L];
          void 0 !== z && z.setValue(_, R, N);
        }
        setOptional(_, L, R) {
          let N = L[R];
          void 0 !== N && this.setValue(_, R, N);
        }
        static upload(_, L, R, N) {
          for (let z = 0, F = L.length; z !== F; ++z) {
            let F = L[z],
              U = R[F.id];
            !1 !== U.needsUpdate && F.setValue(_, U.value, N);
          }
        }
        static seqWithValue(_, L) {
          let R = [];
          for (let N = 0, z = _.length; N !== z; ++N) {
            let z = _[N];
            z.id in L && R.push(z);
          }
          return R;
        }
      };
      function t1(_, L, R) {
        let N = _.createShader(L);
        return _.shaderSource(N, R), _.compileShader(N), N;
      }
      var nz = 0;
      function n1(_, L, R) {
        let N = _.getShaderParameter(L, 35713),
          z = _.getShaderInfoLog(L).trim();
        if (N && "" === z) return "";
        let F = /ERROR: 0:(\d+)/.exec(z);
        if (!F) return z;
        {
          let N = parseInt(F[1]);
          return (
            R.toUpperCase() +
            `

` +
            z +
            `

` +
            (function (_, L) {
              let R = _.split(`
`),
                N = [],
                z = Math.max(L - 6, 0),
                F = Math.min(L + 6, R.length);
              for (let _ = z; _ < F; _++) {
                let z = _ + 1;
                N.push(`${z === L ? ">" : " "} ${z}: ${R[_]}`);
              }
              return N.join(`
`);
            })(_.getShaderSource(L), N)
          );
        }
      }
      function Sd(_) {
        return "" !== _;
      }
      function r1(_, L) {
        let R =
          L.numSpotLightShadows +
          L.numSpotLightMaps -
          L.numSpotLightShadowsWithMaps;
        return _.replace(/NUM_DIR_LIGHTS/g, L.numDirLights)
          .replace(/NUM_SPOT_LIGHTS/g, L.numSpotLights)
          .replace(/NUM_SPOT_LIGHT_MAPS/g, L.numSpotLightMaps)
          .replace(/NUM_SPOT_LIGHT_COORDS/g, R)
          .replace(/NUM_RECT_AREA_LIGHTS/g, L.numRectAreaLights)
          .replace(/NUM_POINT_LIGHTS/g, L.numPointLights)
          .replace(/NUM_HEMI_LIGHTS/g, L.numHemiLights)
          .replace(/NUM_DIR_LIGHT_SHADOWS/g, L.numDirLightShadows)
          .replace(
            /NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,
            L.numSpotLightShadowsWithMaps,
          )
          .replace(/NUM_SPOT_LIGHT_SHADOWS/g, L.numSpotLightShadows)
          .replace(/NUM_POINT_LIGHT_SHADOWS/g, L.numPointLightShadows);
      }
      function i1(_, L) {
        return _.replace(/NUM_CLIPPING_PLANES/g, L.numClippingPlanes).replace(
          /UNION_CLIPPING_PLANES/g,
          L.numClippingPlanes - L.numClipIntersection,
        );
      }
      var nF = /^[ \t]*#include +<([\w\d./]+)>/gm;
      function Vv(_) {
        return _.replace(nF, F3);
      }
      function F3(_, L) {
        let R = nt[L];
        if (void 0 === R) throw Error("Can not resolve #include <" + L + ">");
        return Vv(R);
      }
      var nU =
        /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
      function s1(_) {
        return _.replace(nU, G3);
      }
      function G3(_, L, R, N) {
        let z = "";
        for (let _ = parseInt(L); _ < parseInt(R); _++)
          z += N.replace(/\[\s*i\s*\]/g, "[ " + _ + " ]").replace(
            /UNROLLED_LOOP_INDEX/g,
            _,
          );
        return z;
      }
      function o1(_) {
        let L =
          "precision " +
          _.precision +
          ` float;
precision ` +
          _.precision +
          " int;";
        return (
          "highp" === _.precision
            ? (L += `
#define HIGH_PRECISION`)
            : "mediump" === _.precision
              ? (L += `
#define MEDIUM_PRECISION`)
              : "lowp" === _.precision &&
                (L += `
#define LOW_PRECISION`),
          L
        );
      }
      function j3(_, L, R, N) {
        let z, F, U;
        let k,
          Y,
          X = _.getContext(),
          Q = R.defines,
          K = R.vertexShader,
          J = R.fragmentShader,
          $ =
            ((z = "SHADOWMAP_TYPE_BASIC"),
            1 === R.shadowMapType
              ? (z = "SHADOWMAP_TYPE_PCF")
              : 2 === R.shadowMapType
                ? (z = "SHADOWMAP_TYPE_PCF_SOFT")
                : 3 === R.shadowMapType && (z = "SHADOWMAP_TYPE_VSM"),
            z),
          ee = (function (_) {
            let L = "ENVMAP_TYPE_CUBE";
            if (_.envMap)
              switch (_.envMapMode) {
                case 301:
                case 302:
                  L = "ENVMAP_TYPE_CUBE";
                  break;
                case 306:
                  L = "ENVMAP_TYPE_CUBE_UV";
              }
            return L;
          })(R),
          er =
            ((F = "ENVMAP_MODE_REFLECTION"),
            R.envMap && 302 === R.envMapMode && (F = "ENVMAP_MODE_REFRACTION"),
            F),
          en = (function (_) {
            let L = "ENVMAP_BLENDING_NONE";
            if (_.envMap)
              switch (_.combine) {
                case 0:
                  L = "ENVMAP_BLENDING_MULTIPLY";
                  break;
                case 1:
                  L = "ENVMAP_BLENDING_MIX";
                  break;
                case 2:
                  L = "ENVMAP_BLENDING_ADD";
              }
            return L;
          })(R),
          ea = (function (_) {
            let L = _.envMapCubeUVHeight;
            if (null === L) return null;
            let R = Math.log2(L) - 2;
            return {
              texelWidth: 1 / (3 * Math.max(Math.pow(2, R), 112)),
              texelHeight: 1 / L,
              maxMip: R,
            };
          })(R),
          eo = R.isWebGL2
            ? ""
            : [
                R.extensionDerivatives ||
                R.envMapCubeUVHeight ||
                R.bumpMap ||
                R.tangentSpaceNormalMap ||
                R.clearcoatNormalMap ||
                R.flatShading ||
                "physical" === R.shaderID
                  ? "#extension GL_OES_standard_derivatives : enable"
                  : "",
                (R.extensionFragDepth || R.logarithmicDepthBuffer) &&
                R.rendererExtensionFragDepth
                  ? "#extension GL_EXT_frag_depth : enable"
                  : "",
                R.extensionDrawBuffers && R.rendererExtensionDrawBuffers
                  ? "#extension GL_EXT_draw_buffers : require"
                  : "",
                (R.extensionShaderTextureLOD || R.envMap || R.transmission) &&
                R.rendererExtensionShaderTextureLod
                  ? "#extension GL_EXT_shader_texture_lod : enable"
                  : "",
              ].filter(Sd).join(`
`),
          el = (function (_) {
            let L = [];
            for (let R in _) {
              let N = _[R];
              !1 !== N && L.push("#define " + R + " " + N);
            }
            return L.join(`
`);
          })(Q),
          ec = X.createProgram(),
          ed,
          eu,
          ep = R.glslVersion
            ? "#version " +
              R.glslVersion +
              `
`
            : "";
        R.isRawShaderMaterial
          ? ((ed = [el].filter(Sd).join(`
`)).length > 0 &&
              (ed += `
`),
            (eu = [eo, el].filter(Sd).join(`
`)).length > 0 &&
              (eu += `
`))
          : ((ed = [
              o1(R),
              "#define SHADER_NAME " + R.shaderName,
              el,
              R.instancing ? "#define USE_INSTANCING" : "",
              R.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
              R.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
              R.useFog && R.fog ? "#define USE_FOG" : "",
              R.useFog && R.fogExp2 ? "#define FOG_EXP2" : "",
              R.map ? "#define USE_MAP" : "",
              R.envMap ? "#define USE_ENVMAP" : "",
              R.envMap ? "#define " + er : "",
              R.lightMap ? "#define USE_LIGHTMAP" : "",
              R.aoMap ? "#define USE_AOMAP" : "",
              R.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
              R.bumpMap ? "#define USE_BUMPMAP" : "",
              R.normalMap ? "#define USE_NORMALMAP" : "",
              R.normalMap && R.objectSpaceNormalMap
                ? "#define OBJECTSPACE_NORMALMAP"
                : "",
              R.normalMap && R.tangentSpaceNormalMap
                ? "#define TANGENTSPACE_NORMALMAP"
                : "",
              R.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
              R.clearcoatRoughnessMap
                ? "#define USE_CLEARCOAT_ROUGHNESSMAP"
                : "",
              R.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
              R.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
              R.iridescenceThicknessMap
                ? "#define USE_IRIDESCENCE_THICKNESSMAP"
                : "",
              R.displacementMap && R.supportsVertexTextures
                ? "#define USE_DISPLACEMENTMAP"
                : "",
              R.specularMap ? "#define USE_SPECULARMAP" : "",
              R.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
              R.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
              R.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
              R.metalnessMap ? "#define USE_METALNESSMAP" : "",
              R.alphaMap ? "#define USE_ALPHAMAP" : "",
              R.transmission ? "#define USE_TRANSMISSION" : "",
              R.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
              R.thicknessMap ? "#define USE_THICKNESSMAP" : "",
              R.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
              R.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
              R.vertexTangents ? "#define USE_TANGENT" : "",
              R.vertexColors ? "#define USE_COLOR" : "",
              R.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
              R.vertexUvs ? "#define USE_UV" : "",
              R.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
              R.flatShading ? "#define FLAT_SHADED" : "",
              R.skinning ? "#define USE_SKINNING" : "",
              R.morphTargets ? "#define USE_MORPHTARGETS" : "",
              R.morphNormals && !1 === R.flatShading
                ? "#define USE_MORPHNORMALS"
                : "",
              R.morphColors && R.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
              R.morphTargetsCount > 0 && R.isWebGL2
                ? "#define MORPHTARGETS_TEXTURE"
                : "",
              R.morphTargetsCount > 0 && R.isWebGL2
                ? "#define MORPHTARGETS_TEXTURE_STRIDE " + R.morphTextureStride
                : "",
              R.morphTargetsCount > 0 && R.isWebGL2
                ? "#define MORPHTARGETS_COUNT " + R.morphTargetsCount
                : "",
              R.doubleSided ? "#define DOUBLE_SIDED" : "",
              R.flipSided ? "#define FLIP_SIDED" : "",
              R.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
              R.shadowMapEnabled ? "#define " + $ : "",
              R.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
              R.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
              R.logarithmicDepthBuffer && R.rendererExtensionFragDepth
                ? "#define USE_LOGDEPTHBUF_EXT"
                : "",
              "uniform mat4 modelMatrix;",
              "uniform mat4 modelViewMatrix;",
              "uniform mat4 projectionMatrix;",
              "uniform mat4 viewMatrix;",
              "uniform mat3 normalMatrix;",
              "uniform vec3 cameraPosition;",
              "uniform bool isOrthographic;",
              "#ifdef USE_INSTANCING",
              "	attribute mat4 instanceMatrix;",
              "#endif",
              "#ifdef USE_INSTANCING_COLOR",
              "	attribute vec3 instanceColor;",
              "#endif",
              "attribute vec3 position;",
              "attribute vec3 normal;",
              "attribute vec2 uv;",
              "#ifdef USE_TANGENT",
              "	attribute vec4 tangent;",
              "#endif",
              "#if defined( USE_COLOR_ALPHA )",
              "	attribute vec4 color;",
              "#elif defined( USE_COLOR )",
              "	attribute vec3 color;",
              "#endif",
              "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
              "	attribute vec3 morphTarget0;",
              "	attribute vec3 morphTarget1;",
              "	attribute vec3 morphTarget2;",
              "	attribute vec3 morphTarget3;",
              "	#ifdef USE_MORPHNORMALS",
              "		attribute vec3 morphNormal0;",
              "		attribute vec3 morphNormal1;",
              "		attribute vec3 morphNormal2;",
              "		attribute vec3 morphNormal3;",
              "	#else",
              "		attribute vec3 morphTarget4;",
              "		attribute vec3 morphTarget5;",
              "		attribute vec3 morphTarget6;",
              "		attribute vec3 morphTarget7;",
              "	#endif",
              "#endif",
              "#ifdef USE_SKINNING",
              "	attribute vec4 skinIndex;",
              "	attribute vec4 skinWeight;",
              "#endif",
              `
`,
            ].filter(Sd).join(`
`)),
            (eu = [
              eo,
              o1(R),
              "#define SHADER_NAME " + R.shaderName,
              el,
              R.useFog && R.fog ? "#define USE_FOG" : "",
              R.useFog && R.fogExp2 ? "#define FOG_EXP2" : "",
              R.map ? "#define USE_MAP" : "",
              R.matcap ? "#define USE_MATCAP" : "",
              R.envMap ? "#define USE_ENVMAP" : "",
              R.envMap ? "#define " + ee : "",
              R.envMap ? "#define " + er : "",
              R.envMap ? "#define " + en : "",
              ea ? "#define CUBEUV_TEXEL_WIDTH " + ea.texelWidth : "",
              ea ? "#define CUBEUV_TEXEL_HEIGHT " + ea.texelHeight : "",
              ea ? "#define CUBEUV_MAX_MIP " + ea.maxMip + ".0" : "",
              R.lightMap ? "#define USE_LIGHTMAP" : "",
              R.aoMap ? "#define USE_AOMAP" : "",
              R.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
              R.bumpMap ? "#define USE_BUMPMAP" : "",
              R.normalMap ? "#define USE_NORMALMAP" : "",
              R.normalMap && R.objectSpaceNormalMap
                ? "#define OBJECTSPACE_NORMALMAP"
                : "",
              R.normalMap && R.tangentSpaceNormalMap
                ? "#define TANGENTSPACE_NORMALMAP"
                : "",
              R.clearcoat ? "#define USE_CLEARCOAT" : "",
              R.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
              R.clearcoatRoughnessMap
                ? "#define USE_CLEARCOAT_ROUGHNESSMAP"
                : "",
              R.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
              R.iridescence ? "#define USE_IRIDESCENCE" : "",
              R.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
              R.iridescenceThicknessMap
                ? "#define USE_IRIDESCENCE_THICKNESSMAP"
                : "",
              R.specularMap ? "#define USE_SPECULARMAP" : "",
              R.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
              R.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
              R.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
              R.metalnessMap ? "#define USE_METALNESSMAP" : "",
              R.alphaMap ? "#define USE_ALPHAMAP" : "",
              R.alphaTest ? "#define USE_ALPHATEST" : "",
              R.sheen ? "#define USE_SHEEN" : "",
              R.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
              R.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
              R.transmission ? "#define USE_TRANSMISSION" : "",
              R.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
              R.thicknessMap ? "#define USE_THICKNESSMAP" : "",
              R.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
              R.vertexTangents ? "#define USE_TANGENT" : "",
              R.vertexColors || R.instancingColor ? "#define USE_COLOR" : "",
              R.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
              R.vertexUvs ? "#define USE_UV" : "",
              R.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
              R.gradientMap ? "#define USE_GRADIENTMAP" : "",
              R.flatShading ? "#define FLAT_SHADED" : "",
              R.doubleSided ? "#define DOUBLE_SIDED" : "",
              R.flipSided ? "#define FLIP_SIDED" : "",
              R.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
              R.shadowMapEnabled ? "#define " + $ : "",
              R.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
              R.physicallyCorrectLights
                ? "#define PHYSICALLY_CORRECT_LIGHTS"
                : "",
              R.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
              R.logarithmicDepthBuffer && R.rendererExtensionFragDepth
                ? "#define USE_LOGDEPTHBUF_EXT"
                : "",
              "uniform mat4 viewMatrix;",
              "uniform vec3 cameraPosition;",
              "uniform bool isOrthographic;",
              0 !== R.toneMapping ? "#define TONE_MAPPING" : "",
              0 !== R.toneMapping ? nt.tonemapping_pars_fragment : "",
              0 !== R.toneMapping
                ? (function (_, L) {
                    let R;
                    switch (L) {
                      case 1:
                        R = "Linear";
                        break;
                      case 2:
                        R = "Reinhard";
                        break;
                      case 3:
                        R = "OptimizedCineon";
                        break;
                      case 4:
                        R = "ACESFilmic";
                        break;
                      case 5:
                        R = "Custom";
                        break;
                      default:
                        console.warn(
                          "THREE.WebGLProgram: Unsupported toneMapping:",
                          L,
                        ),
                          (R = "Linear");
                    }
                    return (
                      "vec3 " +
                      _ +
                      "( vec3 color ) { return " +
                      R +
                      "ToneMapping( color ); }"
                    );
                  })("toneMapping", R.toneMapping)
                : "",
              R.dithering ? "#define DITHERING" : "",
              R.opaque ? "#define OPAQUE" : "",
              nt.encodings_pars_fragment,
              "vec4 linearToOutputTexel( vec4 value ) { return LinearTo" +
                (U = (function (_) {
                  switch (_) {
                    case 3e3:
                      return ["Linear", "( value )"];
                    case 3001:
                      return ["sRGB", "( value )"];
                    default:
                      return (
                        console.warn(
                          "THREE.WebGLProgram: Unsupported encoding:",
                          _,
                        ),
                        ["Linear", "( value )"]
                      );
                  }
                })(R.outputEncoding))[0] +
                U[1] +
                "; }",
              R.useDepthPacking
                ? "#define DEPTH_PACKING " + R.depthPacking
                : "",
              `
`,
            ].filter(Sd).join(`
`))),
          (K = i1((K = r1((K = Vv(K)), R)), R)),
          (J = i1((J = r1((J = Vv(J)), R)), R)),
          (K = s1(K)),
          (J = s1(J)),
          R.isWebGL2 &&
            !0 !== R.isRawShaderMaterial &&
            ((ep = `#version 300 es
`),
            (ed =
              [
                "precision mediump sampler2DArray;",
                "#define attribute in",
                "#define varying out",
                "#define texture2D texture",
              ].join(`
`) +
              `
` +
              ed),
            (eu =
              [
                "#define varying in",
                R.glslVersion === ip
                  ? ""
                  : "layout(location = 0) out highp vec4 pc_fragColor;",
                R.glslVersion === ip ? "" : "#define gl_FragColor pc_fragColor",
                "#define gl_FragDepthEXT gl_FragDepth",
                "#define texture2D texture",
                "#define textureCube texture",
                "#define texture2DProj textureProj",
                "#define texture2DLodEXT textureLod",
                "#define texture2DProjLodEXT textureProjLod",
                "#define textureCubeLodEXT textureLod",
                "#define texture2DGradEXT textureGrad",
                "#define texture2DProjGradEXT textureProjGrad",
                "#define textureCubeGradEXT textureGrad",
              ].join(`
`) +
              `
` +
              eu));
        let ef = ep + ed + K,
          ev = ep + eu + J,
          ex = t1(X, 35633, ef),
          eb = t1(X, 35632, ev);
        if (
          (X.attachShader(ec, ex),
          X.attachShader(ec, eb),
          void 0 !== R.index0AttributeName
            ? X.bindAttribLocation(ec, 0, R.index0AttributeName)
            : !0 === R.morphTargets && X.bindAttribLocation(ec, 0, "position"),
          X.linkProgram(ec),
          _.debug.checkShaderErrors)
        ) {
          let _ = X.getProgramInfoLog(ec).trim(),
            L = X.getShaderInfoLog(ex).trim(),
            R = X.getShaderInfoLog(eb).trim(),
            N = !0,
            z = !0;
          if (!1 === X.getProgramParameter(ec, 35714)) {
            N = !1;
            let L = n1(X, ex, "vertex"),
              R = n1(X, eb, "fragment");
            console.error(
              "THREE.WebGLProgram: Shader Error " +
                X.getError() +
                " - VALIDATE_STATUS " +
                X.getProgramParameter(ec, 35715) +
                `

Program Info Log: ` +
                _ +
                `
` +
                L +
                `
` +
                R,
            );
          } else
            "" !== _
              ? console.warn("THREE.WebGLProgram: Program Info Log:", _)
              : ("" === L || "" === R) && (z = !1);
          z &&
            (this.diagnostics = {
              runnable: N,
              programLog: _,
              vertexShader: { log: L, prefix: ed },
              fragmentShader: { log: R, prefix: eu },
            });
        }
        return (
          X.deleteShader(ex),
          X.deleteShader(eb),
          (this.getUniforms = function () {
            return void 0 === k && (k = new nB(X, ec)), k;
          }),
          (this.getAttributes = function () {
            return (
              void 0 === Y &&
                (Y = (function (_, L) {
                  let R = {},
                    N = _.getProgramParameter(L, 35721);
                  for (let z = 0; z < N; z++) {
                    let N = _.getActiveAttrib(L, z),
                      F = N.name,
                      U = 1;
                    35674 === N.type && (U = 2),
                      35675 === N.type && (U = 3),
                      35676 === N.type && (U = 4),
                      (R[F] = {
                        type: N.type,
                        location: _.getAttribLocation(L, F),
                        locationSize: U,
                      });
                  }
                  return R;
                })(X, ec)),
              Y
            );
          }),
          (this.destroy = function () {
            N.releaseStatesOfProgram(this),
              X.deleteProgram(ec),
              (this.program = void 0);
          }),
          (this.name = R.shaderName),
          (this.id = nz++),
          (this.cacheKey = L),
          (this.usedTimes = 1),
          (this.program = ec),
          (this.vertexShader = ex),
          (this.fragmentShader = eb),
          this
        );
      }
      var nk = 0,
        nj = class {
          constructor() {
            (this.shaderCache = new Map()), (this.materialCache = new Map());
          }
          update(_) {
            let L = _.vertexShader,
              R = _.fragmentShader,
              N = this._getShaderStage(L),
              z = this._getShaderStage(R),
              F = this._getShaderCacheForMaterial(_);
            return (
              !1 === F.has(N) && (F.add(N), N.usedTimes++),
              !1 === F.has(z) && (F.add(z), z.usedTimes++),
              this
            );
          }
          remove(_) {
            for (let L of this.materialCache.get(_))
              L.usedTimes--,
                0 === L.usedTimes && this.shaderCache.delete(L.code);
            return this.materialCache.delete(_), this;
          }
          getVertexShaderID(_) {
            return this._getShaderStage(_.vertexShader).id;
          }
          getFragmentShaderID(_) {
            return this._getShaderStage(_.fragmentShader).id;
          }
          dispose() {
            this.shaderCache.clear(), this.materialCache.clear();
          }
          _getShaderCacheForMaterial(_) {
            let L = this.materialCache,
              R = L.get(_);
            return void 0 === R && ((R = new Set()), L.set(_, R)), R;
          }
          _getShaderStage(_) {
            let L = this.shaderCache,
              R = L.get(_);
            return void 0 === R && ((R = new nG(_)), L.set(_, R)), R;
          }
        },
        nG = class {
          constructor(_) {
            (this.id = nk++), (this.code = _), (this.usedTimes = 0);
          }
        };
      function X3(_, L, R, N, z, F, U) {
        let k = new rz(),
          Y = new nj(),
          X = [],
          Q = z.isWebGL2,
          K = z.logarithmicDepthBuffer,
          J = z.vertexTextures,
          $ = z.precision,
          ee = {
            MeshDepthMaterial: "depth",
            MeshDistanceMaterial: "distanceRGBA",
            MeshNormalMaterial: "normal",
            MeshBasicMaterial: "basic",
            MeshLambertMaterial: "lambert",
            MeshPhongMaterial: "phong",
            MeshToonMaterial: "toon",
            MeshStandardMaterial: "physical",
            MeshPhysicalMaterial: "physical",
            MeshMatcapMaterial: "matcap",
            LineBasicMaterial: "basic",
            LineDashedMaterial: "dashed",
            PointsMaterial: "points",
            ShadowMaterial: "shadow",
            SpriteMaterial: "sprite",
          };
        return {
          getParameters: function (F, k, X, er, en) {
            let ea,
              eo,
              el,
              ec,
              ed = er.fog,
              eu = en.geometry,
              ep = F.isMeshStandardMaterial ? er.environment : null,
              ef = (F.isMeshStandardMaterial ? R : L).get(F.envMap || ep),
              ev = ef && 306 === ef.mapping ? ef.image.height : null,
              ex = ee[F.type];
            null !== F.precision &&
              ($ = z.getMaxPrecision(F.precision)) !== F.precision &&
              console.warn(
                "THREE.WebGLProgram.getParameters:",
                F.precision,
                "not supported, using",
                $,
                "instead.",
              );
            let eb =
                eu.morphAttributes.position ||
                eu.morphAttributes.normal ||
                eu.morphAttributes.color,
              ew = void 0 !== eb ? eb.length : 0,
              e_ = 0;
            if (
              (void 0 !== eu.morphAttributes.position && (e_ = 1),
              void 0 !== eu.morphAttributes.normal && (e_ = 2),
              void 0 !== eu.morphAttributes.color && (e_ = 3),
              ex)
            ) {
              let _ = nr[ex];
              (ea = _.vertexShader), (eo = _.fragmentShader);
            } else
              (ea = F.vertexShader),
                (eo = F.fragmentShader),
                Y.update(F),
                (el = Y.getVertexShaderID(F)),
                (ec = Y.getFragmentShaderID(F));
            let eA = _.getRenderTarget(),
              eM = F.alphaTest > 0,
              eE = F.clearcoat > 0,
              eC = F.iridescence > 0;
            return {
              isWebGL2: Q,
              shaderID: ex,
              shaderName: F.type,
              vertexShader: ea,
              fragmentShader: eo,
              defines: F.defines,
              customVertexShaderID: el,
              customFragmentShaderID: ec,
              isRawShaderMaterial: !0 === F.isRawShaderMaterial,
              glslVersion: F.glslVersion,
              precision: $,
              instancing: !0 === en.isInstancedMesh,
              instancingColor:
                !0 === en.isInstancedMesh && null !== en.instanceColor,
              supportsVertexTextures: J,
              outputEncoding:
                null === eA
                  ? _.outputEncoding
                  : !0 === eA.isXRRenderTarget
                    ? eA.texture.encoding
                    : 3e3,
              map: !!F.map,
              matcap: !!F.matcap,
              envMap: !!ef,
              envMapMode: ef && ef.mapping,
              envMapCubeUVHeight: ev,
              lightMap: !!F.lightMap,
              aoMap: !!F.aoMap,
              emissiveMap: !!F.emissiveMap,
              bumpMap: !!F.bumpMap,
              normalMap: !!F.normalMap,
              objectSpaceNormalMap: 1 === F.normalMapType,
              tangentSpaceNormalMap: 0 === F.normalMapType,
              decodeVideoTexture:
                !!F.map &&
                !0 === F.map.isVideoTexture &&
                3001 === F.map.encoding,
              clearcoat: eE,
              clearcoatMap: eE && !!F.clearcoatMap,
              clearcoatRoughnessMap: eE && !!F.clearcoatRoughnessMap,
              clearcoatNormalMap: eE && !!F.clearcoatNormalMap,
              iridescence: eC,
              iridescenceMap: eC && !!F.iridescenceMap,
              iridescenceThicknessMap: eC && !!F.iridescenceThicknessMap,
              displacementMap: !!F.displacementMap,
              roughnessMap: !!F.roughnessMap,
              metalnessMap: !!F.metalnessMap,
              specularMap: !!F.specularMap,
              specularIntensityMap: !!F.specularIntensityMap,
              specularColorMap: !!F.specularColorMap,
              opaque: !1 === F.transparent && 1 === F.blending,
              alphaMap: !!F.alphaMap,
              alphaTest: eM,
              gradientMap: !!F.gradientMap,
              sheen: F.sheen > 0,
              sheenColorMap: !!F.sheenColorMap,
              sheenRoughnessMap: !!F.sheenRoughnessMap,
              transmission: F.transmission > 0,
              transmissionMap: !!F.transmissionMap,
              thicknessMap: !!F.thicknessMap,
              combine: F.combine,
              vertexTangents: !!F.normalMap && !!eu.attributes.tangent,
              vertexColors: F.vertexColors,
              vertexAlphas:
                !0 === F.vertexColors &&
                !!eu.attributes.color &&
                4 === eu.attributes.color.itemSize,
              vertexUvs:
                !!F.map ||
                !!F.bumpMap ||
                !!F.normalMap ||
                !!F.specularMap ||
                !!F.alphaMap ||
                !!F.emissiveMap ||
                !!F.roughnessMap ||
                !!F.metalnessMap ||
                !!F.clearcoatMap ||
                !!F.clearcoatRoughnessMap ||
                !!F.clearcoatNormalMap ||
                !!F.iridescenceMap ||
                !!F.iridescenceThicknessMap ||
                !!F.displacementMap ||
                !!F.transmissionMap ||
                !!F.thicknessMap ||
                !!F.specularIntensityMap ||
                !!F.specularColorMap ||
                !!F.sheenColorMap ||
                !!F.sheenRoughnessMap,
              uvsVertexOnly:
                !(
                  F.map ||
                  F.bumpMap ||
                  F.normalMap ||
                  F.specularMap ||
                  F.alphaMap ||
                  F.emissiveMap ||
                  F.roughnessMap ||
                  F.metalnessMap ||
                  F.clearcoatNormalMap ||
                  F.iridescenceMap ||
                  F.iridescenceThicknessMap ||
                  F.transmission > 0 ||
                  F.transmissionMap ||
                  F.thicknessMap ||
                  F.specularIntensityMap ||
                  F.specularColorMap ||
                  F.sheen > 0 ||
                  F.sheenColorMap ||
                  F.sheenRoughnessMap
                ) && !!F.displacementMap,
              fog: !!ed,
              useFog: !0 === F.fog,
              fogExp2: ed && ed.isFogExp2,
              flatShading: !!F.flatShading,
              sizeAttenuation: F.sizeAttenuation,
              logarithmicDepthBuffer: K,
              skinning: !0 === en.isSkinnedMesh,
              morphTargets: void 0 !== eu.morphAttributes.position,
              morphNormals: void 0 !== eu.morphAttributes.normal,
              morphColors: void 0 !== eu.morphAttributes.color,
              morphTargetsCount: ew,
              morphTextureStride: e_,
              numDirLights: k.directional.length,
              numPointLights: k.point.length,
              numSpotLights: k.spot.length,
              numSpotLightMaps: k.spotLightMap.length,
              numRectAreaLights: k.rectArea.length,
              numHemiLights: k.hemi.length,
              numDirLightShadows: k.directionalShadowMap.length,
              numPointLightShadows: k.pointShadowMap.length,
              numSpotLightShadows: k.spotShadowMap.length,
              numSpotLightShadowsWithMaps: k.numSpotLightShadowsWithMaps,
              numClippingPlanes: U.numPlanes,
              numClipIntersection: U.numIntersection,
              dithering: F.dithering,
              shadowMapEnabled: _.shadowMap.enabled && X.length > 0,
              shadowMapType: _.shadowMap.type,
              toneMapping: F.toneMapped ? _.toneMapping : 0,
              physicallyCorrectLights: _.physicallyCorrectLights,
              premultipliedAlpha: F.premultipliedAlpha,
              doubleSided: 2 === F.side,
              flipSided: 1 === F.side,
              useDepthPacking: !!F.depthPacking,
              depthPacking: F.depthPacking || 0,
              index0AttributeName: F.index0AttributeName,
              extensionDerivatives: F.extensions && F.extensions.derivatives,
              extensionFragDepth: F.extensions && F.extensions.fragDepth,
              extensionDrawBuffers: F.extensions && F.extensions.drawBuffers,
              extensionShaderTextureLOD:
                F.extensions && F.extensions.shaderTextureLOD,
              rendererExtensionFragDepth: Q || N.has("EXT_frag_depth"),
              rendererExtensionDrawBuffers: Q || N.has("WEBGL_draw_buffers"),
              rendererExtensionShaderTextureLod:
                Q || N.has("EXT_shader_texture_lod"),
              customProgramCacheKey: F.customProgramCacheKey(),
            };
          },
          getProgramCacheKey: function (L) {
            let R = [];
            if (
              (L.shaderID
                ? R.push(L.shaderID)
                : (R.push(L.customVertexShaderID),
                  R.push(L.customFragmentShaderID)),
              void 0 !== L.defines)
            )
              for (let _ in L.defines) R.push(_), R.push(L.defines[_]);
            return (
              !1 === L.isRawShaderMaterial &&
                (R.push(L.precision),
                R.push(L.outputEncoding),
                R.push(L.envMapMode),
                R.push(L.envMapCubeUVHeight),
                R.push(L.combine),
                R.push(L.vertexUvs),
                R.push(L.fogExp2),
                R.push(L.sizeAttenuation),
                R.push(L.morphTargetsCount),
                R.push(L.morphAttributeCount),
                R.push(L.numDirLights),
                R.push(L.numPointLights),
                R.push(L.numSpotLights),
                R.push(L.numSpotLightMaps),
                R.push(L.numHemiLights),
                R.push(L.numRectAreaLights),
                R.push(L.numDirLightShadows),
                R.push(L.numPointLightShadows),
                R.push(L.numSpotLightShadows),
                R.push(L.numSpotLightShadowsWithMaps),
                R.push(L.shadowMapType),
                R.push(L.toneMapping),
                R.push(L.numClippingPlanes),
                R.push(L.numClipIntersection),
                R.push(L.depthPacking),
                k.disableAll(),
                L.isWebGL2 && k.enable(0),
                L.supportsVertexTextures && k.enable(1),
                L.instancing && k.enable(2),
                L.instancingColor && k.enable(3),
                L.map && k.enable(4),
                L.matcap && k.enable(5),
                L.envMap && k.enable(6),
                L.lightMap && k.enable(7),
                L.aoMap && k.enable(8),
                L.emissiveMap && k.enable(9),
                L.bumpMap && k.enable(10),
                L.normalMap && k.enable(11),
                L.objectSpaceNormalMap && k.enable(12),
                L.tangentSpaceNormalMap && k.enable(13),
                L.clearcoat && k.enable(14),
                L.clearcoatMap && k.enable(15),
                L.clearcoatRoughnessMap && k.enable(16),
                L.clearcoatNormalMap && k.enable(17),
                L.iridescence && k.enable(18),
                L.iridescenceMap && k.enable(19),
                L.iridescenceThicknessMap && k.enable(20),
                L.displacementMap && k.enable(21),
                L.specularMap && k.enable(22),
                L.roughnessMap && k.enable(23),
                L.metalnessMap && k.enable(24),
                L.gradientMap && k.enable(25),
                L.alphaMap && k.enable(26),
                L.alphaTest && k.enable(27),
                L.vertexColors && k.enable(28),
                L.vertexAlphas && k.enable(29),
                L.vertexUvs && k.enable(30),
                L.vertexTangents && k.enable(31),
                L.uvsVertexOnly && k.enable(32),
                R.push(k.mask),
                k.disableAll(),
                L.fog && k.enable(0),
                L.useFog && k.enable(1),
                L.flatShading && k.enable(2),
                L.logarithmicDepthBuffer && k.enable(3),
                L.skinning && k.enable(4),
                L.morphTargets && k.enable(5),
                L.morphNormals && k.enable(6),
                L.morphColors && k.enable(7),
                L.premultipliedAlpha && k.enable(8),
                L.shadowMapEnabled && k.enable(9),
                L.physicallyCorrectLights && k.enable(10),
                L.doubleSided && k.enable(11),
                L.flipSided && k.enable(12),
                L.useDepthPacking && k.enable(13),
                L.dithering && k.enable(14),
                L.specularIntensityMap && k.enable(15),
                L.specularColorMap && k.enable(16),
                L.transmission && k.enable(17),
                L.transmissionMap && k.enable(18),
                L.thicknessMap && k.enable(19),
                L.sheen && k.enable(20),
                L.sheenColorMap && k.enable(21),
                L.sheenRoughnessMap && k.enable(22),
                L.decodeVideoTexture && k.enable(23),
                L.opaque && k.enable(24),
                R.push(k.mask),
                R.push(_.outputEncoding)),
              R.push(L.customProgramCacheKey),
              R.join()
            );
          },
          getUniforms: function (_) {
            let L = ee[_.type],
              R;
            if (L) {
              let _ = nr[L];
              R = sY.clone(_.uniforms);
            } else R = _.uniforms;
            return R;
          },
          acquireProgram: function (L, R) {
            let N;
            for (let _ = 0, L = X.length; _ < L; _++) {
              let L = X[_];
              if (L.cacheKey === R) {
                (N = L), ++N.usedTimes;
                break;
              }
            }
            return void 0 === N && ((N = new j3(_, R, L, F)), X.push(N)), N;
          },
          releaseProgram: function (_) {
            if (0 == --_.usedTimes) {
              let L = X.indexOf(_);
              (X[L] = X[X.length - 1]), X.pop(), _.destroy();
            }
          },
          releaseShaderCache: function (_) {
            Y.remove(_);
          },
          programs: X,
          dispose: function () {
            Y.dispose();
          },
        };
      }
      function Y3() {
        let _ = new WeakMap();
        return {
          get: function (L) {
            let R = _.get(L);
            return void 0 === R && ((R = {}), _.set(L, R)), R;
          },
          remove: function (L) {
            _.delete(L);
          },
          update: function (L, R, N) {
            _.get(L)[R] = N;
          },
          dispose: function () {
            _ = new WeakMap();
          },
        };
      }
      function K3(_, L) {
        return _.groupOrder !== L.groupOrder
          ? _.groupOrder - L.groupOrder
          : _.renderOrder !== L.renderOrder
            ? _.renderOrder - L.renderOrder
            : _.material.id !== L.material.id
              ? _.material.id - L.material.id
              : _.z !== L.z
                ? _.z - L.z
                : _.id - L.id;
      }
      function a1(_, L) {
        return _.groupOrder !== L.groupOrder
          ? _.groupOrder - L.groupOrder
          : _.renderOrder !== L.renderOrder
            ? _.renderOrder - L.renderOrder
            : _.z !== L.z
              ? L.z - _.z
              : _.id - L.id;
      }
      function l1() {
        let _ = [],
          L = 0,
          R = [],
          N = [],
          z = [];
        function o(R, N, z, F, U, k) {
          let Y = _[L];
          return (
            void 0 === Y
              ? ((Y = {
                  id: R.id,
                  object: R,
                  geometry: N,
                  material: z,
                  groupOrder: F,
                  renderOrder: R.renderOrder,
                  z: U,
                  group: k,
                }),
                (_[L] = Y))
              : ((Y.id = R.id),
                (Y.object = R),
                (Y.geometry = N),
                (Y.material = z),
                (Y.groupOrder = F),
                (Y.renderOrder = R.renderOrder),
                (Y.z = U),
                (Y.group = k)),
            L++,
            Y
          );
        }
        return {
          opaque: R,
          transmissive: N,
          transparent: z,
          init: function () {
            (L = 0), (R.length = 0), (N.length = 0), (z.length = 0);
          },
          push: function (_, L, F, U, k, Y) {
            let X = o(_, L, F, U, k, Y);
            F.transmission > 0
              ? N.push(X)
              : !0 === F.transparent
                ? z.push(X)
                : R.push(X);
          },
          unshift: function (_, L, F, U, k, Y) {
            let X = o(_, L, F, U, k, Y);
            F.transmission > 0
              ? N.unshift(X)
              : !0 === F.transparent
                ? z.unshift(X)
                : R.unshift(X);
          },
          finish: function () {
            for (let R = L, N = _.length; R < N; R++) {
              let L = _[R];
              if (null === L.id) break;
              (L.id = null),
                (L.object = null),
                (L.geometry = null),
                (L.material = null),
                (L.group = null);
            }
          },
          sort: function (_, L) {
            R.length > 1 && R.sort(_ || K3),
              N.length > 1 && N.sort(L || a1),
              z.length > 1 && z.sort(L || a1);
          },
        };
      }
      function Z3() {
        let _ = new WeakMap();
        return {
          get: function (L, R) {
            let N = _.get(L),
              z;
            return (
              void 0 === N
                ? ((z = new l1()), _.set(L, [z]))
                : R >= N.length
                  ? ((z = new l1()), N.push(z))
                  : (z = N[R]),
              z
            );
          },
          dispose: function () {
            _ = new WeakMap();
          },
        };
      }
      function Q3() {
        let _ = {};
        return {
          get: function (L) {
            let R;
            if (void 0 !== _[L.id]) return _[L.id];
            switch (L.type) {
              case "DirectionalLight":
                R = { direction: new iq(), color: new iz() };
                break;
              case "SpotLight":
                R = {
                  position: new iq(),
                  direction: new iq(),
                  color: new iz(),
                  distance: 0,
                  coneCos: 0,
                  penumbraCos: 0,
                  decay: 0,
                };
                break;
              case "PointLight":
                R = {
                  position: new iq(),
                  color: new iz(),
                  distance: 0,
                  decay: 0,
                };
                break;
              case "HemisphereLight":
                R = {
                  direction: new iq(),
                  skyColor: new iz(),
                  groundColor: new iz(),
                };
                break;
              case "RectAreaLight":
                R = {
                  color: new iz(),
                  position: new iq(),
                  halfWidth: new iq(),
                  halfHeight: new iq(),
                };
            }
            return (_[L.id] = R), R;
          },
        };
      }
      var nV = 0;
      function eN(_, L) {
        return (
          (L.castShadow ? 2 : 0) -
          (_.castShadow ? 2 : 0) +
          (L.map ? 1 : 0) -
          (_.map ? 1 : 0)
        );
      }
      function tN(_, L) {
        let R;
        let N = new Q3(),
          z =
            ((R = {}),
            {
              get: function (_) {
                let L;
                if (void 0 !== R[_.id]) return R[_.id];
                switch (_.type) {
                  case "DirectionalLight":
                  case "SpotLight":
                    L = {
                      shadowBias: 0,
                      shadowNormalBias: 0,
                      shadowRadius: 1,
                      shadowMapSize: new iT(),
                    };
                    break;
                  case "PointLight":
                    L = {
                      shadowBias: 0,
                      shadowNormalBias: 0,
                      shadowRadius: 1,
                      shadowMapSize: new iT(),
                      shadowCameraNear: 1,
                      shadowCameraFar: 1e3,
                    };
                }
                return (R[_.id] = L), L;
              },
            }),
          F = {
            version: 0,
            hash: {
              directionalLength: -1,
              pointLength: -1,
              spotLength: -1,
              rectAreaLength: -1,
              hemiLength: -1,
              numDirectionalShadows: -1,
              numPointShadows: -1,
              numSpotShadows: -1,
              numSpotMaps: -1,
            },
            ambient: [0, 0, 0],
            probe: [],
            directional: [],
            directionalShadow: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotLightMap: [],
            spotShadow: [],
            spotShadowMap: [],
            spotLightMatrix: [],
            rectArea: [],
            rectAreaLTC1: null,
            rectAreaLTC2: null,
            point: [],
            pointShadow: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: [],
            numSpotLightShadowsWithMaps: 0,
          };
        for (let _ = 0; _ < 9; _++) F.probe.push(new iq());
        let U = new iq(),
          k = new rw(),
          Y = new rw();
        return {
          setup: function (R, U) {
            let k = 0,
              Y = 0,
              X = 0;
            for (let _ = 0; _ < 9; _++) F.probe[_].set(0, 0, 0);
            let Q = 0,
              K = 0,
              J = 0,
              $ = 0,
              ee = 0,
              er = 0,
              en = 0,
              ea = 0,
              eo = 0,
              el = 0;
            R.sort(eN);
            let ec = !0 !== U ? Math.PI : 1;
            for (let _ = 0, L = R.length; _ < L; _++) {
              let L = R[_],
                U = L.color,
                ed = L.intensity,
                eu = L.distance,
                ep = L.shadow && L.shadow.map ? L.shadow.map.texture : null;
              if (L.isAmbientLight)
                (k += U.r * ed * ec),
                  (Y += U.g * ed * ec),
                  (X += U.b * ed * ec);
              else if (L.isLightProbe)
                for (let _ = 0; _ < 9; _++)
                  F.probe[_].addScaledVector(L.sh.coefficients[_], ed);
              else if (L.isDirectionalLight) {
                let _ = N.get(L);
                if (
                  (_.color.copy(L.color).multiplyScalar(L.intensity * ec),
                  L.castShadow)
                ) {
                  let _ = L.shadow,
                    R = z.get(L);
                  (R.shadowBias = _.bias),
                    (R.shadowNormalBias = _.normalBias),
                    (R.shadowRadius = _.radius),
                    (R.shadowMapSize = _.mapSize),
                    (F.directionalShadow[Q] = R),
                    (F.directionalShadowMap[Q] = ep),
                    (F.directionalShadowMatrix[Q] = L.shadow.matrix),
                    er++;
                }
                (F.directional[Q] = _), Q++;
              } else if (L.isSpotLight) {
                let _ = N.get(L);
                _.position.setFromMatrixPosition(L.matrixWorld),
                  _.color.copy(U).multiplyScalar(ed * ec),
                  (_.distance = eu),
                  (_.coneCos = Math.cos(L.angle)),
                  (_.penumbraCos = Math.cos(L.angle * (1 - L.penumbra))),
                  (_.decay = L.decay),
                  (F.spot[J] = _);
                let R = L.shadow;
                if (
                  (L.map &&
                    ((F.spotLightMap[eo] = L.map),
                    eo++,
                    R.updateMatrices(L),
                    L.castShadow && el++),
                  (F.spotLightMatrix[J] = R.matrix),
                  L.castShadow)
                ) {
                  let _ = z.get(L);
                  (_.shadowBias = R.bias),
                    (_.shadowNormalBias = R.normalBias),
                    (_.shadowRadius = R.radius),
                    (_.shadowMapSize = R.mapSize),
                    (F.spotShadow[J] = _),
                    (F.spotShadowMap[J] = ep),
                    ea++;
                }
                J++;
              } else if (L.isRectAreaLight) {
                let _ = N.get(L);
                _.color.copy(U).multiplyScalar(ed),
                  _.halfWidth.set(0.5 * L.width, 0, 0),
                  _.halfHeight.set(0, 0.5 * L.height, 0),
                  (F.rectArea[$] = _),
                  $++;
              } else if (L.isPointLight) {
                let _ = N.get(L);
                if (
                  (_.color.copy(L.color).multiplyScalar(L.intensity * ec),
                  (_.distance = L.distance),
                  (_.decay = L.decay),
                  L.castShadow)
                ) {
                  let _ = L.shadow,
                    R = z.get(L);
                  (R.shadowBias = _.bias),
                    (R.shadowNormalBias = _.normalBias),
                    (R.shadowRadius = _.radius),
                    (R.shadowMapSize = _.mapSize),
                    (R.shadowCameraNear = _.camera.near),
                    (R.shadowCameraFar = _.camera.far),
                    (F.pointShadow[K] = R),
                    (F.pointShadowMap[K] = ep),
                    (F.pointShadowMatrix[K] = L.shadow.matrix),
                    en++;
                }
                (F.point[K] = _), K++;
              } else if (L.isHemisphereLight) {
                let _ = N.get(L);
                _.skyColor.copy(L.color).multiplyScalar(ed * ec),
                  _.groundColor.copy(L.groundColor).multiplyScalar(ed * ec),
                  (F.hemi[ee] = _),
                  ee++;
              }
            }
            $ > 0 &&
              (L.isWebGL2 || !0 === _.has("OES_texture_float_linear")
                ? ((F.rectAreaLTC1 = ni.LTC_FLOAT_1),
                  (F.rectAreaLTC2 = ni.LTC_FLOAT_2))
                : !0 === _.has("OES_texture_half_float_linear")
                  ? ((F.rectAreaLTC1 = ni.LTC_HALF_1),
                    (F.rectAreaLTC2 = ni.LTC_HALF_2))
                  : console.error(
                      "THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.",
                    )),
              (F.ambient[0] = k),
              (F.ambient[1] = Y),
              (F.ambient[2] = X);
            let ed = F.hash;
            (ed.directionalLength !== Q ||
              ed.pointLength !== K ||
              ed.spotLength !== J ||
              ed.rectAreaLength !== $ ||
              ed.hemiLength !== ee ||
              ed.numDirectionalShadows !== er ||
              ed.numPointShadows !== en ||
              ed.numSpotShadows !== ea ||
              ed.numSpotMaps !== eo) &&
              ((F.directional.length = Q),
              (F.spot.length = J),
              (F.rectArea.length = $),
              (F.point.length = K),
              (F.hemi.length = ee),
              (F.directionalShadow.length = er),
              (F.directionalShadowMap.length = er),
              (F.pointShadow.length = en),
              (F.pointShadowMap.length = en),
              (F.spotShadow.length = ea),
              (F.spotShadowMap.length = ea),
              (F.directionalShadowMatrix.length = er),
              (F.pointShadowMatrix.length = en),
              (F.spotLightMatrix.length = ea + eo - el),
              (F.spotLightMap.length = eo),
              (F.numSpotLightShadowsWithMaps = el),
              (ed.directionalLength = Q),
              (ed.pointLength = K),
              (ed.spotLength = J),
              (ed.rectAreaLength = $),
              (ed.hemiLength = ee),
              (ed.numDirectionalShadows = er),
              (ed.numPointShadows = en),
              (ed.numSpotShadows = ea),
              (ed.numSpotMaps = eo),
              (F.version = nV++));
          },
          setupView: function (_, L) {
            let R = 0,
              N = 0,
              z = 0,
              X = 0,
              Q = 0,
              K = L.matrixWorldInverse;
            for (let L = 0, J = _.length; L < J; L++) {
              let J = _[L];
              if (J.isDirectionalLight) {
                let _ = F.directional[R];
                _.direction.setFromMatrixPosition(J.matrixWorld),
                  U.setFromMatrixPosition(J.target.matrixWorld),
                  _.direction.sub(U),
                  _.direction.transformDirection(K),
                  R++;
              } else if (J.isSpotLight) {
                let _ = F.spot[z];
                _.position.setFromMatrixPosition(J.matrixWorld),
                  _.position.applyMatrix4(K),
                  _.direction.setFromMatrixPosition(J.matrixWorld),
                  U.setFromMatrixPosition(J.target.matrixWorld),
                  _.direction.sub(U),
                  _.direction.transformDirection(K),
                  z++;
              } else if (J.isRectAreaLight) {
                let _ = F.rectArea[X];
                _.position.setFromMatrixPosition(J.matrixWorld),
                  _.position.applyMatrix4(K),
                  Y.identity(),
                  k.copy(J.matrixWorld),
                  k.premultiply(K),
                  Y.extractRotation(k),
                  _.halfWidth.set(0.5 * J.width, 0, 0),
                  _.halfHeight.set(0, 0.5 * J.height, 0),
                  _.halfWidth.applyMatrix4(Y),
                  _.halfHeight.applyMatrix4(Y),
                  X++;
              } else if (J.isPointLight) {
                let _ = F.point[N];
                _.position.setFromMatrixPosition(J.matrixWorld),
                  _.position.applyMatrix4(K),
                  N++;
              } else if (J.isHemisphereLight) {
                let _ = F.hemi[Q];
                _.direction.setFromMatrixPosition(J.matrixWorld),
                  _.direction.transformDirection(K),
                  Q++;
              }
            }
          },
          state: F,
        };
      }
      function c1(_, L) {
        let R = new tN(_, L),
          N = [],
          z = [];
        return {
          init: function () {
            (N.length = 0), (z.length = 0);
          },
          state: { lightsArray: N, shadowsArray: z, lights: R },
          setupLights: function (_) {
            R.setup(N, _);
          },
          setupLightsView: function (_) {
            R.setupView(N, _);
          },
          pushLight: function (_) {
            N.push(_);
          },
          pushShadow: function (_) {
            z.push(_);
          },
        };
      }
      function nN(_, L) {
        let R = new WeakMap();
        return {
          get: function (N, z = 0) {
            let F = R.get(N),
              U;
            return (
              void 0 === F
                ? ((U = new c1(_, L)), R.set(N, [U]))
                : z >= F.length
                  ? ((U = new c1(_, L)), F.push(U))
                  : (U = F[z]),
              U
            );
          },
          dispose: function () {
            R = new WeakMap();
          },
        };
      }
      var nH = class extends sr {
          constructor(_) {
            super(),
              (this.isMeshDepthMaterial = !0),
              (this.type = "MeshDepthMaterial"),
              (this.depthPacking = 3200),
              (this.map = null),
              (this.alphaMap = null),
              (this.displacementMap = null),
              (this.displacementScale = 1),
              (this.displacementBias = 0),
              (this.wireframe = !1),
              (this.wireframeLinewidth = 1),
              this.setValues(_);
          }
          copy(_) {
            return (
              super.copy(_),
              (this.depthPacking = _.depthPacking),
              (this.map = _.map),
              (this.alphaMap = _.alphaMap),
              (this.displacementMap = _.displacementMap),
              (this.displacementScale = _.displacementScale),
              (this.displacementBias = _.displacementBias),
              (this.wireframe = _.wireframe),
              (this.wireframeLinewidth = _.wireframeLinewidth),
              this
            );
          }
        },
        nW = class extends sr {
          constructor(_) {
            super(),
              (this.isMeshDistanceMaterial = !0),
              (this.type = "MeshDistanceMaterial"),
              (this.referencePosition = new iq()),
              (this.nearDistance = 1),
              (this.farDistance = 1e3),
              (this.map = null),
              (this.alphaMap = null),
              (this.displacementMap = null),
              (this.displacementScale = 1),
              (this.displacementBias = 0),
              this.setValues(_);
          }
          copy(_) {
            return (
              super.copy(_),
              this.referencePosition.copy(_.referencePosition),
              (this.nearDistance = _.nearDistance),
              (this.farDistance = _.farDistance),
              (this.map = _.map),
              (this.alphaMap = _.alphaMap),
              (this.displacementMap = _.displacementMap),
              (this.displacementScale = _.displacementScale),
              (this.displacementBias = _.displacementBias),
              this
            );
          }
        },
        nY = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
        nX = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
      function sN(_, L, R) {
        let N = new s7(),
          z = new iT(),
          F = new iT(),
          U = new iV(),
          k = new nH({ depthPacking: 3201 }),
          Y = new nW(),
          X = {},
          Q = R.maxTextureSize,
          K = { 0: 1, 1: 0, 2: 2 },
          J = new sQ({
            defines: { VSM_SAMPLES: 8 },
            uniforms: {
              shadow_pass: { value: null },
              resolution: { value: new iT() },
              radius: { value: 4 },
            },
            vertexShader: nY,
            fragmentShader: nX,
          }),
          $ = J.clone();
        $.defines.HORIZONTAL_PASS = 1;
        let ee = new sP();
        ee.setAttribute(
          "position",
          new sh(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3),
        );
        let er = new sH(ee, J),
          en = this;
        function v(L, R, N, z, F, U) {
          let Q = null,
            J =
              !0 === N.isPointLight
                ? L.customDistanceMaterial
                : L.customDepthMaterial;
          if (void 0 !== J) Q = J;
          else if (
            ((Q = !0 === N.isPointLight ? Y : k),
            (_.localClippingEnabled &&
              !0 === R.clipShadows &&
              Array.isArray(R.clippingPlanes) &&
              0 !== R.clippingPlanes.length) ||
              (R.displacementMap && 0 !== R.displacementScale) ||
              (R.alphaMap && R.alphaTest > 0) ||
              (R.map && R.alphaTest > 0))
          ) {
            let _ = Q.uuid,
              L = R.uuid,
              N = X[_];
            void 0 === N && ((N = {}), (X[_] = N));
            let z = N[L];
            void 0 === z && ((z = Q.clone()), (N[L] = z)), (Q = z);
          }
          return (
            (Q.visible = R.visible),
            (Q.wireframe = R.wireframe),
            3 === U
              ? (Q.side = null !== R.shadowSide ? R.shadowSide : R.side)
              : (Q.side = null !== R.shadowSide ? R.shadowSide : K[R.side]),
            (Q.alphaMap = R.alphaMap),
            (Q.alphaTest = R.alphaTest),
            (Q.map = R.map),
            (Q.clipShadows = R.clipShadows),
            (Q.clippingPlanes = R.clippingPlanes),
            (Q.clipIntersection = R.clipIntersection),
            (Q.displacementMap = R.displacementMap),
            (Q.displacementScale = R.displacementScale),
            (Q.displacementBias = R.displacementBias),
            (Q.wireframeLinewidth = R.wireframeLinewidth),
            (Q.linewidth = R.linewidth),
            !0 === N.isPointLight &&
              !0 === Q.isMeshDistanceMaterial &&
              (Q.referencePosition.setFromMatrixPosition(N.matrixWorld),
              (Q.nearDistance = z),
              (Q.farDistance = F)),
            Q
          );
        }
        (this.enabled = !1),
          (this.autoUpdate = !0),
          (this.needsUpdate = !1),
          (this.type = 1),
          (this.render = function (R, k, Y) {
            if (
              !1 === en.enabled ||
              (!1 === en.autoUpdate && !1 === en.needsUpdate) ||
              0 === R.length
            )
              return;
            let X = _.getRenderTarget(),
              K = _.getActiveCubeFace(),
              ee = _.getActiveMipmapLevel(),
              ea = _.state;
            ea.setBlending(0),
              ea.buffers.color.setClear(1, 1, 1, 1),
              ea.buffers.depth.setTest(!0),
              ea.setScissorTest(!1);
            for (let X = 0, K = R.length; X < K; X++) {
              let K = R[X],
                ee = K.shadow;
              if (void 0 === ee) {
                console.warn("THREE.WebGLShadowMap:", K, "has no shadow.");
                continue;
              }
              if (!1 === ee.autoUpdate && !1 === ee.needsUpdate) continue;
              z.copy(ee.mapSize);
              let en = ee.getFrameExtents();
              if (
                (z.multiply(en),
                F.copy(ee.mapSize),
                (z.x > Q || z.y > Q) &&
                  (z.x > Q &&
                    ((F.x = Math.floor(Q / en.x)),
                    (z.x = F.x * en.x),
                    (ee.mapSize.x = F.x)),
                  z.y > Q &&
                    ((F.y = Math.floor(Q / en.y)),
                    (z.y = F.y * en.y),
                    (ee.mapSize.y = F.y))),
                null === ee.map)
              ) {
                let _ =
                  3 !== this.type ? { minFilter: 1003, magFilter: 1003 } : {};
                (ee.map = new iH(z.x, z.y, _)),
                  (ee.map.texture.name = K.name + ".shadowMap"),
                  ee.camera.updateProjectionMatrix();
              }
              _.setRenderTarget(ee.map), _.clear();
              let eo = ee.getViewportCount();
              for (let R = 0; R < eo; R++) {
                let z = ee.getViewport(R);
                U.set(F.x * z.x, F.y * z.y, F.x * z.z, F.y * z.w),
                  ea.viewport(U),
                  ee.updateMatrices(K, R),
                  (N = ee.getFrustum()),
                  (function x(R, z, F, U, k) {
                    if (!1 === R.visible) return;
                    if (
                      R.layers.test(z.layers) &&
                      (R.isMesh || R.isLine || R.isPoints) &&
                      (R.castShadow || (R.receiveShadow && 3 === k)) &&
                      (!R.frustumCulled || N.intersectsObject(R))
                    ) {
                      R.modelViewMatrix.multiplyMatrices(
                        F.matrixWorldInverse,
                        R.matrixWorld,
                      );
                      let N = L.update(R),
                        z = R.material;
                      if (Array.isArray(z)) {
                        let L = N.groups;
                        for (let Y = 0, X = L.length; Y < X; Y++) {
                          let X = L[Y],
                            Q = z[X.materialIndex];
                          if (Q && Q.visible) {
                            let L = v(R, Q, U, F.near, F.far, k);
                            _.renderBufferDirect(F, null, N, L, R, X);
                          }
                        }
                      } else if (z.visible) {
                        let L = v(R, z, U, F.near, F.far, k);
                        _.renderBufferDirect(F, null, N, L, R, null);
                      }
                    }
                    let Y = R.children;
                    for (let _ = 0, L = Y.length; _ < L; _++)
                      x(Y[_], z, F, U, k);
                  })(k, Y, ee.camera, K, this.type);
              }
              !0 !== ee.isPointLightShadow &&
                3 === this.type &&
                (function (R, N) {
                  let F = L.update(er);
                  J.defines.VSM_SAMPLES !== R.blurSamples &&
                    ((J.defines.VSM_SAMPLES = R.blurSamples),
                    ($.defines.VSM_SAMPLES = R.blurSamples),
                    (J.needsUpdate = !0),
                    ($.needsUpdate = !0)),
                    null === R.mapPass && (R.mapPass = new iH(z.x, z.y)),
                    (J.uniforms.shadow_pass.value = R.map.texture),
                    (J.uniforms.resolution.value = R.mapSize),
                    (J.uniforms.radius.value = R.radius),
                    _.setRenderTarget(R.mapPass),
                    _.clear(),
                    _.renderBufferDirect(N, null, F, J, er, null),
                    ($.uniforms.shadow_pass.value = R.mapPass.texture),
                    ($.uniforms.resolution.value = R.mapSize),
                    ($.uniforms.radius.value = R.radius),
                    _.setRenderTarget(R.map),
                    _.clear(),
                    _.renderBufferDirect(N, null, F, $, er, null);
                })(ee, Y),
                (ee.needsUpdate = !1);
            }
            (en.needsUpdate = !1), _.setRenderTarget(X, K, ee);
          });
      }
      function oN(_, L, R) {
        let N = R.isWebGL2,
          z = new (function () {
            let L = !1,
              R = new iV(),
              N = null,
              z = new iV(0, 0, 0, 0);
            return {
              setMask: function (R) {
                N === R || L || (_.colorMask(R, R, R, R), (N = R));
              },
              setLocked: function (_) {
                L = _;
              },
              setClear: function (L, N, F, U, k) {
                !0 === k && ((L *= U), (N *= U), (F *= U)),
                  R.set(L, N, F, U),
                  !1 === z.equals(R) && (_.clearColor(L, N, F, U), z.copy(R));
              },
              reset: function () {
                (L = !1), (N = null), z.set(-1, 0, 0, 0);
              },
            };
          })(),
          F = new (function () {
            let L = !1,
              R = null,
              N = null,
              z = null;
            return {
              setTest: function (_) {
                _ ? re(2929) : Z(2929);
              },
              setMask: function (N) {
                R === N || L || (_.depthMask(N), (R = N));
              },
              setFunc: function (L) {
                if (N !== L) {
                  switch (L) {
                    case 0:
                      _.depthFunc(512);
                      break;
                    case 1:
                      _.depthFunc(519);
                      break;
                    case 2:
                      _.depthFunc(513);
                      break;
                    case 3:
                    default:
                      _.depthFunc(515);
                      break;
                    case 4:
                      _.depthFunc(514);
                      break;
                    case 5:
                      _.depthFunc(518);
                      break;
                    case 6:
                      _.depthFunc(516);
                      break;
                    case 7:
                      _.depthFunc(517);
                  }
                  N = L;
                }
              },
              setLocked: function (_) {
                L = _;
              },
              setClear: function (L) {
                z !== L && (_.clearDepth(L), (z = L));
              },
              reset: function () {
                (L = !1), (R = null), (N = null), (z = null);
              },
            };
          })(),
          U = new (function () {
            let L = !1,
              R = null,
              N = null,
              z = null,
              F = null,
              U = null,
              k = null,
              Y = null,
              X = null;
            return {
              setTest: function (_) {
                L || (_ ? re(2960) : Z(2960));
              },
              setMask: function (N) {
                R === N || L || (_.stencilMask(N), (R = N));
              },
              setFunc: function (L, R, U) {
                (N !== L || z !== R || F !== U) &&
                  (_.stencilFunc(L, R, U), (N = L), (z = R), (F = U));
              },
              setOp: function (L, R, N) {
                (U !== L || k !== R || Y !== N) &&
                  (_.stencilOp(L, R, N), (U = L), (k = R), (Y = N));
              },
              setLocked: function (_) {
                L = _;
              },
              setClear: function (L) {
                X !== L && (_.clearStencil(L), (X = L));
              },
              reset: function () {
                (L = !1),
                  (R = null),
                  (N = null),
                  (z = null),
                  (F = null),
                  (U = null),
                  (k = null),
                  (Y = null),
                  (X = null);
              },
            };
          })(),
          k = new WeakMap(),
          Y = new WeakMap(),
          X = {},
          Q = {},
          K = new WeakMap(),
          J = [],
          $ = null,
          ee = !1,
          er = null,
          en = null,
          ea = null,
          eo = null,
          el = null,
          ec = null,
          ed = null,
          eu = !1,
          ep = null,
          ef = null,
          ev = null,
          ex = null,
          eb = null,
          ew = _.getParameter(35661),
          e_ = !1,
          eA = _.getParameter(7938);
        -1 !== eA.indexOf("WebGL")
          ? (e_ = parseFloat(/^WebGL (\d)/.exec(eA)[1]) >= 1)
          : -1 !== eA.indexOf("OpenGL ES") &&
            (e_ = parseFloat(/^OpenGL ES (\d)/.exec(eA)[1]) >= 2);
        let eM = null,
          eE = {},
          eC = _.getParameter(3088),
          eP = _.getParameter(2978),
          eD = new iV().fromArray(eC),
          eO = new iV().fromArray(eP);
        function j(L, R, N) {
          let z = new Uint8Array(4),
            F = _.createTexture();
          _.bindTexture(L, F),
            _.texParameteri(L, 10241, 9728),
            _.texParameteri(L, 10240, 9728);
          for (let L = 0; L < N; L++)
            _.texImage2D(R + L, 0, 6408, 1, 1, 0, 6408, 5121, z);
          return F;
        }
        let eL = {};
        function re(L) {
          !0 !== X[L] && (_.enable(L), (X[L] = !0));
        }
        function Z(L) {
          !1 !== X[L] && (_.disable(L), (X[L] = !1));
        }
        (eL[3553] = j(3553, 3553, 1)),
          (eL[34067] = j(34067, 34069, 6)),
          z.setClear(0, 0, 0, 1),
          F.setClear(1),
          U.setClear(0),
          re(2929),
          F.setFunc(3),
          me(!1),
          Me(1),
          re(2884),
          fe(0);
        let eR = { 100: 32774, 101: 32778, 102: 32779 };
        if (N) (eR[103] = 32775), (eR[104] = 32776);
        else {
          let _ = L.get("EXT_blend_minmax");
          null !== _ && ((eR[103] = _.MIN_EXT), (eR[104] = _.MAX_EXT));
        }
        let eI = {
          200: 0,
          201: 1,
          202: 768,
          204: 770,
          210: 776,
          208: 774,
          206: 772,
          203: 769,
          205: 771,
          209: 775,
          207: 773,
        };
        function fe(L, R, N, z, F, U, k, Y) {
          if (0 === L) {
            !0 === ee && (Z(3042), (ee = !1));
            return;
          }
          if ((!1 === ee && (re(3042), (ee = !0)), 5 !== L)) {
            if (L !== er || Y !== eu) {
              if (
                ((100 !== en || 100 !== el) &&
                  (_.blendEquation(32774), (en = 100), (el = 100)),
                Y)
              )
                switch (L) {
                  case 1:
                    _.blendFuncSeparate(1, 771, 1, 771);
                    break;
                  case 2:
                    _.blendFunc(1, 1);
                    break;
                  case 3:
                    _.blendFuncSeparate(0, 769, 0, 1);
                    break;
                  case 4:
                    _.blendFuncSeparate(0, 768, 0, 770);
                    break;
                  default:
                    console.error("THREE.WebGLState: Invalid blending: ", L);
                }
              else
                switch (L) {
                  case 1:
                    _.blendFuncSeparate(770, 771, 1, 771);
                    break;
                  case 2:
                    _.blendFunc(770, 1);
                    break;
                  case 3:
                    _.blendFuncSeparate(0, 769, 0, 1);
                    break;
                  case 4:
                    _.blendFunc(0, 768);
                    break;
                  default:
                    console.error("THREE.WebGLState: Invalid blending: ", L);
                }
              (ea = null),
                (eo = null),
                (ec = null),
                (ed = null),
                (er = L),
                (eu = Y);
            }
            return;
          }
          (F = F || R),
            (U = U || N),
            (k = k || z),
            (R !== en || F !== el) &&
              (_.blendEquationSeparate(eR[R], eR[F]), (en = R), (el = F)),
            (N !== ea || z !== eo || U !== ec || k !== ed) &&
              (_.blendFuncSeparate(eI[N], eI[z], eI[U], eI[k]),
              (ea = N),
              (eo = z),
              (ec = U),
              (ed = k)),
            (er = L),
            (eu = !1);
        }
        function me(L) {
          ep !== L && (L ? _.frontFace(2304) : _.frontFace(2305), (ep = L));
        }
        function Me(L) {
          0 !== L
            ? (re(2884),
              L !== ef &&
                (1 === L
                  ? _.cullFace(1029)
                  : 2 === L
                    ? _.cullFace(1028)
                    : _.cullFace(1032)))
            : Z(2884),
            (ef = L);
        }
        function be(L, R, N) {
          L
            ? (re(32823),
              (ex !== R || eb !== N) &&
                (_.polygonOffset(R, N), (ex = R), (eb = N)))
            : Z(32823);
        }
        return {
          buffers: { color: z, depth: F, stencil: U },
          enable: re,
          disable: Z,
          bindFramebuffer: function (L, R) {
            return (
              Q[L] !== R &&
              (_.bindFramebuffer(L, R),
              (Q[L] = R),
              N &&
                (36009 === L && (Q[36160] = R), 36160 === L && (Q[36009] = R)),
              !0)
            );
          },
          drawBuffers: function (N, z) {
            let F = J,
              U = !1;
            if (N) {
              if (
                (void 0 === (F = K.get(z)) && ((F = []), K.set(z, F)),
                N.isWebGLMultipleRenderTargets)
              ) {
                let _ = N.texture;
                if (F.length !== _.length || 36064 !== F[0]) {
                  for (let L = 0, R = _.length; L < R; L++) F[L] = 36064 + L;
                  (F.length = _.length), (U = !0);
                }
              } else 36064 !== F[0] && ((F[0] = 36064), (U = !0));
            } else 1029 !== F[0] && ((F[0] = 1029), (U = !0));
            U &&
              (R.isWebGL2
                ? _.drawBuffers(F)
                : L.get("WEBGL_draw_buffers").drawBuffersWEBGL(F));
          },
          useProgram: function (L) {
            return $ !== L && (_.useProgram(L), ($ = L), !0);
          },
          setBlending: fe,
          setMaterial: function (_, L) {
            2 === _.side ? Z(2884) : re(2884);
            let R = 1 === _.side;
            L && (R = !R),
              me(R),
              1 === _.blending && !1 === _.transparent
                ? fe(0)
                : fe(
                    _.blending,
                    _.blendEquation,
                    _.blendSrc,
                    _.blendDst,
                    _.blendEquationAlpha,
                    _.blendSrcAlpha,
                    _.blendDstAlpha,
                    _.premultipliedAlpha,
                  ),
              F.setFunc(_.depthFunc),
              F.setTest(_.depthTest),
              F.setMask(_.depthWrite),
              z.setMask(_.colorWrite);
            let N = _.stencilWrite;
            U.setTest(N),
              N &&
                (U.setMask(_.stencilWriteMask),
                U.setFunc(_.stencilFunc, _.stencilRef, _.stencilFuncMask),
                U.setOp(_.stencilFail, _.stencilZFail, _.stencilZPass)),
              be(_.polygonOffset, _.polygonOffsetFactor, _.polygonOffsetUnits),
              !0 === _.alphaToCoverage ? re(32926) : Z(32926);
          },
          setFlipSided: me,
          setCullFace: Me,
          setLineWidth: function (L) {
            L !== ev && (e_ && _.lineWidth(L), (ev = L));
          },
          setPolygonOffset: be,
          setScissorTest: function (_) {
            _ ? re(3089) : Z(3089);
          },
          activeTexture: function (L) {
            void 0 === L && (L = 33984 + ew - 1),
              eM !== L && (_.activeTexture(L), (eM = L));
          },
          bindTexture: function (L, R, N) {
            void 0 === N && (N = null === eM ? 33984 + ew - 1 : eM);
            let z = eE[N];
            void 0 === z &&
              ((z = { type: void 0, texture: void 0 }), (eE[N] = z)),
              (z.type !== L || z.texture !== R) &&
                (eM !== N && (_.activeTexture(N), (eM = N)),
                _.bindTexture(L, R || eL[L]),
                (z.type = L),
                (z.texture = R));
          },
          unbindTexture: function () {
            let L = eE[eM];
            void 0 !== L &&
              void 0 !== L.type &&
              (_.bindTexture(L.type, null),
              (L.type = void 0),
              (L.texture = void 0));
          },
          compressedTexImage2D: function () {
            try {
              _.compressedTexImage2D.apply(_, arguments);
            } catch (_) {
              console.error("THREE.WebGLState:", _);
            }
          },
          compressedTexImage3D: function () {
            try {
              _.compressedTexImage3D.apply(_, arguments);
            } catch (_) {
              console.error("THREE.WebGLState:", _);
            }
          },
          texImage2D: function () {
            try {
              _.texImage2D.apply(_, arguments);
            } catch (_) {
              console.error("THREE.WebGLState:", _);
            }
          },
          texImage3D: function () {
            try {
              _.texImage3D.apply(_, arguments);
            } catch (_) {
              console.error("THREE.WebGLState:", _);
            }
          },
          updateUBOMapping: function (L, R) {
            let N = Y.get(R);
            void 0 === N && ((N = new WeakMap()), Y.set(R, N));
            let z = N.get(L);
            void 0 === z &&
              ((z = _.getUniformBlockIndex(R, L.name)), N.set(L, z));
          },
          uniformBlockBinding: function (L, R) {
            let N = Y.get(R).get(L);
            k.get(R) !== N &&
              (_.uniformBlockBinding(R, N, L.__bindingPointIndex), k.set(R, N));
          },
          texStorage2D: function () {
            try {
              _.texStorage2D.apply(_, arguments);
            } catch (_) {
              console.error("THREE.WebGLState:", _);
            }
          },
          texStorage3D: function () {
            try {
              _.texStorage3D.apply(_, arguments);
            } catch (_) {
              console.error("THREE.WebGLState:", _);
            }
          },
          texSubImage2D: function () {
            try {
              _.texSubImage2D.apply(_, arguments);
            } catch (_) {
              console.error("THREE.WebGLState:", _);
            }
          },
          texSubImage3D: function () {
            try {
              _.texSubImage3D.apply(_, arguments);
            } catch (_) {
              console.error("THREE.WebGLState:", _);
            }
          },
          compressedTexSubImage2D: function () {
            try {
              _.compressedTexSubImage2D.apply(_, arguments);
            } catch (_) {
              console.error("THREE.WebGLState:", _);
            }
          },
          compressedTexSubImage3D: function () {
            try {
              _.compressedTexSubImage3D.apply(_, arguments);
            } catch (_) {
              console.error("THREE.WebGLState:", _);
            }
          },
          scissor: function (L) {
            !1 === eD.equals(L) && (_.scissor(L.x, L.y, L.z, L.w), eD.copy(L));
          },
          viewport: function (L) {
            !1 === eO.equals(L) && (_.viewport(L.x, L.y, L.z, L.w), eO.copy(L));
          },
          reset: function () {
            _.disable(3042),
              _.disable(2884),
              _.disable(2929),
              _.disable(32823),
              _.disable(3089),
              _.disable(2960),
              _.disable(32926),
              _.blendEquation(32774),
              _.blendFunc(1, 0),
              _.blendFuncSeparate(1, 0, 1, 0),
              _.colorMask(!0, !0, !0, !0),
              _.clearColor(0, 0, 0, 0),
              _.depthMask(!0),
              _.depthFunc(513),
              _.clearDepth(1),
              _.stencilMask(4294967295),
              _.stencilFunc(519, 0, 4294967295),
              _.stencilOp(7680, 7680, 7680),
              _.clearStencil(0),
              _.cullFace(1029),
              _.frontFace(2305),
              _.polygonOffset(0, 0),
              _.activeTexture(33984),
              _.bindFramebuffer(36160, null),
              !0 === N &&
                (_.bindFramebuffer(36009, null),
                _.bindFramebuffer(36008, null)),
              _.useProgram(null),
              _.lineWidth(1),
              _.scissor(0, 0, _.canvas.width, _.canvas.height),
              _.viewport(0, 0, _.canvas.width, _.canvas.height),
              (X = {}),
              (eM = null),
              (eE = {}),
              (Q = {}),
              (K = new WeakMap()),
              (J = []),
              ($ = null),
              (ee = !1),
              (er = null),
              (en = null),
              (ea = null),
              (eo = null),
              (el = null),
              (ec = null),
              (ed = null),
              (eu = !1),
              (ep = null),
              (ef = null),
              (ev = null),
              (ex = null),
              (eb = null),
              eD.set(0, 0, _.canvas.width, _.canvas.height),
              eO.set(0, 0, _.canvas.width, _.canvas.height),
              z.reset(),
              F.reset(),
              U.reset();
          },
        };
      }
      function aN(_, L, R, N, z, F, U) {
        let k = z.isWebGL2,
          Y = z.maxTextures,
          X = z.maxCubemapSize,
          Q = z.maxTextureSize,
          K = z.maxSamples,
          J = L.has("WEBGL_multisampled_render_to_texture")
            ? L.get("WEBGL_multisampled_render_to_texture")
            : null,
          $ =
            !(typeof navigator > "u") &&
            /OculusBrowser/g.test(navigator.userAgent),
          ee = new WeakMap(),
          er,
          en = new WeakMap(),
          ea = !1;
        try {
          ea =
            "u" > typeof OffscreenCanvas &&
            null !== new OffscreenCanvas(1, 1).getContext("2d");
        } catch {}
        function v(_, L) {
          return ea ? new OffscreenCanvas(_, L) : ap("canvas");
        }
        function x(_, L, R, N) {
          let z = 1;
          if (
            ((_.width > N || _.height > N) &&
              (z = N / Math.max(_.width, _.height)),
            z < 1 || !0 === L)
          ) {
            if (
              !(
                ("u" > typeof HTMLImageElement &&
                  _ instanceof HTMLImageElement) ||
                ("u" > typeof HTMLCanvasElement &&
                  _ instanceof HTMLCanvasElement) ||
                ("u" > typeof ImageBitmap && _ instanceof ImageBitmap)
              )
            )
              return (
                "data" in _ &&
                  console.warn(
                    "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                      _.width +
                      "x" +
                      _.height +
                      ").",
                  ),
                _
              );
            {
              let N = L ? op : Math.floor,
                F = N(z * _.width),
                U = N(z * _.height);
              void 0 === er && (er = v(F, U));
              let k = R ? v(F, U) : er;
              return (
                (k.width = F),
                (k.height = U),
                k.getContext("2d").drawImage(_, 0, 0, F, U),
                console.warn(
                  "THREE.WebGLRenderer: Texture has been resized from (" +
                    _.width +
                    "x" +
                    _.height +
                    ") to (" +
                    F +
                    "x" +
                    U +
                    ").",
                ),
                k
              );
            }
          }
          return _;
        }
        function b(_) {
          return Bv(_.width) && Bv(_.height);
        }
        function A(_, L) {
          return (
            _.generateMipmaps &&
            L &&
            1003 !== _.minFilter &&
            1006 !== _.minFilter
          );
        }
        function T(L) {
          _.generateMipmap(L);
        }
        function S(R, N, z, F, U = !1) {
          if (!1 === k) return N;
          if (null !== R) {
            if (void 0 !== _[R]) return _[R];
            console.warn(
              "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
                R +
                "'",
            );
          }
          let Y = N;
          return (
            6403 === N &&
              (5126 === z && (Y = 33326),
              5131 === z && (Y = 33325),
              5121 === z && (Y = 33321)),
            33319 === N &&
              (5126 === z && (Y = 33328),
              5131 === z && (Y = 33327),
              5121 === z && (Y = 33323)),
            6408 === N &&
              (5126 === z && (Y = 34836),
              5131 === z && (Y = 34842),
              5121 === z && (Y = 3001 === F && !1 === U ? 35907 : 32856),
              32819 === z && (Y = 32854),
              32820 === z && (Y = 32855)),
            (33325 === Y ||
              33326 === Y ||
              33327 === Y ||
              33328 === Y ||
              34842 === Y ||
              34836 === Y) &&
              L.get("EXT_color_buffer_float"),
            Y
          );
        }
        function E(_, L, R) {
          return !0 === A(_, R) ||
            (_.isFramebufferTexture &&
              1003 !== _.minFilter &&
              1006 !== _.minFilter)
            ? Math.log2(Math.max(L.width, L.height)) + 1
            : void 0 !== _.mipmaps && _.mipmaps.length > 0
              ? _.mipmaps.length
              : _.isCompressedTexture && Array.isArray(_.image)
                ? L.mipmaps.length
                : 1;
        }
        function M(_) {
          return 1003 === _ || 1004 === _ || 1005 === _ ? 9728 : 9729;
        }
        function I(_) {
          let L = _.target;
          L.removeEventListener("dispose", I),
            (function (_) {
              let L = N.get(_);
              if (void 0 === L.__webglInit) return;
              let R = _.source,
                z = en.get(R);
              if (z) {
                let N = z[L.__cacheKey];
                N.usedTimes--,
                  0 === N.usedTimes && D(_),
                  0 === Object.keys(z).length && en.delete(R);
              }
              N.remove(_);
            })(L),
            L.isVideoTexture && ee.delete(L);
        }
        function P(L) {
          let R = L.target;
          R.removeEventListener("dispose", P),
            (function (L) {
              let R = L.texture,
                z = N.get(L),
                F = N.get(R);
              if (
                (void 0 !== F.__webglTexture &&
                  (_.deleteTexture(F.__webglTexture), U.memory.textures--),
                L.depthTexture && L.depthTexture.dispose(),
                L.isWebGLCubeRenderTarget)
              )
                for (let L = 0; L < 6; L++)
                  _.deleteFramebuffer(z.__webglFramebuffer[L]),
                    z.__webglDepthbuffer &&
                      _.deleteRenderbuffer(z.__webglDepthbuffer[L]);
              else {
                if (
                  (_.deleteFramebuffer(z.__webglFramebuffer),
                  z.__webglDepthbuffer &&
                    _.deleteRenderbuffer(z.__webglDepthbuffer),
                  z.__webglMultisampledFramebuffer &&
                    _.deleteFramebuffer(z.__webglMultisampledFramebuffer),
                  z.__webglColorRenderbuffer)
                )
                  for (let L = 0; L < z.__webglColorRenderbuffer.length; L++)
                    z.__webglColorRenderbuffer[L] &&
                      _.deleteRenderbuffer(z.__webglColorRenderbuffer[L]);
                z.__webglDepthRenderbuffer &&
                  _.deleteRenderbuffer(z.__webglDepthRenderbuffer);
              }
              if (L.isWebGLMultipleRenderTargets)
                for (let L = 0, z = R.length; L < z; L++) {
                  let z = N.get(R[L]);
                  z.__webglTexture &&
                    (_.deleteTexture(z.__webglTexture), U.memory.textures--),
                    N.remove(R[L]);
                }
              N.remove(R), N.remove(L);
            })(R);
        }
        function D(L) {
          let R = N.get(L);
          _.deleteTexture(R.__webglTexture);
          let z = L.source,
            F = en.get(z);
          delete F[R.__cacheKey], U.memory.textures--;
        }
        let eo = 0;
        function H(_, L) {
          let z,
            F = N.get(_);
          if (
            (_.isVideoTexture &&
              ((z = U.render.frame),
              ee.get(_) !== z && (ee.set(_, z), _.update())),
            !1 === _.isRenderTargetTexture &&
              _.version > 0 &&
              F.__version !== _.version)
          ) {
            let R = _.image;
            if (null === R)
              console.warn(
                "THREE.WebGLRenderer: Texture marked for update but no image data found.",
              );
            else if (!1 === R.complete)
              console.warn(
                "THREE.WebGLRenderer: Texture marked for update but image is incomplete",
              );
            else {
              Z(F, _, L);
              return;
            }
          }
          R.bindTexture(3553, F.__webglTexture, 33984 + L);
        }
        let el = { 1e3: 10497, 1001: 33071, 1002: 33648 },
          ec = {
            1003: 9728,
            1004: 9984,
            1005: 9986,
            1006: 9729,
            1007: 9985,
            1008: 9987,
          };
        function G(R, F, U) {
          if (
            (U
              ? (_.texParameteri(R, 10242, el[F.wrapS]),
                _.texParameteri(R, 10243, el[F.wrapT]),
                (32879 === R || 35866 === R) &&
                  _.texParameteri(R, 32882, el[F.wrapR]),
                _.texParameteri(R, 10240, ec[F.magFilter]),
                _.texParameteri(R, 10241, ec[F.minFilter]))
              : (_.texParameteri(R, 10242, 33071),
                _.texParameteri(R, 10243, 33071),
                (32879 === R || 35866 === R) &&
                  _.texParameteri(R, 32882, 33071),
                (1001 !== F.wrapS || 1001 !== F.wrapT) &&
                  console.warn(
                    "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.",
                  ),
                _.texParameteri(R, 10240, M(F.magFilter)),
                _.texParameteri(R, 10241, M(F.minFilter)),
                1003 !== F.minFilter &&
                  1006 !== F.minFilter &&
                  console.warn(
                    "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.",
                  )),
            !0 === L.has("EXT_texture_filter_anisotropic"))
          ) {
            let U = L.get("EXT_texture_filter_anisotropic");
            1003 !== F.magFilter &&
              (1005 === F.minFilter || 1008 === F.minFilter) &&
              (1015 !== F.type || !1 !== L.has("OES_texture_float_linear")) &&
              (!1 !== k ||
                1016 !== F.type ||
                !1 !== L.has("OES_texture_half_float_linear")) &&
              (F.anisotropy > 1 || N.get(F).__currentAnisotropy) &&
              (_.texParameterf(
                R,
                U.TEXTURE_MAX_ANISOTROPY_EXT,
                Math.min(F.anisotropy, z.getMaxAnisotropy()),
              ),
              (N.get(F).__currentAnisotropy = F.anisotropy));
          }
        }
        function re(L, R) {
          let N,
            z = !1;
          void 0 === L.__webglInit &&
            ((L.__webglInit = !0), R.addEventListener("dispose", I));
          let F = R.source,
            k = en.get(F);
          void 0 === k && ((k = {}), en.set(F, k));
          let Y =
            ((N = []).push(R.wrapS),
            N.push(R.wrapT),
            N.push(R.wrapR || 0),
            N.push(R.magFilter),
            N.push(R.minFilter),
            N.push(R.anisotropy),
            N.push(R.internalFormat),
            N.push(R.format),
            N.push(R.type),
            N.push(R.generateMipmaps),
            N.push(R.premultiplyAlpha),
            N.push(R.flipY),
            N.push(R.unpackAlignment),
            N.push(R.encoding),
            N.join());
          if (Y !== L.__cacheKey) {
            void 0 === k[Y] &&
              ((k[Y] = { texture: _.createTexture(), usedTimes: 0 }),
              U.memory.textures++,
              (z = !0)),
              k[Y].usedTimes++;
            let N = k[L.__cacheKey];
            void 0 !== N &&
              (k[L.__cacheKey].usedTimes--, 0 === N.usedTimes && D(R)),
              (L.__cacheKey = Y),
              (L.__webglTexture = k[Y].texture);
          }
          return z;
        }
        function Z(L, z, U) {
          let Y = 3553;
          (z.isDataArrayTexture || z.isCompressedArrayTexture) && (Y = 35866),
            z.isData3DTexture && (Y = 32879);
          let X = re(L, z),
            K = z.source;
          R.bindTexture(Y, L.__webglTexture, 33984 + U);
          let J = N.get(K);
          if (K.version !== J.__version || !0 === X) {
            R.activeTexture(33984 + U),
              _.pixelStorei(37440, z.flipY),
              _.pixelStorei(37441, z.premultiplyAlpha),
              _.pixelStorei(3317, z.unpackAlignment),
              _.pixelStorei(37443, 0);
            let L =
                !k &&
                (1001 !== z.wrapS ||
                  1001 !== z.wrapT ||
                  (1003 !== z.minFilter && 1006 !== z.minFilter)) &&
                !1 === b(z.image),
              N = x(z.image, L, !1, Q),
              $ = b((N = ht(z, N))) || k,
              ee = F.convert(z.format, z.encoding),
              er = F.convert(z.type),
              en = S(z.internalFormat, ee, er, z.encoding, z.isVideoTexture);
            G(Y, z, $);
            let ea,
              eo = z.mipmaps,
              el = k && !0 !== z.isVideoTexture,
              ec = void 0 === J.__version || !0 === X,
              ed = E(z, N, $);
            if (z.isDepthTexture)
              (en = 6402),
                k
                  ? (en =
                      1015 === z.type
                        ? 36012
                        : 1014 === z.type
                          ? 33190
                          : 1020 === z.type
                            ? 35056
                            : 33189)
                  : 1015 === z.type &&
                    console.error(
                      "WebGLRenderer: Floating point depth texture requires WebGL2.",
                    ),
                1026 === z.format &&
                  6402 === en &&
                  1012 !== z.type &&
                  1014 !== z.type &&
                  (console.warn(
                    "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.",
                  ),
                  (z.type = 1014),
                  (er = F.convert(z.type))),
                1027 === z.format &&
                  6402 === en &&
                  ((en = 34041),
                  1020 !== z.type &&
                    (console.warn(
                      "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.",
                    ),
                    (z.type = 1020),
                    (er = F.convert(z.type)))),
                ec &&
                  (el
                    ? R.texStorage2D(3553, 1, en, N.width, N.height)
                    : R.texImage2D(
                        3553,
                        0,
                        en,
                        N.width,
                        N.height,
                        0,
                        ee,
                        er,
                        null,
                      ));
            else if (z.isDataTexture) {
              if (eo.length > 0 && $) {
                el &&
                  ec &&
                  R.texStorage2D(3553, ed, en, eo[0].width, eo[0].height);
                for (let _ = 0, L = eo.length; _ < L; _++)
                  (ea = eo[_]),
                    el
                      ? R.texSubImage2D(
                          3553,
                          _,
                          0,
                          0,
                          ea.width,
                          ea.height,
                          ee,
                          er,
                          ea.data,
                        )
                      : R.texImage2D(
                          3553,
                          _,
                          en,
                          ea.width,
                          ea.height,
                          0,
                          ee,
                          er,
                          ea.data,
                        );
                z.generateMipmaps = !1;
              } else
                el
                  ? (ec && R.texStorage2D(3553, ed, en, N.width, N.height),
                    R.texSubImage2D(
                      3553,
                      0,
                      0,
                      0,
                      N.width,
                      N.height,
                      ee,
                      er,
                      N.data,
                    ))
                  : R.texImage2D(
                      3553,
                      0,
                      en,
                      N.width,
                      N.height,
                      0,
                      ee,
                      er,
                      N.data,
                    );
            } else if (z.isCompressedTexture) {
              if (z.isCompressedArrayTexture) {
                el &&
                  ec &&
                  R.texStorage3D(
                    35866,
                    ed,
                    en,
                    eo[0].width,
                    eo[0].height,
                    N.depth,
                  );
                for (let _ = 0, L = eo.length; _ < L; _++)
                  (ea = eo[_]),
                    1023 !== z.format
                      ? null !== ee
                        ? el
                          ? R.compressedTexSubImage3D(
                              35866,
                              _,
                              0,
                              0,
                              0,
                              ea.width,
                              ea.height,
                              N.depth,
                              ee,
                              ea.data,
                              0,
                              0,
                            )
                          : R.compressedTexImage3D(
                              35866,
                              _,
                              en,
                              ea.width,
                              ea.height,
                              N.depth,
                              0,
                              ea.data,
                              0,
                              0,
                            )
                        : console.warn(
                            "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()",
                          )
                      : el
                        ? R.texSubImage3D(
                            35866,
                            _,
                            0,
                            0,
                            0,
                            ea.width,
                            ea.height,
                            N.depth,
                            ee,
                            er,
                            ea.data,
                          )
                        : R.texImage3D(
                            35866,
                            _,
                            en,
                            ea.width,
                            ea.height,
                            N.depth,
                            0,
                            ee,
                            er,
                            ea.data,
                          );
              } else {
                el &&
                  ec &&
                  R.texStorage2D(3553, ed, en, eo[0].width, eo[0].height);
                for (let _ = 0, L = eo.length; _ < L; _++)
                  (ea = eo[_]),
                    1023 !== z.format
                      ? null !== ee
                        ? el
                          ? R.compressedTexSubImage2D(
                              3553,
                              _,
                              0,
                              0,
                              ea.width,
                              ea.height,
                              ee,
                              ea.data,
                            )
                          : R.compressedTexImage2D(
                              3553,
                              _,
                              en,
                              ea.width,
                              ea.height,
                              0,
                              ea.data,
                            )
                        : console.warn(
                            "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()",
                          )
                      : el
                        ? R.texSubImage2D(
                            3553,
                            _,
                            0,
                            0,
                            ea.width,
                            ea.height,
                            ee,
                            er,
                            ea.data,
                          )
                        : R.texImage2D(
                            3553,
                            _,
                            en,
                            ea.width,
                            ea.height,
                            0,
                            ee,
                            er,
                            ea.data,
                          );
              }
            } else if (z.isDataArrayTexture)
              el
                ? (ec &&
                    R.texStorage3D(35866, ed, en, N.width, N.height, N.depth),
                  R.texSubImage3D(
                    35866,
                    0,
                    0,
                    0,
                    0,
                    N.width,
                    N.height,
                    N.depth,
                    ee,
                    er,
                    N.data,
                  ))
                : R.texImage3D(
                    35866,
                    0,
                    en,
                    N.width,
                    N.height,
                    N.depth,
                    0,
                    ee,
                    er,
                    N.data,
                  );
            else if (z.isData3DTexture)
              el
                ? (ec &&
                    R.texStorage3D(32879, ed, en, N.width, N.height, N.depth),
                  R.texSubImage3D(
                    32879,
                    0,
                    0,
                    0,
                    0,
                    N.width,
                    N.height,
                    N.depth,
                    ee,
                    er,
                    N.data,
                  ))
                : R.texImage3D(
                    32879,
                    0,
                    en,
                    N.width,
                    N.height,
                    N.depth,
                    0,
                    ee,
                    er,
                    N.data,
                  );
            else if (z.isFramebufferTexture) {
              if (ec) {
                if (el) R.texStorage2D(3553, ed, en, N.width, N.height);
                else {
                  let _ = N.width,
                    L = N.height;
                  for (let N = 0; N < ed; N++)
                    R.texImage2D(3553, N, en, _, L, 0, ee, er, null),
                      (_ >>= 1),
                      (L >>= 1);
                }
              }
            } else if (eo.length > 0 && $) {
              el &&
                ec &&
                R.texStorage2D(3553, ed, en, eo[0].width, eo[0].height);
              for (let _ = 0, L = eo.length; _ < L; _++)
                (ea = eo[_]),
                  el
                    ? R.texSubImage2D(3553, _, 0, 0, ee, er, ea)
                    : R.texImage2D(3553, _, en, ee, er, ea);
              z.generateMipmaps = !1;
            } else
              el
                ? (ec && R.texStorage2D(3553, ed, en, N.width, N.height),
                  R.texSubImage2D(3553, 0, 0, 0, ee, er, N))
                : R.texImage2D(3553, 0, en, ee, er, N);
            A(z, $) && T(Y),
              (J.__version = K.version),
              z.onUpdate && z.onUpdate(z);
          }
          L.__version = z.version;
        }
        function V(L, z, U, k, Y) {
          let X = F.convert(U.format, U.encoding),
            Q = F.convert(U.type),
            K = S(U.internalFormat, X, Q, U.encoding);
          N.get(z).__hasExternalTextures ||
            (32879 === Y || 35866 === Y
              ? R.texImage3D(Y, 0, K, z.width, z.height, z.depth, 0, X, Q, null)
              : R.texImage2D(Y, 0, K, z.width, z.height, 0, X, Q, null)),
            R.bindFramebuffer(36160, L),
            be(z)
              ? J.framebufferTexture2DMultisampleEXT(
                  36160,
                  k,
                  Y,
                  N.get(U).__webglTexture,
                  0,
                  Pe(z),
                )
              : (3553 === Y || (Y >= 34069 && Y <= 34074)) &&
                _.framebufferTexture2D(36160, k, Y, N.get(U).__webglTexture, 0),
            R.bindFramebuffer(36160, null);
        }
        function pe(L, R, N) {
          if (
            (_.bindRenderbuffer(36161, L), R.depthBuffer && !R.stencilBuffer)
          ) {
            let z = 33189;
            if (N || be(R)) {
              let L = R.depthTexture;
              L &&
                L.isDepthTexture &&
                (1015 === L.type
                  ? (z = 36012)
                  : 1014 === L.type && (z = 33190));
              let N = Pe(R);
              be(R)
                ? J.renderbufferStorageMultisampleEXT(
                    36161,
                    N,
                    z,
                    R.width,
                    R.height,
                  )
                : _.renderbufferStorageMultisample(
                    36161,
                    N,
                    z,
                    R.width,
                    R.height,
                  );
            } else _.renderbufferStorage(36161, z, R.width, R.height);
            _.framebufferRenderbuffer(36160, 36096, 36161, L);
          } else if (R.depthBuffer && R.stencilBuffer) {
            let z = Pe(R);
            N && !1 === be(R)
              ? _.renderbufferStorageMultisample(
                  36161,
                  z,
                  35056,
                  R.width,
                  R.height,
                )
              : be(R)
                ? J.renderbufferStorageMultisampleEXT(
                    36161,
                    z,
                    35056,
                    R.width,
                    R.height,
                  )
                : _.renderbufferStorage(36161, 34041, R.width, R.height),
              _.framebufferRenderbuffer(36160, 33306, 36161, L);
          } else {
            let L =
              !0 === R.isWebGLMultipleRenderTargets ? R.texture : [R.texture];
            for (let z = 0; z < L.length; z++) {
              let U = L[z],
                k = F.convert(U.format, U.encoding),
                Y = F.convert(U.type),
                X = S(U.internalFormat, k, Y, U.encoding),
                Q = Pe(R);
              N && !1 === be(R)
                ? _.renderbufferStorageMultisample(
                    36161,
                    Q,
                    X,
                    R.width,
                    R.height,
                  )
                : be(R)
                  ? J.renderbufferStorageMultisampleEXT(
                      36161,
                      Q,
                      X,
                      R.width,
                      R.height,
                    )
                  : _.renderbufferStorage(36161, X, R.width, R.height);
            }
          }
          _.bindRenderbuffer(36161, null);
        }
        function ae(L) {
          let z = N.get(L),
            F = !0 === L.isWebGLCubeRenderTarget;
          if (L.depthTexture && !z.__autoAllocateDepthBuffer) {
            if (F)
              throw Error(
                "target.depthTexture not supported in Cube render targets",
              );
            !(function (L, z) {
              if (z && z.isWebGLCubeRenderTarget)
                throw Error(
                  "Depth Texture with cube render targets is not supported",
                );
              if (
                (R.bindFramebuffer(36160, L),
                !(z.depthTexture && z.depthTexture.isDepthTexture))
              )
                throw Error(
                  "renderTarget.depthTexture must be an instance of THREE.DepthTexture",
                );
              (N.get(z.depthTexture).__webglTexture &&
                z.depthTexture.image.width === z.width &&
                z.depthTexture.image.height === z.height) ||
                ((z.depthTexture.image.width = z.width),
                (z.depthTexture.image.height = z.height),
                (z.depthTexture.needsUpdate = !0)),
                H(z.depthTexture, 0);
              let F = N.get(z.depthTexture).__webglTexture,
                U = Pe(z);
              if (1026 === z.depthTexture.format)
                be(z)
                  ? J.framebufferTexture2DMultisampleEXT(
                      36160,
                      36096,
                      3553,
                      F,
                      0,
                      U,
                    )
                  : _.framebufferTexture2D(36160, 36096, 3553, F, 0);
              else if (1027 === z.depthTexture.format)
                be(z)
                  ? J.framebufferTexture2DMultisampleEXT(
                      36160,
                      33306,
                      3553,
                      F,
                      0,
                      U,
                    )
                  : _.framebufferTexture2D(36160, 33306, 3553, F, 0);
              else throw Error("Unknown depthTexture format");
            })(z.__webglFramebuffer, L);
          } else if (F) {
            z.__webglDepthbuffer = [];
            for (let N = 0; N < 6; N++)
              R.bindFramebuffer(36160, z.__webglFramebuffer[N]),
                (z.__webglDepthbuffer[N] = _.createRenderbuffer()),
                pe(z.__webglDepthbuffer[N], L, !1);
          } else
            R.bindFramebuffer(36160, z.__webglFramebuffer),
              (z.__webglDepthbuffer = _.createRenderbuffer()),
              pe(z.__webglDepthbuffer, L, !1);
          R.bindFramebuffer(36160, null);
        }
        function Pe(_) {
          return Math.min(K, _.samples);
        }
        function be(_) {
          let R = N.get(_);
          return (
            k &&
            _.samples > 0 &&
            !0 === L.has("WEBGL_multisampled_render_to_texture") &&
            !1 !== R.__useRenderToTexture
          );
        }
        function ht(_, R) {
          let N = _.encoding,
            z = _.format,
            F = _.type;
          return (
            !0 === _.isCompressedTexture ||
              !0 === _.isVideoTexture ||
              1035 === _.format ||
              (3e3 !== N &&
                (3001 === N
                  ? !1 === k
                    ? !0 === L.has("EXT_sRGB") && 1023 === z
                      ? ((_.format = 1035),
                        (_.minFilter = 1006),
                        (_.generateMipmaps = !1))
                      : (R = iU.sRGBToLinear(R))
                    : (1023 !== z || 1009 !== F) &&
                      console.warn(
                        "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.",
                      )
                  : console.error(
                      "THREE.WebGLTextures: Unsupported texture encoding:",
                      N,
                    ))),
            R
          );
        }
        (this.allocateTextureUnit = function () {
          let _ = eo;
          return (
            _ >= Y &&
              console.warn(
                "THREE.WebGLTextures: Trying to use " +
                  _ +
                  " texture units while this GPU supports only " +
                  Y,
              ),
            (eo += 1),
            _
          );
        }),
          (this.resetTextureUnits = function () {
            eo = 0;
          }),
          (this.setTexture2D = H),
          (this.setTexture2DArray = function (_, L) {
            let z = N.get(_);
            if (_.version > 0 && z.__version !== _.version) {
              Z(z, _, L);
              return;
            }
            R.bindTexture(35866, z.__webglTexture, 33984 + L);
          }),
          (this.setTexture3D = function (_, L) {
            let z = N.get(_);
            if (_.version > 0 && z.__version !== _.version) {
              Z(z, _, L);
              return;
            }
            R.bindTexture(32879, z.__webglTexture, 33984 + L);
          }),
          (this.setTextureCube = function (L, z) {
            let U = N.get(L);
            if (L.version > 0 && U.__version !== L.version) {
              (function (L, z, U) {
                if (6 !== z.image.length) return;
                let Y = re(L, z),
                  Q = z.source;
                R.bindTexture(34067, L.__webglTexture, 33984 + U);
                let K = N.get(Q);
                if (Q.version !== K.__version || !0 === Y) {
                  let L;
                  R.activeTexture(33984 + U),
                    _.pixelStorei(37440, z.flipY),
                    _.pixelStorei(37441, z.premultiplyAlpha),
                    _.pixelStorei(3317, z.unpackAlignment),
                    _.pixelStorei(37443, 0);
                  let N =
                      z.isCompressedTexture || z.image[0].isCompressedTexture,
                    J = z.image[0] && z.image[0].isDataTexture,
                    $ = [];
                  for (let _ = 0; _ < 6; _++)
                    N || J
                      ? ($[_] = J ? z.image[_].image : z.image[_])
                      : ($[_] = x(z.image[_], !1, !0, X)),
                      ($[_] = ht(z, $[_]));
                  let ee = $[0],
                    er = b(ee) || k,
                    en = F.convert(z.format, z.encoding),
                    ea = F.convert(z.type),
                    eo = S(z.internalFormat, en, ea, z.encoding),
                    el = k && !0 !== z.isVideoTexture,
                    ec = void 0 === K.__version || !0 === Y,
                    ed = E(z, ee, er);
                  if ((G(34067, z, er), N)) {
                    el &&
                      ec &&
                      R.texStorage2D(34067, ed, eo, ee.width, ee.height);
                    for (let _ = 0; _ < 6; _++) {
                      L = $[_].mipmaps;
                      for (let N = 0; N < L.length; N++) {
                        let F = L[N];
                        1023 !== z.format
                          ? null !== en
                            ? el
                              ? R.compressedTexSubImage2D(
                                  34069 + _,
                                  N,
                                  0,
                                  0,
                                  F.width,
                                  F.height,
                                  en,
                                  F.data,
                                )
                              : R.compressedTexImage2D(
                                  34069 + _,
                                  N,
                                  eo,
                                  F.width,
                                  F.height,
                                  0,
                                  F.data,
                                )
                            : console.warn(
                                "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()",
                              )
                          : el
                            ? R.texSubImage2D(
                                34069 + _,
                                N,
                                0,
                                0,
                                F.width,
                                F.height,
                                en,
                                ea,
                                F.data,
                              )
                            : R.texImage2D(
                                34069 + _,
                                N,
                                eo,
                                F.width,
                                F.height,
                                0,
                                en,
                                ea,
                                F.data,
                              );
                      }
                    }
                  } else {
                    (L = z.mipmaps),
                      el &&
                        ec &&
                        (L.length > 0 && ed++,
                        R.texStorage2D(34067, ed, eo, $[0].width, $[0].height));
                    for (let _ = 0; _ < 6; _++)
                      if (J) {
                        el
                          ? R.texSubImage2D(
                              34069 + _,
                              0,
                              0,
                              0,
                              $[_].width,
                              $[_].height,
                              en,
                              ea,
                              $[_].data,
                            )
                          : R.texImage2D(
                              34069 + _,
                              0,
                              eo,
                              $[_].width,
                              $[_].height,
                              0,
                              en,
                              ea,
                              $[_].data,
                            );
                        for (let N = 0; N < L.length; N++) {
                          let z = L[N].image[_].image;
                          el
                            ? R.texSubImage2D(
                                34069 + _,
                                N + 1,
                                0,
                                0,
                                z.width,
                                z.height,
                                en,
                                ea,
                                z.data,
                              )
                            : R.texImage2D(
                                34069 + _,
                                N + 1,
                                eo,
                                z.width,
                                z.height,
                                0,
                                en,
                                ea,
                                z.data,
                              );
                        }
                      } else {
                        el
                          ? R.texSubImage2D(34069 + _, 0, 0, 0, en, ea, $[_])
                          : R.texImage2D(34069 + _, 0, eo, en, ea, $[_]);
                        for (let N = 0; N < L.length; N++) {
                          let z = L[N];
                          el
                            ? R.texSubImage2D(
                                34069 + _,
                                N + 1,
                                0,
                                0,
                                en,
                                ea,
                                z.image[_],
                              )
                            : R.texImage2D(
                                34069 + _,
                                N + 1,
                                eo,
                                en,
                                ea,
                                z.image[_],
                              );
                        }
                      }
                  }
                  A(z, er) && T(34067),
                    (K.__version = Q.version),
                    z.onUpdate && z.onUpdate(z);
                }
                L.__version = z.version;
              })(U, L, z);
              return;
            }
            R.bindTexture(34067, U.__webglTexture, 33984 + z);
          }),
          (this.rebindTextures = function (_, L, R) {
            let z = N.get(_);
            void 0 !== L && V(z.__webglFramebuffer, _, _.texture, 36064, 3553),
              void 0 !== R && ae(_);
          }),
          (this.setupRenderTarget = function (L) {
            let Y = L.texture,
              X = N.get(L),
              Q = N.get(Y);
            L.addEventListener("dispose", P),
              !0 !== L.isWebGLMultipleRenderTargets &&
                (void 0 === Q.__webglTexture &&
                  (Q.__webglTexture = _.createTexture()),
                (Q.__version = Y.version),
                U.memory.textures++);
            let K = !0 === L.isWebGLCubeRenderTarget,
              J = !0 === L.isWebGLMultipleRenderTargets,
              $ = b(L) || k;
            if (K) {
              X.__webglFramebuffer = [];
              for (let L = 0; L < 6; L++)
                X.__webglFramebuffer[L] = _.createFramebuffer();
            } else {
              if (((X.__webglFramebuffer = _.createFramebuffer()), J)) {
                if (z.drawBuffers) {
                  let R = L.texture;
                  for (let L = 0, z = R.length; L < z; L++) {
                    let z = N.get(R[L]);
                    void 0 === z.__webglTexture &&
                      ((z.__webglTexture = _.createTexture()),
                      U.memory.textures++);
                  }
                } else
                  console.warn(
                    "THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.",
                  );
              }
              if (k && L.samples > 0 && !1 === be(L)) {
                let N = J ? Y : [Y];
                (X.__webglMultisampledFramebuffer = _.createFramebuffer()),
                  (X.__webglColorRenderbuffer = []),
                  R.bindFramebuffer(36160, X.__webglMultisampledFramebuffer);
                for (let R = 0; R < N.length; R++) {
                  let z = N[R];
                  (X.__webglColorRenderbuffer[R] = _.createRenderbuffer()),
                    _.bindRenderbuffer(36161, X.__webglColorRenderbuffer[R]);
                  let U = F.convert(z.format, z.encoding),
                    k = F.convert(z.type),
                    Y = S(
                      z.internalFormat,
                      U,
                      k,
                      z.encoding,
                      !0 === L.isXRRenderTarget,
                    ),
                    Q = Pe(L);
                  _.renderbufferStorageMultisample(
                    36161,
                    Q,
                    Y,
                    L.width,
                    L.height,
                  ),
                    _.framebufferRenderbuffer(
                      36160,
                      36064 + R,
                      36161,
                      X.__webglColorRenderbuffer[R],
                    );
                }
                _.bindRenderbuffer(36161, null),
                  L.depthBuffer &&
                    ((X.__webglDepthRenderbuffer = _.createRenderbuffer()),
                    pe(X.__webglDepthRenderbuffer, L, !0)),
                  R.bindFramebuffer(36160, null);
              }
            }
            if (K) {
              R.bindTexture(34067, Q.__webglTexture), G(34067, Y, $);
              for (let _ = 0; _ < 6; _++)
                V(X.__webglFramebuffer[_], L, Y, 36064, 34069 + _);
              A(Y, $) && T(34067), R.unbindTexture();
            } else if (J) {
              let _ = L.texture;
              for (let z = 0, F = _.length; z < F; z++) {
                let F = _[z],
                  U = N.get(F);
                R.bindTexture(3553, U.__webglTexture),
                  G(3553, F, $),
                  V(X.__webglFramebuffer, L, F, 36064 + z, 3553),
                  A(F, $) && T(3553);
              }
              R.unbindTexture();
            } else {
              let _ = 3553;
              (L.isWebGL3DRenderTarget || L.isWebGLArrayRenderTarget) &&
                (k
                  ? (_ = L.isWebGL3DRenderTarget ? 32879 : 35866)
                  : console.error(
                      "THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.",
                    )),
                R.bindTexture(_, Q.__webglTexture),
                G(_, Y, $),
                V(X.__webglFramebuffer, L, Y, 36064, _),
                A(Y, $) && T(_),
                R.unbindTexture();
            }
            L.depthBuffer && ae(L);
          }),
          (this.updateRenderTargetMipmap = function (_) {
            let L = b(_) || k,
              z =
                !0 === _.isWebGLMultipleRenderTargets ? _.texture : [_.texture];
            for (let F = 0, U = z.length; F < U; F++) {
              let U = z[F];
              if (A(U, L)) {
                let L = _.isWebGLCubeRenderTarget ? 34067 : 3553,
                  z = N.get(U).__webglTexture;
                R.bindTexture(L, z), T(L), R.unbindTexture();
              }
            }
          }),
          (this.updateMultisampleRenderTarget = function (L) {
            if (k && L.samples > 0 && !1 === be(L)) {
              let z = L.isWebGLMultipleRenderTargets ? L.texture : [L.texture],
                F = L.width,
                U = L.height,
                k = 16384,
                Y = [],
                X = L.stencilBuffer ? 33306 : 36096,
                Q = N.get(L),
                K = !0 === L.isWebGLMultipleRenderTargets;
              if (K)
                for (let L = 0; L < z.length; L++)
                  R.bindFramebuffer(36160, Q.__webglMultisampledFramebuffer),
                    _.framebufferRenderbuffer(36160, 36064 + L, 36161, null),
                    R.bindFramebuffer(36160, Q.__webglFramebuffer),
                    _.framebufferTexture2D(36009, 36064 + L, 3553, null, 0);
              R.bindFramebuffer(36008, Q.__webglMultisampledFramebuffer),
                R.bindFramebuffer(36009, Q.__webglFramebuffer);
              for (let R = 0; R < z.length; R++) {
                Y.push(36064 + R), L.depthBuffer && Y.push(X);
                let J =
                  void 0 !== Q.__ignoreDepthValues && Q.__ignoreDepthValues;
                if (
                  (!1 === J &&
                    (L.depthBuffer && (k |= 256),
                    L.stencilBuffer && (k |= 1024)),
                  K &&
                    _.framebufferRenderbuffer(
                      36008,
                      36064,
                      36161,
                      Q.__webglColorRenderbuffer[R],
                    ),
                  !0 === J &&
                    (_.invalidateFramebuffer(36008, [X]),
                    _.invalidateFramebuffer(36009, [X])),
                  K)
                ) {
                  let L = N.get(z[R]).__webglTexture;
                  _.framebufferTexture2D(36009, 36064, 3553, L, 0);
                }
                _.blitFramebuffer(0, 0, F, U, 0, 0, F, U, k, 9728),
                  $ && _.invalidateFramebuffer(36008, Y);
              }
              if (
                (R.bindFramebuffer(36008, null),
                R.bindFramebuffer(36009, null),
                K)
              )
                for (let L = 0; L < z.length; L++) {
                  R.bindFramebuffer(36160, Q.__webglMultisampledFramebuffer),
                    _.framebufferRenderbuffer(
                      36160,
                      36064 + L,
                      36161,
                      Q.__webglColorRenderbuffer[L],
                    );
                  let F = N.get(z[L]).__webglTexture;
                  R.bindFramebuffer(36160, Q.__webglFramebuffer),
                    _.framebufferTexture2D(36009, 36064 + L, 3553, F, 0);
                }
              R.bindFramebuffer(36009, Q.__webglMultisampledFramebuffer);
            }
          }),
          (this.setupDepthRenderbuffer = ae),
          (this.setupFrameBufferTexture = V),
          (this.useMultisampledRTT = be);
      }
      function lN(_, L, R) {
        let N = R.isWebGL2;
        return {
          convert: function (R, z = null) {
            let F;
            if (1009 === R) return 5121;
            if (1017 === R) return 32819;
            if (1018 === R) return 32820;
            if (1010 === R) return 5120;
            if (1011 === R) return 5122;
            if (1012 === R) return 5123;
            if (1013 === R) return 5124;
            if (1014 === R) return 5125;
            if (1015 === R) return 5126;
            if (1016 === R)
              return N
                ? 5131
                : null !== (F = L.get("OES_texture_half_float"))
                  ? F.HALF_FLOAT_OES
                  : null;
            if (1021 === R) return 6406;
            if (1023 === R) return 6408;
            if (1024 === R) return 6409;
            if (1025 === R) return 6410;
            if (1026 === R) return 6402;
            if (1027 === R) return 34041;
            if (1035 === R)
              return null !== (F = L.get("EXT_sRGB")) ? F.SRGB_ALPHA_EXT : null;
            if (1028 === R) return 6403;
            if (1029 === R) return 36244;
            if (1030 === R) return 33319;
            if (1031 === R) return 33320;
            if (1033 === R) return 36249;
            if (33776 === R || 33777 === R || 33778 === R || 33779 === R) {
              if (3001 === z) {
                if (null === (F = L.get("WEBGL_compressed_texture_s3tc_srgb")))
                  return null;
                if (33776 === R) return F.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                if (33777 === R) return F.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                if (33778 === R) return F.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                if (33779 === R) return F.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
              } else {
                if (null === (F = L.get("WEBGL_compressed_texture_s3tc")))
                  return null;
                if (33776 === R) return F.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (33777 === R) return F.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (33778 === R) return F.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (33779 === R) return F.COMPRESSED_RGBA_S3TC_DXT5_EXT;
              }
            }
            if (35840 === R || 35841 === R || 35842 === R || 35843 === R) {
              if (null === (F = L.get("WEBGL_compressed_texture_pvrtc")))
                return null;
              if (35840 === R) return F.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
              if (35841 === R) return F.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
              if (35842 === R) return F.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
              if (35843 === R) return F.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
            }
            if (36196 === R)
              return null !== (F = L.get("WEBGL_compressed_texture_etc1"))
                ? F.COMPRESSED_RGB_ETC1_WEBGL
                : null;
            if (37492 === R || 37496 === R) {
              if (null === (F = L.get("WEBGL_compressed_texture_etc")))
                return null;
              if (37492 === R)
                return 3001 === z
                  ? F.COMPRESSED_SRGB8_ETC2
                  : F.COMPRESSED_RGB8_ETC2;
              if (37496 === R)
                return 3001 === z
                  ? F.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
                  : F.COMPRESSED_RGBA8_ETC2_EAC;
            }
            if (
              37808 === R ||
              37809 === R ||
              37810 === R ||
              37811 === R ||
              37812 === R ||
              37813 === R ||
              37814 === R ||
              37815 === R ||
              37816 === R ||
              37817 === R ||
              37818 === R ||
              37819 === R ||
              37820 === R ||
              37821 === R
            ) {
              if (null === (F = L.get("WEBGL_compressed_texture_astc")))
                return null;
              if (37808 === R)
                return 3001 === z
                  ? F.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
                  : F.COMPRESSED_RGBA_ASTC_4x4_KHR;
              if (37809 === R)
                return 3001 === z
                  ? F.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
                  : F.COMPRESSED_RGBA_ASTC_5x4_KHR;
              if (37810 === R)
                return 3001 === z
                  ? F.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
                  : F.COMPRESSED_RGBA_ASTC_5x5_KHR;
              if (37811 === R)
                return 3001 === z
                  ? F.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
                  : F.COMPRESSED_RGBA_ASTC_6x5_KHR;
              if (37812 === R)
                return 3001 === z
                  ? F.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
                  : F.COMPRESSED_RGBA_ASTC_6x6_KHR;
              if (37813 === R)
                return 3001 === z
                  ? F.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
                  : F.COMPRESSED_RGBA_ASTC_8x5_KHR;
              if (37814 === R)
                return 3001 === z
                  ? F.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
                  : F.COMPRESSED_RGBA_ASTC_8x6_KHR;
              if (37815 === R)
                return 3001 === z
                  ? F.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
                  : F.COMPRESSED_RGBA_ASTC_8x8_KHR;
              if (37816 === R)
                return 3001 === z
                  ? F.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
                  : F.COMPRESSED_RGBA_ASTC_10x5_KHR;
              if (37817 === R)
                return 3001 === z
                  ? F.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
                  : F.COMPRESSED_RGBA_ASTC_10x6_KHR;
              if (37818 === R)
                return 3001 === z
                  ? F.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
                  : F.COMPRESSED_RGBA_ASTC_10x8_KHR;
              if (37819 === R)
                return 3001 === z
                  ? F.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
                  : F.COMPRESSED_RGBA_ASTC_10x10_KHR;
              if (37820 === R)
                return 3001 === z
                  ? F.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
                  : F.COMPRESSED_RGBA_ASTC_12x10_KHR;
              if (37821 === R)
                return 3001 === z
                  ? F.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
                  : F.COMPRESSED_RGBA_ASTC_12x12_KHR;
            }
            if (36492 === R) {
              if (null === (F = L.get("EXT_texture_compression_bptc")))
                return null;
              if (36492 === R)
                return 3001 === z
                  ? F.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
                  : F.COMPRESSED_RGBA_BPTC_UNORM_EXT;
            }
            if (36283 === R || 36284 === R || 36285 === R || 36286 === R) {
              if (null === (F = L.get("EXT_texture_compression_rgtc")))
                return null;
              if (36492 === R) return F.COMPRESSED_RED_RGTC1_EXT;
              if (36284 === R) return F.COMPRESSED_SIGNED_RED_RGTC1_EXT;
              if (36285 === R) return F.COMPRESSED_RED_GREEN_RGTC2_EXT;
              if (36286 === R) return F.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
            }
            return 1020 === R
              ? N
                ? 34042
                : null !== (F = L.get("WEBGL_depth_texture"))
                  ? F.UNSIGNED_INT_24_8_WEBGL
                  : null
              : void 0 !== _[R]
                ? _[R]
                : null;
          },
        };
      }
      var nq = class extends sK {
          constructor(_ = []) {
            super(), (this.isArrayCamera = !0), (this.cameras = _);
          }
        },
        nQ = class extends rK {
          constructor() {
            super(), (this.isGroup = !0), (this.type = "Group");
          }
        },
        nZ = { type: "move" },
        nK = class {
          constructor() {
            (this._targetRay = null), (this._grip = null), (this._hand = null);
          }
          getHandSpace() {
            return (
              null === this._hand &&
                ((this._hand = new nQ()),
                (this._hand.matrixAutoUpdate = !1),
                (this._hand.visible = !1),
                (this._hand.joints = {}),
                (this._hand.inputState = { pinching: !1 })),
              this._hand
            );
          }
          getTargetRaySpace() {
            return (
              null === this._targetRay &&
                ((this._targetRay = new nQ()),
                (this._targetRay.matrixAutoUpdate = !1),
                (this._targetRay.visible = !1),
                (this._targetRay.hasLinearVelocity = !1),
                (this._targetRay.linearVelocity = new iq()),
                (this._targetRay.hasAngularVelocity = !1),
                (this._targetRay.angularVelocity = new iq())),
              this._targetRay
            );
          }
          getGripSpace() {
            return (
              null === this._grip &&
                ((this._grip = new nQ()),
                (this._grip.matrixAutoUpdate = !1),
                (this._grip.visible = !1),
                (this._grip.hasLinearVelocity = !1),
                (this._grip.linearVelocity = new iq()),
                (this._grip.hasAngularVelocity = !1),
                (this._grip.angularVelocity = new iq())),
              this._grip
            );
          }
          dispatchEvent(_) {
            return (
              null !== this._targetRay && this._targetRay.dispatchEvent(_),
              null !== this._grip && this._grip.dispatchEvent(_),
              null !== this._hand && this._hand.dispatchEvent(_),
              this
            );
          }
          connect(_) {
            if (_ && _.hand) {
              let L = this._hand;
              if (L) for (let R of _.hand.values()) this._getHandJoint(L, R);
            }
            return this.dispatchEvent({ type: "connected", data: _ }), this;
          }
          disconnect(_) {
            return (
              this.dispatchEvent({ type: "disconnected", data: _ }),
              null !== this._targetRay && (this._targetRay.visible = !1),
              null !== this._grip && (this._grip.visible = !1),
              null !== this._hand && (this._hand.visible = !1),
              this
            );
          }
          update(_, L, R) {
            let N = null,
              z = null,
              F = null,
              U = this._targetRay,
              k = this._grip,
              Y = this._hand;
            if (_ && "visible-blurred" !== L.session.visibilityState) {
              if (Y && _.hand) {
                for (let N of ((F = !0), _.hand.values())) {
                  let _ = L.getJointPose(N, R),
                    z = this._getHandJoint(Y, N);
                  null !== _ &&
                    (z.matrix.fromArray(_.transform.matrix),
                    z.matrix.decompose(z.position, z.rotation, z.scale),
                    (z.jointRadius = _.radius)),
                    (z.visible = null !== _);
                }
                let N = Y.joints["index-finger-tip"],
                  z = Y.joints["thumb-tip"],
                  U = N.position.distanceTo(z.position);
                Y.inputState.pinching && U > 0.025
                  ? ((Y.inputState.pinching = !1),
                    this.dispatchEvent({
                      type: "pinchend",
                      handedness: _.handedness,
                      target: this,
                    }))
                  : !Y.inputState.pinching &&
                    U <= 0.015 &&
                    ((Y.inputState.pinching = !0),
                    this.dispatchEvent({
                      type: "pinchstart",
                      handedness: _.handedness,
                      target: this,
                    }));
              } else
                null !== k &&
                  _.gripSpace &&
                  null !== (z = L.getPose(_.gripSpace, R)) &&
                  (k.matrix.fromArray(z.transform.matrix),
                  k.matrix.decompose(k.position, k.rotation, k.scale),
                  z.linearVelocity
                    ? ((k.hasLinearVelocity = !0),
                      k.linearVelocity.copy(z.linearVelocity))
                    : (k.hasLinearVelocity = !1),
                  z.angularVelocity
                    ? ((k.hasAngularVelocity = !0),
                      k.angularVelocity.copy(z.angularVelocity))
                    : (k.hasAngularVelocity = !1));
              null !== U &&
                (null === (N = L.getPose(_.targetRaySpace, R)) &&
                  null !== z &&
                  (N = z),
                null !== N &&
                  (U.matrix.fromArray(N.transform.matrix),
                  U.matrix.decompose(U.position, U.rotation, U.scale),
                  N.linearVelocity
                    ? ((U.hasLinearVelocity = !0),
                      U.linearVelocity.copy(N.linearVelocity))
                    : (U.hasLinearVelocity = !1),
                  N.angularVelocity
                    ? ((U.hasAngularVelocity = !0),
                      U.angularVelocity.copy(N.angularVelocity))
                    : (U.hasAngularVelocity = !1),
                  this.dispatchEvent(nZ)));
            }
            return (
              null !== U && (U.visible = null !== N),
              null !== k && (k.visible = null !== z),
              null !== Y && (Y.visible = null !== F),
              this
            );
          }
          _getHandJoint(_, L) {
            if (void 0 === _.joints[L.jointName]) {
              let R = new nQ();
              (R.matrixAutoUpdate = !1),
                (R.visible = !1),
                (_.joints[L.jointName] = R),
                _.add(R);
            }
            return _.joints[L.jointName];
          }
        },
        nJ = class extends iG {
          constructor(_, L, R, N, z, F, U, k, Y, X) {
            if (1026 !== (X = void 0 !== X ? X : 1026) && 1027 !== X)
              throw Error(
                "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat",
              );
            void 0 === R && 1026 === X && (R = 1014),
              void 0 === R && 1027 === X && (R = 1020),
              super(null, N, z, F, U, k, X, R, Y),
              (this.isDepthTexture = !0),
              (this.image = { width: _, height: L }),
              (this.magFilter = void 0 !== U ? U : 1003),
              (this.minFilter = void 0 !== k ? k : 1003),
              (this.flipY = !1),
              (this.generateMipmaps = !1);
          }
        },
        n$ = class extends ig {
          constructor(_, L) {
            super();
            let R = this,
              N = null,
              z = 1,
              F = null,
              U = "local-floor",
              k = 1,
              Y = null,
              X = null,
              Q = null,
              K = null,
              J = null,
              $ = null,
              ee = L.getContextAttributes(),
              er = null,
              en = null,
              ea = [],
              eo = [],
              el = new Set(),
              ec = new Map(),
              ed = new sK();
            ed.layers.enable(1), (ed.viewport = new iV());
            let eu = new sK();
            eu.layers.enable(2), (eu.viewport = new iV());
            let ep = [ed, eu],
              ef = new nq();
            ef.layers.enable(1), ef.layers.enable(2);
            let ev = null,
              ex = null;
            function P(_) {
              let L = eo.indexOf(_.inputSource);
              if (-1 === L) return;
              let R = ea[L];
              void 0 !== R &&
                R.dispatchEvent({ type: _.type, data: _.inputSource });
            }
            function C() {
              N.removeEventListener("select", P),
                N.removeEventListener("selectstart", P),
                N.removeEventListener("selectend", P),
                N.removeEventListener("squeeze", P),
                N.removeEventListener("squeezestart", P),
                N.removeEventListener("squeezeend", P),
                N.removeEventListener("end", C),
                N.removeEventListener("inputsourceschange", D);
              for (let _ = 0; _ < ea.length; _++) {
                let L = eo[_];
                null !== L && ((eo[_] = null), ea[_].disconnect(L));
              }
              (ev = null),
                (ex = null),
                _.setRenderTarget(er),
                (J = null),
                (K = null),
                (Q = null),
                (N = null),
                (en = null),
                eA.stop(),
                (R.isPresenting = !1),
                R.dispatchEvent({ type: "sessionend" });
            }
            function D(_) {
              for (let L = 0; L < _.removed.length; L++) {
                let R = _.removed[L],
                  N = eo.indexOf(R);
                N >= 0 && ((eo[N] = null), ea[N].disconnect(R));
              }
              for (let L = 0; L < _.added.length; L++) {
                let R = _.added[L],
                  N = eo.indexOf(R);
                if (-1 === N) {
                  for (let _ = 0; _ < ea.length; _++)
                    if (_ >= eo.length) {
                      eo.push(R), (N = _);
                      break;
                    } else if (null === eo[_]) {
                      (eo[_] = R), (N = _);
                      break;
                    }
                  if (-1 === N) break;
                }
                let z = ea[N];
                z && z.connect(R);
              }
            }
            (this.cameraAutoUpdate = !0),
              (this.enabled = !1),
              (this.isPresenting = !1),
              (this.getController = function (_) {
                let L = ea[_];
                return (
                  void 0 === L && ((L = new nK()), (ea[_] = L)),
                  L.getTargetRaySpace()
                );
              }),
              (this.getControllerGrip = function (_) {
                let L = ea[_];
                return (
                  void 0 === L && ((L = new nK()), (ea[_] = L)),
                  L.getGripSpace()
                );
              }),
              (this.getHand = function (_) {
                let L = ea[_];
                return (
                  void 0 === L && ((L = new nK()), (ea[_] = L)),
                  L.getHandSpace()
                );
              }),
              (this.setFramebufferScaleFactor = function (_) {
                (z = _),
                  !0 === R.isPresenting &&
                    console.warn(
                      "THREE.WebXRManager: Cannot change framebuffer scale while presenting.",
                    );
              }),
              (this.setReferenceSpaceType = function (_) {
                (U = _),
                  !0 === R.isPresenting &&
                    console.warn(
                      "THREE.WebXRManager: Cannot change reference space type while presenting.",
                    );
              }),
              (this.getReferenceSpace = function () {
                return Y || F;
              }),
              (this.setReferenceSpace = function (_) {
                Y = _;
              }),
              (this.getBaseLayer = function () {
                return null !== K ? K : J;
              }),
              (this.getBinding = function () {
                return Q;
              }),
              (this.getFrame = function () {
                return $;
              }),
              (this.getSession = function () {
                return N;
              }),
              (this.setSession = async function (X) {
                if (null !== (N = X)) {
                  if (
                    ((er = _.getRenderTarget()),
                    N.addEventListener("select", P),
                    N.addEventListener("selectstart", P),
                    N.addEventListener("selectend", P),
                    N.addEventListener("squeeze", P),
                    N.addEventListener("squeezestart", P),
                    N.addEventListener("squeezeend", P),
                    N.addEventListener("end", C),
                    N.addEventListener("inputsourceschange", D),
                    !0 !== ee.xrCompatible && (await L.makeXRCompatible()),
                    void 0 === N.renderState.layers ||
                      !1 === _.capabilities.isWebGL2)
                  ) {
                    let R = {
                      antialias:
                        void 0 !== N.renderState.layers || ee.antialias,
                      alpha: ee.alpha,
                      depth: ee.depth,
                      stencil: ee.stencil,
                      framebufferScaleFactor: z,
                    };
                    (J = new XRWebGLLayer(N, L, R)),
                      N.updateRenderState({ baseLayer: J }),
                      (en = new iH(J.framebufferWidth, J.framebufferHeight, {
                        format: 1023,
                        type: 1009,
                        encoding: _.outputEncoding,
                        stencilBuffer: ee.stencil,
                      }));
                  } else {
                    let R = null,
                      F = null,
                      U = null;
                    ee.depth &&
                      ((U = ee.stencil ? 35056 : 33190),
                      (R = ee.stencil ? 1027 : 1026),
                      (F = ee.stencil ? 1020 : 1014));
                    let k = {
                      colorFormat: 32856,
                      depthFormat: U,
                      scaleFactor: z,
                    };
                    (K = (Q = new XRWebGLBinding(N, L)).createProjectionLayer(
                      k,
                    )),
                      N.updateRenderState({ layers: [K] }),
                      (en = new iH(K.textureWidth, K.textureHeight, {
                        format: 1023,
                        type: 1009,
                        depthTexture: new nJ(
                          K.textureWidth,
                          K.textureHeight,
                          F,
                          void 0,
                          void 0,
                          void 0,
                          void 0,
                          void 0,
                          void 0,
                          R,
                        ),
                        stencilBuffer: ee.stencil,
                        encoding: _.outputEncoding,
                        samples: ee.antialias ? 4 : 0,
                      })),
                      (_.properties.get(en).__ignoreDepthValues =
                        K.ignoreDepthValues);
                  }
                  (en.isXRRenderTarget = !0),
                    this.setFoveation(k),
                    (Y = null),
                    (F = await N.requestReferenceSpace(U)),
                    eA.setContext(N),
                    eA.start(),
                    (R.isPresenting = !0),
                    R.dispatchEvent({ type: "sessionstart" });
                }
              });
            let eb = new iq(),
              ew = new iq();
            function W(_, L) {
              null === L
                ? _.matrixWorld.copy(_.matrix)
                : _.matrixWorld.multiplyMatrices(L.matrixWorld, _.matrix),
                _.matrixWorldInverse.copy(_.matrixWorld).invert();
            }
            (this.updateCamera = function (_) {
              if (null === N) return;
              (ef.near = eu.near = ed.near = _.near),
                (ef.far = eu.far = ed.far = _.far),
                (ev !== ef.near || ex !== ef.far) &&
                  (N.updateRenderState({
                    depthNear: ef.near,
                    depthFar: ef.far,
                  }),
                  (ev = ef.near),
                  (ex = ef.far));
              let L = _.parent,
                R = ef.cameras;
              W(ef, L);
              for (let _ = 0; _ < R.length; _++) W(R[_], L);
              ef.matrixWorld.decompose(ef.position, ef.quaternion, ef.scale),
                _.matrix.copy(ef.matrix),
                _.matrix.decompose(_.position, _.quaternion, _.scale);
              let z = _.children;
              for (let _ = 0, L = z.length; _ < L; _++)
                z[_].updateMatrixWorld(!0);
              2 === R.length
                ? (function (_, L, R) {
                    eb.setFromMatrixPosition(L.matrixWorld),
                      ew.setFromMatrixPosition(R.matrixWorld);
                    let N = eb.distanceTo(ew),
                      z = L.projectionMatrix.elements,
                      F = R.projectionMatrix.elements,
                      U = z[14] / (z[10] - 1),
                      k = z[14] / (z[10] + 1),
                      Y = (z[9] + 1) / z[5],
                      X = (z[9] - 1) / z[5],
                      Q = (z[8] - 1) / z[0],
                      K = (F[8] + 1) / F[0],
                      J = N / (-Q + K),
                      $ = -(J * Q);
                    L.matrixWorld.decompose(_.position, _.quaternion, _.scale),
                      _.translateX($),
                      _.translateZ(J),
                      _.matrixWorld.compose(_.position, _.quaternion, _.scale),
                      _.matrixWorldInverse.copy(_.matrixWorld).invert();
                    let ee = U + J,
                      er = k + J,
                      en = U * Q - $,
                      ea = U * K + (N - $),
                      eo = ((Y * k) / er) * ee,
                      el = ((X * k) / er) * ee;
                    _.projectionMatrix.makePerspective(en, ea, eo, el, ee, er);
                  })(ef, ed, eu)
                : ef.projectionMatrix.copy(ed.projectionMatrix);
            }),
              (this.getCamera = function () {
                return ef;
              }),
              (this.getFoveation = function () {
                if (!(null === K && null === J)) return k;
              }),
              (this.setFoveation = function (_) {
                (k = _),
                  null !== K && (K.fixedFoveation = _),
                  null !== J &&
                    void 0 !== J.fixedFoveation &&
                    (J.fixedFoveation = _);
              }),
              (this.getPlanes = function () {
                return el;
              });
            let e_ = null,
              eA = new U1();
            eA.setAnimationLoop(function (L, N) {
              if (((X = N.getViewerPose(Y || F)), ($ = N), null !== X)) {
                let L = X.views;
                null !== J &&
                  (_.setRenderTargetFramebuffer(en, J.framebuffer),
                  _.setRenderTarget(en));
                let R = !1;
                L.length !== ef.cameras.length &&
                  ((ef.cameras.length = 0), (R = !0));
                for (let N = 0; N < L.length; N++) {
                  let z = L[N],
                    F = null;
                  if (null !== J) F = J.getViewport(z);
                  else {
                    let L = Q.getViewSubImage(K, z);
                    (F = L.viewport),
                      0 === N &&
                        (_.setRenderTargetTextures(
                          en,
                          L.colorTexture,
                          K.ignoreDepthValues ? void 0 : L.depthStencilTexture,
                        ),
                        _.setRenderTarget(en));
                  }
                  let U = ep[N];
                  void 0 === U &&
                    ((U = new sK()).layers.enable(N),
                    (U.viewport = new iV()),
                    (ep[N] = U)),
                    U.matrix.fromArray(z.transform.matrix),
                    U.projectionMatrix.fromArray(z.projectionMatrix),
                    U.viewport.set(F.x, F.y, F.width, F.height),
                    0 === N && ef.matrix.copy(U.matrix),
                    !0 === R && ef.cameras.push(U);
                }
              }
              for (let _ = 0; _ < ea.length; _++) {
                let L = eo[_],
                  R = ea[_];
                null !== L && void 0 !== R && R.update(L, N, Y || F);
              }
              if ((e_ && e_(L, N), N.detectedPlanes)) {
                R.dispatchEvent({
                  type: "planesdetected",
                  data: N.detectedPlanes,
                });
                let _ = null;
                for (let L of el)
                  N.detectedPlanes.has(L) ||
                    (null === _ && (_ = []), _.push(L));
                if (null !== _)
                  for (let L of _)
                    el.delete(L),
                      ec.delete(L),
                      R.dispatchEvent({ type: "planeremoved", data: L });
                for (let _ of N.detectedPlanes)
                  if (el.has(_)) {
                    let L = ec.get(_);
                    _.lastChangedTime > L &&
                      (ec.set(_, _.lastChangedTime),
                      R.dispatchEvent({ type: "planechanged", data: _ }));
                  } else
                    el.add(_),
                      ec.set(_, N.lastChangedTime),
                      R.dispatchEvent({ type: "planeadded", data: _ });
              }
              $ = null;
            }),
              (this.setAnimationLoop = function (_) {
                e_ = _;
              }),
              (this.dispose = function () {});
          }
        };
      function uN(_, L) {
        function i(R, N) {
          let z, F;
          (R.opacity.value = N.opacity),
            N.color && R.diffuse.value.copy(N.color),
            N.emissive &&
              R.emissive.value
                .copy(N.emissive)
                .multiplyScalar(N.emissiveIntensity),
            N.map && (R.map.value = N.map),
            N.alphaMap && (R.alphaMap.value = N.alphaMap),
            N.bumpMap &&
              ((R.bumpMap.value = N.bumpMap),
              (R.bumpScale.value = N.bumpScale),
              1 === N.side && (R.bumpScale.value *= -1)),
            N.displacementMap &&
              ((R.displacementMap.value = N.displacementMap),
              (R.displacementScale.value = N.displacementScale),
              (R.displacementBias.value = N.displacementBias)),
            N.emissiveMap && (R.emissiveMap.value = N.emissiveMap),
            N.normalMap &&
              ((R.normalMap.value = N.normalMap),
              R.normalScale.value.copy(N.normalScale),
              1 === N.side && R.normalScale.value.negate()),
            N.specularMap && (R.specularMap.value = N.specularMap),
            N.alphaTest > 0 && (R.alphaTest.value = N.alphaTest);
          let U = L.get(N).envMap;
          if (
            (U &&
              ((R.envMap.value = U),
              (R.flipEnvMap.value =
                U.isCubeTexture && !1 === U.isRenderTargetTexture ? -1 : 1),
              (R.reflectivity.value = N.reflectivity),
              (R.ior.value = N.ior),
              (R.refractionRatio.value = N.refractionRatio)),
            N.lightMap)
          ) {
            R.lightMap.value = N.lightMap;
            let L = !0 !== _.physicallyCorrectLights ? Math.PI : 1;
            R.lightMapIntensity.value = N.lightMapIntensity * L;
          }
          N.aoMap &&
            ((R.aoMap.value = N.aoMap),
            (R.aoMapIntensity.value = N.aoMapIntensity)),
            N.map
              ? (z = N.map)
              : N.specularMap
                ? (z = N.specularMap)
                : N.displacementMap
                  ? (z = N.displacementMap)
                  : N.normalMap
                    ? (z = N.normalMap)
                    : N.bumpMap
                      ? (z = N.bumpMap)
                      : N.roughnessMap
                        ? (z = N.roughnessMap)
                        : N.metalnessMap
                          ? (z = N.metalnessMap)
                          : N.alphaMap
                            ? (z = N.alphaMap)
                            : N.emissiveMap
                              ? (z = N.emissiveMap)
                              : N.clearcoatMap
                                ? (z = N.clearcoatMap)
                                : N.clearcoatNormalMap
                                  ? (z = N.clearcoatNormalMap)
                                  : N.clearcoatRoughnessMap
                                    ? (z = N.clearcoatRoughnessMap)
                                    : N.iridescenceMap
                                      ? (z = N.iridescenceMap)
                                      : N.iridescenceThicknessMap
                                        ? (z = N.iridescenceThicknessMap)
                                        : N.specularIntensityMap
                                          ? (z = N.specularIntensityMap)
                                          : N.specularColorMap
                                            ? (z = N.specularColorMap)
                                            : N.transmissionMap
                                              ? (z = N.transmissionMap)
                                              : N.thicknessMap
                                                ? (z = N.thicknessMap)
                                                : N.sheenColorMap
                                                  ? (z = N.sheenColorMap)
                                                  : N.sheenRoughnessMap &&
                                                    (z = N.sheenRoughnessMap),
            void 0 !== z &&
              (z.isWebGLRenderTarget && (z = z.texture),
              !0 === z.matrixAutoUpdate && z.updateMatrix(),
              R.uvTransform.value.copy(z.matrix)),
            N.aoMap ? (F = N.aoMap) : N.lightMap && (F = N.lightMap),
            void 0 !== F &&
              (F.isWebGLRenderTarget && (F = F.texture),
              !0 === F.matrixAutoUpdate && F.updateMatrix(),
              R.uv2Transform.value.copy(F.matrix));
        }
        return {
          refreshFogUniforms: function (L, R) {
            R.color.getRGB(L.fogColor.value, F1(_)),
              R.isFog
                ? ((L.fogNear.value = R.near), (L.fogFar.value = R.far))
                : R.isFogExp2 && (L.fogDensity.value = R.density);
          },
          refreshMaterialUniforms: function (_, R, N, z, F) {
            let U, k;
            R.isMeshBasicMaterial || R.isMeshLambertMaterial
              ? i(_, R)
              : R.isMeshToonMaterial
                ? (i(_, R),
                  R.gradientMap && (_.gradientMap.value = R.gradientMap))
                : R.isMeshPhongMaterial
                  ? (i(_, R),
                    _.specular.value.copy(R.specular),
                    (_.shininess.value = Math.max(R.shininess, 1e-4)))
                  : R.isMeshStandardMaterial
                    ? (i(_, R),
                      (_.roughness.value = R.roughness),
                      (_.metalness.value = R.metalness),
                      R.roughnessMap && (_.roughnessMap.value = R.roughnessMap),
                      R.metalnessMap && (_.metalnessMap.value = R.metalnessMap),
                      L.get(R).envMap &&
                        (_.envMapIntensity.value = R.envMapIntensity),
                      R.isMeshPhysicalMaterial &&
                        ((_.ior.value = R.ior),
                        R.sheen > 0 &&
                          (_.sheenColor.value
                            .copy(R.sheenColor)
                            .multiplyScalar(R.sheen),
                          (_.sheenRoughness.value = R.sheenRoughness),
                          R.sheenColorMap &&
                            (_.sheenColorMap.value = R.sheenColorMap),
                          R.sheenRoughnessMap &&
                            (_.sheenRoughnessMap.value = R.sheenRoughnessMap)),
                        R.clearcoat > 0 &&
                          ((_.clearcoat.value = R.clearcoat),
                          (_.clearcoatRoughness.value = R.clearcoatRoughness),
                          R.clearcoatMap &&
                            (_.clearcoatMap.value = R.clearcoatMap),
                          R.clearcoatRoughnessMap &&
                            (_.clearcoatRoughnessMap.value =
                              R.clearcoatRoughnessMap),
                          R.clearcoatNormalMap &&
                            (_.clearcoatNormalScale.value.copy(
                              R.clearcoatNormalScale,
                            ),
                            (_.clearcoatNormalMap.value = R.clearcoatNormalMap),
                            1 === R.side &&
                              _.clearcoatNormalScale.value.negate())),
                        R.iridescence > 0 &&
                          ((_.iridescence.value = R.iridescence),
                          (_.iridescenceIOR.value = R.iridescenceIOR),
                          (_.iridescenceThicknessMinimum.value =
                            R.iridescenceThicknessRange[0]),
                          (_.iridescenceThicknessMaximum.value =
                            R.iridescenceThicknessRange[1]),
                          R.iridescenceMap &&
                            (_.iridescenceMap.value = R.iridescenceMap),
                          R.iridescenceThicknessMap &&
                            (_.iridescenceThicknessMap.value =
                              R.iridescenceThicknessMap)),
                        R.transmission > 0 &&
                          ((_.transmission.value = R.transmission),
                          (_.transmissionSamplerMap.value = F.texture),
                          _.transmissionSamplerSize.value.set(
                            F.width,
                            F.height,
                          ),
                          R.transmissionMap &&
                            (_.transmissionMap.value = R.transmissionMap),
                          (_.thickness.value = R.thickness),
                          R.thicknessMap &&
                            (_.thicknessMap.value = R.thicknessMap),
                          (_.attenuationDistance.value = R.attenuationDistance),
                          _.attenuationColor.value.copy(R.attenuationColor)),
                        (_.specularIntensity.value = R.specularIntensity),
                        _.specularColor.value.copy(R.specularColor),
                        R.specularIntensityMap &&
                          (_.specularIntensityMap.value =
                            R.specularIntensityMap),
                        R.specularColorMap &&
                          (_.specularColorMap.value = R.specularColorMap)))
                    : R.isMeshMatcapMaterial
                      ? (i(_, R), R.matcap && (_.matcap.value = R.matcap))
                      : R.isMeshDepthMaterial
                        ? i(_, R)
                        : R.isMeshDistanceMaterial
                          ? (i(_, R),
                            _.referencePosition.value.copy(R.referencePosition),
                            (_.nearDistance.value = R.nearDistance),
                            (_.farDistance.value = R.farDistance))
                          : R.isMeshNormalMaterial
                            ? i(_, R)
                            : R.isLineBasicMaterial
                              ? (_.diffuse.value.copy(R.color),
                                (_.opacity.value = R.opacity),
                                R.isLineDashedMaterial &&
                                  ((_.dashSize.value = R.dashSize),
                                  (_.totalSize.value = R.dashSize + R.gapSize),
                                  (_.scale.value = R.scale)))
                              : R.isPointsMaterial
                                ? (_.diffuse.value.copy(R.color),
                                  (_.opacity.value = R.opacity),
                                  (_.size.value = R.size * N),
                                  (_.scale.value = 0.5 * z),
                                  R.map && (_.map.value = R.map),
                                  R.alphaMap && (_.alphaMap.value = R.alphaMap),
                                  R.alphaTest > 0 &&
                                    (_.alphaTest.value = R.alphaTest),
                                  R.map
                                    ? (U = R.map)
                                    : R.alphaMap && (U = R.alphaMap),
                                  void 0 !== U &&
                                    (!0 === U.matrixAutoUpdate &&
                                      U.updateMatrix(),
                                    _.uvTransform.value.copy(U.matrix)))
                                : R.isSpriteMaterial
                                  ? (_.diffuse.value.copy(R.color),
                                    (_.opacity.value = R.opacity),
                                    (_.rotation.value = R.rotation),
                                    R.map && (_.map.value = R.map),
                                    R.alphaMap &&
                                      (_.alphaMap.value = R.alphaMap),
                                    R.alphaTest > 0 &&
                                      (_.alphaTest.value = R.alphaTest),
                                    R.map
                                      ? (k = R.map)
                                      : R.alphaMap && (k = R.alphaMap),
                                    void 0 !== k &&
                                      (!0 === k.matrixAutoUpdate &&
                                        k.updateMatrix(),
                                      _.uvTransform.value.copy(k.matrix)))
                                  : R.isShadowMaterial
                                    ? (_.color.value.copy(R.color),
                                      (_.opacity.value = R.opacity))
                                    : R.isShaderMaterial &&
                                      (R.uniformsNeedUpdate = !1);
          },
        };
      }
      function dN(_, L, R, N) {
        let z = {},
          F = {},
          U = [],
          k = R.isWebGL2 ? _.getParameter(35375) : 0;
        function p(_) {
          let L = { boundary: 0, storage: 0 };
          return (
            "number" == typeof _
              ? ((L.boundary = 4), (L.storage = 4))
              : _.isVector2
                ? ((L.boundary = 8), (L.storage = 8))
                : _.isVector3 || _.isColor
                  ? ((L.boundary = 16), (L.storage = 12))
                  : _.isVector4
                    ? ((L.boundary = 16), (L.storage = 16))
                    : _.isMatrix3
                      ? ((L.boundary = 48), (L.storage = 48))
                      : _.isMatrix4
                        ? ((L.boundary = 64), (L.storage = 64))
                        : _.isTexture
                          ? console.warn(
                              "THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.",
                            )
                          : console.warn(
                              "THREE.WebGLRenderer: Unsupported uniform value type.",
                              _,
                            ),
            L
          );
        }
        function m(L) {
          let R = L.target;
          R.removeEventListener("dispose", m);
          let N = U.indexOf(R.__bindingPointIndex);
          U.splice(N, 1),
            _.deleteBuffer(z[R.id]),
            delete z[R.id],
            delete F[R.id];
        }
        return {
          bind: function (_, L) {
            let R = L.program;
            N.uniformBlockBinding(_, R);
          },
          update: function (R, Y) {
            let X,
              Q,
              K,
              J,
              $ = z[R.id];
            void 0 === $ &&
              ((function (_) {
                let L = _.uniforms,
                  R = 0,
                  N = 0;
                for (let _ = 0, z = L.length; _ < z; _++) {
                  let z = L[_],
                    F = { boundary: 0, storage: 0 },
                    U = Array.isArray(z.value) ? z.value : [z.value];
                  for (let _ = 0, L = U.length; _ < L; _++) {
                    let L = p(U[_]);
                    (F.boundary += L.boundary), (F.storage += L.storage);
                  }
                  if (
                    ((z.__data = new Float32Array(
                      F.storage / Float32Array.BYTES_PER_ELEMENT,
                    )),
                    (z.__offset = R),
                    _ > 0)
                  ) {
                    let _ = 16 - (N = R % 16);
                    0 !== N &&
                      _ - F.boundary < 0 &&
                      ((R += 16 - N), (z.__offset = R));
                  }
                  R += F.storage;
                }
                (N = R % 16) > 0 && (R += 16 - N),
                  (_.__size = R),
                  (_.__cache = {});
              })(R),
              (X = (function () {
                for (let _ = 0; _ < k; _++)
                  if (-1 === U.indexOf(_)) return U.push(_), _;
                return (
                  console.error(
                    "THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.",
                  ),
                  0
                );
              })()),
              (R.__bindingPointIndex = X),
              (Q = _.createBuffer()),
              (K = R.__size),
              (J = R.usage),
              _.bindBuffer(35345, Q),
              _.bufferData(35345, K, J),
              _.bindBuffer(35345, null),
              _.bindBufferBase(35345, X, Q),
              ($ = Q),
              (z[R.id] = $),
              R.addEventListener("dispose", m));
            let ee = Y.program;
            N.updateUBOMapping(R, ee);
            let er = L.render.frame;
            F[R.id] !== er &&
              ((function (L) {
                let R = z[L.id],
                  N = L.uniforms,
                  F = L.__cache;
                _.bindBuffer(35345, R);
                for (let L = 0, R = N.length; L < R; L++) {
                  let R = N[L];
                  if (
                    !0 ===
                    (function (_, L, R) {
                      let N = _.value;
                      if (void 0 === R[L]) {
                        if ("number" == typeof N) R[L] = N;
                        else {
                          let _ = Array.isArray(N) ? N : [N],
                            z = [];
                          for (let L = 0; L < _.length; L++)
                            z.push(_[L].clone());
                          R[L] = z;
                        }
                        return !0;
                      }
                      if ("number" == typeof N) {
                        if (R[L] !== N) return (R[L] = N), !0;
                      } else {
                        let _ = Array.isArray(R[L]) ? R[L] : [R[L]],
                          z = Array.isArray(N) ? N : [N];
                        for (let L = 0; L < _.length; L++) {
                          let R = _[L];
                          if (!1 === R.equals(z[L])) return R.copy(z[L]), !0;
                        }
                      }
                      return !1;
                    })(R, L, F)
                  ) {
                    let L = R.__offset,
                      N = Array.isArray(R.value) ? R.value : [R.value],
                      z = 0;
                    for (let F = 0; F < N.length; F++) {
                      let U = N[F],
                        k = p(U);
                      "number" == typeof U
                        ? ((R.__data[0] = U),
                          _.bufferSubData(35345, L + z, R.__data))
                        : U.isMatrix3
                          ? ((R.__data[0] = U.elements[0]),
                            (R.__data[1] = U.elements[1]),
                            (R.__data[2] = U.elements[2]),
                            (R.__data[3] = U.elements[0]),
                            (R.__data[4] = U.elements[3]),
                            (R.__data[5] = U.elements[4]),
                            (R.__data[6] = U.elements[5]),
                            (R.__data[7] = U.elements[0]),
                            (R.__data[8] = U.elements[6]),
                            (R.__data[9] = U.elements[7]),
                            (R.__data[10] = U.elements[8]),
                            (R.__data[11] = U.elements[0]))
                          : (U.toArray(R.__data, z),
                            (z += k.storage / Float32Array.BYTES_PER_ELEMENT));
                    }
                    _.bufferSubData(35345, L, R.__data);
                  }
                }
                _.bindBuffer(35345, null);
              })(R),
              (F[R.id] = er));
          },
          dispose: function () {
            for (let L in z) _.deleteBuffer(z[L]);
            (U = []), (z = {}), (F = {});
          },
        };
      }
      function v0(_ = {}) {
        let L,
          R,
          N,
          z,
          F,
          U,
          k,
          Y,
          X,
          Q,
          K,
          J,
          $,
          ee,
          er,
          en,
          ea,
          eo,
          el,
          ec,
          ed,
          eu,
          ep,
          ef,
          ev;
        this.isWebGLRenderer = !0;
        let ex =
            void 0 !== _.canvas
              ? _.canvas
              : (((ev = ap("canvas")).style.display = "block"), ev),
          eb = void 0 !== _.context ? _.context : null,
          ew = void 0 === _.depth || _.depth,
          e_ = void 0 === _.stencil || _.stencil,
          eA = void 0 !== _.antialias && _.antialias,
          eM = void 0 === _.premultipliedAlpha || _.premultipliedAlpha,
          eE = void 0 !== _.preserveDrawingBuffer && _.preserveDrawingBuffer,
          eC = void 0 !== _.powerPreference ? _.powerPreference : "default",
          eP =
            void 0 !== _.failIfMajorPerformanceCaveat &&
            _.failIfMajorPerformanceCaveat,
          eD;
        eD =
          null !== eb
            ? eb.getContextAttributes().alpha
            : void 0 !== _.alpha && _.alpha;
        let eO = null,
          eL = null,
          eR = [],
          eI = [];
        (this.domElement = ex),
          (this.debug = { checkShaderErrors: !0 }),
          (this.autoClear = !0),
          (this.autoClearColor = !0),
          (this.autoClearDepth = !0),
          (this.autoClearStencil = !0),
          (this.sortObjects = !0),
          (this.clippingPlanes = []),
          (this.localClippingEnabled = !1),
          (this.outputEncoding = 3e3),
          (this.physicallyCorrectLights = !1),
          (this.toneMapping = 0),
          (this.toneMappingExposure = 1);
        let eB = this,
          ez = !1,
          eF = 0,
          eU = 0,
          ek = null,
          ej = -1,
          eG = null,
          eV = new iV(),
          eH = new iV(),
          eW = null,
          eY = ex.width,
          eX = ex.height,
          eq = 1,
          eQ = null,
          eZ = null,
          eK = new iV(0, 0, eY, eX),
          eJ = new iV(0, 0, eY, eX),
          e$ = !1,
          e0 = new s7(),
          e2 = !1,
          e4 = !1,
          e6 = null,
          e8 = new rw(),
          e9 = new iT(),
          e7 = new iq(),
          te = {
            background: null,
            fog: null,
            environment: null,
            overrideMaterial: null,
            isScene: !0,
          };
        function j() {
          return null === ek ? eq : 1;
        }
        let tt = eb;
        function re(_, L) {
          for (let R = 0; R < _.length; R++) {
            let N = _[R],
              z = ex.getContext(N, L);
            if (null !== z) return z;
          }
          return null;
        }
        try {
          if (
            ("setAttribute" in ex &&
              ex.setAttribute("data-engine", "three.js r149"),
            ex.addEventListener("webglcontextlost", Re, !1),
            ex.addEventListener("webglcontextrestored", Ne, !1),
            ex.addEventListener("webglcontextcreationerror", pt, !1),
            null === tt)
          ) {
            let _ = ["webgl2", "webgl", "experimental-webgl"];
            if (
              (!0 === eB.isWebGL1Renderer && _.shift(),
              (tt = re(_, {
                alpha: !0,
                depth: ew,
                stencil: e_,
                antialias: eA,
                premultipliedAlpha: eM,
                preserveDrawingBuffer: eE,
                powerPreference: eC,
                failIfMajorPerformanceCaveat: eP,
              })),
              null === tt)
            )
              throw re(_)
                ? Error(
                    "Error creating WebGL context with your selected attributes.",
                  )
                : Error("Error creating WebGL context.");
          }
          void 0 === tt.getShaderPrecisionFormat &&
            (tt.getShaderPrecisionFormat = function () {
              return { rangeMin: 1, rangeMax: 1, precision: 1 };
            });
        } catch (_) {
          throw (console.error("THREE.WebGLRenderer: " + _.message), _);
        }
        function qe() {
          (L = new LR(tt)),
            (R = new MR(tt, L, _)),
            L.init(R),
            (eu = new lN(tt, L, R)),
            (N = new oN(tt, L, R)),
            (z = new BR()),
            (F = new Y3()),
            (U = new aN(tt, L, N, F, R, eu, z)),
            (k = new PR(eB)),
            (Y = new OR(eB)),
            (X = new jD(tt, R)),
            (ep = new TR(tt, L, X, R)),
            (Q = new RR(tt, X, z, ep)),
            (K = new kR(tt, Q, X, z)),
            (el = new GR(tt, R, U)),
            (en = new CR(F)),
            (J = new X3(eB, k, Y, L, R, ep, en)),
            ($ = new uN(eB, F)),
            (ee = new Z3()),
            (er = new nN(L, R)),
            (eo = new _R(eB, k, Y, N, K, eD, eM)),
            (ea = new sN(eB, K, R)),
            (ef = new dN(tt, z, R, N)),
            (ec = new ER(tt, L, z, R)),
            (ed = new NR(tt, L, z, R)),
            (z.programs = J.programs),
            (eB.capabilities = R),
            (eB.extensions = L),
            (eB.properties = F),
            (eB.renderLists = ee),
            (eB.shadowMap = ea),
            (eB.state = N),
            (eB.info = z);
        }
        qe();
        let ti = new n$(eB, tt);
        function Re(_) {
          _.preventDefault(),
            console.log("THREE.WebGLRenderer: Context Lost."),
            (ez = !0);
        }
        function Ne() {
          console.log("THREE.WebGLRenderer: Context Restored."), (ez = !1);
          let _ = z.autoReset,
            L = ea.enabled,
            R = ea.autoUpdate,
            N = ea.needsUpdate,
            F = ea.type;
          qe(),
            (z.autoReset = _),
            (ea.enabled = L),
            (ea.autoUpdate = R),
            (ea.needsUpdate = N),
            (ea.type = F);
        }
        function pt(_) {
          console.error(
            "THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",
            _.statusMessage,
          );
        }
        function Nt(_) {
          let L,
            R = _.target;
          R.removeEventListener("dispose", Nt),
            void 0 !== (L = F.get(R).programs) &&
              (L.forEach(function (_) {
                J.releaseProgram(_);
              }),
              R.isShaderMaterial && J.releaseShaderCache(R)),
            F.remove(R);
        }
        (this.xr = ti),
          (this.getContext = function () {
            return tt;
          }),
          (this.getContextAttributes = function () {
            return tt.getContextAttributes();
          }),
          (this.forceContextLoss = function () {
            let _ = L.get("WEBGL_lose_context");
            _ && _.loseContext();
          }),
          (this.forceContextRestore = function () {
            let _ = L.get("WEBGL_lose_context");
            _ && _.restoreContext();
          }),
          (this.getPixelRatio = function () {
            return eq;
          }),
          (this.setPixelRatio = function (_) {
            void 0 !== _ && ((eq = _), this.setSize(eY, eX, !1));
          }),
          (this.getSize = function (_) {
            return _.set(eY, eX);
          }),
          (this.setSize = function (_, L, R) {
            if (ti.isPresenting) {
              console.warn(
                "THREE.WebGLRenderer: Can't change size while VR device is presenting.",
              );
              return;
            }
            (eY = _),
              (eX = L),
              (ex.width = Math.floor(_ * eq)),
              (ex.height = Math.floor(L * eq)),
              !1 !== R &&
                ((ex.style.width = _ + "px"), (ex.style.height = L + "px")),
              this.setViewport(0, 0, _, L);
          }),
          (this.getDrawingBufferSize = function (_) {
            return _.set(eY * eq, eX * eq).floor();
          }),
          (this.setDrawingBufferSize = function (_, L, R) {
            (eY = _),
              (eX = L),
              (eq = R),
              (ex.width = Math.floor(_ * R)),
              (ex.height = Math.floor(L * R)),
              this.setViewport(0, 0, _, L);
          }),
          (this.getCurrentViewport = function (_) {
            return _.copy(eV);
          }),
          (this.getViewport = function (_) {
            return _.copy(eK);
          }),
          (this.setViewport = function (_, L, R, z) {
            _.isVector4 ? eK.set(_.x, _.y, _.z, _.w) : eK.set(_, L, R, z),
              N.viewport(eV.copy(eK).multiplyScalar(eq).floor());
          }),
          (this.getScissor = function (_) {
            return _.copy(eJ);
          }),
          (this.setScissor = function (_, L, R, z) {
            _.isVector4 ? eJ.set(_.x, _.y, _.z, _.w) : eJ.set(_, L, R, z),
              N.scissor(eH.copy(eJ).multiplyScalar(eq).floor());
          }),
          (this.getScissorTest = function () {
            return e$;
          }),
          (this.setScissorTest = function (_) {
            N.setScissorTest((e$ = _));
          }),
          (this.setOpaqueSort = function (_) {
            eQ = _;
          }),
          (this.setTransparentSort = function (_) {
            eZ = _;
          }),
          (this.getClearColor = function (_) {
            return _.copy(eo.getClearColor());
          }),
          (this.setClearColor = function () {
            eo.setClearColor.apply(eo, arguments);
          }),
          (this.getClearAlpha = function () {
            return eo.getClearAlpha();
          }),
          (this.setClearAlpha = function () {
            eo.setClearAlpha.apply(eo, arguments);
          }),
          (this.clear = function (_ = !0, L = !0, R = !0) {
            let N = 0;
            _ && (N |= 16384), L && (N |= 256), R && (N |= 1024), tt.clear(N);
          }),
          (this.clearColor = function () {
            this.clear(!0, !1, !1);
          }),
          (this.clearDepth = function () {
            this.clear(!1, !0, !1);
          }),
          (this.clearStencil = function () {
            this.clear(!1, !1, !0);
          }),
          (this.dispose = function () {
            ex.removeEventListener("webglcontextlost", Re, !1),
              ex.removeEventListener("webglcontextrestored", Ne, !1),
              ex.removeEventListener("webglcontextcreationerror", pt, !1),
              ee.dispose(),
              er.dispose(),
              F.dispose(),
              k.dispose(),
              Y.dispose(),
              K.dispose(),
              ep.dispose(),
              ef.dispose(),
              J.dispose(),
              ti.dispose(),
              ti.removeEventListener("sessionstart", Ce),
              ti.removeEventListener("sessionend", Ue),
              e6 && (e6.dispose(), (e6 = null)),
              tn.stop();
          }),
          (this.renderBufferDirect = function (_, L, z, K, J, ee) {
            null === L && (L = te);
            let er = J.isMesh && 0 > J.matrixWorld.determinant(),
              ea = (function (_, L, z, X, Q) {
                var K;
                !0 !== L.isScene && (L = te), U.resetTextureUnits();
                let J = L.fog,
                  ee = X.isMeshStandardMaterial ? L.environment : null,
                  er =
                    null === ek
                      ? eB.outputEncoding
                      : !0 === ek.isXRRenderTarget
                        ? ek.texture.encoding
                        : 3e3,
                  ea = (X.isMeshStandardMaterial ? Y : k).get(X.envMap || ee),
                  eo =
                    !0 === X.vertexColors &&
                    !!z.attributes.color &&
                    4 === z.attributes.color.itemSize,
                  ec = !!X.normalMap && !!z.attributes.tangent,
                  ed = !!z.morphAttributes.position,
                  eu = !!z.morphAttributes.normal,
                  ep = !!z.morphAttributes.color,
                  ev = X.toneMapped ? eB.toneMapping : 0,
                  ex =
                    z.morphAttributes.position ||
                    z.morphAttributes.normal ||
                    z.morphAttributes.color,
                  eb = void 0 !== ex ? ex.length : 0,
                  ew = F.get(X),
                  e_ = eL.state.lights;
                if (!0 === e2 && (!0 === e4 || _ !== eG)) {
                  let L = _ === eG && X.id === ej;
                  en.setState(X, _, L);
                }
                let eA = !1;
                X.version === ew.__version
                  ? ((ew.needsLights &&
                      ew.lightsStateVersion !== e_.state.version) ||
                      ew.outputEncoding !== er ||
                      (Q.isInstancedMesh && !1 === ew.instancing) ||
                      (!Q.isInstancedMesh && !0 === ew.instancing) ||
                      (Q.isSkinnedMesh && !1 === ew.skinning) ||
                      (!Q.isSkinnedMesh && !0 === ew.skinning) ||
                      ew.envMap !== ea ||
                      (!0 === X.fog && ew.fog !== J) ||
                      (void 0 !== ew.numClippingPlanes &&
                        (ew.numClippingPlanes !== en.numPlanes ||
                          ew.numIntersection !== en.numIntersection)) ||
                      ew.vertexAlphas !== eo ||
                      ew.vertexTangents !== ec ||
                      ew.morphTargets !== ed ||
                      ew.morphNormals !== eu ||
                      ew.morphColors !== ep ||
                      ew.toneMapping !== ev ||
                      (!0 === R.isWebGL2 && ew.morphTargetsCount !== eb)) &&
                    (eA = !0)
                  : ((eA = !0), (ew.__version = X.version));
                let eM = ew.currentProgram;
                !0 === eA && (eM = si(X, L, Q));
                let eE = !1,
                  eC = !1,
                  eP = !1,
                  eD = eM.getUniforms(),
                  eO = ew.uniforms;
                if (
                  (N.useProgram(eM.program) &&
                    ((eE = !0), (eC = !0), (eP = !0)),
                  X.id !== ej && ((ej = X.id), (eC = !0)),
                  eE || eG !== _)
                ) {
                  if (
                    (eD.setValue(tt, "projectionMatrix", _.projectionMatrix),
                    R.logarithmicDepthBuffer &&
                      eD.setValue(
                        tt,
                        "logDepthBufFC",
                        2 / (Math.log(_.far + 1) / Math.LN2),
                      ),
                    eG !== _ && ((eG = _), (eC = !0), (eP = !0)),
                    X.isShaderMaterial ||
                      X.isMeshPhongMaterial ||
                      X.isMeshToonMaterial ||
                      X.isMeshStandardMaterial ||
                      X.envMap)
                  ) {
                    let L = eD.map.cameraPosition;
                    void 0 !== L &&
                      L.setValue(tt, e7.setFromMatrixPosition(_.matrixWorld));
                  }
                  (X.isMeshPhongMaterial ||
                    X.isMeshToonMaterial ||
                    X.isMeshLambertMaterial ||
                    X.isMeshBasicMaterial ||
                    X.isMeshStandardMaterial ||
                    X.isShaderMaterial) &&
                    eD.setValue(
                      tt,
                      "isOrthographic",
                      !0 === _.isOrthographicCamera,
                    ),
                    (X.isMeshPhongMaterial ||
                      X.isMeshToonMaterial ||
                      X.isMeshLambertMaterial ||
                      X.isMeshBasicMaterial ||
                      X.isMeshStandardMaterial ||
                      X.isShaderMaterial ||
                      X.isShadowMaterial ||
                      Q.isSkinnedMesh) &&
                      eD.setValue(tt, "viewMatrix", _.matrixWorldInverse);
                }
                if (Q.isSkinnedMesh) {
                  eD.setOptional(tt, Q, "bindMatrix"),
                    eD.setOptional(tt, Q, "bindMatrixInverse");
                  let _ = Q.skeleton;
                  _ &&
                    (R.floatVertexTextures
                      ? (null === _.boneTexture && _.computeBoneTexture(),
                        eD.setValue(tt, "boneTexture", _.boneTexture, U),
                        eD.setValue(tt, "boneTextureSize", _.boneTextureSize))
                      : console.warn(
                          "THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required.",
                        ));
                }
                let eR = z.morphAttributes;
                if (
                  ((void 0 !== eR.position ||
                    void 0 !== eR.normal ||
                    (void 0 !== eR.color && !0 === R.isWebGL2)) &&
                    el.update(Q, z, X, eM),
                  (eC || ew.receiveShadow !== Q.receiveShadow) &&
                    ((ew.receiveShadow = Q.receiveShadow),
                    eD.setValue(tt, "receiveShadow", Q.receiveShadow)),
                  X.isMeshGouraudMaterial &&
                    null !== X.envMap &&
                    ((eO.envMap.value = ea),
                    (eO.flipEnvMap.value =
                      ea.isCubeTexture && !1 === ea.isRenderTargetTexture
                        ? -1
                        : 1)),
                  eC &&
                    (eD.setValue(
                      tt,
                      "toneMappingExposure",
                      eB.toneMappingExposure,
                    ),
                    ew.needsLights &&
                      ((K = eP),
                      (eO.ambientLightColor.needsUpdate = K),
                      (eO.lightProbe.needsUpdate = K),
                      (eO.directionalLights.needsUpdate = K),
                      (eO.directionalLightShadows.needsUpdate = K),
                      (eO.pointLights.needsUpdate = K),
                      (eO.pointLightShadows.needsUpdate = K),
                      (eO.spotLights.needsUpdate = K),
                      (eO.spotLightShadows.needsUpdate = K),
                      (eO.rectAreaLights.needsUpdate = K),
                      (eO.hemisphereLights.needsUpdate = K)),
                    J && !0 === X.fog && $.refreshFogUniforms(eO, J),
                    $.refreshMaterialUniforms(eO, X, eq, eX, e6),
                    nB.upload(tt, ew.uniformsList, eO, U)),
                  X.isShaderMaterial &&
                    !0 === X.uniformsNeedUpdate &&
                    (nB.upload(tt, ew.uniformsList, eO, U),
                    (X.uniformsNeedUpdate = !1)),
                  X.isSpriteMaterial && eD.setValue(tt, "center", Q.center),
                  eD.setValue(tt, "modelViewMatrix", Q.modelViewMatrix),
                  eD.setValue(tt, "normalMatrix", Q.normalMatrix),
                  eD.setValue(tt, "modelMatrix", Q.matrixWorld),
                  X.isShaderMaterial || X.isRawShaderMaterial)
                ) {
                  let _ = X.uniformsGroups;
                  for (let L = 0, N = _.length; L < N; L++)
                    if (R.isWebGL2) {
                      let R = _[L];
                      ef.update(R, eM), ef.bind(R, eM);
                    } else
                      console.warn(
                        "THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.",
                      );
                }
                return eM;
              })(_, L, z, K, J);
            N.setMaterial(K, er);
            let eo = z.index,
              eu = 1;
            !0 === K.wireframe && ((eo = Q.getWireframeAttribute(z)), (eu = 2));
            let ev = z.drawRange,
              ex = z.attributes.position,
              eb = ev.start * eu,
              ew = (ev.start + ev.count) * eu;
            null !== ee &&
              ((eb = Math.max(eb, ee.start * eu)),
              (ew = Math.min(ew, (ee.start + ee.count) * eu))),
              null !== eo
                ? ((eb = Math.max(eb, 0)), (ew = Math.min(ew, eo.count)))
                : null != ex &&
                  ((eb = Math.max(eb, 0)), (ew = Math.min(ew, ex.count)));
            let e_ = ew - eb;
            if (e_ < 0 || e_ === 1 / 0) return;
            ep.setup(J, K, ea, z, eo);
            let eA,
              eM = ec;
            if (
              (null !== eo && ((eA = X.get(eo)), (eM = ed).setIndex(eA)),
              J.isMesh)
            )
              !0 === K.wireframe
                ? (N.setLineWidth(K.wireframeLinewidth * j()), eM.setMode(1))
                : eM.setMode(4);
            else if (J.isLine) {
              let _ = K.linewidth;
              void 0 === _ && (_ = 1),
                N.setLineWidth(_ * j()),
                J.isLineSegments
                  ? eM.setMode(1)
                  : J.isLineLoop
                    ? eM.setMode(2)
                    : eM.setMode(3);
            } else J.isPoints ? eM.setMode(0) : J.isSprite && eM.setMode(4);
            if (J.isInstancedMesh) eM.renderInstances(eb, e_, J.count);
            else if (z.isInstancedBufferGeometry) {
              let _ =
                  void 0 !== z._maxInstanceCount ? z._maxInstanceCount : 1 / 0,
                L = Math.min(z.instanceCount, _);
              eM.renderInstances(eb, e_, L);
            } else eM.render(eb, e_);
          }),
          (this.compile = function (_, L) {
            function oe(_, L, R) {
              !0 === _.transparent && 2 === _.side && !1 === _.forceSinglePass
                ? ((_.side = 1),
                  (_.needsUpdate = !0),
                  si(_, L, R),
                  (_.side = 0),
                  (_.needsUpdate = !0),
                  si(_, L, R),
                  (_.side = 2))
                : si(_, L, R);
            }
            (eL = er.get(_)).init(),
              eI.push(eL),
              _.traverseVisible(function (_) {
                _.isLight &&
                  _.layers.test(L.layers) &&
                  (eL.pushLight(_), _.castShadow && eL.pushShadow(_));
              }),
              eL.setupLights(eB.physicallyCorrectLights),
              _.traverse(function (L) {
                let R = L.material;
                if (R) {
                  if (Array.isArray(R))
                    for (let N = 0; N < R.length; N++) oe(R[N], _, L);
                  else oe(R, _, L);
                }
              }),
              eI.pop(),
              (eL = null);
          });
        let tr = null;
        function Ce() {
          tn.stop();
        }
        function Ue() {
          tn.start();
        }
        let tn = new U1();
        function Nn(_, z, F, k) {
          let Y,
            X,
            Q,
            K = _.opaque,
            J = _.transmissive,
            $ = _.transparent;
          eL.setupLightsView(F),
            !0 === e2 && en.setGlobalState(eB.clippingPlanes, F),
            J.length > 0 &&
              ((Y = R.isWebGL2),
              null === e6 &&
                (e6 = new iH(1, 1, {
                  generateMipmaps: !0,
                  type: L.has("EXT_color_buffer_half_float") ? 1016 : 1009,
                  minFilter: 1008,
                  samples: Y && !0 === eA ? 4 : 0,
                })),
              eB.getDrawingBufferSize(e9),
              Y ? e6.setSize(e9.x, e9.y) : e6.setSize(op(e9.x), op(e9.y)),
              (X = eB.getRenderTarget()),
              eB.setRenderTarget(e6),
              eB.clear(),
              (Q = eB.toneMapping),
              (eB.toneMapping = 0),
              Ht(K, z, F),
              (eB.toneMapping = Q),
              U.updateMultisampleRenderTarget(e6),
              U.updateRenderTargetMipmap(e6),
              eB.setRenderTarget(X)),
            k && N.viewport(eV.copy(k)),
            K.length > 0 && Ht(K, z, F),
            J.length > 0 && Ht(J, z, F),
            $.length > 0 && Ht($, z, F),
            N.buffers.depth.setTest(!0),
            N.buffers.depth.setMask(!0),
            N.buffers.color.setMask(!0),
            N.setPolygonOffset(!1);
        }
        function Ht(_, L, R) {
          let N = !0 === L.isScene ? L.overrideMaterial : null;
          for (let z = 0, F = _.length; z < F; z++) {
            let F = _[z],
              U = F.object,
              k = F.geometry,
              Y = null === N ? F.material : N,
              X = F.group;
            U.layers.test(R.layers) &&
              (U.onBeforeRender(eB, L, R, k, Y, X),
              U.modelViewMatrix.multiplyMatrices(
                R.matrixWorldInverse,
                U.matrixWorld,
              ),
              U.normalMatrix.getNormalMatrix(U.modelViewMatrix),
              Y.onBeforeRender(eB, L, R, k, U, X),
              !0 === Y.transparent && 2 === Y.side && !1 === Y.forceSinglePass
                ? ((Y.side = 1),
                  (Y.needsUpdate = !0),
                  eB.renderBufferDirect(R, L, k, Y, U, X),
                  (Y.side = 0),
                  (Y.needsUpdate = !0),
                  eB.renderBufferDirect(R, L, k, Y, U, X),
                  (Y.side = 2))
                : eB.renderBufferDirect(R, L, k, Y, U, X),
              U.onAfterRender(eB, L, R, k, Y, X));
          }
        }
        function si(_, L, R) {
          !0 !== L.isScene && (L = te);
          let N = F.get(_),
            z = eL.state.lights,
            U = eL.state.shadowsArray,
            X = z.state.version,
            Q = J.getParameters(_, z.state, U, L, R),
            K = J.getProgramCacheKey(Q),
            $ = N.programs;
          (N.environment = _.isMeshStandardMaterial ? L.environment : null),
            (N.fog = L.fog),
            (N.envMap = (_.isMeshStandardMaterial ? Y : k).get(
              _.envMap || N.environment,
            )),
            void 0 === $ &&
              (_.addEventListener("dispose", Nt),
              ($ = new Map()),
              (N.programs = $));
          let ee = $.get(K);
          if (void 0 !== ee) {
            if (N.currentProgram === ee && N.lightsStateVersion === X)
              return KS(_, Q), ee;
          } else
            (Q.uniforms = J.getUniforms(_)),
              _.onBuild(R, Q, eB),
              _.onBeforeCompile(Q, eB),
              (ee = J.acquireProgram(Q, K)),
              $.set(K, ee),
              (N.uniforms = Q.uniforms);
          let er = N.uniforms;
          ((_.isShaderMaterial || _.isRawShaderMaterial) &&
            !0 !== _.clipping) ||
            (er.clippingPlanes = en.uniform),
            KS(_, Q),
            (N.needsLights =
              _.isMeshLambertMaterial ||
              _.isMeshToonMaterial ||
              _.isMeshPhongMaterial ||
              _.isMeshStandardMaterial ||
              _.isShadowMaterial ||
              (_.isShaderMaterial && !0 === _.lights)),
            (N.lightsStateVersion = X),
            N.needsLights &&
              ((er.ambientLightColor.value = z.state.ambient),
              (er.lightProbe.value = z.state.probe),
              (er.directionalLights.value = z.state.directional),
              (er.directionalLightShadows.value = z.state.directionalShadow),
              (er.spotLights.value = z.state.spot),
              (er.spotLightShadows.value = z.state.spotShadow),
              (er.rectAreaLights.value = z.state.rectArea),
              (er.ltc_1.value = z.state.rectAreaLTC1),
              (er.ltc_2.value = z.state.rectAreaLTC2),
              (er.pointLights.value = z.state.point),
              (er.pointLightShadows.value = z.state.pointShadow),
              (er.hemisphereLights.value = z.state.hemi),
              (er.directionalShadowMap.value = z.state.directionalShadowMap),
              (er.directionalShadowMatrix.value =
                z.state.directionalShadowMatrix),
              (er.spotShadowMap.value = z.state.spotShadowMap),
              (er.spotLightMatrix.value = z.state.spotLightMatrix),
              (er.spotLightMap.value = z.state.spotLightMap),
              (er.pointShadowMap.value = z.state.pointShadowMap),
              (er.pointShadowMatrix.value = z.state.pointShadowMatrix));
          let ea = ee.getUniforms(),
            eo = nB.seqWithValue(ea.seq, er);
          return (N.currentProgram = ee), (N.uniformsList = eo), ee;
        }
        function KS(_, L) {
          let R = F.get(_);
          (R.outputEncoding = L.outputEncoding),
            (R.instancing = L.instancing),
            (R.skinning = L.skinning),
            (R.morphTargets = L.morphTargets),
            (R.morphNormals = L.morphNormals),
            (R.morphColors = L.morphColors),
            (R.morphTargetsCount = L.morphTargetsCount),
            (R.numClippingPlanes = L.numClippingPlanes),
            (R.numIntersection = L.numClipIntersection),
            (R.vertexAlphas = L.vertexAlphas),
            (R.vertexTangents = L.vertexTangents),
            (R.toneMapping = L.toneMapping);
        }
        tn.setAnimationLoop(function (_) {
          tr && tr(_);
        }),
          "u" > typeof self && tn.setContext(self),
          (this.setAnimationLoop = function (_) {
            (tr = _),
              ti.setAnimationLoop(_),
              null === _ ? tn.stop() : tn.start();
          }),
          ti.addEventListener("sessionstart", Ce),
          ti.addEventListener("sessionend", Ue),
          (this.render = function (_, L) {
            if (void 0 !== L && !0 !== L.isCamera) {
              console.error(
                "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.",
              );
              return;
            }
            if (!0 === ez) return;
            !0 === _.matrixWorldAutoUpdate && _.updateMatrixWorld(),
              null === L.parent &&
                !0 === L.matrixWorldAutoUpdate &&
                L.updateMatrixWorld(),
              !0 === ti.enabled &&
                !0 === ti.isPresenting &&
                (!0 === ti.cameraAutoUpdate && ti.updateCamera(L),
                (L = ti.getCamera())),
              !0 === _.isScene && _.onBeforeRender(eB, _, L, ek),
              (eL = er.get(_, eI.length)).init(),
              eI.push(eL),
              e8.multiplyMatrices(L.projectionMatrix, L.matrixWorldInverse),
              e0.setFromProjectionMatrix(e8),
              (e4 = this.localClippingEnabled),
              (e2 = en.init(this.clippingPlanes, e4)),
              (eO = ee.get(_, eR.length)).init(),
              eR.push(eO),
              (function $t(_, L, R, N) {
                if (!1 === _.visible) return;
                if (_.layers.test(L.layers)) {
                  if (_.isGroup) R = _.renderOrder;
                  else if (_.isLOD) !0 === _.autoUpdate && _.update(L);
                  else if (_.isLight)
                    eL.pushLight(_), _.castShadow && eL.pushShadow(_);
                  else if (_.isSprite) {
                    if (!_.frustumCulled || e0.intersectsSprite(_)) {
                      N &&
                        e7
                          .setFromMatrixPosition(_.matrixWorld)
                          .applyMatrix4(e8);
                      let L = K.update(_),
                        z = _.material;
                      z.visible && eO.push(_, L, z, R, e7.z, null);
                    }
                  } else if (
                    (_.isMesh || _.isLine || _.isPoints) &&
                    (_.isSkinnedMesh &&
                      _.skeleton.frame !== z.render.frame &&
                      (_.skeleton.update(),
                      (_.skeleton.frame = z.render.frame)),
                    !_.frustumCulled || e0.intersectsObject(_))
                  ) {
                    N &&
                      e7.setFromMatrixPosition(_.matrixWorld).applyMatrix4(e8);
                    let L = K.update(_),
                      z = _.material;
                    if (Array.isArray(z)) {
                      let N = L.groups;
                      for (let F = 0, U = N.length; F < U; F++) {
                        let U = N[F],
                          k = z[U.materialIndex];
                        k && k.visible && eO.push(_, L, k, R, e7.z, U);
                      }
                    } else z.visible && eO.push(_, L, z, R, e7.z, null);
                  }
                }
                let F = _.children;
                for (let _ = 0, z = F.length; _ < z; _++) $t(F[_], L, R, N);
              })(_, L, 0, eB.sortObjects),
              eO.finish(),
              !0 === eB.sortObjects && eO.sort(eQ, eZ),
              !0 === e2 && en.beginShadows();
            let R = eL.state.shadowsArray;
            if (
              (ea.render(R, _, L),
              !0 === e2 && en.endShadows(),
              !0 === this.info.autoReset && this.info.reset(),
              eo.render(eO, _),
              eL.setupLights(eB.physicallyCorrectLights),
              L.isArrayCamera)
            ) {
              let R = L.cameras;
              for (let L = 0, N = R.length; L < N; L++) {
                let N = R[L];
                Nn(eO, _, N, N.viewport);
              }
            } else Nn(eO, _, L);
            null !== ek &&
              (U.updateMultisampleRenderTarget(ek),
              U.updateRenderTargetMipmap(ek)),
              !0 === _.isScene && _.onAfterRender(eB, _, L),
              ep.resetDefaultState(),
              (ej = -1),
              (eG = null),
              eI.pop(),
              (eL = eI.length > 0 ? eI[eI.length - 1] : null),
              eR.pop(),
              (eO = eR.length > 0 ? eR[eR.length - 1] : null);
          }),
          (this.getActiveCubeFace = function () {
            return eF;
          }),
          (this.getActiveMipmapLevel = function () {
            return eU;
          }),
          (this.getRenderTarget = function () {
            return ek;
          }),
          (this.setRenderTargetTextures = function (_, R, N) {
            (F.get(_.texture).__webglTexture = R),
              (F.get(_.depthTexture).__webglTexture = N);
            let z = F.get(_);
            (z.__hasExternalTextures = !0),
              z.__hasExternalTextures &&
                ((z.__autoAllocateDepthBuffer = void 0 === N),
                z.__autoAllocateDepthBuffer ||
                  (!0 === L.has("WEBGL_multisampled_render_to_texture") &&
                    (console.warn(
                      "THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided",
                    ),
                    (z.__useRenderToTexture = !1))));
          }),
          (this.setRenderTargetFramebuffer = function (_, L) {
            let R = F.get(_);
            (R.__webglFramebuffer = L),
              (R.__useDefaultFramebuffer = void 0 === L);
          }),
          (this.setRenderTarget = function (_, L = 0, z = 0) {
            (ek = _), (eF = L), (eU = z);
            let k = !0,
              Y = null,
              X = !1,
              Q = !1;
            if (_) {
              let z = F.get(_);
              void 0 !== z.__useDefaultFramebuffer
                ? (N.bindFramebuffer(36160, null), (k = !1))
                : void 0 === z.__webglFramebuffer
                  ? U.setupRenderTarget(_)
                  : z.__hasExternalTextures &&
                    U.rebindTextures(
                      _,
                      F.get(_.texture).__webglTexture,
                      F.get(_.depthTexture).__webglTexture,
                    );
              let K = _.texture;
              (K.isData3DTexture ||
                K.isDataArrayTexture ||
                K.isCompressedArrayTexture) &&
                (Q = !0);
              let J = F.get(_).__webglFramebuffer;
              _.isWebGLCubeRenderTarget
                ? ((Y = J[L]), (X = !0))
                : (Y =
                    R.isWebGL2 &&
                    _.samples > 0 &&
                    !1 === U.useMultisampledRTT(_)
                      ? F.get(_).__webglMultisampledFramebuffer
                      : J),
                eV.copy(_.viewport),
                eH.copy(_.scissor),
                (eW = _.scissorTest);
            } else
              eV.copy(eK).multiplyScalar(eq).floor(),
                eH.copy(eJ).multiplyScalar(eq).floor(),
                (eW = e$);
            if (
              (N.bindFramebuffer(36160, Y) &&
                R.drawBuffers &&
                k &&
                N.drawBuffers(_, Y),
              N.viewport(eV),
              N.scissor(eH),
              N.setScissorTest(eW),
              X)
            ) {
              let R = F.get(_.texture);
              tt.framebufferTexture2D(
                36160,
                36064,
                34069 + L,
                R.__webglTexture,
                z,
              );
            } else if (Q) {
              let R = F.get(_.texture),
                N = L || 0;
              tt.framebufferTextureLayer(
                36160,
                36064,
                R.__webglTexture,
                z || 0,
                N,
              );
            }
            ej = -1;
          }),
          (this.readRenderTargetPixels = function (_, z, U, k, Y, X, Q) {
            if (!(_ && _.isWebGLRenderTarget)) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.",
              );
              return;
            }
            let K = F.get(_).__webglFramebuffer;
            if ((_.isWebGLCubeRenderTarget && void 0 !== Q && (K = K[Q]), K)) {
              N.bindFramebuffer(36160, K);
              try {
                let N = _.texture,
                  F = N.format,
                  Q = N.type;
                if (1023 !== F && eu.convert(F) !== tt.getParameter(35739)) {
                  console.error(
                    "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.",
                  );
                  return;
                }
                let K =
                  1016 === Q &&
                  (L.has("EXT_color_buffer_half_float") ||
                    (R.isWebGL2 && L.has("EXT_color_buffer_float")));
                if (
                  1009 !== Q &&
                  eu.convert(Q) !== tt.getParameter(35738) &&
                  !(
                    1015 === Q &&
                    (R.isWebGL2 ||
                      L.has("OES_texture_float") ||
                      L.has("WEBGL_color_buffer_float"))
                  ) &&
                  !K
                ) {
                  console.error(
                    "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.",
                  );
                  return;
                }
                z >= 0 &&
                  z <= _.width - k &&
                  U >= 0 &&
                  U <= _.height - Y &&
                  tt.readPixels(z, U, k, Y, eu.convert(F), eu.convert(Q), X);
              } finally {
                let _ = null !== ek ? F.get(ek).__webglFramebuffer : null;
                N.bindFramebuffer(36160, _);
              }
            }
          }),
          (this.copyFramebufferToTexture = function (_, L, R = 0) {
            let z = Math.pow(2, -R),
              F = Math.floor(L.image.width * z),
              k = Math.floor(L.image.height * z);
            U.setTexture2D(L, 0),
              tt.copyTexSubImage2D(3553, R, 0, 0, _.x, _.y, F, k),
              N.unbindTexture();
          }),
          (this.copyTextureToTexture = function (_, L, R, z = 0) {
            let F = L.image.width,
              k = L.image.height,
              Y = eu.convert(R.format),
              X = eu.convert(R.type);
            U.setTexture2D(R, 0),
              tt.pixelStorei(37440, R.flipY),
              tt.pixelStorei(37441, R.premultiplyAlpha),
              tt.pixelStorei(3317, R.unpackAlignment),
              L.isDataTexture
                ? tt.texSubImage2D(3553, z, _.x, _.y, F, k, Y, X, L.image.data)
                : L.isCompressedTexture
                  ? tt.compressedTexSubImage2D(
                      3553,
                      z,
                      _.x,
                      _.y,
                      L.mipmaps[0].width,
                      L.mipmaps[0].height,
                      Y,
                      L.mipmaps[0].data,
                    )
                  : tt.texSubImage2D(3553, z, _.x, _.y, Y, X, L.image),
              0 === z && R.generateMipmaps && tt.generateMipmap(3553),
              N.unbindTexture();
          }),
          (this.copyTextureToTexture3D = function (_, L, R, z, F = 0) {
            if (eB.isWebGL1Renderer) {
              console.warn(
                "THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.",
              );
              return;
            }
            let k = _.max.x - _.min.x + 1,
              Y = _.max.y - _.min.y + 1,
              X = _.max.z - _.min.z + 1,
              Q = eu.convert(z.format),
              K = eu.convert(z.type),
              J;
            if (z.isData3DTexture) U.setTexture3D(z, 0), (J = 32879);
            else if (z.isDataArrayTexture)
              U.setTexture2DArray(z, 0), (J = 35866);
            else {
              console.warn(
                "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.",
              );
              return;
            }
            tt.pixelStorei(37440, z.flipY),
              tt.pixelStorei(37441, z.premultiplyAlpha),
              tt.pixelStorei(3317, z.unpackAlignment);
            let $ = tt.getParameter(3314),
              ee = tt.getParameter(32878),
              er = tt.getParameter(3316),
              en = tt.getParameter(3315),
              ea = tt.getParameter(32877),
              eo = R.isCompressedTexture ? R.mipmaps[0] : R.image;
            tt.pixelStorei(3314, eo.width),
              tt.pixelStorei(32878, eo.height),
              tt.pixelStorei(3316, _.min.x),
              tt.pixelStorei(3315, _.min.y),
              tt.pixelStorei(32877, _.min.z),
              R.isDataTexture || R.isData3DTexture
                ? tt.texSubImage3D(J, F, L.x, L.y, L.z, k, Y, X, Q, K, eo.data)
                : R.isCompressedArrayTexture
                  ? (console.warn(
                      "THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.",
                    ),
                    tt.compressedTexSubImage3D(
                      J,
                      F,
                      L.x,
                      L.y,
                      L.z,
                      k,
                      Y,
                      X,
                      Q,
                      eo.data,
                    ))
                  : tt.texSubImage3D(J, F, L.x, L.y, L.z, k, Y, X, Q, K, eo),
              tt.pixelStorei(3314, $),
              tt.pixelStorei(32878, ee),
              tt.pixelStorei(3316, er),
              tt.pixelStorei(3315, en),
              tt.pixelStorei(32877, ea),
              0 === F && z.generateMipmaps && tt.generateMipmap(J),
              N.unbindTexture();
          }),
          (this.initTexture = function (_) {
            _.isCubeTexture
              ? U.setTextureCube(_, 0)
              : _.isData3DTexture
                ? U.setTexture3D(_, 0)
                : _.isDataArrayTexture || _.isCompressedArrayTexture
                  ? U.setTexture2DArray(_, 0)
                  : U.setTexture2D(_, 0),
              N.unbindTexture();
          }),
          (this.resetState = function () {
            (eF = 0), (eU = 0), (ek = null), N.reset(), ep.reset();
          }),
          "u" > typeof __THREE_DEVTOOLS__ &&
            __THREE_DEVTOOLS__.dispatchEvent(
              new CustomEvent("observe", { detail: this }),
            );
      }
      (class extends v0 {}).prototype.isWebGL1Renderer = !0;
      var n0 = class {
          constructor(_, L = 1, R = 1e3) {
            (this.isFog = !0),
              (this.name = ""),
              (this.color = new iz(_)),
              (this.near = L),
              (this.far = R);
          }
          clone() {
            return new n0(this.color, this.near, this.far);
          }
          toJSON() {
            return {
              type: "Fog",
              color: this.color.getHex(),
              near: this.near,
              far: this.far,
            };
          }
        },
        n2 = class extends rK {
          constructor() {
            super(),
              (this.isScene = !0),
              (this.type = "Scene"),
              (this.background = null),
              (this.environment = null),
              (this.fog = null),
              (this.backgroundBlurriness = 0),
              (this.backgroundIntensity = 1),
              (this.overrideMaterial = null),
              "u" > typeof __THREE_DEVTOOLS__ &&
                __THREE_DEVTOOLS__.dispatchEvent(
                  new CustomEvent("observe", { detail: this }),
                );
          }
          copy(_, L) {
            return (
              super.copy(_, L),
              null !== _.background && (this.background = _.background.clone()),
              null !== _.environment &&
                (this.environment = _.environment.clone()),
              null !== _.fog && (this.fog = _.fog.clone()),
              (this.backgroundBlurriness = _.backgroundBlurriness),
              (this.backgroundIntensity = _.backgroundIntensity),
              null !== _.overrideMaterial &&
                (this.overrideMaterial = _.overrideMaterial.clone()),
              (this.matrixAutoUpdate = _.matrixAutoUpdate),
              this
            );
          }
          toJSON(_) {
            let L = super.toJSON(_);
            return (
              null !== this.fog && (L.object.fog = this.fog.toJSON()),
              this.backgroundBlurriness > 0 &&
                (L.object.backgroundBlurriness = this.backgroundBlurriness),
              1 !== this.backgroundIntensity &&
                (L.object.backgroundIntensity = this.backgroundIntensity),
              L
            );
          }
          get autoUpdate() {
            return (
              console.warn(
                "THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144.",
              ),
              this.matrixWorldAutoUpdate
            );
          }
          set autoUpdate(_) {
            console.warn(
              "THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144.",
            ),
              (this.matrixWorldAutoUpdate = _);
          }
        },
        n4 = class {
          constructor(_, L) {
            (this.isInterleavedBuffer = !0),
              (this.array = _),
              (this.stride = L),
              (this.count = void 0 !== _ ? _.length / L : 0),
              (this.usage = 35044),
              (this.updateRange = { offset: 0, count: -1 }),
              (this.version = 0),
              (this.uuid = es());
          }
          onUploadCallback() {}
          set needsUpdate(_) {
            !0 === _ && this.version++;
          }
          setUsage(_) {
            return (this.usage = _), this;
          }
          copy(_) {
            return (
              (this.array = new _.array.constructor(_.array)),
              (this.count = _.count),
              (this.stride = _.stride),
              (this.usage = _.usage),
              this
            );
          }
          copyAt(_, L, R) {
            (_ *= this.stride), (R *= L.stride);
            for (let N = 0, z = this.stride; N < z; N++)
              this.array[_ + N] = L.array[R + N];
            return this;
          }
          set(_, L = 0) {
            return this.array.set(_, L), this;
          }
          clone(_) {
            void 0 === _.arrayBuffers && (_.arrayBuffers = {}),
              void 0 === this.array.buffer._uuid &&
                (this.array.buffer._uuid = es()),
              void 0 === _.arrayBuffers[this.array.buffer._uuid] &&
                (_.arrayBuffers[this.array.buffer._uuid] =
                  this.array.slice(0).buffer);
            let L = new this.array.constructor(
                _.arrayBuffers[this.array.buffer._uuid],
              ),
              R = new this.constructor(L, this.stride);
            return R.setUsage(this.usage), R;
          }
          onUpload(_) {
            return (this.onUploadCallback = _), this;
          }
          toJSON(_) {
            return (
              void 0 === _.arrayBuffers && (_.arrayBuffers = {}),
              void 0 === this.array.buffer._uuid &&
                (this.array.buffer._uuid = es()),
              void 0 === _.arrayBuffers[this.array.buffer._uuid] &&
                (_.arrayBuffers[this.array.buffer._uuid] = Array.from(
                  new Uint32Array(this.array.buffer),
                )),
              {
                uuid: this.uuid,
                buffer: this.array.buffer._uuid,
                type: this.array.constructor.name,
                stride: this.stride,
              }
            );
          }
        },
        n5 = new iq(),
        n6 = class {
          constructor(_, L, R, N = !1) {
            (this.isInterleavedBufferAttribute = !0),
              (this.name = ""),
              (this.data = _),
              (this.itemSize = L),
              (this.offset = R),
              (this.normalized = N);
          }
          get count() {
            return this.data.count;
          }
          get array() {
            return this.data.array;
          }
          set needsUpdate(_) {
            this.data.needsUpdate = _;
          }
          applyMatrix4(_) {
            for (let L = 0, R = this.data.count; L < R; L++)
              n5.fromBufferAttribute(this, L),
                n5.applyMatrix4(_),
                this.setXYZ(L, n5.x, n5.y, n5.z);
            return this;
          }
          applyNormalMatrix(_) {
            for (let L = 0, R = this.count; L < R; L++)
              n5.fromBufferAttribute(this, L),
                n5.applyNormalMatrix(_),
                this.setXYZ(L, n5.x, n5.y, n5.z);
            return this;
          }
          transformDirection(_) {
            for (let L = 0, R = this.count; L < R; L++)
              n5.fromBufferAttribute(this, L),
                n5.transformDirection(_),
                this.setXYZ(L, n5.x, n5.y, n5.z);
            return this;
          }
          setX(_, L) {
            return (
              this.normalized && (L = Rt(L, this.array)),
              (this.data.array[_ * this.data.stride + this.offset] = L),
              this
            );
          }
          setY(_, L) {
            return (
              this.normalized && (L = Rt(L, this.array)),
              (this.data.array[_ * this.data.stride + this.offset + 1] = L),
              this
            );
          }
          setZ(_, L) {
            return (
              this.normalized && (L = Rt(L, this.array)),
              (this.data.array[_ * this.data.stride + this.offset + 2] = L),
              this
            );
          }
          setW(_, L) {
            return (
              this.normalized && (L = Rt(L, this.array)),
              (this.data.array[_ * this.data.stride + this.offset + 3] = L),
              this
            );
          }
          getX(_) {
            let L = this.data.array[_ * this.data.stride + this.offset];
            return this.normalized && (L = zs(L, this.array)), L;
          }
          getY(_) {
            let L = this.data.array[_ * this.data.stride + this.offset + 1];
            return this.normalized && (L = zs(L, this.array)), L;
          }
          getZ(_) {
            let L = this.data.array[_ * this.data.stride + this.offset + 2];
            return this.normalized && (L = zs(L, this.array)), L;
          }
          getW(_) {
            let L = this.data.array[_ * this.data.stride + this.offset + 3];
            return this.normalized && (L = zs(L, this.array)), L;
          }
          setXY(_, L, R) {
            return (
              (_ = _ * this.data.stride + this.offset),
              this.normalized &&
                ((L = Rt(L, this.array)), (R = Rt(R, this.array))),
              (this.data.array[_ + 0] = L),
              (this.data.array[_ + 1] = R),
              this
            );
          }
          setXYZ(_, L, R, N) {
            return (
              (_ = _ * this.data.stride + this.offset),
              this.normalized &&
                ((L = Rt(L, this.array)),
                (R = Rt(R, this.array)),
                (N = Rt(N, this.array))),
              (this.data.array[_ + 0] = L),
              (this.data.array[_ + 1] = R),
              (this.data.array[_ + 2] = N),
              this
            );
          }
          setXYZW(_, L, R, N, z) {
            return (
              (_ = _ * this.data.stride + this.offset),
              this.normalized &&
                ((L = Rt(L, this.array)),
                (R = Rt(R, this.array)),
                (N = Rt(N, this.array)),
                (z = Rt(z, this.array))),
              (this.data.array[_ + 0] = L),
              (this.data.array[_ + 1] = R),
              (this.data.array[_ + 2] = N),
              (this.data.array[_ + 3] = z),
              this
            );
          }
          clone(_) {
            if (void 0 !== _)
              return (
                void 0 === _.interleavedBuffers && (_.interleavedBuffers = {}),
                void 0 === _.interleavedBuffers[this.data.uuid] &&
                  (_.interleavedBuffers[this.data.uuid] = this.data.clone(_)),
                new n6(
                  _.interleavedBuffers[this.data.uuid],
                  this.itemSize,
                  this.offset,
                  this.normalized,
                )
              );
            {
              console.log(
                "THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.",
              );
              let _ = [];
              for (let L = 0; L < this.count; L++) {
                let R = L * this.data.stride + this.offset;
                for (let L = 0; L < this.itemSize; L++)
                  _.push(this.data.array[R + L]);
              }
              return new sh(
                new this.array.constructor(_),
                this.itemSize,
                this.normalized,
              );
            }
          }
          toJSON(_) {
            if (void 0 !== _)
              return (
                void 0 === _.interleavedBuffers && (_.interleavedBuffers = {}),
                void 0 === _.interleavedBuffers[this.data.uuid] &&
                  (_.interleavedBuffers[this.data.uuid] = this.data.toJSON(_)),
                {
                  isInterleavedBufferAttribute: !0,
                  itemSize: this.itemSize,
                  data: this.data.uuid,
                  offset: this.offset,
                  normalized: this.normalized,
                }
              );
            {
              console.log(
                "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.",
              );
              let _ = [];
              for (let L = 0; L < this.count; L++) {
                let R = L * this.data.stride + this.offset;
                for (let L = 0; L < this.itemSize; L++)
                  _.push(this.data.array[R + L]);
              }
              return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: _,
                normalized: this.normalized,
              };
            }
          }
        },
        n8 = class extends sh {
          constructor(_, L, R, N = 1) {
            super(_, L, R),
              (this.isInstancedBufferAttribute = !0),
              (this.meshPerAttribute = N);
          }
          copy(_) {
            return (
              super.copy(_), (this.meshPerAttribute = _.meshPerAttribute), this
            );
          }
          toJSON() {
            let _ = super.toJSON();
            return (
              (_.meshPerAttribute = this.meshPerAttribute),
              (_.isInstancedBufferAttribute = !0),
              _
            );
          }
        },
        n9 = class extends sr {
          constructor(_) {
            super(),
              (this.isLineBasicMaterial = !0),
              (this.type = "LineBasicMaterial"),
              (this.color = new iz(16777215)),
              (this.linewidth = 1),
              (this.linecap = "round"),
              (this.linejoin = "round"),
              (this.fog = !0),
              this.setValues(_);
          }
          copy(_) {
            return (
              super.copy(_),
              this.color.copy(_.color),
              (this.linewidth = _.linewidth),
              (this.linecap = _.linecap),
              (this.linejoin = _.linejoin),
              (this.fog = _.fog),
              this
            );
          }
        },
        n7 = new iq(),
        at = new iq(),
        ai = new rw(),
        as = new rx(),
        an = new ro(),
        aa = class extends rK {
          constructor(_ = new sP(), L = new n9()) {
            super(),
              (this.isLine = !0),
              (this.type = "Line"),
              (this.geometry = _),
              (this.material = L),
              this.updateMorphTargets();
          }
          copy(_, L) {
            return (
              super.copy(_, L),
              (this.material = _.material),
              (this.geometry = _.geometry),
              this
            );
          }
          computeLineDistances() {
            let _ = this.geometry;
            if (null === _.index) {
              let L = _.attributes.position,
                R = [0];
              for (let _ = 1, N = L.count; _ < N; _++)
                n7.fromBufferAttribute(L, _ - 1),
                  at.fromBufferAttribute(L, _),
                  (R[_] = R[_ - 1]),
                  (R[_] += n7.distanceTo(at));
              _.setAttribute("lineDistance", new sv(R, 1));
            } else
              console.warn(
                "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.",
              );
            return this;
          }
          raycast(_, L) {
            let R = this.geometry,
              N = this.matrixWorld,
              z = _.params.Line.threshold,
              F = R.drawRange;
            if (
              (null === R.boundingSphere && R.computeBoundingSphere(),
              an.copy(R.boundingSphere),
              an.applyMatrix4(N),
              (an.radius += z),
              !1 === _.ray.intersectsSphere(an))
            )
              return;
            ai.copy(N).invert(), as.copy(_.ray).applyMatrix4(ai);
            let U = z / ((this.scale.x + this.scale.y + this.scale.z) / 3),
              k = U * U,
              Y = new iq(),
              X = new iq(),
              Q = new iq(),
              K = new iq(),
              J = this.isLineSegments ? 2 : 1,
              $ = R.index,
              ee = R.attributes.position;
            if (null !== $) {
              let R = Math.max(0, F.start),
                N = Math.min($.count, F.start + F.count);
              for (let z = R, F = N - 1; z < F; z += J) {
                let R = $.getX(z),
                  N = $.getX(z + 1);
                if (
                  (Y.fromBufferAttribute(ee, R),
                  X.fromBufferAttribute(ee, N),
                  as.distanceSqToSegment(Y, X, K, Q) > k)
                )
                  continue;
                K.applyMatrix4(this.matrixWorld);
                let F = _.ray.origin.distanceTo(K);
                F < _.near ||
                  F > _.far ||
                  L.push({
                    distance: F,
                    point: Q.clone().applyMatrix4(this.matrixWorld),
                    index: z,
                    face: null,
                    faceIndex: null,
                    object: this,
                  });
              }
            } else {
              let R = Math.max(0, F.start),
                N = Math.min(ee.count, F.start + F.count);
              for (let z = R, F = N - 1; z < F; z += J) {
                if (
                  (Y.fromBufferAttribute(ee, z),
                  X.fromBufferAttribute(ee, z + 1),
                  as.distanceSqToSegment(Y, X, K, Q) > k)
                )
                  continue;
                K.applyMatrix4(this.matrixWorld);
                let R = _.ray.origin.distanceTo(K);
                R < _.near ||
                  R > _.far ||
                  L.push({
                    distance: R,
                    point: Q.clone().applyMatrix4(this.matrixWorld),
                    index: z,
                    face: null,
                    faceIndex: null,
                    object: this,
                  });
              }
            }
          }
          updateMorphTargets() {
            let _ = this.geometry.morphAttributes,
              L = Object.keys(_);
            if (L.length > 0) {
              let R = _[L[0]];
              if (void 0 !== R) {
                (this.morphTargetInfluences = []),
                  (this.morphTargetDictionary = {});
                for (let _ = 0, L = R.length; _ < L; _++) {
                  let L = R[_].name || String(_);
                  this.morphTargetInfluences.push(0),
                    (this.morphTargetDictionary[L] = _);
                }
              }
            }
          }
        },
        ao = new iq(),
        al = new iq(),
        ah = class extends aa {
          constructor(_, L) {
            super(_, L),
              (this.isLineSegments = !0),
              (this.type = "LineSegments");
          }
          computeLineDistances() {
            let _ = this.geometry;
            if (null === _.index) {
              let L = _.attributes.position,
                R = [];
              for (let _ = 0, N = L.count; _ < N; _ += 2)
                ao.fromBufferAttribute(L, _),
                  al.fromBufferAttribute(L, _ + 1),
                  (R[_] = 0 === _ ? 0 : R[_ - 1]),
                  (R[_ + 1] = R[_] + ao.distanceTo(al));
              _.setAttribute("lineDistance", new sv(R, 1));
            } else
              console.warn(
                "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.",
              );
            return this;
          }
        },
        ac = class extends iG {
          constructor(_, L, R, N, z, F, U, k, Y) {
            super(_, L, R, N, z, F, U, k, Y),
              (this.isVideoTexture = !0),
              (this.minFilter = void 0 !== F ? F : 1006),
              (this.magFilter = void 0 !== z ? z : 1006),
              (this.generateMipmaps = !1);
            let X = this;
            "requestVideoFrameCallback" in _ &&
              _.requestVideoFrameCallback(function d() {
                (X.needsUpdate = !0), _.requestVideoFrameCallback(d);
              });
          }
          clone() {
            return new this.constructor(this.image).copy(this);
          }
          update() {
            let _ = this.image;
            "requestVideoFrameCallback" in _ == !1 &&
              _.readyState >= _.HAVE_CURRENT_DATA &&
              (this.needsUpdate = !0);
          }
        },
        ad = class {
          constructor() {
            (this.type = "Curve"), (this.arcLengthDivisions = 200);
          }
          getPoint() {
            return (
              console.warn("THREE.Curve: .getPoint() not implemented."), null
            );
          }
          getPointAt(_, L) {
            let R = this.getUtoTmapping(_);
            return this.getPoint(R, L);
          }
          getPoints(_ = 5) {
            let L = [];
            for (let R = 0; R <= _; R++) L.push(this.getPoint(R / _));
            return L;
          }
          getSpacedPoints(_ = 5) {
            let L = [];
            for (let R = 0; R <= _; R++) L.push(this.getPointAt(R / _));
            return L;
          }
          getLength() {
            let _ = this.getLengths();
            return _[_.length - 1];
          }
          getLengths(_ = this.arcLengthDivisions) {
            if (
              this.cacheArcLengths &&
              this.cacheArcLengths.length === _ + 1 &&
              !this.needsUpdate
            )
              return this.cacheArcLengths;
            this.needsUpdate = !1;
            let L = [],
              R,
              N = this.getPoint(0),
              z = 0;
            L.push(0);
            for (let F = 1; F <= _; F++)
              L.push((z += (R = this.getPoint(F / _)).distanceTo(N))), (N = R);
            return (this.cacheArcLengths = L), L;
          }
          updateArcLengths() {
            (this.needsUpdate = !0), this.getLengths();
          }
          getUtoTmapping(_, L) {
            let R = this.getLengths(),
              N = 0,
              z = R.length,
              F;
            F = L || _ * R[z - 1];
            let U = 0,
              k = z - 1,
              Y;
            for (; U <= k; )
              if ((Y = R[(N = Math.floor(U + (k - U) / 2))] - F) < 0) U = N + 1;
              else if (Y > 0) k = N - 1;
              else {
                k = N;
                break;
              }
            if (R[(N = k)] === F) return N / (z - 1);
            let X = R[N],
              Q = R[N + 1] - X;
            return (N + (F - X) / Q) / (z - 1);
          }
          getTangent(_, L) {
            let R = _ - 1e-4,
              N = _ + 1e-4;
            R < 0 && (R = 0), N > 1 && (N = 1);
            let z = this.getPoint(R),
              F = this.getPoint(N),
              U = L || (z.isVector2 ? new iT() : new iq());
            return U.copy(F).sub(z).normalize(), U;
          }
          getTangentAt(_, L) {
            let R = this.getUtoTmapping(_);
            return this.getTangent(R, L);
          }
          computeFrenetFrames(_, L) {
            let R = new iq(),
              N = [],
              z = [],
              F = [],
              U = new iq(),
              k = new rw();
            for (let L = 0; L <= _; L++) {
              let R = L / _;
              N[L] = this.getTangentAt(R, new iq());
            }
            (z[0] = new iq()), (F[0] = new iq());
            let Y = Number.MAX_VALUE,
              X = Math.abs(N[0].x),
              Q = Math.abs(N[0].y),
              K = Math.abs(N[0].z);
            X <= Y && ((Y = X), R.set(1, 0, 0)),
              Q <= Y && ((Y = Q), R.set(0, 1, 0)),
              K <= Y && R.set(0, 0, 1),
              U.crossVectors(N[0], R).normalize(),
              z[0].crossVectors(N[0], U),
              F[0].crossVectors(N[0], z[0]);
            for (let L = 1; L <= _; L++) {
              if (
                ((z[L] = z[L - 1].clone()),
                (F[L] = F[L - 1].clone()),
                U.crossVectors(N[L - 1], N[L]),
                U.length() > Number.EPSILON)
              ) {
                U.normalize();
                let _ = Math.acos(_n(N[L - 1].dot(N[L]), -1, 1));
                z[L].applyMatrix4(k.makeRotationAxis(U, _));
              }
              F[L].crossVectors(N[L], z[L]);
            }
            if (!0 === L) {
              let L = Math.acos(_n(z[0].dot(z[_]), -1, 1));
              (L /= _), N[0].dot(U.crossVectors(z[0], z[_])) > 0 && (L = -L);
              for (let R = 1; R <= _; R++)
                z[R].applyMatrix4(k.makeRotationAxis(N[R], L * R)),
                  F[R].crossVectors(N[R], z[R]);
            }
            return { tangents: N, normals: z, binormals: F };
          }
          clone() {
            return new this.constructor().copy(this);
          }
          copy(_) {
            return (this.arcLengthDivisions = _.arcLengthDivisions), this;
          }
          toJSON() {
            let _ = {
              metadata: {
                version: 4.5,
                type: "Curve",
                generator: "Curve.toJSON",
              },
            };
            return (
              (_.arcLengthDivisions = this.arcLengthDivisions),
              (_.type = this.type),
              _
            );
          }
          fromJSON(_) {
            return (this.arcLengthDivisions = _.arcLengthDivisions), this;
          }
        },
        af = class extends ad {
          constructor(
            _ = 0,
            L = 0,
            R = 1,
            N = 1,
            z = 0,
            F = 2 * Math.PI,
            U = !1,
            k = 0,
          ) {
            super(),
              (this.isEllipseCurve = !0),
              (this.type = "EllipseCurve"),
              (this.aX = _),
              (this.aY = L),
              (this.xRadius = R),
              (this.yRadius = N),
              (this.aStartAngle = z),
              (this.aEndAngle = F),
              (this.aClockwise = U),
              (this.aRotation = k);
          }
          getPoint(_, L) {
            let R = L || new iT(),
              N = 2 * Math.PI,
              z = this.aEndAngle - this.aStartAngle,
              F = Math.abs(z) < Number.EPSILON;
            for (; z < 0; ) z += N;
            for (; z > N; ) z -= N;
            z < Number.EPSILON && (z = F ? 0 : N),
              !0 !== this.aClockwise || F || (z === N ? (z = -N) : (z -= N));
            let U = this.aStartAngle + _ * z,
              k = this.aX + this.xRadius * Math.cos(U),
              Y = this.aY + this.yRadius * Math.sin(U);
            if (0 !== this.aRotation) {
              let _ = Math.cos(this.aRotation),
                L = Math.sin(this.aRotation),
                R = k - this.aX,
                N = Y - this.aY;
              (k = R * _ - N * L + this.aX), (Y = R * L + N * _ + this.aY);
            }
            return R.set(k, Y);
          }
          copy(_) {
            return (
              super.copy(_),
              (this.aX = _.aX),
              (this.aY = _.aY),
              (this.xRadius = _.xRadius),
              (this.yRadius = _.yRadius),
              (this.aStartAngle = _.aStartAngle),
              (this.aEndAngle = _.aEndAngle),
              (this.aClockwise = _.aClockwise),
              (this.aRotation = _.aRotation),
              this
            );
          }
          toJSON() {
            let _ = super.toJSON();
            return (
              (_.aX = this.aX),
              (_.aY = this.aY),
              (_.xRadius = this.xRadius),
              (_.yRadius = this.yRadius),
              (_.aStartAngle = this.aStartAngle),
              (_.aEndAngle = this.aEndAngle),
              (_.aClockwise = this.aClockwise),
              (_.aRotation = this.aRotation),
              _
            );
          }
          fromJSON(_) {
            return (
              super.fromJSON(_),
              (this.aX = _.aX),
              (this.aY = _.aY),
              (this.xRadius = _.xRadius),
              (this.yRadius = _.yRadius),
              (this.aStartAngle = _.aStartAngle),
              (this.aEndAngle = _.aEndAngle),
              (this.aClockwise = _.aClockwise),
              (this.aRotation = _.aRotation),
              this
            );
          }
        },
        am = class extends af {
          constructor(_, L, R, N, z, F) {
            super(_, L, R, R, N, z, F),
              (this.isArcCurve = !0),
              (this.type = "ArcCurve");
          }
        };
      function x0() {
        let _ = 0,
          L = 0,
          R = 0,
          N = 0;
        function i(z, F, U, k) {
          (_ = z),
            (L = U),
            (R = -3 * z + 3 * F - 2 * U - k),
            (N = 2 * z - 2 * F + U + k);
        }
        return {
          initCatmullRom: function (_, L, R, N, z) {
            i(L, R, z * (R - _), z * (N - L));
          },
          initNonuniformCatmullRom: function (_, L, R, N, z, F, U) {
            let k = (L - _) / z - (R - _) / (z + F) + (R - L) / F,
              Y = (R - L) / F - (N - L) / (F + U) + (N - R) / U;
            i(L, R, (k *= F), (Y *= F));
          },
          calc: function (z) {
            let F = z * z;
            return _ + L * z + R * F + N * (F * z);
          },
        };
      }
      var ag = new iq(),
        ay = new x0(),
        ax = new x0(),
        ab = new x0(),
        aw = class extends ad {
          constructor(_ = [], L = !1, R = "centripetal", N = 0.5) {
            super(),
              (this.isCatmullRomCurve3 = !0),
              (this.type = "CatmullRomCurve3"),
              (this.points = _),
              (this.closed = L),
              (this.curveType = R),
              (this.tension = N);
          }
          getPoint(_, L = new iq()) {
            let R,
              N,
              z = this.points,
              F = z.length,
              U = (F - (this.closed ? 0 : 1)) * _,
              k = Math.floor(U),
              Y = U - k;
            this.closed
              ? (k += k > 0 ? 0 : (Math.floor(Math.abs(k) / F) + 1) * F)
              : 0 === Y && k === F - 1 && ((k = F - 2), (Y = 1)),
              this.closed || k > 0
                ? (R = z[(k - 1) % F])
                : (ag.subVectors(z[0], z[1]).add(z[0]), (R = ag));
            let X = z[k % F],
              Q = z[(k + 1) % F];
            if (
              (this.closed || k + 2 < F
                ? (N = z[(k + 2) % F])
                : (ag.subVectors(z[F - 1], z[F - 2]).add(z[F - 1]), (N = ag)),
              "centripetal" === this.curveType || "chordal" === this.curveType)
            ) {
              let _ = "chordal" === this.curveType ? 0.5 : 0.25,
                L = Math.pow(R.distanceToSquared(X), _),
                z = Math.pow(X.distanceToSquared(Q), _),
                F = Math.pow(Q.distanceToSquared(N), _);
              z < 1e-4 && (z = 1),
                L < 1e-4 && (L = z),
                F < 1e-4 && (F = z),
                ay.initNonuniformCatmullRom(R.x, X.x, Q.x, N.x, L, z, F),
                ax.initNonuniformCatmullRom(R.y, X.y, Q.y, N.y, L, z, F),
                ab.initNonuniformCatmullRom(R.z, X.z, Q.z, N.z, L, z, F);
            } else
              "catmullrom" === this.curveType &&
                (ay.initCatmullRom(R.x, X.x, Q.x, N.x, this.tension),
                ax.initCatmullRom(R.y, X.y, Q.y, N.y, this.tension),
                ab.initCatmullRom(R.z, X.z, Q.z, N.z, this.tension));
            return L.set(ay.calc(Y), ax.calc(Y), ab.calc(Y)), L;
          }
          copy(_) {
            super.copy(_), (this.points = []);
            for (let L = 0, R = _.points.length; L < R; L++) {
              let R = _.points[L];
              this.points.push(R.clone());
            }
            return (
              (this.closed = _.closed),
              (this.curveType = _.curveType),
              (this.tension = _.tension),
              this
            );
          }
          toJSON() {
            let _ = super.toJSON();
            _.points = [];
            for (let L = 0, R = this.points.length; L < R; L++) {
              let R = this.points[L];
              _.points.push(R.toArray());
            }
            return (
              (_.closed = this.closed),
              (_.curveType = this.curveType),
              (_.tension = this.tension),
              _
            );
          }
          fromJSON(_) {
            super.fromJSON(_), (this.points = []);
            for (let L = 0, R = _.points.length; L < R; L++) {
              let R = _.points[L];
              this.points.push(new iq().fromArray(R));
            }
            return (
              (this.closed = _.closed),
              (this.curveType = _.curveType),
              (this.tension = _.tension),
              this
            );
          }
        };
      function m1(_, L, R, N, z) {
        let F = (N - L) * 0.5,
          U = (z - R) * 0.5,
          k = _ * _;
        return (
          (2 * R - 2 * N + F + U) * (_ * k) +
          (-3 * R + 3 * N - 2 * F - U) * k +
          F * _ +
          R
        );
      }
      function Td(_, L, R, N) {
        let z;
        return (z = 1 - _) * z * L + 2 * (1 - _) * _ * R + _ * _ * N;
      }
      function Ed(_, L, R, N, z) {
        let F, U;
        return (
          (F = 1 - _) * F * F * L +
          3 * (U = 1 - _) * U * _ * R +
          3 * (1 - _) * _ * _ * N +
          _ * _ * _ * z
        );
      }
      var aA = class extends ad {
          constructor(_ = new iT(), L = new iT(), R = new iT(), N = new iT()) {
            super(),
              (this.isCubicBezierCurve = !0),
              (this.type = "CubicBezierCurve"),
              (this.v0 = _),
              (this.v1 = L),
              (this.v2 = R),
              (this.v3 = N);
          }
          getPoint(_, L = new iT()) {
            let R = this.v0,
              N = this.v1,
              z = this.v2,
              F = this.v3;
            return (
              L.set(Ed(_, R.x, N.x, z.x, F.x), Ed(_, R.y, N.y, z.y, F.y)), L
            );
          }
          copy(_) {
            return (
              super.copy(_),
              this.v0.copy(_.v0),
              this.v1.copy(_.v1),
              this.v2.copy(_.v2),
              this.v3.copy(_.v3),
              this
            );
          }
          toJSON() {
            let _ = super.toJSON();
            return (
              (_.v0 = this.v0.toArray()),
              (_.v1 = this.v1.toArray()),
              (_.v2 = this.v2.toArray()),
              (_.v3 = this.v3.toArray()),
              _
            );
          }
          fromJSON(_) {
            return (
              super.fromJSON(_),
              this.v0.fromArray(_.v0),
              this.v1.fromArray(_.v1),
              this.v2.fromArray(_.v2),
              this.v3.fromArray(_.v3),
              this
            );
          }
        },
        aE = class extends ad {
          constructor(_ = new iq(), L = new iq(), R = new iq(), N = new iq()) {
            super(),
              (this.isCubicBezierCurve3 = !0),
              (this.type = "CubicBezierCurve3"),
              (this.v0 = _),
              (this.v1 = L),
              (this.v2 = R),
              (this.v3 = N);
          }
          getPoint(_, L = new iq()) {
            let R = this.v0,
              N = this.v1,
              z = this.v2,
              F = this.v3;
            return (
              L.set(
                Ed(_, R.x, N.x, z.x, F.x),
                Ed(_, R.y, N.y, z.y, F.y),
                Ed(_, R.z, N.z, z.z, F.z),
              ),
              L
            );
          }
          copy(_) {
            return (
              super.copy(_),
              this.v0.copy(_.v0),
              this.v1.copy(_.v1),
              this.v2.copy(_.v2),
              this.v3.copy(_.v3),
              this
            );
          }
          toJSON() {
            let _ = super.toJSON();
            return (
              (_.v0 = this.v0.toArray()),
              (_.v1 = this.v1.toArray()),
              (_.v2 = this.v2.toArray()),
              (_.v3 = this.v3.toArray()),
              _
            );
          }
          fromJSON(_) {
            return (
              super.fromJSON(_),
              this.v0.fromArray(_.v0),
              this.v1.fromArray(_.v1),
              this.v2.fromArray(_.v2),
              this.v3.fromArray(_.v3),
              this
            );
          }
        },
        aT = class extends ad {
          constructor(_ = new iT(), L = new iT()) {
            super(),
              (this.isLineCurve = !0),
              (this.type = "LineCurve"),
              (this.v1 = _),
              (this.v2 = L);
          }
          getPoint(_, L = new iT()) {
            return (
              1 === _
                ? L.copy(this.v2)
                : (L.copy(this.v2).sub(this.v1),
                  L.multiplyScalar(_).add(this.v1)),
              L
            );
          }
          getPointAt(_, L) {
            return this.getPoint(_, L);
          }
          getTangent(_, L) {
            let R = L || new iT();
            return R.copy(this.v2).sub(this.v1).normalize(), R;
          }
          copy(_) {
            return super.copy(_), this.v1.copy(_.v1), this.v2.copy(_.v2), this;
          }
          toJSON() {
            let _ = super.toJSON();
            return (_.v1 = this.v1.toArray()), (_.v2 = this.v2.toArray()), _;
          }
          fromJSON(_) {
            return (
              super.fromJSON(_),
              this.v1.fromArray(_.v1),
              this.v2.fromArray(_.v2),
              this
            );
          }
        },
        aC = class extends ad {
          constructor(_ = new iq(), L = new iq()) {
            super(),
              (this.isLineCurve3 = !0),
              (this.type = "LineCurve3"),
              (this.v1 = _),
              (this.v2 = L);
          }
          getPoint(_, L = new iq()) {
            return (
              1 === _
                ? L.copy(this.v2)
                : (L.copy(this.v2).sub(this.v1),
                  L.multiplyScalar(_).add(this.v1)),
              L
            );
          }
          getPointAt(_, L) {
            return this.getPoint(_, L);
          }
          copy(_) {
            return super.copy(_), this.v1.copy(_.v1), this.v2.copy(_.v2), this;
          }
          toJSON() {
            let _ = super.toJSON();
            return (_.v1 = this.v1.toArray()), (_.v2 = this.v2.toArray()), _;
          }
          fromJSON(_) {
            return (
              super.fromJSON(_),
              this.v1.fromArray(_.v1),
              this.v2.fromArray(_.v2),
              this
            );
          }
        },
        aD = class extends ad {
          constructor(_ = new iT(), L = new iT(), R = new iT()) {
            super(),
              (this.isQuadraticBezierCurve = !0),
              (this.type = "QuadraticBezierCurve"),
              (this.v0 = _),
              (this.v1 = L),
              (this.v2 = R);
          }
          getPoint(_, L = new iT()) {
            let R = this.v0,
              N = this.v1,
              z = this.v2;
            return L.set(Td(_, R.x, N.x, z.x), Td(_, R.y, N.y, z.y)), L;
          }
          copy(_) {
            return (
              super.copy(_),
              this.v0.copy(_.v0),
              this.v1.copy(_.v1),
              this.v2.copy(_.v2),
              this
            );
          }
          toJSON() {
            let _ = super.toJSON();
            return (
              (_.v0 = this.v0.toArray()),
              (_.v1 = this.v1.toArray()),
              (_.v2 = this.v2.toArray()),
              _
            );
          }
          fromJSON(_) {
            return (
              super.fromJSON(_),
              this.v0.fromArray(_.v0),
              this.v1.fromArray(_.v1),
              this.v2.fromArray(_.v2),
              this
            );
          }
        },
        aO = class extends ad {
          constructor(_ = new iq(), L = new iq(), R = new iq()) {
            super(),
              (this.isQuadraticBezierCurve3 = !0),
              (this.type = "QuadraticBezierCurve3"),
              (this.v0 = _),
              (this.v1 = L),
              (this.v2 = R);
          }
          getPoint(_, L = new iq()) {
            let R = this.v0,
              N = this.v1,
              z = this.v2;
            return (
              L.set(
                Td(_, R.x, N.x, z.x),
                Td(_, R.y, N.y, z.y),
                Td(_, R.z, N.z, z.z),
              ),
              L
            );
          }
          copy(_) {
            return (
              super.copy(_),
              this.v0.copy(_.v0),
              this.v1.copy(_.v1),
              this.v2.copy(_.v2),
              this
            );
          }
          toJSON() {
            let _ = super.toJSON();
            return (
              (_.v0 = this.v0.toArray()),
              (_.v1 = this.v1.toArray()),
              (_.v2 = this.v2.toArray()),
              _
            );
          }
          fromJSON(_) {
            return (
              super.fromJSON(_),
              this.v0.fromArray(_.v0),
              this.v1.fromArray(_.v1),
              this.v2.fromArray(_.v2),
              this
            );
          }
        },
        aL = class extends ad {
          constructor(_ = []) {
            super(),
              (this.isSplineCurve = !0),
              (this.type = "SplineCurve"),
              (this.points = _);
          }
          getPoint(_, L = new iT()) {
            let R = this.points,
              N = (R.length - 1) * _,
              z = Math.floor(N),
              F = N - z,
              U = R[0 === z ? z : z - 1],
              k = R[z],
              Y = R[z > R.length - 2 ? R.length - 1 : z + 1],
              X = R[z > R.length - 3 ? R.length - 1 : z + 2];
            return (
              L.set(m1(F, U.x, k.x, Y.x, X.x), m1(F, U.y, k.y, Y.y, X.y)), L
            );
          }
          copy(_) {
            super.copy(_), (this.points = []);
            for (let L = 0, R = _.points.length; L < R; L++) {
              let R = _.points[L];
              this.points.push(R.clone());
            }
            return this;
          }
          toJSON() {
            let _ = super.toJSON();
            _.points = [];
            for (let L = 0, R = this.points.length; L < R; L++) {
              let R = this.points[L];
              _.points.push(R.toArray());
            }
            return _;
          }
          fromJSON(_) {
            super.fromJSON(_), (this.points = []);
            for (let L = 0, R = _.points.length; L < R; L++) {
              let R = _.points[L];
              this.points.push(new iT().fromArray(R));
            }
            return this;
          }
        },
        aR = Object.freeze({
          __proto__: null,
          ArcCurve: am,
          CatmullRomCurve3: aw,
          CubicBezierCurve: aA,
          CubicBezierCurve3: aE,
          EllipseCurve: af,
          LineCurve: aT,
          LineCurve3: aC,
          QuadraticBezierCurve: aD,
          QuadraticBezierCurve3: aO,
          SplineCurve: aL,
        }),
        aI = class extends ad {
          constructor() {
            super(),
              (this.type = "CurvePath"),
              (this.curves = []),
              (this.autoClose = !1);
          }
          add(_) {
            this.curves.push(_);
          }
          closePath() {
            let _ = this.curves[0].getPoint(0),
              L = this.curves[this.curves.length - 1].getPoint(1);
            _.equals(L) || this.curves.push(new aT(L, _));
          }
          getPoint(_, L) {
            let R = _ * this.getLength(),
              N = this.getCurveLengths(),
              z = 0;
            for (; z < N.length; ) {
              if (N[z] >= R) {
                let _ = N[z] - R,
                  F = this.curves[z],
                  U = F.getLength(),
                  k = 0 === U ? 0 : 1 - _ / U;
                return F.getPointAt(k, L);
              }
              z++;
            }
            return null;
          }
          getLength() {
            let _ = this.getCurveLengths();
            return _[_.length - 1];
          }
          updateArcLengths() {
            (this.needsUpdate = !0),
              (this.cacheLengths = null),
              this.getCurveLengths();
          }
          getCurveLengths() {
            if (
              this.cacheLengths &&
              this.cacheLengths.length === this.curves.length
            )
              return this.cacheLengths;
            let _ = [],
              L = 0;
            for (let R = 0, N = this.curves.length; R < N; R++)
              _.push((L += this.curves[R].getLength()));
            return (this.cacheLengths = _), _;
          }
          getSpacedPoints(_ = 40) {
            let L = [];
            for (let R = 0; R <= _; R++) L.push(this.getPoint(R / _));
            return this.autoClose && L.push(L[0]), L;
          }
          getPoints(_ = 12) {
            let L = [],
              R;
            for (let N = 0, z = this.curves; N < z.length; N++) {
              let F = z[N],
                U = F.isEllipseCurve
                  ? 2 * _
                  : F.isLineCurve || F.isLineCurve3
                    ? 1
                    : F.isSplineCurve
                      ? _ * F.points.length
                      : _,
                k = F.getPoints(U);
              for (let _ = 0; _ < k.length; _++) {
                let N = k[_];
                (R && R.equals(N)) || (L.push(N), (R = N));
              }
            }
            return (
              this.autoClose &&
                L.length > 1 &&
                !L[L.length - 1].equals(L[0]) &&
                L.push(L[0]),
              L
            );
          }
          copy(_) {
            super.copy(_), (this.curves = []);
            for (let L = 0, R = _.curves.length; L < R; L++) {
              let R = _.curves[L];
              this.curves.push(R.clone());
            }
            return (this.autoClose = _.autoClose), this;
          }
          toJSON() {
            let _ = super.toJSON();
            (_.autoClose = this.autoClose), (_.curves = []);
            for (let L = 0, R = this.curves.length; L < R; L++) {
              let R = this.curves[L];
              _.curves.push(R.toJSON());
            }
            return _;
          }
          fromJSON(_) {
            super.fromJSON(_),
              (this.autoClose = _.autoClose),
              (this.curves = []);
            for (let L = 0, R = _.curves.length; L < R; L++) {
              let R = _.curves[L];
              this.curves.push(new aR[R.type]().fromJSON(R));
            }
            return this;
          }
        },
        aB = class extends aI {
          constructor(_) {
            super(),
              (this.type = "Path"),
              (this.currentPoint = new iT()),
              _ && this.setFromPoints(_);
          }
          setFromPoints(_) {
            this.moveTo(_[0].x, _[0].y);
            for (let L = 1, R = _.length; L < R; L++)
              this.lineTo(_[L].x, _[L].y);
            return this;
          }
          moveTo(_, L) {
            return this.currentPoint.set(_, L), this;
          }
          lineTo(_, L) {
            let R = new aT(this.currentPoint.clone(), new iT(_, L));
            return this.curves.push(R), this.currentPoint.set(_, L), this;
          }
          quadraticCurveTo(_, L, R, N) {
            let z = new aD(
              this.currentPoint.clone(),
              new iT(_, L),
              new iT(R, N),
            );
            return this.curves.push(z), this.currentPoint.set(R, N), this;
          }
          bezierCurveTo(_, L, R, N, z, F) {
            let U = new aA(
              this.currentPoint.clone(),
              new iT(_, L),
              new iT(R, N),
              new iT(z, F),
            );
            return this.curves.push(U), this.currentPoint.set(z, F), this;
          }
          splineThru(_) {
            let L = [this.currentPoint.clone()].concat(_),
              R = new aL(L);
            return (
              this.curves.push(R), this.currentPoint.copy(_[_.length - 1]), this
            );
          }
          arc(_, L, R, N, z, F) {
            let U = this.currentPoint.x,
              k = this.currentPoint.y;
            return this.absarc(_ + U, L + k, R, N, z, F), this;
          }
          absarc(_, L, R, N, z, F) {
            return this.absellipse(_, L, R, R, N, z, F), this;
          }
          ellipse(_, L, R, N, z, F, U, k) {
            let Y = this.currentPoint.x,
              X = this.currentPoint.y;
            return this.absellipse(_ + Y, L + X, R, N, z, F, U, k), this;
          }
          absellipse(_, L, R, N, z, F, U, k) {
            let Y = new af(_, L, R, N, z, F, U, k);
            if (this.curves.length > 0) {
              let _ = Y.getPoint(0);
              _.equals(this.currentPoint) || this.lineTo(_.x, _.y);
            }
            this.curves.push(Y);
            let X = Y.getPoint(1);
            return this.currentPoint.copy(X), this;
          }
          copy(_) {
            return super.copy(_), this.currentPoint.copy(_.currentPoint), this;
          }
          toJSON() {
            let _ = super.toJSON();
            return (_.currentPoint = this.currentPoint.toArray()), _;
          }
          fromJSON(_) {
            return (
              super.fromJSON(_),
              this.currentPoint.fromArray(_.currentPoint),
              this
            );
          }
        },
        az = class extends sP {
          constructor(
            _ = [new iT(0, -0.5), new iT(0.5, 0), new iT(0, 0.5)],
            L = 12,
            R = 0,
            N = 2 * Math.PI,
          ) {
            super(),
              (this.type = "LatheGeometry"),
              (this.parameters = {
                points: _,
                segments: L,
                phiStart: R,
                phiLength: N,
              }),
              (L = Math.floor(L)),
              (N = _n(N, 0, 2 * Math.PI));
            let z = [],
              F = [],
              U = [],
              k = [],
              Y = [],
              X = 1 / L,
              Q = new iq(),
              K = new iT(),
              J = new iq(),
              $ = new iq(),
              ee = new iq(),
              er = 0,
              en = 0;
            for (let L = 0; L <= _.length - 1; L++)
              switch (L) {
                case 0:
                  (er = _[L + 1].x - _[L].x),
                    (en = _[L + 1].y - _[L].y),
                    (J.x = 1 * en),
                    (J.y = -er),
                    (J.z = 0 * en),
                    ee.copy(J),
                    J.normalize(),
                    k.push(J.x, J.y, J.z);
                  break;
                case _.length - 1:
                  k.push(ee.x, ee.y, ee.z);
                  break;
                default:
                  (er = _[L + 1].x - _[L].x),
                    (en = _[L + 1].y - _[L].y),
                    (J.x = 1 * en),
                    (J.y = -er),
                    (J.z = 0 * en),
                    $.copy(J),
                    (J.x += ee.x),
                    (J.y += ee.y),
                    (J.z += ee.z),
                    J.normalize(),
                    k.push(J.x, J.y, J.z),
                    ee.copy($);
              }
            for (let z = 0; z <= L; z++) {
              let J = R + z * X * N,
                $ = Math.sin(J),
                ee = Math.cos(J);
              for (let R = 0; R <= _.length - 1; R++) {
                (Q.x = _[R].x * $),
                  (Q.y = _[R].y),
                  (Q.z = _[R].x * ee),
                  F.push(Q.x, Q.y, Q.z),
                  (K.x = z / L),
                  (K.y = R / (_.length - 1)),
                  U.push(K.x, K.y);
                let N = k[3 * R + 0] * $,
                  X = k[3 * R + 1],
                  J = k[3 * R + 0] * ee;
                Y.push(N, X, J);
              }
            }
            for (let R = 0; R < L; R++)
              for (let L = 0; L < _.length - 1; L++) {
                let N = L + R * _.length,
                  F = N + _.length,
                  U = N + _.length + 1,
                  k = N + 1;
                z.push(N, F, k), z.push(U, k, F);
              }
            this.setIndex(z),
              this.setAttribute("position", new sv(F, 3)),
              this.setAttribute("uv", new sv(U, 2)),
              this.setAttribute("normal", new sv(Y, 3));
          }
          static fromJSON(_) {
            return new az(_.points, _.segments, _.phiStart, _.phiLength);
          }
        },
        aF = class extends sP {
          constructor(
            _ = 1,
            L = 1,
            R = 1,
            N = 32,
            z = 1,
            F = !1,
            U = 0,
            k = 2 * Math.PI,
          ) {
            super(),
              (this.type = "CylinderGeometry"),
              (this.parameters = {
                radiusTop: _,
                radiusBottom: L,
                height: R,
                radialSegments: N,
                heightSegments: z,
                openEnded: F,
                thetaStart: U,
                thetaLength: k,
              });
            let Y = this;
            (N = Math.floor(N)), (z = Math.floor(z));
            let X = [],
              Q = [],
              K = [],
              J = [],
              $ = 0,
              ee = [],
              er = R / 2,
              en = 0;
            function x(R) {
              let z = $,
                F = new iT(),
                ee = new iq(),
                ea = 0,
                eo = !0 === R ? _ : L,
                el = !0 === R ? 1 : -1;
              for (let _ = 1; _ <= N; _++)
                Q.push(0, er * el, 0), K.push(0, el, 0), J.push(0.5, 0.5), $++;
              let ec = $;
              for (let _ = 0; _ <= N; _++) {
                let L = (_ / N) * k + U,
                  R = Math.cos(L),
                  z = Math.sin(L);
                (ee.x = eo * z),
                  (ee.y = er * el),
                  (ee.z = eo * R),
                  Q.push(ee.x, ee.y, ee.z),
                  K.push(0, el, 0),
                  (F.x = 0.5 * R + 0.5),
                  (F.y = 0.5 * z * el + 0.5),
                  J.push(F.x, F.y),
                  $++;
              }
              for (let _ = 0; _ < N; _++) {
                let L = z + _,
                  N = ec + _;
                !0 === R ? X.push(N, N + 1, L) : X.push(N + 1, N, L), (ea += 3);
              }
              Y.addGroup(en, ea, !0 === R ? 1 : 2), (en += ea);
            }
            (function () {
              let F = new iq(),
                ea = new iq(),
                eo = 0,
                el = (L - _) / R;
              for (let Y = 0; Y <= z; Y++) {
                let X = [],
                  en = Y / z,
                  eo = en * (L - _) + _;
                for (let _ = 0; _ <= N; _++) {
                  let L = _ / N,
                    z = L * k + U,
                    Y = Math.sin(z),
                    ee = Math.cos(z);
                  (ea.x = eo * Y),
                    (ea.y = -en * R + er),
                    (ea.z = eo * ee),
                    Q.push(ea.x, ea.y, ea.z),
                    F.set(Y, el, ee).normalize(),
                    K.push(F.x, F.y, F.z),
                    J.push(L, 1 - en),
                    X.push($++);
                }
                ee.push(X);
              }
              for (let _ = 0; _ < N; _++)
                for (let L = 0; L < z; L++) {
                  let R = ee[L][_],
                    N = ee[L + 1][_],
                    z = ee[L + 1][_ + 1],
                    F = ee[L][_ + 1];
                  X.push(R, N, F), X.push(N, z, F), (eo += 6);
                }
              Y.addGroup(en, eo, 0), (en += eo);
            })(),
              !1 === F && (_ > 0 && x(!0), L > 0 && x(!1)),
              this.setIndex(X),
              this.setAttribute("position", new sv(Q, 3)),
              this.setAttribute("normal", new sv(K, 3)),
              this.setAttribute("uv", new sv(J, 2));
          }
          static fromJSON(_) {
            return new aF(
              _.radiusTop,
              _.radiusBottom,
              _.height,
              _.radialSegments,
              _.heightSegments,
              _.openEnded,
              _.thetaStart,
              _.thetaLength,
            );
          }
        },
        aU = class extends aF {
          constructor(
            _ = 1,
            L = 1,
            R = 32,
            N = 1,
            z = !1,
            F = 0,
            U = 2 * Math.PI,
          ) {
            super(0, _, L, R, N, z, F, U),
              (this.type = "ConeGeometry"),
              (this.parameters = {
                radius: _,
                height: L,
                radialSegments: R,
                heightSegments: N,
                openEnded: z,
                thetaStart: F,
                thetaLength: U,
              });
          }
          static fromJSON(_) {
            return new aU(
              _.radius,
              _.height,
              _.radialSegments,
              _.heightSegments,
              _.openEnded,
              _.thetaStart,
              _.thetaLength,
            );
          }
        },
        ak = class extends sP {
          constructor(_ = [], L = [], R = 1, N = 0) {
            super(),
              (this.type = "PolyhedronGeometry"),
              (this.parameters = {
                vertices: _,
                indices: L,
                radius: R,
                detail: N,
              });
            let z = [],
              F = [];
            function h(_) {
              z.push(_.x, _.y, _.z);
            }
            function f(L, R) {
              let N = 3 * L;
              (R.x = _[N + 0]), (R.y = _[N + 1]), (R.z = _[N + 2]);
            }
            function p(_, L, R, N) {
              N < 0 && 1 === _.x && (F[L] = _.x - 1),
                0 === R.x && 0 === R.z && (F[L] = N / 2 / Math.PI + 0.5);
            }
            function m(_) {
              return Math.atan2(_.z, -_.x);
            }
            (function (_) {
              let R = new iq(),
                N = new iq(),
                z = new iq();
              for (let F = 0; F < L.length; F += 3)
                f(L[F + 0], R),
                  f(L[F + 1], N),
                  f(L[F + 2], z),
                  (function (_, L, R, N) {
                    let z = N + 1,
                      F = [];
                    for (let N = 0; N <= z; N++) {
                      F[N] = [];
                      let U = _.clone().lerp(R, N / z),
                        k = L.clone().lerp(R, N / z),
                        Y = z - N;
                      for (let _ = 0; _ <= Y; _++)
                        0 === _ && N === z
                          ? (F[N][_] = U)
                          : (F[N][_] = U.clone().lerp(k, _ / Y));
                    }
                    for (let _ = 0; _ < z; _++)
                      for (let L = 0; L < 2 * (z - _) - 1; L++) {
                        let R = Math.floor(L / 2);
                        L % 2 == 0
                          ? (h(F[_][R + 1]), h(F[_ + 1][R]), h(F[_][R]))
                          : (h(F[_][R + 1]),
                            h(F[_ + 1][R + 1]),
                            h(F[_ + 1][R]));
                      }
                  })(R, N, z, _);
            })(N),
              (function (_) {
                let L = new iq();
                for (let R = 0; R < z.length; R += 3)
                  (L.x = z[R + 0]),
                    (L.y = z[R + 1]),
                    (L.z = z[R + 2]),
                    L.normalize().multiplyScalar(_),
                    (z[R + 0] = L.x),
                    (z[R + 1] = L.y),
                    (z[R + 2] = L.z);
              })(R),
              (function () {
                let _ = new iq();
                for (let L = 0; L < z.length; L += 3) {
                  (_.x = z[L + 0]), (_.y = z[L + 1]), (_.z = z[L + 2]);
                  let R = m(_) / 2 / Math.PI + 0.5,
                    N =
                      Math.atan2(-_.y, Math.sqrt(_.x * _.x + _.z * _.z)) /
                        Math.PI +
                      0.5;
                  F.push(R, 1 - N);
                }
                (function () {
                  let _ = new iq(),
                    L = new iq(),
                    R = new iq(),
                    N = new iq(),
                    U = new iT(),
                    k = new iT(),
                    Y = new iT();
                  for (let X = 0, Q = 0; X < z.length; X += 9, Q += 6) {
                    _.set(z[X + 0], z[X + 1], z[X + 2]),
                      L.set(z[X + 3], z[X + 4], z[X + 5]),
                      R.set(z[X + 6], z[X + 7], z[X + 8]),
                      U.set(F[Q + 0], F[Q + 1]),
                      k.set(F[Q + 2], F[Q + 3]),
                      Y.set(F[Q + 4], F[Q + 5]),
                      N.copy(_).add(L).add(R).divideScalar(3);
                    let K = m(N);
                    p(U, Q + 0, _, K), p(k, Q + 2, L, K), p(Y, Q + 4, R, K);
                  }
                })(),
                  (function () {
                    for (let _ = 0; _ < F.length; _ += 6) {
                      let L = F[_ + 0],
                        R = F[_ + 2],
                        N = F[_ + 4],
                        z = Math.max(L, R, N),
                        U = Math.min(L, R, N);
                      z > 0.9 &&
                        U < 0.1 &&
                        (L < 0.2 && (F[_ + 0] += 1),
                        R < 0.2 && (F[_ + 2] += 1),
                        N < 0.2 && (F[_ + 4] += 1));
                    }
                  })();
              })(),
              this.setAttribute("position", new sv(z, 3)),
              this.setAttribute("normal", new sv(z.slice(), 3)),
              this.setAttribute("uv", new sv(F, 2)),
              0 === N ? this.computeVertexNormals() : this.normalizeNormals();
          }
          static fromJSON(_) {
            return new ak(_.vertices, _.indices, _.radius, _.details);
          }
        },
        aj = class extends ak {
          constructor(_ = 1, L = 0) {
            let R = (1 + Math.sqrt(5)) / 2,
              N = 1 / R;
            super(
              [
                -1,
                -1,
                -1,
                -1,
                -1,
                1,
                -1,
                1,
                -1,
                -1,
                1,
                1,
                1,
                -1,
                -1,
                1,
                -1,
                1,
                1,
                1,
                -1,
                1,
                1,
                1,
                0,
                -N,
                -R,
                0,
                -N,
                R,
                0,
                N,
                -R,
                0,
                N,
                R,
                -N,
                -R,
                0,
                -N,
                R,
                0,
                N,
                -R,
                0,
                N,
                R,
                0,
                -R,
                0,
                -N,
                R,
                0,
                -N,
                -R,
                0,
                N,
                R,
                0,
                N,
              ],
              [
                3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15,
                17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0,
                12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2,
                16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4,
                14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19,
                5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9,
              ],
              _,
              L,
            ),
              (this.type = "DodecahedronGeometry"),
              (this.parameters = { radius: _, detail: L });
          }
          static fromJSON(_) {
            return new aj(_.radius, _.detail);
          }
        },
        aG = class extends aB {
          constructor(_) {
            super(_),
              (this.uuid = es()),
              (this.type = "Shape"),
              (this.holes = []);
          }
          getPointsHoles(_) {
            let L = [];
            for (let R = 0, N = this.holes.length; R < N; R++)
              L[R] = this.holes[R].getPoints(_);
            return L;
          }
          extractPoints(_) {
            return { shape: this.getPoints(_), holes: this.getPointsHoles(_) };
          }
          copy(_) {
            super.copy(_), (this.holes = []);
            for (let L = 0, R = _.holes.length; L < R; L++) {
              let R = _.holes[L];
              this.holes.push(R.clone());
            }
            return this;
          }
          toJSON() {
            let _ = super.toJSON();
            (_.uuid = this.uuid), (_.holes = []);
            for (let L = 0, R = this.holes.length; L < R; L++) {
              let R = this.holes[L];
              _.holes.push(R.toJSON());
            }
            return _;
          }
          fromJSON(_) {
            super.fromJSON(_), (this.uuid = _.uuid), (this.holes = []);
            for (let L = 0, R = _.holes.length; L < R; L++) {
              let R = _.holes[L];
              this.holes.push(new aB().fromJSON(R));
            }
            return this;
          }
        },
        aV = {
          triangulate: function (_, L, R = 2) {
            let N,
              z,
              F,
              U,
              k,
              Y,
              X,
              Q = L && L.length,
              K = Q ? L[0] * R : _.length,
              J = H1(_, 0, K, R, !0),
              $ = [];
            if (!J || J.next === J.prev) return $;
            if (
              (Q &&
                (J = (function (_, L, R, N) {
                  let z = [],
                    F,
                    U,
                    k,
                    Y,
                    X;
                  for (F = 0, U = L.length; F < U; F++)
                    (k = L[F] * N),
                      (Y = F < U - 1 ? L[F + 1] * N : _.length),
                      (X = H1(_, k, Y, N, !1)) === X.next && (X.steiner = !0),
                      z.push(
                        (function (_) {
                          let L = _,
                            R = _;
                          do
                            (L.x < R.x || (L.x === R.x && L.y < R.y)) &&
                              (R = L),
                              (L = L.next);
                          while (L !== _);
                          return R;
                        })(X),
                      );
                  for (z.sort(MN), F = 0; F < z.length; F++)
                    R = (function (_, L) {
                      let R = (function (_, L) {
                        let R = L,
                          N = -1 / 0,
                          z,
                          F = _.x,
                          U = _.y;
                        do {
                          if (U <= R.y && U >= R.next.y && R.next.y !== R.y) {
                            let _ =
                              R.x +
                              ((U - R.y) * (R.next.x - R.x)) / (R.next.y - R.y);
                            if (
                              _ <= F &&
                              _ > N &&
                              ((N = _),
                              (z = R.x < R.next.x ? R : R.next),
                              _ === F)
                            )
                              return z;
                          }
                          R = R.next;
                        } while (R !== L);
                        if (!z) return null;
                        let k = z,
                          Y = z.x,
                          X = z.y,
                          Q = 1 / 0,
                          K;
                        R = z;
                        do {
                          var J, $;
                          F >= R.x &&
                            R.x >= Y &&
                            F !== R.x &&
                            Rl(
                              U < X ? F : N,
                              U,
                              Y,
                              X,
                              U < X ? N : F,
                              U,
                              R.x,
                              R.y,
                            ) &&
                            ((K = Math.abs(U - R.y) / (F - R.x)),
                            Bd(R, _) &&
                              (K < Q ||
                                (K === Q &&
                                  (R.x > z.x ||
                                    (R.x === z.x &&
                                      ((J = z),
                                      ($ = R),
                                      0 > Qt(J.prev, J, $.prev) &&
                                        0 > Qt($.next, J, J.next)))))) &&
                              ((z = R), (Q = K))),
                            (R = R.next);
                        } while (R !== k);
                        return z;
                      })(_, L);
                      if (!R) return L;
                      let N = j1(R, _);
                      return Na(N, N.next), Na(R, R.next);
                    })(z[F], R);
                  return R;
                })(_, L, J, R)),
              _.length > 80 * R)
            ) {
              (N = F = _[0]), (z = U = _[1]);
              for (let L = R; L < K; L += R)
                (k = _[L]),
                  (Y = _[L + 1]),
                  k < N && (N = k),
                  Y < z && (z = Y),
                  k > F && (F = k),
                  Y > U && (U = Y);
              X = 0 !== (X = Math.max(F - N, U - z)) ? 32767 / X : 0;
            }
            return (
              (function Nd(_, L, R, N, z, F, U) {
                if (!_) return;
                !U &&
                  F &&
                  (function (_, L, R, N) {
                    let z = _;
                    do
                      0 === z.z && (z.z = Jv(z.x, z.y, L, R, N)),
                        (z.prevZ = z.prev),
                        (z.nextZ = z.next),
                        (z = z.next);
                    while (z !== _);
                    (z.prevZ.nextZ = null),
                      (z.prevZ = null),
                      (function (_) {
                        let L,
                          R,
                          N,
                          z,
                          F,
                          U,
                          k,
                          Y,
                          X = 1;
                        do {
                          for (R = _, _ = null, F = null, U = 0; R; ) {
                            for (
                              U++, N = R, k = 0, L = 0;
                              L < X && (k++, (N = N.nextZ));
                              L++
                            );
                            for (Y = X; k > 0 || (Y > 0 && N); )
                              0 !== k && (0 === Y || !N || R.z <= N.z)
                                ? ((z = R), (R = R.nextZ), k--)
                                : ((z = N), (N = N.nextZ), Y--),
                                F ? (F.nextZ = z) : (_ = z),
                                (z.prevZ = F),
                                (F = z);
                            R = N;
                          }
                          (F.nextZ = null), (X *= 2);
                        } while (U > 1);
                      })(z);
                  })(_, N, z, F);
                let k = _,
                  Y,
                  X;
                for (; _.prev !== _.next; ) {
                  if (
                    ((Y = _.prev),
                    (X = _.next),
                    F
                      ? (function (_, L, R, N) {
                          let z = _.prev,
                            F = _.next;
                          if (Qt(z, _, F) >= 0) return !1;
                          let U = z.x,
                            k = _.x,
                            Y = F.x,
                            X = z.y,
                            Q = _.y,
                            K = F.y,
                            J = U < k ? (U < Y ? U : Y) : k < Y ? k : Y,
                            $ = X < Q ? (X < K ? X : K) : Q < K ? Q : K,
                            ee = U > k ? (U > Y ? U : Y) : k > Y ? k : Y,
                            er = X > Q ? (X > K ? X : K) : Q > K ? Q : K,
                            en = Jv(J, $, L, R, N),
                            ea = Jv(ee, er, L, R, N),
                            eo = _.prevZ,
                            el = _.nextZ;
                          for (; eo && eo.z >= en && el && el.z <= ea; ) {
                            if (
                              (eo.x >= J &&
                                eo.x <= ee &&
                                eo.y >= $ &&
                                eo.y <= er &&
                                eo !== z &&
                                eo !== F &&
                                Rl(U, X, k, Q, Y, K, eo.x, eo.y) &&
                                Qt(eo.prev, eo, eo.next) >= 0) ||
                              ((eo = eo.prevZ),
                              el.x >= J &&
                                el.x <= ee &&
                                el.y >= $ &&
                                el.y <= er &&
                                el !== z &&
                                el !== F &&
                                Rl(U, X, k, Q, Y, K, el.x, el.y) &&
                                Qt(el.prev, el, el.next) >= 0)
                            )
                              return !1;
                            el = el.nextZ;
                          }
                          for (; eo && eo.z >= en; ) {
                            if (
                              eo.x >= J &&
                              eo.x <= ee &&
                              eo.y >= $ &&
                              eo.y <= er &&
                              eo !== z &&
                              eo !== F &&
                              Rl(U, X, k, Q, Y, K, eo.x, eo.y) &&
                              Qt(eo.prev, eo, eo.next) >= 0
                            )
                              return !1;
                            eo = eo.prevZ;
                          }
                          for (; el && el.z <= ea; ) {
                            if (
                              el.x >= J &&
                              el.x <= ee &&
                              el.y >= $ &&
                              el.y <= er &&
                              el !== z &&
                              el !== F &&
                              Rl(U, X, k, Q, Y, K, el.x, el.y) &&
                              Qt(el.prev, el, el.next) >= 0
                            )
                              return !1;
                            el = el.nextZ;
                          }
                          return !0;
                        })(_, N, z, F)
                      : (function (_) {
                          let L = _.prev,
                            R = _.next;
                          if (Qt(L, _, R) >= 0) return !1;
                          let N = L.x,
                            z = _.x,
                            F = R.x,
                            U = L.y,
                            k = _.y,
                            Y = R.y,
                            X = N < z ? (N < F ? N : F) : z < F ? z : F,
                            Q = U < k ? (U < Y ? U : Y) : k < Y ? k : Y,
                            K = N > z ? (N > F ? N : F) : z > F ? z : F,
                            J = U > k ? (U > Y ? U : Y) : k > Y ? k : Y,
                            $ = R.next;
                          for (; $ !== L; ) {
                            if (
                              $.x >= X &&
                              $.x <= K &&
                              $.y >= Q &&
                              $.y <= J &&
                              Rl(N, U, z, k, F, Y, $.x, $.y) &&
                              Qt($.prev, $, $.next) >= 0
                            )
                              return !1;
                            $ = $.next;
                          }
                          return !0;
                        })(_))
                  ) {
                    L.push((Y.i / R) | 0),
                      L.push((_.i / R) | 0),
                      L.push((X.i / R) | 0),
                      Fd(_),
                      (_ = X.next),
                      (k = X.next);
                    continue;
                  }
                  if ((_ = X) === k) {
                    U
                      ? 1 === U
                        ? Nd(
                            (_ = (function (_, L, R) {
                              let N = _;
                              do {
                                let z = N.prev,
                                  F = N.next.next;
                                !Ip(z, F) &&
                                  W1(z, N, N.next, F) &&
                                  Bd(z, F) &&
                                  Bd(F, z) &&
                                  (L.push((z.i / R) | 0),
                                  L.push((N.i / R) | 0),
                                  L.push((F.i / R) | 0),
                                  Fd(N),
                                  Fd(N.next),
                                  (N = _ = F)),
                                  (N = N.next);
                              } while (N !== _);
                              return Na(N);
                            })(Na(_), L, R)),
                            L,
                            R,
                            N,
                            z,
                            F,
                            2,
                          )
                        : 2 === U &&
                          (function (_, L, R, N, z, F) {
                            let U = _;
                            do {
                              let _ = U.next.next;
                              for (; _ !== U.prev; ) {
                                var k, Y;
                                if (
                                  U.i !== _.i &&
                                  ((k = U),
                                  (Y = _),
                                  k.next.i !== Y.i &&
                                    k.prev.i !== Y.i &&
                                    !(function (_, L) {
                                      let R = _;
                                      do {
                                        if (
                                          R.i !== _.i &&
                                          R.next.i !== _.i &&
                                          R.i !== L.i &&
                                          R.next.i !== L.i &&
                                          W1(R, R.next, _, L)
                                        )
                                          return !0;
                                        R = R.next;
                                      } while (R !== _);
                                      return !1;
                                    })(k, Y) &&
                                    ((Bd(k, Y) &&
                                      Bd(Y, k) &&
                                      (function (_, L) {
                                        let R = _,
                                          N = !1,
                                          z = (_.x + L.x) / 2,
                                          F = (_.y + L.y) / 2;
                                        do
                                          R.y > F != R.next.y > F &&
                                            R.next.y !== R.y &&
                                            z <
                                              ((R.next.x - R.x) * (F - R.y)) /
                                                (R.next.y - R.y) +
                                                R.x &&
                                            (N = !N),
                                            (R = R.next);
                                        while (R !== _);
                                        return N;
                                      })(k, Y) &&
                                      (Qt(k.prev, k, Y.prev) ||
                                        Qt(k, Y.prev, Y))) ||
                                      (Ip(k, Y) &&
                                        Qt(k.prev, k, k.next) > 0 &&
                                        Qt(Y.prev, Y, Y.next) > 0)))
                                ) {
                                  let k = j1(U, _);
                                  (U = Na(U, U.next)),
                                    (k = Na(k, k.next)),
                                    Nd(U, L, R, N, z, F, 0),
                                    Nd(k, L, R, N, z, F, 0);
                                  return;
                                }
                                _ = _.next;
                              }
                              U = U.next;
                            } while (U !== _);
                          })(_, L, R, N, z, F)
                      : Nd(Na(_), L, R, N, z, F, 1);
                    break;
                  }
                }
              })(J, $, R, N, z, X, 0),
              $
            );
          },
        };
      function H1(_, L, R, N, z) {
        let F, U;
        if (
          z ===
          (function (_, L, R, N) {
            let z = 0;
            for (let F = L, U = R - N; F < R; F += N)
              (z += (_[U] - _[F]) * (_[F + 1] + _[U + 1])), (U = F);
            return z;
          })(_, L, R, N) >
            0
        )
          for (F = L; F < R; F += N) U = g1(F, _[F], _[F + 1], U);
        else for (F = R - N; F >= L; F -= N) U = g1(F, _[F], _[F + 1], U);
        return U && Ip(U, U.next) && (Fd(U), (U = U.next)), U;
      }
      function Na(_, L) {
        if (!_) return _;
        L || (L = _);
        let R = _,
          N;
        do
          if (
            ((N = !1),
            !R.steiner && (Ip(R, R.next) || 0 === Qt(R.prev, R, R.next)))
          ) {
            if ((Fd(R), (R = L = R.prev) === R.next)) break;
            N = !0;
          } else R = R.next;
        while (N || R !== L);
        return L;
      }
      function MN(_, L) {
        return _.x - L.x;
      }
      function Jv(_, L, R, N, z) {
        return (
          (_ =
            ((_ =
              ((_ =
                ((_ = ((_ = ((_ - R) * z) | 0) | (_ << 8)) & 16711935) |
                  (_ << 4)) &
                252645135) |
                (_ << 2)) &
              858993459) |
              (_ << 1)) &
            1431655765) |
          ((L =
            ((L =
              ((L =
                ((L = ((L = ((L - N) * z) | 0) | (L << 8)) & 16711935) |
                  (L << 4)) &
                252645135) |
                (L << 2)) &
              858993459) |
              (L << 1)) &
            1431655765) <<
            1)
        );
      }
      function Rl(_, L, R, N, z, F, U, k) {
        return (
          (z - U) * (L - k) >= (_ - U) * (F - k) &&
          (_ - U) * (N - k) >= (R - U) * (L - k) &&
          (R - U) * (F - k) >= (z - U) * (N - k)
        );
      }
      function Qt(_, L, R) {
        return (L.y - _.y) * (R.x - L.x) - (L.x - _.x) * (R.y - L.y);
      }
      function Ip(_, L) {
        return _.x === L.x && _.y === L.y;
      }
      function W1(_, L, R, N) {
        let z = Jf(Qt(_, L, R)),
          F = Jf(Qt(_, L, N)),
          U = Jf(Qt(R, N, _)),
          k = Jf(Qt(R, N, L));
        return !!(
          (z !== F && U !== k) ||
          (0 === z && Qf(_, R, L)) ||
          (0 === F && Qf(_, N, L)) ||
          (0 === U && Qf(R, _, N)) ||
          (0 === k && Qf(R, L, N))
        );
      }
      function Qf(_, L, R) {
        return (
          L.x <= Math.max(_.x, R.x) &&
          L.x >= Math.min(_.x, R.x) &&
          L.y <= Math.max(_.y, R.y) &&
          L.y >= Math.min(_.y, R.y)
        );
      }
      function Jf(_) {
        return _ > 0 ? 1 : _ < 0 ? -1 : 0;
      }
      function Bd(_, L) {
        return 0 > Qt(_.prev, _, _.next)
          ? Qt(_, L, _.next) >= 0 && Qt(_, _.prev, L) >= 0
          : 0 > Qt(_, L, _.prev) || 0 > Qt(_, _.next, L);
      }
      function j1(_, L) {
        let R = new $v(_.i, _.x, _.y),
          N = new $v(L.i, L.x, L.y),
          z = _.next,
          F = L.prev;
        return (
          (_.next = L),
          (L.prev = _),
          (R.next = z),
          (z.prev = R),
          (N.next = R),
          (R.prev = N),
          (F.next = N),
          (N.prev = F),
          N
        );
      }
      function g1(_, L, R, N) {
        let z = new $v(_, L, R);
        return (
          N
            ? ((z.next = N.next), (z.prev = N), (N.next.prev = z), (N.next = z))
            : ((z.prev = z), (z.next = z)),
          z
        );
      }
      function Fd(_) {
        (_.next.prev = _.prev),
          (_.prev.next = _.next),
          _.prevZ && (_.prevZ.nextZ = _.nextZ),
          _.nextZ && (_.nextZ.prevZ = _.prevZ);
      }
      function $v(_, L, R) {
        (this.i = _),
          (this.x = L),
          (this.y = R),
          (this.prev = null),
          (this.next = null),
          (this.z = 0),
          (this.prevZ = null),
          (this.nextZ = null),
          (this.steiner = !1);
      }
      var aH = class {
        static area(_) {
          let L = _.length,
            R = 0;
          for (let N = L - 1, z = 0; z < L; N = z++)
            R += _[N].x * _[z].y - _[z].x * _[N].y;
          return 0.5 * R;
        }
        static isClockWise(_) {
          return 0 > aH.area(_);
        }
        static triangulateShape(_, L) {
          let R = [],
            N = [],
            z = [];
          y1(_), v1(R, _);
          let F = _.length;
          L.forEach(y1);
          for (let _ = 0; _ < L.length; _++)
            N.push(F), (F += L[_].length), v1(R, L[_]);
          let U = aV.triangulate(R, N);
          for (let _ = 0; _ < U.length; _ += 3) z.push(U.slice(_, _ + 3));
          return z;
        }
      };
      function y1(_) {
        let L = _.length;
        L > 2 && _[L - 1].equals(_[0]) && _.pop();
      }
      function v1(_, L) {
        for (let R = 0; R < L.length; R++) _.push(L[R].x), _.push(L[R].y);
      }
      var aW = class extends ak {
          constructor(_ = 1, L = 0) {
            let R = (1 + Math.sqrt(5)) / 2;
            super(
              [
                -1,
                R,
                0,
                1,
                R,
                0,
                -1,
                -R,
                0,
                1,
                -R,
                0,
                0,
                -1,
                R,
                0,
                1,
                R,
                0,
                -1,
                -R,
                0,
                1,
                -R,
                R,
                0,
                -1,
                R,
                0,
                1,
                -R,
                0,
                -1,
                -R,
                0,
                1,
              ],
              [
                0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11,
                4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3,
                6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1,
              ],
              _,
              L,
            ),
              (this.type = "IcosahedronGeometry"),
              (this.parameters = { radius: _, detail: L });
          }
          static fromJSON(_) {
            return new aW(_.radius, _.detail);
          }
        },
        aY = class extends sP {
          constructor(
            _ = 1,
            L = 32,
            R = 16,
            N = 0,
            z = 2 * Math.PI,
            F = 0,
            U = Math.PI,
          ) {
            super(),
              (this.type = "SphereGeometry"),
              (this.parameters = {
                radius: _,
                widthSegments: L,
                heightSegments: R,
                phiStart: N,
                phiLength: z,
                thetaStart: F,
                thetaLength: U,
              }),
              (L = Math.max(3, Math.floor(L))),
              (R = Math.max(2, Math.floor(R)));
            let k = Math.min(F + U, Math.PI),
              Y = 0,
              X = [],
              Q = new iq(),
              K = new iq(),
              J = [],
              $ = [],
              ee = [],
              er = [];
            for (let J = 0; J <= R; J++) {
              let en = [],
                ea = J / R,
                eo = 0;
              0 == J && 0 == F
                ? (eo = 0.5 / L)
                : J == R && k == Math.PI && (eo = -0.5 / L);
              for (let R = 0; R <= L; R++) {
                let k = R / L;
                (Q.x = -_ * Math.cos(N + k * z) * Math.sin(F + ea * U)),
                  (Q.y = _ * Math.cos(F + ea * U)),
                  (Q.z = _ * Math.sin(N + k * z) * Math.sin(F + ea * U)),
                  $.push(Q.x, Q.y, Q.z),
                  K.copy(Q).normalize(),
                  ee.push(K.x, K.y, K.z),
                  er.push(k + eo, 1 - ea),
                  en.push(Y++);
              }
              X.push(en);
            }
            for (let _ = 0; _ < R; _++)
              for (let N = 0; N < L; N++) {
                let L = X[_][N + 1],
                  z = X[_][N],
                  U = X[_ + 1][N],
                  Y = X[_ + 1][N + 1];
                (0 !== _ || F > 0) && J.push(L, z, Y),
                  (_ !== R - 1 || k < Math.PI) && J.push(z, U, Y);
              }
            this.setIndex(J),
              this.setAttribute("position", new sv($, 3)),
              this.setAttribute("normal", new sv(ee, 3)),
              this.setAttribute("uv", new sv(er, 2));
          }
          static fromJSON(_) {
            return new aY(
              _.radius,
              _.widthSegments,
              _.heightSegments,
              _.phiStart,
              _.phiLength,
              _.thetaStart,
              _.thetaLength,
            );
          }
        },
        aX = class extends sP {
          constructor(_ = 1, L = 0.4, R = 64, N = 8, z = 2, F = 3) {
            super(),
              (this.type = "TorusKnotGeometry"),
              (this.parameters = {
                radius: _,
                tube: L,
                tubularSegments: R,
                radialSegments: N,
                p: z,
                q: F,
              }),
              (R = Math.floor(R)),
              (N = Math.floor(N));
            let U = [],
              k = [],
              Y = [],
              X = [],
              Q = new iq(),
              K = new iq(),
              J = new iq(),
              $ = new iq(),
              ee = new iq(),
              er = new iq(),
              en = new iq();
            for (let U = 0; U <= R; ++U) {
              let ea = (U / R) * z * Math.PI * 2;
              v(ea, z, F, _, J),
                v(ea + 0.01, z, F, _, $),
                er.subVectors($, J),
                en.addVectors($, J),
                ee.crossVectors(er, en),
                en.crossVectors(ee, er),
                ee.normalize(),
                en.normalize();
              for (let _ = 0; _ <= N; ++_) {
                let z = (_ / N) * Math.PI * 2,
                  F = -L * Math.cos(z),
                  $ = L * Math.sin(z);
                (Q.x = J.x + (F * en.x + $ * ee.x)),
                  (Q.y = J.y + (F * en.y + $ * ee.y)),
                  (Q.z = J.z + (F * en.z + $ * ee.z)),
                  k.push(Q.x, Q.y, Q.z),
                  K.subVectors(Q, J).normalize(),
                  Y.push(K.x, K.y, K.z),
                  X.push(U / R),
                  X.push(_ / N);
              }
            }
            for (let _ = 1; _ <= R; _++)
              for (let L = 1; L <= N; L++) {
                let R = (N + 1) * (_ - 1) + (L - 1),
                  z = (N + 1) * _ + (L - 1),
                  F = (N + 1) * _ + L,
                  k = (N + 1) * (_ - 1) + L;
                U.push(R, z, k), U.push(z, F, k);
              }
            function v(_, L, R, N, z) {
              let F = Math.cos(_),
                U = Math.sin(_),
                k = (R / L) * _,
                Y = Math.cos(k);
              (z.x = N * (2 + Y) * 0.5 * F),
                (z.y = N * (2 + Y) * U * 0.5),
                (z.z = N * Math.sin(k) * 0.5);
            }
            this.setIndex(U),
              this.setAttribute("position", new sv(k, 3)),
              this.setAttribute("normal", new sv(Y, 3)),
              this.setAttribute("uv", new sv(X, 2));
          }
          static fromJSON(_) {
            return new aX(
              _.radius,
              _.tube,
              _.tubularSegments,
              _.radialSegments,
              _.p,
              _.q,
            );
          }
        };
      function wo(_, L, R) {
        return q1(_)
          ? new _.constructor(_.subarray(L, void 0 !== R ? R : _.length))
          : _.slice(L, R);
      }
      function $f(_, L, R) {
        return _ && (R || _.constructor !== L)
          ? "number" == typeof L.BYTES_PER_ELEMENT
            ? new L(_)
            : Array.prototype.slice.call(_)
          : _;
      }
      function q1(_) {
        return ArrayBuffer.isView(_) && !(_ instanceof DataView);
      }
      var aq = class {
          constructor(_, L, R, N) {
            (this.parameterPositions = _),
              (this._cachedIndex = 0),
              (this.resultBuffer = void 0 !== N ? N : new L.constructor(R)),
              (this.sampleValues = L),
              (this.valueSize = R),
              (this.settings = null),
              (this.DefaultSettings_ = {});
          }
          evaluate(_) {
            let L = this.parameterPositions,
              R = this._cachedIndex,
              N = L[R],
              z = L[R - 1];
            e: {
              t: {
                let F;
                i: {
                  r: if (!(_ < N)) {
                    for (let F = R + 2; ; ) {
                      if (void 0 === N) {
                        if (_ < z) break r;
                        return (
                          (R = L.length),
                          (this._cachedIndex = R),
                          this.copySampleValue_(R - 1)
                        );
                      }
                      if (R === F) break;
                      if (((z = N), _ < (N = L[++R]))) break t;
                    }
                    F = L.length;
                    break i;
                  }
                  if (!(_ >= z)) {
                    let U = L[1];
                    _ < U && ((R = 2), (z = U));
                    for (let F = R - 2; ; ) {
                      if (void 0 === z)
                        return (
                          (this._cachedIndex = 0), this.copySampleValue_(0)
                        );
                      if (R === F) break;
                      if (((N = z), _ >= (z = L[--R - 1]))) break t;
                    }
                    (F = R), (R = 0);
                    break i;
                  }
                  break e;
                }
                for (; R < F; ) {
                  let N = (R + F) >>> 1;
                  _ < L[N] ? (F = N) : (R = N + 1);
                }
                if (((N = L[R]), void 0 === (z = L[R - 1])))
                  return (this._cachedIndex = 0), this.copySampleValue_(0);
                if (void 0 === N)
                  return (
                    (R = L.length),
                    (this._cachedIndex = R),
                    this.copySampleValue_(R - 1)
                  );
              }
              (this._cachedIndex = R), this.intervalChanged_(R, z, N);
            }
            return this.interpolate_(R, z, _, N);
          }
          getSettings_() {
            return this.settings || this.DefaultSettings_;
          }
          copySampleValue_(_) {
            let L = this.resultBuffer,
              R = this.sampleValues,
              N = this.valueSize,
              z = _ * N;
            for (let _ = 0; _ !== N; ++_) L[_] = R[z + _];
            return L;
          }
          interpolate_() {
            throw Error("call to abstract method");
          }
          intervalChanged_() {}
        },
        aQ = class extends aq {
          constructor(_, L, R, N) {
            super(_, L, R, N),
              (this._weightPrev = -0),
              (this._offsetPrev = -0),
              (this._weightNext = -0),
              (this._offsetNext = -0),
              (this.DefaultSettings_ = { endingStart: 2400, endingEnd: 2400 });
          }
          intervalChanged_(_, L, R) {
            let N = this.parameterPositions,
              z = _ - 2,
              F = _ + 1,
              U = N[z],
              k = N[F];
            if (void 0 === U)
              switch (this.getSettings_().endingStart) {
                case 2401:
                  (z = _), (U = 2 * L - R);
                  break;
                case 2402:
                  (z = N.length - 2), (U = L + N[z] - N[z + 1]);
                  break;
                default:
                  (z = _), (U = R);
              }
            if (void 0 === k)
              switch (this.getSettings_().endingEnd) {
                case 2401:
                  (F = _), (k = 2 * R - L);
                  break;
                case 2402:
                  (F = 1), (k = R + N[1] - N[0]);
                  break;
                default:
                  (F = _ - 1), (k = L);
              }
            let Y = (R - L) * 0.5,
              X = this.valueSize;
            (this._weightPrev = Y / (L - U)),
              (this._weightNext = Y / (k - R)),
              (this._offsetPrev = z * X),
              (this._offsetNext = F * X);
          }
          interpolate_(_, L, R, N) {
            let z = this.resultBuffer,
              F = this.sampleValues,
              U = this.valueSize,
              k = _ * U,
              Y = k - U,
              X = this._offsetPrev,
              Q = this._offsetNext,
              K = this._weightPrev,
              J = this._weightNext,
              $ = (R - L) / (N - L),
              ee = $ * $,
              er = ee * $,
              en = -K * er + 2 * K * ee - K * $,
              ea = (1 + K) * er + (-1.5 - 2 * K) * ee + (-0.5 + K) * $ + 1,
              eo = (-1 - J) * er + (1.5 + J) * ee + 0.5 * $,
              el = J * er - J * ee;
            for (let _ = 0; _ !== U; ++_)
              z[_] =
                en * F[X + _] + ea * F[Y + _] + eo * F[k + _] + el * F[Q + _];
            return z;
          }
        },
        aZ = class extends aq {
          constructor(_, L, R, N) {
            super(_, L, R, N);
          }
          interpolate_(_, L, R, N) {
            let z = this.resultBuffer,
              F = this.sampleValues,
              U = this.valueSize,
              k = _ * U,
              Y = k - U,
              X = (R - L) / (N - L),
              Q = 1 - X;
            for (let _ = 0; _ !== U; ++_) z[_] = F[Y + _] * Q + F[k + _] * X;
            return z;
          }
        },
        aK = class extends aq {
          constructor(_, L, R, N) {
            super(_, L, R, N);
          }
          interpolate_(_) {
            return this.copySampleValue_(_ - 1);
          }
        },
        aJ = class {
          constructor(_, L, R, N) {
            if (void 0 === _)
              throw Error("THREE.KeyframeTrack: track name is undefined");
            if (void 0 === L || 0 === L.length)
              throw Error(
                "THREE.KeyframeTrack: no keyframes in track named " + _,
              );
            (this.name = _),
              (this.times = $f(L, this.TimeBufferType)),
              (this.values = $f(R, this.ValueBufferType)),
              this.setInterpolation(N || this.DefaultInterpolation);
          }
          static toJSON(_) {
            let L = _.constructor,
              R;
            if (L.toJSON !== this.toJSON) R = L.toJSON(_);
            else {
              R = {
                name: _.name,
                times: $f(_.times, Array),
                values: $f(_.values, Array),
              };
              let L = _.getInterpolation();
              L !== _.DefaultInterpolation && (R.interpolation = L);
            }
            return (R.type = _.ValueTypeName), R;
          }
          InterpolantFactoryMethodDiscrete(_) {
            return new aK(this.times, this.values, this.getValueSize(), _);
          }
          InterpolantFactoryMethodLinear(_) {
            return new aZ(this.times, this.values, this.getValueSize(), _);
          }
          InterpolantFactoryMethodSmooth(_) {
            return new aQ(this.times, this.values, this.getValueSize(), _);
          }
          setInterpolation(_) {
            let L;
            switch (_) {
              case 2300:
                L = this.InterpolantFactoryMethodDiscrete;
                break;
              case 2301:
                L = this.InterpolantFactoryMethodLinear;
                break;
              case 2302:
                L = this.InterpolantFactoryMethodSmooth;
            }
            if (void 0 === L) {
              let L =
                "unsupported interpolation for " +
                this.ValueTypeName +
                " keyframe track named " +
                this.name;
              if (void 0 === this.createInterpolant) {
                if (_ !== this.DefaultInterpolation)
                  this.setInterpolation(this.DefaultInterpolation);
                else throw Error(L);
              }
              return console.warn("THREE.KeyframeTrack:", L), this;
            }
            return (this.createInterpolant = L), this;
          }
          getInterpolation() {
            switch (this.createInterpolant) {
              case this.InterpolantFactoryMethodDiscrete:
                return 2300;
              case this.InterpolantFactoryMethodLinear:
                return 2301;
              case this.InterpolantFactoryMethodSmooth:
                return 2302;
            }
          }
          getValueSize() {
            return this.values.length / this.times.length;
          }
          shift(_) {
            if (0 !== _) {
              let L = this.times;
              for (let R = 0, N = L.length; R !== N; ++R) L[R] += _;
            }
            return this;
          }
          scale(_) {
            if (1 !== _) {
              let L = this.times;
              for (let R = 0, N = L.length; R !== N; ++R) L[R] *= _;
            }
            return this;
          }
          trim(_, L) {
            let R = this.times,
              N = R.length,
              z = 0,
              F = N - 1;
            for (; z !== N && R[z] < _; ) ++z;
            for (; -1 !== F && R[F] > L; ) --F;
            if ((++F, 0 !== z || F !== N)) {
              z >= F && (z = (F = Math.max(F, 1)) - 1);
              let _ = this.getValueSize();
              (this.times = wo(R, z, F)),
                (this.values = wo(this.values, z * _, F * _));
            }
            return this;
          }
          validate() {
            let _ = !0,
              L = this.getValueSize();
            L - Math.floor(L) != 0 &&
              (console.error(
                "THREE.KeyframeTrack: Invalid value size in track.",
                this,
              ),
              (_ = !1));
            let R = this.times,
              N = this.values,
              z = R.length;
            0 === z &&
              (console.error("THREE.KeyframeTrack: Track is empty.", this),
              (_ = !1));
            let F = null;
            for (let L = 0; L !== z; L++) {
              let N = R[L];
              if ("number" == typeof N && isNaN(N)) {
                console.error(
                  "THREE.KeyframeTrack: Time is not a valid number.",
                  this,
                  L,
                  N,
                ),
                  (_ = !1);
                break;
              }
              if (null !== F && F > N) {
                console.error(
                  "THREE.KeyframeTrack: Out of order keys.",
                  this,
                  L,
                  N,
                  F,
                ),
                  (_ = !1);
                break;
              }
              F = N;
            }
            if (void 0 !== N && q1(N))
              for (let L = 0, R = N.length; L !== R; ++L) {
                let R = N[L];
                if (isNaN(R)) {
                  console.error(
                    "THREE.KeyframeTrack: Value is not a valid number.",
                    this,
                    L,
                    R,
                  ),
                    (_ = !1);
                  break;
                }
              }
            return _;
          }
          optimize() {
            let _ = wo(this.times),
              L = wo(this.values),
              R = this.getValueSize(),
              N = 2302 === this.getInterpolation(),
              z = _.length - 1,
              F = 1;
            for (let U = 1; U < z; ++U) {
              let z = !1,
                k = _[U];
              if (k !== _[U + 1] && (1 !== U || k !== _[0])) {
                if (N) z = !0;
                else {
                  let _ = U * R,
                    N = _ - R,
                    F = _ + R;
                  for (let U = 0; U !== R; ++U) {
                    let R = L[_ + U];
                    if (R !== L[N + U] || R !== L[F + U]) {
                      z = !0;
                      break;
                    }
                  }
                }
              }
              if (z) {
                if (U !== F) {
                  _[F] = _[U];
                  let N = U * R,
                    z = F * R;
                  for (let _ = 0; _ !== R; ++_) L[z + _] = L[N + _];
                }
                ++F;
              }
            }
            if (z > 0) {
              _[F] = _[z];
              for (let _ = z * R, N = F * R, U = 0; U !== R; ++U)
                L[N + U] = L[_ + U];
              ++F;
            }
            return (
              F !== _.length
                ? ((this.times = wo(_, 0, F)), (this.values = wo(L, 0, F * R)))
                : ((this.times = _), (this.values = L)),
              this
            );
          }
          clone() {
            let _ = wo(this.times, 0),
              L = wo(this.values, 0),
              R = new this.constructor(this.name, _, L);
            return (R.createInterpolant = this.createInterpolant), R;
          }
        };
      (aJ.prototype.TimeBufferType = Float32Array),
        (aJ.prototype.ValueBufferType = Float32Array),
        (aJ.prototype.DefaultInterpolation = 2301);
      var a$ = class extends aJ {};
      (a$.prototype.ValueTypeName = "bool"),
        (a$.prototype.ValueBufferType = Array),
        (a$.prototype.DefaultInterpolation = 2300),
        (a$.prototype.InterpolantFactoryMethodLinear = void 0),
        (a$.prototype.InterpolantFactoryMethodSmooth = void 0),
        (class extends aJ {}.prototype.ValueTypeName = "color"),
        (class extends aJ {}.prototype.ValueTypeName = "number");
      var a0 = class extends aq {
          constructor(_, L, R, N) {
            super(_, L, R, N);
          }
          interpolate_(_, L, R, N) {
            let z = this.resultBuffer,
              F = this.sampleValues,
              U = this.valueSize,
              k = (R - L) / (N - L),
              Y = _ * U;
            for (let _ = Y + U; Y !== _; Y += 4)
              iX.slerpFlat(z, 0, F, Y - U, F, Y, k);
            return z;
          }
        },
        a2 = class extends aJ {
          InterpolantFactoryMethodLinear(_) {
            return new a0(this.times, this.values, this.getValueSize(), _);
          }
        };
      (a2.prototype.ValueTypeName = "quaternion"),
        (a2.prototype.DefaultInterpolation = 2301),
        (a2.prototype.InterpolantFactoryMethodSmooth = void 0);
      var a4 = class extends aJ {};
      (a4.prototype.ValueTypeName = "string"),
        (a4.prototype.ValueBufferType = Array),
        (a4.prototype.DefaultInterpolation = 2300),
        (a4.prototype.InterpolantFactoryMethodLinear = void 0),
        (a4.prototype.InterpolantFactoryMethodSmooth = void 0),
        (class extends aJ {}.prototype.ValueTypeName = "vector");
      var a5 = {
          enabled: !1,
          files: {},
          add: function (_, L) {
            !1 !== this.enabled && (this.files[_] = L);
          },
          get: function (_) {
            if (!1 !== this.enabled) return this.files[_];
          },
          remove: function (_) {
            delete this.files[_];
          },
          clear: function () {
            this.files = {};
          },
        },
        a6 = class {
          constructor(_, L, R) {
            let N = this,
              z = !1,
              F = 0,
              U = 0,
              k,
              Y = [];
            (this.onStart = void 0),
              (this.onLoad = _),
              (this.onProgress = L),
              (this.onError = R),
              (this.itemStart = function (_) {
                U++,
                  !1 === z && void 0 !== N.onStart && N.onStart(_, F, U),
                  (z = !0);
              }),
              (this.itemEnd = function (_) {
                F++,
                  void 0 !== N.onProgress && N.onProgress(_, F, U),
                  F === U && ((z = !1), void 0 !== N.onLoad && N.onLoad());
              }),
              (this.itemError = function (_) {
                void 0 !== N.onError && N.onError(_);
              }),
              (this.resolveURL = function (_) {
                return k ? k(_) : _;
              }),
              (this.setURLModifier = function (_) {
                return (k = _), this;
              }),
              (this.addHandler = function (_, L) {
                return Y.push(_, L), this;
              }),
              (this.removeHandler = function (_) {
                let L = Y.indexOf(_);
                return -1 !== L && Y.splice(L, 2), this;
              }),
              (this.getHandler = function (_) {
                for (let L = 0, R = Y.length; L < R; L += 2) {
                  let R = Y[L],
                    N = Y[L + 1];
                  if ((R.global && (R.lastIndex = 0), R.test(_))) return N;
                }
                return null;
              });
          }
        },
        a8 = new a6(),
        a9 = class {
          constructor(_) {
            (this.manager = void 0 !== _ ? _ : a8),
              (this.crossOrigin = "anonymous"),
              (this.withCredentials = !1),
              (this.path = ""),
              (this.resourcePath = ""),
              (this.requestHeader = {});
          }
          load() {}
          loadAsync(_, L) {
            let R = this;
            return new Promise(function (N, z) {
              R.load(_, N, L, z);
            });
          }
          parse() {}
          setCrossOrigin(_) {
            return (this.crossOrigin = _), this;
          }
          setWithCredentials(_) {
            return (this.withCredentials = _), this;
          }
          setPath(_) {
            return (this.path = _), this;
          }
          setResourcePath(_) {
            return (this.resourcePath = _), this;
          }
          setRequestHeader(_) {
            return (this.requestHeader = _), this;
          }
        },
        a7 = {},
        ot = class extends Error {
          constructor(_, L) {
            super(_), (this.response = L);
          }
        },
        oi = class extends a9 {
          constructor(_) {
            super(_);
          }
          load(_, L, R, N) {
            void 0 === _ && (_ = ""),
              void 0 !== this.path && (_ = this.path + _),
              (_ = this.manager.resolveURL(_));
            let z = a5.get(_);
            if (void 0 !== z)
              return (
                this.manager.itemStart(_),
                setTimeout(() => {
                  L && L(z), this.manager.itemEnd(_);
                }, 0),
                z
              );
            if (void 0 !== a7[_]) {
              a7[_].push({ onLoad: L, onProgress: R, onError: N });
              return;
            }
            (a7[_] = []), a7[_].push({ onLoad: L, onProgress: R, onError: N });
            let F = new Request(_, {
                headers: new Headers(this.requestHeader),
                credentials: this.withCredentials ? "include" : "same-origin",
              }),
              U = this.mimeType,
              k = this.responseType;
            fetch(F)
              .then((L) => {
                if (200 === L.status || 0 === L.status) {
                  if (
                    (0 === L.status &&
                      console.warn("THREE.FileLoader: HTTP Status 0 received."),
                    typeof ReadableStream > "u" ||
                      void 0 === L.body ||
                      void 0 === L.body.getReader)
                  )
                    return L;
                  let R = a7[_],
                    N = L.body.getReader(),
                    z =
                      L.headers.get("Content-Length") ||
                      L.headers.get("X-File-Size"),
                    F = z ? parseInt(z) : 0,
                    U = 0 !== F,
                    k = 0,
                    Y = new ReadableStream({
                      start(_) {
                        (function v() {
                          N.read().then(({ done: L, value: N }) => {
                            if (L) _.close();
                            else {
                              k += N.byteLength;
                              let L = new ProgressEvent("progress", {
                                lengthComputable: U,
                                loaded: k,
                                total: F,
                              });
                              for (let _ = 0, N = R.length; _ < N; _++) {
                                let N = R[_];
                                N.onProgress && N.onProgress(L);
                              }
                              _.enqueue(N), v();
                            }
                          });
                        })();
                      },
                    });
                  return new Response(Y);
                }
                throw new ot(
                  `fetch for "${L.url}" responded with ${L.status}: ${L.statusText}`,
                  L,
                );
              })
              .then((_) => {
                switch (k) {
                  case "arraybuffer":
                    return _.arrayBuffer();
                  case "blob":
                    return _.blob();
                  case "document":
                    return _.text().then((_) =>
                      new DOMParser().parseFromString(_, U),
                    );
                  case "json":
                    return _.json();
                  default:
                    if (void 0 === U) return _.text();
                    {
                      let L = /charset="?([^;"\s]*)"?/i.exec(U),
                        R = L && L[1] ? L[1].toLowerCase() : void 0,
                        N = new TextDecoder(R);
                      return _.arrayBuffer().then((_) => N.decode(_));
                    }
                }
              })
              .then((L) => {
                a5.add(_, L);
                let R = a7[_];
                delete a7[_];
                for (let _ = 0, N = R.length; _ < N; _++) {
                  let N = R[_];
                  N.onLoad && N.onLoad(L);
                }
              })
              .catch((L) => {
                let R = a7[_];
                if (void 0 === R) throw (this.manager.itemError(_), L);
                delete a7[_];
                for (let _ = 0, N = R.length; _ < N; _++) {
                  let N = R[_];
                  N.onError && N.onError(L);
                }
                this.manager.itemError(_);
              })
              .finally(() => {
                this.manager.itemEnd(_);
              }),
              this.manager.itemStart(_);
          }
          setResponseType(_) {
            return (this.responseType = _), this;
          }
          setMimeType(_) {
            return (this.mimeType = _), this;
          }
        },
        or = class extends rK {
          constructor(_, L = 1) {
            super(),
              (this.isLight = !0),
              (this.type = "Light"),
              (this.color = new iz(_)),
              (this.intensity = L);
          }
          dispose() {}
          copy(_, L) {
            return (
              super.copy(_, L),
              this.color.copy(_.color),
              (this.intensity = _.intensity),
              this
            );
          }
          toJSON(_) {
            let L = super.toJSON(_);
            return (
              (L.object.color = this.color.getHex()),
              (L.object.intensity = this.intensity),
              void 0 !== this.groundColor &&
                (L.object.groundColor = this.groundColor.getHex()),
              void 0 !== this.distance && (L.object.distance = this.distance),
              void 0 !== this.angle && (L.object.angle = this.angle),
              void 0 !== this.decay && (L.object.decay = this.decay),
              void 0 !== this.penumbra && (L.object.penumbra = this.penumbra),
              void 0 !== this.shadow &&
                (L.object.shadow = this.shadow.toJSON()),
              L
            );
          }
        },
        os = class extends or {
          constructor(_, L, R) {
            super(_, R),
              (this.isHemisphereLight = !0),
              (this.type = "HemisphereLight"),
              this.position.copy(rK.DEFAULT_UP),
              this.updateMatrix(),
              (this.groundColor = new iz(L));
          }
          copy(_, L) {
            return super.copy(_, L), this.groundColor.copy(_.groundColor), this;
          }
        },
        on = new rw(),
        oa = new iq(),
        oo = new iq(),
        ol = class {
          constructor(_) {
            (this.camera = _),
              (this.bias = 0),
              (this.normalBias = 0),
              (this.radius = 1),
              (this.blurSamples = 8),
              (this.mapSize = new iT(512, 512)),
              (this.map = null),
              (this.mapPass = null),
              (this.matrix = new rw()),
              (this.autoUpdate = !0),
              (this.needsUpdate = !1),
              (this._frustum = new s7()),
              (this._frameExtents = new iT(1, 1)),
              (this._viewportCount = 1),
              (this._viewports = [new iV(0, 0, 1, 1)]);
          }
          getViewportCount() {
            return this._viewportCount;
          }
          getFrustum() {
            return this._frustum;
          }
          updateMatrices(_) {
            let L = this.camera,
              R = this.matrix;
            oa.setFromMatrixPosition(_.matrixWorld),
              L.position.copy(oa),
              oo.setFromMatrixPosition(_.target.matrixWorld),
              L.lookAt(oo),
              L.updateMatrixWorld(),
              on.multiplyMatrices(L.projectionMatrix, L.matrixWorldInverse),
              this._frustum.setFromProjectionMatrix(on),
              R.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
              R.multiply(on);
          }
          getViewport(_) {
            return this._viewports[_];
          }
          getFrameExtents() {
            return this._frameExtents;
          }
          dispose() {
            this.map && this.map.dispose(),
              this.mapPass && this.mapPass.dispose();
          }
          copy(_) {
            return (
              (this.camera = _.camera.clone()),
              (this.bias = _.bias),
              (this.radius = _.radius),
              this.mapSize.copy(_.mapSize),
              this
            );
          }
          clone() {
            return new this.constructor().copy(this);
          }
          toJSON() {
            let _ = {};
            return (
              0 !== this.bias && (_.bias = this.bias),
              0 !== this.normalBias && (_.normalBias = this.normalBias),
              1 !== this.radius && (_.radius = this.radius),
              (512 !== this.mapSize.x || 512 !== this.mapSize.y) &&
                (_.mapSize = this.mapSize.toArray()),
              (_.camera = this.camera.toJSON(!1).object),
              delete _.camera.matrix,
              _
            );
          }
        },
        oh = class extends ol {
          constructor() {
            super(new sK(50, 1, 0.5, 500)),
              (this.isSpotLightShadow = !0),
              (this.focus = 1);
          }
          updateMatrices(_) {
            let L = this.camera,
              R = 2 * i_ * _.angle * this.focus,
              N = this.mapSize.width / this.mapSize.height,
              z = _.distance || L.far;
            (R !== L.fov || N !== L.aspect || z !== L.far) &&
              ((L.fov = R),
              (L.aspect = N),
              (L.far = z),
              L.updateProjectionMatrix()),
              super.updateMatrices(_);
          }
          copy(_) {
            return super.copy(_), (this.focus = _.focus), this;
          }
        },
        od = class extends or {
          constructor(_, L, R = 0, N = Math.PI / 3, z = 0, F = 2) {
            super(_, L),
              (this.isSpotLight = !0),
              (this.type = "SpotLight"),
              this.position.copy(rK.DEFAULT_UP),
              this.updateMatrix(),
              (this.target = new rK()),
              (this.distance = R),
              (this.angle = N),
              (this.penumbra = z),
              (this.decay = F),
              (this.map = null),
              (this.shadow = new oh());
          }
          get power() {
            return this.intensity * Math.PI;
          }
          set power(_) {
            this.intensity = _ / Math.PI;
          }
          dispose() {
            this.shadow.dispose();
          }
          copy(_, L) {
            return (
              super.copy(_, L),
              (this.distance = _.distance),
              (this.angle = _.angle),
              (this.penumbra = _.penumbra),
              (this.decay = _.decay),
              (this.target = _.target.clone()),
              (this.shadow = _.shadow.clone()),
              this
            );
          }
        },
        ou = new rw(),
        ov = new iq(),
        oy = new iq(),
        ox = class extends ol {
          constructor() {
            super(new sK(90, 1, 0.5, 500)),
              (this.isPointLightShadow = !0),
              (this._frameExtents = new iT(4, 2)),
              (this._viewportCount = 6),
              (this._viewports = [
                new iV(2, 1, 1, 1),
                new iV(0, 1, 1, 1),
                new iV(3, 1, 1, 1),
                new iV(1, 1, 1, 1),
                new iV(3, 0, 1, 1),
                new iV(1, 0, 1, 1),
              ]),
              (this._cubeDirections = [
                new iq(1, 0, 0),
                new iq(-1, 0, 0),
                new iq(0, 0, 1),
                new iq(0, 0, -1),
                new iq(0, 1, 0),
                new iq(0, -1, 0),
              ]),
              (this._cubeUps = [
                new iq(0, 1, 0),
                new iq(0, 1, 0),
                new iq(0, 1, 0),
                new iq(0, 1, 0),
                new iq(0, 0, 1),
                new iq(0, 0, -1),
              ]);
          }
          updateMatrices(_, L = 0) {
            let R = this.camera,
              N = this.matrix,
              z = _.distance || R.far;
            z !== R.far && ((R.far = z), R.updateProjectionMatrix()),
              ov.setFromMatrixPosition(_.matrixWorld),
              R.position.copy(ov),
              oy.copy(R.position),
              oy.add(this._cubeDirections[L]),
              R.up.copy(this._cubeUps[L]),
              R.lookAt(oy),
              R.updateMatrixWorld(),
              N.makeTranslation(-ov.x, -ov.y, -ov.z),
              ou.multiplyMatrices(R.projectionMatrix, R.matrixWorldInverse),
              this._frustum.setFromProjectionMatrix(ou);
          }
        },
        ob = class extends or {
          constructor(_, L, R = 0, N = 2) {
            super(_, L),
              (this.isPointLight = !0),
              (this.type = "PointLight"),
              (this.distance = R),
              (this.decay = N),
              (this.shadow = new ox());
          }
          get power() {
            return 4 * this.intensity * Math.PI;
          }
          set power(_) {
            this.intensity = _ / (4 * Math.PI);
          }
          dispose() {
            this.shadow.dispose();
          }
          copy(_, L) {
            return (
              super.copy(_, L),
              (this.distance = _.distance),
              (this.decay = _.decay),
              (this.shadow = _.shadow.clone()),
              this
            );
          }
        },
        ow = class extends ol {
          constructor() {
            super(new na(-5, 5, 5, -5, 0.5, 500)),
              (this.isDirectionalLightShadow = !0);
          }
        },
        oS = class extends or {
          constructor(_, L) {
            super(_, L),
              (this.isDirectionalLight = !0),
              (this.type = "DirectionalLight"),
              this.position.copy(rK.DEFAULT_UP),
              this.updateMatrix(),
              (this.target = new rK()),
              (this.shadow = new ow());
          }
          dispose() {
            this.shadow.dispose();
          }
          copy(_) {
            return (
              super.copy(_),
              (this.target = _.target.clone()),
              (this.shadow = _.shadow.clone()),
              this
            );
          }
        },
        oA = class extends sP {
          constructor() {
            super(),
              (this.isInstancedBufferGeometry = !0),
              (this.type = "InstancedBufferGeometry"),
              (this.instanceCount = 1 / 0);
          }
          copy(_) {
            return super.copy(_), (this.instanceCount = _.instanceCount), this;
          }
          toJSON() {
            let _ = super.toJSON();
            return (
              (_.instanceCount = this.instanceCount),
              (_.isInstancedBufferGeometry = !0),
              _
            );
          }
        },
        oM = class extends a9 {
          constructor(_) {
            super(_);
          }
          load(_, L, R, N) {
            let z = this,
              F = new oi(z.manager);
            F.setPath(z.path),
              F.setRequestHeader(z.requestHeader),
              F.setWithCredentials(z.withCredentials),
              F.load(
                _,
                function (R) {
                  try {
                    L(z.parse(JSON.parse(R)));
                  } catch (L) {
                    N ? N(L) : console.error(L), z.manager.itemError(_);
                  }
                },
                R,
                N,
              );
          }
          parse(_) {
            let L = {},
              R = {};
            function i(_, N) {
              if (void 0 !== L[N]) return L[N];
              let z = _.interleavedBuffers[N],
                F = (function (_, L) {
                  if (void 0 !== R[L]) return R[L];
                  let N = _.arrayBuffers[L],
                    z = new Uint32Array(N).buffer;
                  return (R[L] = z), z;
                })(_, z.buffer),
                U = If(z.type, F),
                k = new n4(U, z.stride);
              return (k.uuid = z.uuid), (L[N] = k), k;
            }
            let N = _.isInstancedBufferGeometry ? new oA() : new sP(),
              z = _.data.index;
            if (void 0 !== z) {
              let _ = If(z.type, z.array);
              N.setIndex(new sh(_, 1));
            }
            let F = _.data.attributes;
            for (let L in F) {
              let R = F[L],
                z;
              if (R.isInterleavedBufferAttribute) {
                let L = i(_.data, R.data);
                z = new n6(L, R.itemSize, R.offset, R.normalized);
              } else {
                let _ = If(R.type, R.array);
                z = new (R.isInstancedBufferAttribute ? n8 : sh)(
                  _,
                  R.itemSize,
                  R.normalized,
                );
              }
              void 0 !== R.name && (z.name = R.name),
                void 0 !== R.usage && z.setUsage(R.usage),
                void 0 !== R.updateRange &&
                  ((z.updateRange.offset = R.updateRange.offset),
                  (z.updateRange.count = R.updateRange.count)),
                N.setAttribute(L, z);
            }
            let U = _.data.morphAttributes;
            if (U)
              for (let L in U) {
                let R = U[L],
                  z = [];
                for (let L = 0, N = R.length; L < N; L++) {
                  let N = R[L],
                    F;
                  if (N.isInterleavedBufferAttribute) {
                    let L = i(_.data, N.data);
                    F = new n6(L, N.itemSize, N.offset, N.normalized);
                  } else {
                    let _ = If(N.type, N.array);
                    F = new sh(_, N.itemSize, N.normalized);
                  }
                  void 0 !== N.name && (F.name = N.name), z.push(F);
                }
                N.morphAttributes[L] = z;
              }
            _.data.morphTargetsRelative && (N.morphTargetsRelative = !0);
            let k = _.data.groups || _.data.drawcalls || _.data.offsets;
            if (void 0 !== k)
              for (let _ = 0, L = k.length; _ !== L; ++_) {
                let L = k[_];
                N.addGroup(L.start, L.count, L.materialIndex);
              }
            let Y = _.data.boundingSphere;
            if (void 0 !== Y) {
              let _ = new iq();
              void 0 !== Y.center && _.fromArray(Y.center),
                (N.boundingSphere = new ro(_, Y.radius));
            }
            return (
              _.name && (N.name = _.name),
              _.userData && (N.userData = _.userData),
              N
            );
          }
        },
        oE = class {
          constructor(_ = !0) {
            (this.autoStart = _),
              (this.startTime = 0),
              (this.oldTime = 0),
              (this.elapsedTime = 0),
              (this.running = !1);
          }
          start() {
            (this.startTime = A1()),
              (this.oldTime = this.startTime),
              (this.elapsedTime = 0),
              (this.running = !0);
          }
          stop() {
            this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
          }
          getElapsedTime() {
            return this.getDelta(), this.elapsedTime;
          }
          getDelta() {
            let _ = 0;
            if (this.autoStart && !this.running) return this.start(), 0;
            if (this.running) {
              let L = A1();
              (_ = (L - this.oldTime) / 1e3),
                (this.oldTime = L),
                (this.elapsedTime += _);
            }
            return _;
          }
        };
      function A1() {
        return (typeof performance > "u" ? Date : performance).now();
      }
      var oC = "\\[\\]\\.:\\/",
        oP = RegExp("[" + oC + "]", "g"),
        oD = "[^" + oC + "]",
        oO = "[^" + oC.replace("\\.", "") + "]",
        oL = RegExp(
          "^" +
            /((?:WC+[\/:])*)/.source.replace("WC", oD) +
            /(WCOD+)?/.source.replace("WCOD", oO) +
            /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", oD) +
            /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", oD) +
            "$",
        ),
        oR = ["material", "materials", "bones", "map"],
        oI = class {
          constructor(_, L, R) {
            let N = R || oB.parseTrackName(L);
            (this._targetGroup = _), (this._bindings = _.subscribe_(L, N));
          }
          getValue(_, L) {
            this.bind();
            let R = this._targetGroup.nCachedObjects_,
              N = this._bindings[R];
            void 0 !== N && N.getValue(_, L);
          }
          setValue(_, L) {
            let R = this._bindings;
            for (
              let N = this._targetGroup.nCachedObjects_, z = R.length;
              N !== z;
              ++N
            )
              R[N].setValue(_, L);
          }
          bind() {
            let _ = this._bindings;
            for (
              let L = this._targetGroup.nCachedObjects_, R = _.length;
              L !== R;
              ++L
            )
              _[L].bind();
          }
          unbind() {
            let _ = this._bindings;
            for (
              let L = this._targetGroup.nCachedObjects_, R = _.length;
              L !== R;
              ++L
            )
              _[L].unbind();
          }
        },
        oB = class {
          constructor(_, L, R) {
            (this.path = L),
              (this.parsedPath = R || oB.parseTrackName(L)),
              (this.node = oB.findNode(_, this.parsedPath.nodeName) || _),
              (this.rootNode = _),
              (this.getValue = this._getValue_unbound),
              (this.setValue = this._setValue_unbound);
          }
          static create(_, L, R) {
            return _ && _.isAnimationObjectGroup
              ? new oB.Composite(_, L, R)
              : new oB(_, L, R);
          }
          static sanitizeNodeName(_) {
            return _.replace(/\s/g, "_").replace(oP, "");
          }
          static parseTrackName(_) {
            let L = oL.exec(_);
            if (null === L)
              throw Error("PropertyBinding: Cannot parse trackName: " + _);
            let R = {
                nodeName: L[2],
                objectName: L[3],
                objectIndex: L[4],
                propertyName: L[5],
                propertyIndex: L[6],
              },
              N = R.nodeName && R.nodeName.lastIndexOf(".");
            if (void 0 !== N && -1 !== N) {
              let _ = R.nodeName.substring(N + 1);
              -1 !== oR.indexOf(_) &&
                ((R.nodeName = R.nodeName.substring(0, N)), (R.objectName = _));
            }
            if (null === R.propertyName || 0 === R.propertyName.length)
              throw Error(
                "PropertyBinding: can not parse propertyName from trackName: " +
                  _,
              );
            return R;
          }
          static findNode(_, L) {
            if (
              void 0 === L ||
              "" === L ||
              "." === L ||
              -1 === L ||
              L === _.name ||
              L === _.uuid
            )
              return _;
            if (_.skeleton) {
              let R = _.skeleton.getBoneByName(L);
              if (void 0 !== R) return R;
            }
            if (_.children) {
              let n = function (_) {
                  for (let R = 0; R < _.length; R++) {
                    let N = _[R];
                    if (N.name === L || N.uuid === L) return N;
                    let z = n(N.children);
                    if (z) return z;
                  }
                  return null;
                },
                R = n(_.children);
              if (R) return R;
            }
            return null;
          }
          _getValue_unavailable() {}
          _setValue_unavailable() {}
          _getValue_direct(_, L) {
            _[L] = this.targetObject[this.propertyName];
          }
          _getValue_array(_, L) {
            let R = this.resolvedProperty;
            for (let N = 0, z = R.length; N !== z; ++N) _[L++] = R[N];
          }
          _getValue_arrayElement(_, L) {
            _[L] = this.resolvedProperty[this.propertyIndex];
          }
          _getValue_toArray(_, L) {
            this.resolvedProperty.toArray(_, L);
          }
          _setValue_direct(_, L) {
            this.targetObject[this.propertyName] = _[L];
          }
          _setValue_direct_setNeedsUpdate(_, L) {
            (this.targetObject[this.propertyName] = _[L]),
              (this.targetObject.needsUpdate = !0);
          }
          _setValue_direct_setMatrixWorldNeedsUpdate(_, L) {
            (this.targetObject[this.propertyName] = _[L]),
              (this.targetObject.matrixWorldNeedsUpdate = !0);
          }
          _setValue_array(_, L) {
            let R = this.resolvedProperty;
            for (let N = 0, z = R.length; N !== z; ++N) R[N] = _[L++];
          }
          _setValue_array_setNeedsUpdate(_, L) {
            let R = this.resolvedProperty;
            for (let N = 0, z = R.length; N !== z; ++N) R[N] = _[L++];
            this.targetObject.needsUpdate = !0;
          }
          _setValue_array_setMatrixWorldNeedsUpdate(_, L) {
            let R = this.resolvedProperty;
            for (let N = 0, z = R.length; N !== z; ++N) R[N] = _[L++];
            this.targetObject.matrixWorldNeedsUpdate = !0;
          }
          _setValue_arrayElement(_, L) {
            this.resolvedProperty[this.propertyIndex] = _[L];
          }
          _setValue_arrayElement_setNeedsUpdate(_, L) {
            (this.resolvedProperty[this.propertyIndex] = _[L]),
              (this.targetObject.needsUpdate = !0);
          }
          _setValue_arrayElement_setMatrixWorldNeedsUpdate(_, L) {
            (this.resolvedProperty[this.propertyIndex] = _[L]),
              (this.targetObject.matrixWorldNeedsUpdate = !0);
          }
          _setValue_fromArray(_, L) {
            this.resolvedProperty.fromArray(_, L);
          }
          _setValue_fromArray_setNeedsUpdate(_, L) {
            this.resolvedProperty.fromArray(_, L),
              (this.targetObject.needsUpdate = !0);
          }
          _setValue_fromArray_setMatrixWorldNeedsUpdate(_, L) {
            this.resolvedProperty.fromArray(_, L),
              (this.targetObject.matrixWorldNeedsUpdate = !0);
          }
          _getValue_unbound(_, L) {
            this.bind(), this.getValue(_, L);
          }
          _setValue_unbound(_, L) {
            this.bind(), this.setValue(_, L);
          }
          bind() {
            let _ = this.node,
              L = this.parsedPath,
              R = L.objectName,
              N = L.propertyName,
              z = L.propertyIndex;
            if (
              (_ ||
                ((_ = oB.findNode(this.rootNode, L.nodeName) || this.rootNode),
                (this.node = _)),
              (this.getValue = this._getValue_unavailable),
              (this.setValue = this._setValue_unavailable),
              !_)
            ) {
              console.error(
                "THREE.PropertyBinding: Trying to update node for track: " +
                  this.path +
                  " but it wasn't found.",
              );
              return;
            }
            if (R) {
              let N = L.objectIndex;
              switch (R) {
                case "materials":
                  if (!_.material) {
                    console.error(
                      "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                      this,
                    );
                    return;
                  }
                  if (!_.material.materials) {
                    console.error(
                      "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
                      this,
                    );
                    return;
                  }
                  _ = _.material.materials;
                  break;
                case "bones":
                  if (!_.skeleton) {
                    console.error(
                      "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
                      this,
                    );
                    return;
                  }
                  _ = _.skeleton.bones;
                  for (let L = 0; L < _.length; L++)
                    if (_[L].name === N) {
                      N = L;
                      break;
                    }
                  break;
                case "map":
                  if ("map" in _) {
                    _ = _.map;
                    break;
                  }
                  if (!_.material) {
                    console.error(
                      "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                      this,
                    );
                    return;
                  }
                  if (!_.material.map) {
                    console.error(
                      "THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",
                      this,
                    );
                    return;
                  }
                  _ = _.material.map;
                  break;
                default:
                  if (void 0 === _[R]) {
                    console.error(
                      "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
                      this,
                    );
                    return;
                  }
                  _ = _[R];
              }
              if (void 0 !== N) {
                if (void 0 === _[N]) {
                  console.error(
                    "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
                    this,
                    _,
                  );
                  return;
                }
                _ = _[N];
              }
            }
            let F = _[N];
            if (void 0 === F) {
              console.error(
                "THREE.PropertyBinding: Trying to update property for track: " +
                  L.nodeName +
                  "." +
                  N +
                  " but it wasn't found.",
                _,
              );
              return;
            }
            let U = this.Versioning.None;
            (this.targetObject = _),
              void 0 !== _.needsUpdate
                ? (U = this.Versioning.NeedsUpdate)
                : void 0 !== _.matrixWorldNeedsUpdate &&
                  (U = this.Versioning.MatrixWorldNeedsUpdate);
            let k = this.BindingType.Direct;
            if (void 0 !== z) {
              if ("morphTargetInfluences" === N) {
                if (!_.geometry) {
                  console.error(
                    "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
                    this,
                  );
                  return;
                }
                if (!_.geometry.morphAttributes) {
                  console.error(
                    "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
                    this,
                  );
                  return;
                }
                void 0 !== _.morphTargetDictionary[z] &&
                  (z = _.morphTargetDictionary[z]);
              }
              (k = this.BindingType.ArrayElement),
                (this.resolvedProperty = F),
                (this.propertyIndex = z);
            } else
              void 0 !== F.fromArray && void 0 !== F.toArray
                ? ((k = this.BindingType.HasFromToArray),
                  (this.resolvedProperty = F))
                : Array.isArray(F)
                  ? ((k = this.BindingType.EntireArray),
                    (this.resolvedProperty = F))
                  : (this.propertyName = N);
            (this.getValue = this.GetterByBindingType[k]),
              (this.setValue = this.SetterByBindingTypeAndVersioning[k][U]);
          }
          unbind() {
            (this.node = null),
              (this.getValue = this._getValue_unbound),
              (this.setValue = this._setValue_unbound);
          }
        };
      (oB.Composite = oI),
        (oB.prototype.BindingType = {
          Direct: 0,
          EntireArray: 1,
          ArrayElement: 2,
          HasFromToArray: 3,
        }),
        (oB.prototype.Versioning = {
          None: 0,
          NeedsUpdate: 1,
          MatrixWorldNeedsUpdate: 2,
        }),
        (oB.prototype.GetterByBindingType = [
          oB.prototype._getValue_direct,
          oB.prototype._getValue_array,
          oB.prototype._getValue_arrayElement,
          oB.prototype._getValue_toArray,
        ]),
        (oB.prototype.SetterByBindingTypeAndVersioning = [
          [
            oB.prototype._setValue_direct,
            oB.prototype._setValue_direct_setNeedsUpdate,
            oB.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
          ],
          [
            oB.prototype._setValue_array,
            oB.prototype._setValue_array_setNeedsUpdate,
            oB.prototype._setValue_array_setMatrixWorldNeedsUpdate,
          ],
          [
            oB.prototype._setValue_arrayElement,
            oB.prototype._setValue_arrayElement_setNeedsUpdate,
            oB.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
          ],
          [
            oB.prototype._setValue_fromArray,
            oB.prototype._setValue_fromArray_setNeedsUpdate,
            oB.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
          ],
        ]),
        new Float32Array(1);
      var oz = class {
          constructor(_) {
            this.value = _;
          }
          clone() {
            return new oz(
              void 0 === this.value.clone ? this.value : this.value.clone(),
            );
          }
        },
        oF = class {
          constructor(_, L, R = 0, N = 1 / 0) {
            (this.ray = new rx(_, L)),
              (this.near = R),
              (this.far = N),
              (this.camera = null),
              (this.layers = new rz()),
              (this.params = {
                Mesh: {},
                Line: { threshold: 1 },
                LOD: {},
                Points: { threshold: 1 },
                Sprite: {},
              });
          }
          set(_, L) {
            this.ray.set(_, L);
          }
          setFromCamera(_, L) {
            L.isPerspectiveCamera
              ? (this.ray.origin.setFromMatrixPosition(L.matrixWorld),
                this.ray.direction
                  .set(_.x, _.y, 0.5)
                  .unproject(L)
                  .sub(this.ray.origin)
                  .normalize(),
                (this.camera = L))
              : L.isOrthographicCamera
                ? (this.ray.origin
                    .set(_.x, _.y, (L.near + L.far) / (L.near - L.far))
                    .unproject(L),
                  this.ray.direction
                    .set(0, 0, -1)
                    .transformDirection(L.matrixWorld),
                  (this.camera = L))
                : console.error(
                    "THREE.Raycaster: Unsupported camera type: " + L.type,
                  );
          }
          intersectObject(_, L = !0, R = []) {
            return f0(_, this, R, L), R.sort(_1), R;
          }
          intersectObjects(_, L = !0, R = []) {
            for (let N = 0, z = _.length; N < z; N++) f0(_[N], this, R, L);
            return R.sort(_1), R;
          }
        };
      function _1(_, L) {
        return _.distance - L.distance;
      }
      function f0(_, L, R, N) {
        if ((_.layers.test(L.layers) && _.raycast(L, R), !0 === N)) {
          let N = _.children;
          for (let _ = 0, z = N.length; _ < z; _++) f0(N[_], L, R, !0);
        }
      }
      var oU = class {
          constructor(_ = 1, L = 0, R = 0) {
            return (this.radius = _), (this.phi = L), (this.theta = R), this;
          }
          set(_, L, R) {
            return (this.radius = _), (this.phi = L), (this.theta = R), this;
          }
          copy(_) {
            return (
              (this.radius = _.radius),
              (this.phi = _.phi),
              (this.theta = _.theta),
              this
            );
          }
          makeSafe() {
            return (
              (this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi))),
              this
            );
          }
          setFromVector3(_) {
            return this.setFromCartesianCoords(_.x, _.y, _.z);
          }
          setFromCartesianCoords(_, L, R) {
            return (
              (this.radius = Math.sqrt(_ * _ + L * L + R * R)),
              0 === this.radius
                ? ((this.theta = 0), (this.phi = 0))
                : ((this.theta = Math.atan2(_, R)),
                  (this.phi = Math.acos(_n(L / this.radius, -1, 1)))),
              this
            );
          }
          clone() {
            return new this.constructor().copy(this);
          }
        },
        ok = new iT(),
        oj = class {
          constructor(_ = new iT(1 / 0, 1 / 0), L = new iT(-1 / 0, -1 / 0)) {
            (this.isBox2 = !0), (this.min = _), (this.max = L);
          }
          set(_, L) {
            return this.min.copy(_), this.max.copy(L), this;
          }
          setFromPoints(_) {
            this.makeEmpty();
            for (let L = 0, R = _.length; L < R; L++) this.expandByPoint(_[L]);
            return this;
          }
          setFromCenterAndSize(_, L) {
            let R = ok.copy(L).multiplyScalar(0.5);
            return this.min.copy(_).sub(R), this.max.copy(_).add(R), this;
          }
          clone() {
            return new this.constructor().copy(this);
          }
          copy(_) {
            return this.min.copy(_.min), this.max.copy(_.max), this;
          }
          makeEmpty() {
            return (
              (this.min.x = this.min.y = 1 / 0),
              (this.max.x = this.max.y = -1 / 0),
              this
            );
          }
          isEmpty() {
            return this.max.x < this.min.x || this.max.y < this.min.y;
          }
          getCenter(_) {
            return this.isEmpty()
              ? _.set(0, 0)
              : _.addVectors(this.min, this.max).multiplyScalar(0.5);
          }
          getSize(_) {
            return this.isEmpty()
              ? _.set(0, 0)
              : _.subVectors(this.max, this.min);
          }
          expandByPoint(_) {
            return this.min.min(_), this.max.max(_), this;
          }
          expandByVector(_) {
            return this.min.sub(_), this.max.add(_), this;
          }
          expandByScalar(_) {
            return this.min.addScalar(-_), this.max.addScalar(_), this;
          }
          containsPoint(_) {
            return !(
              _.x < this.min.x ||
              _.x > this.max.x ||
              _.y < this.min.y ||
              _.y > this.max.y
            );
          }
          containsBox(_) {
            return (
              this.min.x <= _.min.x &&
              _.max.x <= this.max.x &&
              this.min.y <= _.min.y &&
              _.max.y <= this.max.y
            );
          }
          getParameter(_, L) {
            return L.set(
              (_.x - this.min.x) / (this.max.x - this.min.x),
              (_.y - this.min.y) / (this.max.y - this.min.y),
            );
          }
          intersectsBox(_) {
            return !(
              _.max.x < this.min.x ||
              _.min.x > this.max.x ||
              _.max.y < this.min.y ||
              _.min.y > this.max.y
            );
          }
          clampPoint(_, L) {
            return L.copy(_).clamp(this.min, this.max);
          }
          distanceToPoint(_) {
            return ok.copy(_).clamp(this.min, this.max).sub(_).length();
          }
          intersect(_) {
            return this.min.max(_.min), this.max.min(_.max), this;
          }
          union(_) {
            return this.min.min(_.min), this.max.max(_.max), this;
          }
          translate(_) {
            return this.min.add(_), this.max.add(_), this;
          }
          equals(_) {
            return _.min.equals(this.min) && _.max.equals(this.max);
          }
        },
        oG = new iq(),
        oV = new iq(),
        oH = class {
          constructor(_ = new iq(), L = new iq()) {
            (this.start = _), (this.end = L);
          }
          set(_, L) {
            return this.start.copy(_), this.end.copy(L), this;
          }
          copy(_) {
            return this.start.copy(_.start), this.end.copy(_.end), this;
          }
          getCenter(_) {
            return _.addVectors(this.start, this.end).multiplyScalar(0.5);
          }
          delta(_) {
            return _.subVectors(this.end, this.start);
          }
          distanceSq() {
            return this.start.distanceToSquared(this.end);
          }
          distance() {
            return this.start.distanceTo(this.end);
          }
          at(_, L) {
            return this.delta(L).multiplyScalar(_).add(this.start);
          }
          closestPointToPointParameter(_, L) {
            oG.subVectors(_, this.start), oV.subVectors(this.end, this.start);
            let R = oV.dot(oV),
              N = oV.dot(oG) / R;
            return L && (N = _n(N, 0, 1)), N;
          }
          closestPointToPoint(_, L, R) {
            let N = this.closestPointToPointParameter(_, L);
            return this.delta(R).multiplyScalar(N).add(this.start);
          }
          applyMatrix4(_) {
            return this.start.applyMatrix4(_), this.end.applyMatrix4(_), this;
          }
          equals(_) {
            return _.start.equals(this.start) && _.end.equals(this.end);
          }
          clone() {
            return new this.constructor().copy(this);
          }
        },
        oW = new iq(),
        oY = class extends rK {
          constructor(_, L) {
            super(),
              (this.light = _),
              (this.matrix = _.matrixWorld),
              (this.matrixAutoUpdate = !1),
              (this.color = L),
              (this.type = "SpotLightHelper");
            let R = new sP(),
              N = [
                0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0,
                0, 1, 1, 0, 0, 0, 0, -1, 1,
              ];
            for (let _ = 0, L = 1; _ < 32; _++, L++) {
              let R = (_ / 32) * Math.PI * 2,
                z = (L / 32) * Math.PI * 2;
              N.push(Math.cos(R), Math.sin(R), 1, Math.cos(z), Math.sin(z), 1);
            }
            R.setAttribute("position", new sv(N, 3));
            let z = new n9({ fog: !1, toneMapped: !1 });
            (this.cone = new ah(R, z)), this.add(this.cone), this.update();
          }
          dispose() {
            this.cone.geometry.dispose(), this.cone.material.dispose();
          }
          update() {
            this.light.updateWorldMatrix(!0, !1),
              this.light.target.updateWorldMatrix(!0, !1);
            let _ = this.light.distance ? this.light.distance : 1e3,
              L = _ * Math.tan(this.light.angle);
            this.cone.scale.set(L, L, _),
              oW.setFromMatrixPosition(this.light.target.matrixWorld),
              this.cone.lookAt(oW),
              void 0 !== this.color
                ? this.cone.material.color.set(this.color)
                : this.cone.material.color.copy(this.light.color);
          }
        },
        oX = class extends sH {
          constructor(_, L, R) {
            super(
              new aY(L, 4, 2),
              new ss({ wireframe: !0, fog: !1, toneMapped: !1 }),
            ),
              (this.light = _),
              (this.color = R),
              (this.type = "PointLightHelper"),
              (this.matrix = this.light.matrixWorld),
              (this.matrixAutoUpdate = !1),
              this.update();
          }
          dispose() {
            this.geometry.dispose(), this.material.dispose();
          }
          update() {
            this.light.updateWorldMatrix(!0, !1),
              void 0 !== this.color
                ? this.material.color.set(this.color)
                : this.material.color.copy(this.light.color);
          }
        },
        oq = new iq(),
        oQ = new iq(),
        oZ = new iq(),
        oK = class extends rK {
          constructor(_, L, R) {
            super(),
              (this.light = _),
              (this.matrix = _.matrixWorld),
              (this.matrixAutoUpdate = !1),
              (this.color = R),
              (this.type = "DirectionalLightHelper"),
              void 0 === L && (L = 1);
            let N = new sP();
            N.setAttribute(
              "position",
              new sv([-L, L, 0, L, L, 0, L, -L, 0, -L, -L, 0, -L, L, 0], 3),
            );
            let z = new n9({ fog: !1, toneMapped: !1 });
            (this.lightPlane = new aa(N, z)),
              this.add(this.lightPlane),
              (N = new sP()).setAttribute(
                "position",
                new sv([0, 0, 0, 0, 0, 1], 3),
              ),
              (this.targetLine = new aa(N, z)),
              this.add(this.targetLine),
              this.update();
          }
          dispose() {
            this.lightPlane.geometry.dispose(),
              this.lightPlane.material.dispose(),
              this.targetLine.geometry.dispose(),
              this.targetLine.material.dispose();
          }
          update() {
            this.light.updateWorldMatrix(!0, !1),
              this.light.target.updateWorldMatrix(!0, !1),
              oq.setFromMatrixPosition(this.light.matrixWorld),
              oQ.setFromMatrixPosition(this.light.target.matrixWorld),
              oZ.subVectors(oQ, oq),
              this.lightPlane.lookAt(oQ),
              void 0 !== this.color
                ? (this.lightPlane.material.color.set(this.color),
                  this.targetLine.material.color.set(this.color))
                : (this.lightPlane.material.color.copy(this.light.color),
                  this.targetLine.material.color.copy(this.light.color)),
              this.targetLine.lookAt(oQ),
              (this.targetLine.scale.z = oZ.length());
          }
        },
        oJ = new iq(),
        o$ = new sZ(),
        o0 = class extends ah {
          constructor(_) {
            let L = new sP(),
              R = new n9({ color: 16777215, vertexColors: !0, toneMapped: !1 }),
              N = [],
              z = [],
              F = {};
            function a(_, L) {
              l(_), l(L);
            }
            function l(_) {
              N.push(0, 0, 0),
                z.push(0, 0, 0),
                void 0 === F[_] && (F[_] = []),
                F[_].push(N.length / 3 - 1);
            }
            a("n1", "n2"),
              a("n2", "n4"),
              a("n4", "n3"),
              a("n3", "n1"),
              a("f1", "f2"),
              a("f2", "f4"),
              a("f4", "f3"),
              a("f3", "f1"),
              a("n1", "f1"),
              a("n2", "f2"),
              a("n3", "f3"),
              a("n4", "f4"),
              a("p", "n1"),
              a("p", "n2"),
              a("p", "n3"),
              a("p", "n4"),
              a("u1", "u2"),
              a("u2", "u3"),
              a("u3", "u1"),
              a("c", "t"),
              a("p", "c"),
              a("cn1", "cn2"),
              a("cn3", "cn4"),
              a("cf1", "cf2"),
              a("cf3", "cf4"),
              L.setAttribute("position", new sv(N, 3)),
              L.setAttribute("color", new sv(z, 3)),
              super(L, R),
              (this.type = "CameraHelper"),
              (this.camera = _),
              this.camera.updateProjectionMatrix &&
                this.camera.updateProjectionMatrix(),
              (this.matrix = _.matrixWorld),
              (this.matrixAutoUpdate = !1),
              (this.pointMap = F),
              this.update();
            let U = new iz(16755200),
              k = new iz(16711680),
              Y = new iz(43775),
              X = new iz(16777215),
              Q = new iz(3355443);
            this.setColors(U, k, Y, X, Q);
          }
          setColors(_, L, R, N, z) {
            let F = this.geometry.getAttribute("color");
            F.setXYZ(0, _.r, _.g, _.b),
              F.setXYZ(1, _.r, _.g, _.b),
              F.setXYZ(2, _.r, _.g, _.b),
              F.setXYZ(3, _.r, _.g, _.b),
              F.setXYZ(4, _.r, _.g, _.b),
              F.setXYZ(5, _.r, _.g, _.b),
              F.setXYZ(6, _.r, _.g, _.b),
              F.setXYZ(7, _.r, _.g, _.b),
              F.setXYZ(8, _.r, _.g, _.b),
              F.setXYZ(9, _.r, _.g, _.b),
              F.setXYZ(10, _.r, _.g, _.b),
              F.setXYZ(11, _.r, _.g, _.b),
              F.setXYZ(12, _.r, _.g, _.b),
              F.setXYZ(13, _.r, _.g, _.b),
              F.setXYZ(14, _.r, _.g, _.b),
              F.setXYZ(15, _.r, _.g, _.b),
              F.setXYZ(16, _.r, _.g, _.b),
              F.setXYZ(17, _.r, _.g, _.b),
              F.setXYZ(18, _.r, _.g, _.b),
              F.setXYZ(19, _.r, _.g, _.b),
              F.setXYZ(20, _.r, _.g, _.b),
              F.setXYZ(21, _.r, _.g, _.b),
              F.setXYZ(22, _.r, _.g, _.b),
              F.setXYZ(23, _.r, _.g, _.b),
              F.setXYZ(24, L.r, L.g, L.b),
              F.setXYZ(25, L.r, L.g, L.b),
              F.setXYZ(26, L.r, L.g, L.b),
              F.setXYZ(27, L.r, L.g, L.b),
              F.setXYZ(28, L.r, L.g, L.b),
              F.setXYZ(29, L.r, L.g, L.b),
              F.setXYZ(30, L.r, L.g, L.b),
              F.setXYZ(31, L.r, L.g, L.b),
              F.setXYZ(32, R.r, R.g, R.b),
              F.setXYZ(33, R.r, R.g, R.b),
              F.setXYZ(34, R.r, R.g, R.b),
              F.setXYZ(35, R.r, R.g, R.b),
              F.setXYZ(36, R.r, R.g, R.b),
              F.setXYZ(37, R.r, R.g, R.b),
              F.setXYZ(38, N.r, N.g, N.b),
              F.setXYZ(39, N.r, N.g, N.b),
              F.setXYZ(40, z.r, z.g, z.b),
              F.setXYZ(41, z.r, z.g, z.b),
              F.setXYZ(42, z.r, z.g, z.b),
              F.setXYZ(43, z.r, z.g, z.b),
              F.setXYZ(44, z.r, z.g, z.b),
              F.setXYZ(45, z.r, z.g, z.b),
              F.setXYZ(46, z.r, z.g, z.b),
              F.setXYZ(47, z.r, z.g, z.b),
              F.setXYZ(48, z.r, z.g, z.b),
              F.setXYZ(49, z.r, z.g, z.b),
              (F.needsUpdate = !0);
          }
          update() {
            let _ = this.geometry,
              L = this.pointMap;
            o$.projectionMatrixInverse.copy(
              this.camera.projectionMatrixInverse,
            ),
              ln("c", L, _, o$, 0, 0, -1),
              ln("t", L, _, o$, 0, 0, 1),
              ln("n1", L, _, o$, -1, -1, -1),
              ln("n2", L, _, o$, 1, -1, -1),
              ln("n3", L, _, o$, -1, 1, -1),
              ln("n4", L, _, o$, 1, 1, -1),
              ln("f1", L, _, o$, -1, -1, 1),
              ln("f2", L, _, o$, 1, -1, 1),
              ln("f3", L, _, o$, -1, 1, 1),
              ln("f4", L, _, o$, 1, 1, 1),
              ln("u1", L, _, o$, 0.7, 1.1, -1),
              ln("u2", L, _, o$, -0.7, 1.1, -1),
              ln("u3", L, _, o$, 0, 2, -1),
              ln("cf1", L, _, o$, -1, 0, 1),
              ln("cf2", L, _, o$, 1, 0, 1),
              ln("cf3", L, _, o$, 0, -1, 1),
              ln("cf4", L, _, o$, 0, 1, 1),
              ln("cn1", L, _, o$, -1, 0, -1),
              ln("cn2", L, _, o$, 1, 0, -1),
              ln("cn3", L, _, o$, 0, -1, -1),
              ln("cn4", L, _, o$, 0, 1, -1),
              (_.getAttribute("position").needsUpdate = !0);
          }
          dispose() {
            this.geometry.dispose(), this.material.dispose();
          }
        };
      function ln(_, L, R, N, z, F, U) {
        oJ.set(z, F, U).unproject(N);
        let k = L[_];
        if (void 0 !== k) {
          let _ = R.getAttribute("position");
          for (let L = 0, R = k.length; L < R; L++)
            _.setXYZ(k[L], oJ.x, oJ.y, oJ.z);
        }
      }
      var o2 = class extends ah {
          constructor(_, L = 16776960) {
            let R = new Uint16Array([
                0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2,
                6, 3, 7,
              ]),
              N = new sP();
            N.setIndex(new sh(R, 1)),
              N.setAttribute(
                "position",
                new sv(
                  [
                    1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1,
                    -1, -1, -1, 1, -1, -1,
                  ],
                  3,
                ),
              ),
              super(N, new n9({ color: L, toneMapped: !1 })),
              (this.box = _),
              (this.type = "Box3Helper"),
              this.geometry.computeBoundingSphere();
          }
          updateMatrixWorld(_) {
            let L = this.box;
            L.isEmpty() ||
              (L.getCenter(this.position),
              L.getSize(this.scale),
              this.scale.multiplyScalar(0.5),
              super.updateMatrixWorld(_));
          }
          dispose() {
            this.geometry.dispose(), this.material.dispose();
          }
        },
        o3 = class extends ah {
          constructor(_ = 1) {
            let L = [0, 0, 0, _, 0, 0, 0, 0, 0, 0, _, 0, 0, 0, 0, 0, 0, _],
              R = new sP();
            R.setAttribute("position", new sv(L, 3)),
              R.setAttribute(
                "color",
                new sv(
                  [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1],
                  3,
                ),
              ),
              super(R, new n9({ vertexColors: !0, toneMapped: !1 })),
              (this.type = "AxesHelper");
          }
          setColors(_, L, R) {
            let N = new iz(),
              z = this.geometry.attributes.color.array;
            return (
              N.set(_),
              N.toArray(z, 0),
              N.toArray(z, 3),
              N.set(L),
              N.toArray(z, 6),
              N.toArray(z, 9),
              N.set(R),
              N.toArray(z, 12),
              N.toArray(z, 15),
              (this.geometry.attributes.color.needsUpdate = !0),
              this
            );
          }
          dispose() {
            this.geometry.dispose(), this.material.dispose();
          }
        };
      "u" > typeof __THREE_DEVTOOLS__ &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("register", { detail: { revision: "149" } }),
        ),
        "u" > typeof window &&
          (window.__THREE__
            ? console.warn(
                "WARNING: Multiple instances of Three.js being imported.",
              )
            : (window.__THREE__ = "149"));
      var o4 = Symbol("target"),
        o5 = Symbol("unsubscribe");
      function Hd(_) {
        return (
          _ instanceof Date ||
          _ instanceof Set ||
          _ instanceof Map ||
          _ instanceof WeakSet ||
          _ instanceof WeakMap ||
          ArrayBuffer.isView(_)
        );
      }
      var o6 = Array.isArray;
      function Ga(_) {
        return "symbol" == typeof _;
      }
      var o8 = {
        after: (_, L) =>
          o6(_) ? _.slice(L.length) : "" === L ? _ : _.slice(L.length + 1),
        concat: (_, L) =>
          o6(_)
            ? ((_ = [..._]), L && _.push(L), _)
            : L && void 0 !== L.toString
              ? ("" !== _ && (_ += "."), Ga(L) ? _ + L.toString() : _ + L)
              : _,
        initial: (_) => {
          if (o6(_)) return _.slice(0, -1);
          if ("" === _) return _;
          let L = _.lastIndexOf(".");
          return -1 === L ? "" : _.slice(0, L);
        },
        last: (_) => {
          if (o6(_)) return _[_.length - 1] || "";
          if ("" === _) return _;
          let L = _.lastIndexOf(".");
          return -1 === L ? _ : _.slice(L + 1);
        },
        walk: (_, L) => {
          if (o6(_)) for (let R of _) L(R);
          else if ("" !== _) {
            let R = 0,
              N = _.indexOf(".");
            if (-1 === N) L(_);
            else
              for (; R < _.length; )
                -1 === N && (N = _.length),
                  L(_.slice(R, N)),
                  (R = N + 1),
                  (N = _.indexOf(".", R));
          }
        },
        get(_, L) {
          return (
            this.walk(L, (L) => {
              _ && (_ = _[L]);
            }),
            _
          );
        },
      };
      function Dp(_, L, R) {
        return (
          _.isUnsubscribed ||
          (L.ignoreSymbols && Ga(R)) ||
          (L.ignoreUnderscores && "_" === R.charAt(0)) ||
          ("ignoreKeys" in L && L.ignoreKeys.includes(R))
        );
      }
      var o9 = class {
        constructor(_) {
          (this._equals = _),
            (this._proxyCache = new WeakMap()),
            (this._pathCache = new WeakMap()),
            (this.isUnsubscribed = !1);
        }
        _getDescriptorCache() {
          return (
            void 0 === this._descriptorCache &&
              (this._descriptorCache = new WeakMap()),
            this._descriptorCache
          );
        }
        _getProperties(_) {
          let L = this._getDescriptorCache(),
            R = L.get(_);
          return void 0 === R && ((R = {}), L.set(_, R)), R;
        }
        _getOwnPropertyDescriptor(_, L) {
          if (this.isUnsubscribed)
            return Reflect.getOwnPropertyDescriptor(_, L);
          let R = this._getProperties(_),
            N = R[L];
          return (
            void 0 === N &&
              ((N = Reflect.getOwnPropertyDescriptor(_, L)), (R[L] = N)),
            N
          );
        }
        getProxy(_, L, R, N) {
          if (this.isUnsubscribed) return _;
          let z = _[N],
            F = z || _;
          this._pathCache.set(F, L);
          let U = this._proxyCache.get(F);
          return (
            void 0 === U &&
              ((U = void 0 === z ? new Proxy(_, R) : _),
              this._proxyCache.set(F, U)),
            U
          );
        }
        getPath(_) {
          return this.isUnsubscribed ? void 0 : this._pathCache.get(_);
        }
        isDetached(_, L) {
          return !Object.is(_, o8.get(L, this.getPath(_)));
        }
        defineProperty(_, L, R) {
          return (
            !!Reflect.defineProperty(_, L, R) &&
            (this.isUnsubscribed || (this._getProperties(_)[L] = R), !0)
          );
        }
        setProperty(_, L, R, N, z) {
          if (!this._equals(z, R) || !(L in _)) {
            let z = this._getOwnPropertyDescriptor(_, L);
            return void 0 !== z && "set" in z
              ? Reflect.set(_, L, R, N)
              : Reflect.set(_, L, R);
          }
          return !0;
        }
        deleteProperty(_, L, R) {
          if (Reflect.deleteProperty(_, L)) {
            if (!this.isUnsubscribed) {
              let N = this._getDescriptorCache().get(_);
              N && (delete N[L], this._pathCache.delete(R));
            }
            return !0;
          }
          return !1;
        }
        isSameDescriptor(_, L, R) {
          let N = this._getOwnPropertyDescriptor(L, R);
          return (
            void 0 !== _ &&
            void 0 !== N &&
            Object.is(_.value, N.value) &&
            (_.writable || !1) === (N.writable || !1) &&
            (_.enumerable || !1) === (N.enumerable || !1) &&
            (_.configurable || !1) === (N.configurable || !1) &&
            _.get === N.get &&
            _.set === N.set
          );
        }
        isGetInvariant(_, L) {
          let R = this._getOwnPropertyDescriptor(_, L);
          return void 0 !== R && !0 !== R.configurable && !0 !== R.writable;
        }
        unsubscribe() {
          (this._descriptorCache = null),
            (this._pathCache = null),
            (this._proxyCache = null),
            (this.isUnsubscribed = !0);
        }
      };
      function rc(_) {
        return "[object Object]" === toString.call(_);
      }
      function ic() {
        return !0;
      }
      function Lo(_, L) {
        return _.length !== L.length || _.some((_, R) => L[R] !== _);
      }
      var o7 = new Set([
          "hasOwnProperty",
          "isPrototypeOf",
          "propertyIsEnumerable",
          "toLocaleString",
          "toString",
          "valueOf",
        ]),
        le = new Set([
          "concat",
          "includes",
          "indexOf",
          "join",
          "keys",
          "lastIndexOf",
        ]),
        lt = {
          push: ic,
          pop: ic,
          shift: ic,
          unshift: ic,
          copyWithin: Lo,
          reverse: Lo,
          sort: Lo,
          splice: Lo,
          flat: Lo,
          fill: Lo,
        },
        li = new Set([...o7, ...le, ...Object.keys(lt)]);
      function sc(_, L) {
        if (_.size !== L.size) return !0;
        for (let R of _) if (!L.has(R)) return !0;
        return !1;
      }
      var lr = ["keys", "values", "entries"],
        ls = new Set(["has", "toString"]),
        la = { add: sc, clear: sc, delete: sc, forEach: sc },
        lo = new Set([...ls, ...Object.keys(la), ...lr]);
      function oc(_, L) {
        let R;
        if (_.size !== L.size) return !0;
        for (let [N, z] of _)
          if ((R = L.get(N)) !== z || (void 0 === R && !L.has(N))) return !0;
        return !1;
      }
      var ll = new Set([...ls, "get"]),
        lh = { set: oc, clear: oc, delete: oc, forEach: oc },
        lc = new Set([...ll, ...Object.keys(lh), ...lr]),
        ld = class {
          constructor(_, L, R, N) {
            (this._path = L),
              (this._isChanged = !1),
              (this._clonedCache = new Set()),
              (this._hasOnValidate = N),
              (this._changes = N ? [] : null),
              (this.clone = void 0 === L ? _ : this._shallowClone(_));
          }
          static isHandledMethod(_) {
            return o7.has(_);
          }
          _shallowClone(_) {
            let L = _;
            if (rc(_)) L = { ..._ };
            else if (o6(_)) L = [..._];
            else if (_ instanceof Date) L = new Date(_);
            else if (_ instanceof Set)
              L = new Set([..._].map((_) => this._shallowClone(_)));
            else if (_ instanceof Map)
              for (let [R, N] of ((L = new Map()), _.entries()))
                L.set(R, this._shallowClone(N));
            return this._clonedCache.add(L), L;
          }
          preferredThisArg(_, L, R, N) {
            return _
              ? (o6(N)
                  ? (this._onIsChanged = lt[L])
                  : N instanceof Set
                    ? (this._onIsChanged = la[L])
                    : N instanceof Map && (this._onIsChanged = lh[L]),
                N)
              : R;
          }
          update(_, L, R) {
            let N = o8.after(_, this._path);
            if ("length" !== L) {
              let _ = this.clone;
              o8.walk(N, (L) => {
                _ &&
                  _[L] &&
                  (this._clonedCache.has(_[L]) ||
                    (_[L] = this._shallowClone(_[L])),
                  (_ = _[L]));
              }),
                this._hasOnValidate &&
                  this._changes.push({ path: N, property: L, previous: R }),
                _ && _[L] && (_[L] = R);
            }
            this._isChanged = !0;
          }
          undo(_) {
            let L;
            for (let R = this._changes.length - 1; -1 !== R; R--)
              (L = this._changes[R]),
                (o8.get(_, L.path)[L.property] = L.previous);
          }
          isChanged(_) {
            return void 0 === this._onIsChanged
              ? this._isChanged
              : this._onIsChanged(this.clone, _);
          }
        },
        lu = class extends ld {
          static isHandledMethod(_) {
            return li.has(_);
          }
        },
        lp = class extends ld {
          undo(_) {
            _.setTime(this.clone.getTime());
          }
          isChanged(_, L) {
            return !L(this.clone.valueOf(), _.valueOf());
          }
        },
        lf = class extends ld {
          static isHandledMethod(_) {
            return lo.has(_);
          }
          undo(_) {
            for (let L of this.clone) _.add(L);
            for (let L of _) this.clone.has(L) || _.delete(L);
          }
        },
        lm = class extends ld {
          static isHandledMethod(_) {
            return lc.has(_);
          }
          undo(_) {
            for (let [L, R] of this.clone.entries()) _.set(L, R);
            for (let L of _.keys()) this.clone.has(L) || _.delete(L);
          }
        },
        lg = class extends ld {
          constructor(_, L, R, N) {
            super(void 0, L, R, N),
              (this._arg1 = R[0]),
              (this._weakValue = _.has(this._arg1));
          }
          isChanged(_) {
            return this._weakValue !== _.has(this._arg1);
          }
          undo(_) {
            this._weakValue && !_.has(this._arg1)
              ? _.add(this._arg1)
              : _.delete(this._arg1);
          }
        },
        lv = class extends ld {
          constructor(_, L, R, N) {
            super(void 0, L, R, N),
              (this._weakKey = R[0]),
              (this._weakHas = _.has(this._weakKey)),
              (this._weakValue = _.get(this._weakKey));
          }
          isChanged(_) {
            return this._weakValue !== _.get(this._weakKey);
          }
          undo(_) {
            let L = _.has(this._weakKey);
            this._weakHas && !L
              ? _.set(this._weakKey, this._weakValue)
              : !this._weakHas && L
                ? _.delete(this._weakKey)
                : this._weakValue !== _.get(this._weakKey) &&
                  _.set(this._weakKey, this._weakValue);
          }
        },
        lx = class {
          constructor(_) {
            (this._stack = []), (this._hasOnValidate = _);
          }
          static isHandledType(_) {
            return rc(_) || o6(_) || Hd(_);
          }
          static isHandledMethod(_, L) {
            return rc(_)
              ? ld.isHandledMethod(L)
              : o6(_)
                ? lu.isHandledMethod(L)
                : _ instanceof Set
                  ? lf.isHandledMethod(L)
                  : _ instanceof Map
                    ? lm.isHandledMethod(L)
                    : Hd(_);
          }
          get isCloning() {
            return this._stack.length > 0;
          }
          start(_, L, R) {
            let N = ld;
            o6(_)
              ? (N = lu)
              : _ instanceof Date
                ? (N = lp)
                : _ instanceof Set
                  ? (N = lf)
                  : _ instanceof Map
                    ? (N = lm)
                    : _ instanceof WeakSet
                      ? (N = lg)
                      : _ instanceof WeakMap && (N = lv),
              this._stack.push(new N(_, L, R, this._hasOnValidate));
          }
          update(_, L, R) {
            this._stack[this._stack.length - 1].update(_, L, R);
          }
          preferredThisArg(_, L, R) {
            let { name: N } = _,
              z = lx.isHandledMethod(R, N);
            return this._stack[this._stack.length - 1].preferredThisArg(
              z,
              N,
              L,
              R,
            );
          }
          isChanged(_, L, R) {
            return this._stack[this._stack.length - 1].isChanged(_, L, R);
          }
          undo(_) {
            void 0 !== this._previousClone && this._previousClone.undo(_);
          }
          stop() {
            return (
              (this._previousClone = this._stack.pop()),
              this._previousClone.clone
            );
          }
        },
        lw = {
          equals: Object.is,
          isShallow: !1,
          pathAsArray: !1,
          ignoreSymbols: !1,
          ignoreUnderscores: !1,
          ignoreDetached: !1,
          details: !1,
        },
        I0 = (_, L, R = {}) => {
          R = { ...lw, ...R };
          let N = Symbol("ProxyTarget"),
            { equals: z, isShallow: F, ignoreDetached: U, details: k } = R,
            Y = new o9(z),
            X = "function" == typeof R.onValidate,
            Q = new lx(X),
            d = (_, L, N, z, F) =>
              !X ||
              Q.isCloning ||
              !0 === R.onValidate(o8.concat(Y.getPath(_), L), N, z, F),
            h = (L, N, z, F) => {
              Dp(Y, R, N) ||
                (U && Y.isDetached(L, _)) ||
                f(Y.getPath(L), N, z, F);
            },
            f = (_, R, N, z, F) => {
              Q.isCloning ? Q.update(_, R, z) : L(o8.concat(_, R), N, z, F);
            },
            g = (_) => _ && (_[N] || _),
            p = (L, z, k, X) =>
              ("object" == typeof L ? null === L : "function" != typeof L) ||
              L instanceof RegExp ||
              "constructor" === k ||
              (F && !lx.isHandledMethod(z, k)) ||
              Dp(Y, R, k) ||
              Y.isGetInvariant(z, k) ||
              (U && Y.isDetached(z, _))
                ? L
                : (void 0 === X && (X = Y.getPath(z)),
                  Y.getProxy(L, o8.concat(X, k), K, N)),
            K = {
              get(_, L, R) {
                if (Ga(L)) {
                  if (L === N || L === o4) return _;
                  if (
                    L === o5 &&
                    !Y.isUnsubscribed &&
                    0 === Y.getPath(_).length
                  )
                    return Y.unsubscribe(), _;
                }
                return p(
                  Hd(_) ? Reflect.get(_, L) : Reflect.get(_, L, R),
                  _,
                  L,
                );
              },
              set(_, L, R, F) {
                R = g(R);
                let U = _[N] || _,
                  k = U[L];
                if (z(k, R) && L in _) return !0;
                let X = d(_, L, R, k);
                return X && Y.setProperty(U, L, R, F, k)
                  ? (h(_, L, _[L], k), !0)
                  : !X;
              },
              defineProperty(_, L, R) {
                if (!Y.isSameDescriptor(R, _, L)) {
                  let N = _[L];
                  d(_, L, R.value, N) &&
                    Y.defineProperty(_, L, R, N) &&
                    h(_, L, R.value, N);
                }
                return !0;
              },
              deleteProperty(_, L) {
                if (!Reflect.has(_, L)) return !0;
                let R = Reflect.get(_, L),
                  N = d(_, L, void 0, R);
                return N && Y.deleteProperty(_, L, R)
                  ? (h(_, L, void 0, R), !0)
                  : !N;
              },
              apply(L, R, F) {
                let U = R[N] || R;
                if (Y.isUnsubscribed) return Reflect.apply(L, U, F);
                if (
                  (!1 === k || (!0 !== k && !k.includes(L.name))) &&
                  lx.isHandledType(U)
                ) {
                  var X;
                  let N = o8.initial(Y.getPath(L)),
                    k = lx.isHandledMethod(U, L.name);
                  Q.start(U, N, F);
                  let J = Reflect.apply(
                      L,
                      Q.preferredThisArg(L, R, U),
                      k ? F.map((_) => g(_)) : F,
                    ),
                    $ = Q.isChanged(U, z),
                    ee = Q.stop();
                  if (
                    (lx.isHandledType(J) &&
                      k &&
                      (R instanceof Map &&
                        "get" === L.name &&
                        (N = o8.concat(N, F[0])),
                      (J = Y.getProxy(J, N, K))),
                    $)
                  ) {
                    let R = { name: L.name, args: F, result: J },
                      z = Q.isCloning ? o8.initial(N) : N,
                      k = Q.isCloning ? o8.last(N) : "";
                    d(o8.get(_, z), k, U, ee, R)
                      ? f(z, k, U, ee, R)
                      : Q.undo(U);
                  }
                  return (R instanceof Map || R instanceof Set) &&
                    "object" == typeof (X = J) &&
                    "function" == typeof X.next
                    ? (function (_, L, R, N, z) {
                        let F = _.next;
                        if ("entries" === L.name)
                          _.next = function () {
                            let _ = F.call(this);
                            return (
                              !1 === _.done &&
                                ((_.value[0] = z(_.value[0], L, _.value[0], N)),
                                (_.value[1] = z(_.value[1], L, _.value[0], N))),
                              _
                            );
                          };
                        else if ("values" === L.name) {
                          let U = R[o4].keys();
                          _.next = function () {
                            let _ = F.call(this);
                            return (
                              !1 === _.done &&
                                (_.value = z(_.value, L, U.next().value, N)),
                              _
                            );
                          };
                        } else
                          _.next = function () {
                            let _ = F.call(this);
                            return (
                              !1 === _.done &&
                                (_.value = z(_.value, L, _.value, N)),
                              _
                            );
                          };
                        return _;
                      })(J, L, R, N, p)
                    : J;
                }
                return Reflect.apply(L, R, F);
              },
            },
            J = Y.getProxy(_, R.pathAsArray ? [] : "", K);
          return (L = L.bind(J)), X && (R.onValidate = R.onValidate.bind(J)), J;
        };
      (I0.target = (_) => (_ && _[o4]) || _),
        (I0.unsubscribe = (_) => _[o5] || _);
      var l_ =
          "object" == typeof global &&
          global &&
          global.Object === Object &&
          global,
        lA = "object" == typeof self && self && self.Object === Object && self,
        lM = l_ || lA || Function("return this")(),
        lE = lM.Symbol,
        lT = Object.prototype,
        lC = lT.hasOwnProperty,
        lP = lT.toString,
        lD = lE ? lE.toStringTag : void 0,
        J1 = function (_) {
          var L = lC.call(_, lD),
            R = _[lD];
          try {
            _[lD] = void 0;
            var N = !0;
          } catch {}
          var z = lP.call(_);
          return N && (L ? (_[lD] = R) : delete _[lD]), z;
        },
        lO = Object.prototype.toString,
        lL = lE ? lE.toStringTag : void 0,
        Kr = function (_) {
          return null == _
            ? void 0 === _
              ? "[object Undefined]"
              : "[object Null]"
            : lL && lL in Object(_)
              ? J1(_)
              : lO.call(_);
        },
        Jn = function (_) {
          return null != _ && "object" == typeof _;
        },
        Ro = function (_) {
          return "symbol" == typeof _ || (Jn(_) && "[object Symbol]" == Kr(_));
        },
        Rp = function (_, L) {
          for (
            var R = -1, N = null == _ ? 0 : _.length, z = Array(N);
            ++R < N;

          )
            z[R] = L(_[R], R, _);
          return z;
        },
        lR = Array.isArray,
        lI = 1 / 0,
        lB = lE ? lE.prototype : void 0,
        lz = lB ? lB.toString : void 0,
        iA = function rA(_) {
          if ("string" == typeof _) return _;
          if (lR(_)) return Rp(_, rA) + "";
          if (Ro(_)) return lz ? lz.call(_) : "";
          var L = _ + "";
          return "0" == L && 1 / _ == -lI ? "-0" : L;
        },
        lF = /\s/,
        sA = function (_) {
          for (var L = _.length; L-- && lF.test(_.charAt(L)); );
          return L;
        },
        lU = /^\s+/,
        Hn = function (_) {
          var L = typeof _;
          return null != _ && ("object" == L || "function" == L);
        },
        lk = 0 / 0,
        lj = /^[-+]0x[0-9a-f]+$/i,
        lG = /^0b[01]+$/i,
        lV = /^0o[0-7]+$/i,
        lH = parseInt,
        O0 = function (_) {
          if ("number" == typeof _) return _;
          if (Ro(_)) return lk;
          if (Hn(_)) {
            var L,
              R = "function" == typeof _.valueOf ? _.valueOf() : _;
            _ = Hn(R) ? R + "" : R;
          }
          if ("string" != typeof _) return 0 === _ ? _ : +_;
          _ = (L = _) && L.slice(0, sA(L) + 1).replace(lU, "");
          var N = lG.test(_);
          return N || lV.test(_)
            ? lH(_.slice(2), N ? 2 : 8)
            : lj.test(_)
              ? lk
              : +_;
        },
        Np = function (_) {
          if (!Hn(_)) return !1;
          var L = Kr(_);
          return (
            "[object Function]" == L ||
            "[object GeneratorFunction]" == L ||
            "[object AsyncFunction]" == L ||
            "[object Proxy]" == L
          );
        },
        lW = lM["__core-js_shared__"],
        lY = (cC = /[^.]+$/.exec((lW && lW.keys && lW.keys.IE_PROTO) || ""))
          ? "Symbol(src)_1." + cC
          : "",
        lX = Function.prototype.toString,
        Xs = function (_) {
          if (null != _) {
            try {
              return lX.call(_);
            } catch {}
            try {
              return _ + "";
            } catch {}
          }
          return "";
        },
        lq = /^\[object .+?Constructor\]$/,
        lQ = Object.prototype,
        lZ = Function.prototype.toString,
        lK = lQ.hasOwnProperty,
        lJ = RegExp(
          "^" +
            lZ
              .call(lK)
              .replace(/[\\^$.*+?()[\]{}|]/g, "\\$&")
              .replace(
                /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
                "$1.*?",
              ) +
            "$",
        ),
        _r = function (_, L) {
          var R,
            N = _?.[L];
          return Hn((R = N)) &&
            (!lY || !(lY in R)) &&
            (Np(R) ? lJ : lq).test(Xs(R))
            ? N
            : void 0;
        },
        l$ = _r(lM, "WeakMap"),
        l0 = Object.create,
        l2 = (function () {
          function r() {}
          return function (_) {
            if (!Hn(_)) return {};
            if (l0) return l0(_);
            r.prototype = _;
            var L = new r();
            return (r.prototype = void 0), L;
          };
        })(),
        mA = function (_, L, R) {
          switch (R.length) {
            case 0:
              return _.call(L);
            case 1:
              return _.call(L, R[0]);
            case 2:
              return _.call(L, R[0], R[1]);
            case 3:
              return _.call(L, R[0], R[1], R[2]);
          }
          return _.apply(L, R);
        },
        gA = function (_, L) {
          var R = -1,
            N = _.length;
          for (L || (L = Array(N)); ++R < N; ) L[R] = _[R];
          return L;
        },
        l4 = Date.now,
        l5 = (function () {
          try {
            var _ = _r(Object, "defineProperty");
            return _({}, "", {}), _;
          } catch {}
        })(),
        l6 = l5
          ? function (_, L) {
              return l5(_, "toString", {
                configurable: !0,
                enumerable: !1,
                value: function () {
                  return L;
                },
                writable: !0,
              });
            }
          : function (_) {
              return _;
            },
        l8 =
          ((cD = 0),
          (cO = 0),
          function () {
            var _ = l4(),
              L = 16 - (_ - cO);
            if (((cO = _), L > 0)) {
              if (++cD >= 800) return arguments[0];
            } else cD = 0;
            return l6.apply(void 0, arguments);
          }),
        SA = function (_, L) {
          for (
            var R = -1, N = null == _ ? 0 : _.length;
            ++R < N && !1 !== L(_[R], R, _);

          );
          return _;
        },
        l9 = /^(?:0|[1-9]\d*)$/,
        dc = function (_, L) {
          var R = typeof _;
          return (
            !!(L = L ?? 9007199254740991) &&
            ("number" == R || ("symbol" != R && l9.test(_))) &&
            _ > -1 &&
            _ % 1 == 0 &&
            _ < L
          );
        },
        Up = function (_, L, R) {
          "__proto__" == L && l5
            ? l5(_, L, {
                configurable: !0,
                enumerable: !0,
                value: R,
                writable: !0,
              })
            : (_[L] = R);
        },
        hc = function (_, L) {
          return _ === L || (_ != _ && L != L);
        },
        l7 = Object.prototype.hasOwnProperty,
        fc = function (_, L, R) {
          var N = _[L];
          (l7.call(_, L) && hc(N, R) && (void 0 !== R || L in _)) ||
            Up(_, L, R);
        },
        ts = function (_, L, R, N) {
          var z = !R;
          R || (R = {});
          for (var F = -1, U = L.length; ++F < U; ) {
            var k = L[F],
              Y = N ? N(R[k], _[k], k, R, _) : void 0;
            void 0 === Y && (Y = _[k]), z ? Up(R, k, Y) : fc(R, k, Y);
          }
          return R;
        },
        he = Math.max,
        pc = function (_) {
          return (
            "number" == typeof _ &&
            _ > -1 &&
            _ % 1 == 0 &&
            _ <= 9007199254740991
          );
        },
        Gp = function (_) {
          return null != _ && pc(_.length) && !Np(_);
        },
        hr = Object.prototype,
        mc = function (_) {
          var L = _ && _.constructor;
          return _ === (("function" == typeof L && L.prototype) || hr);
        },
        _A = function (_, L) {
          for (var R = -1, N = Array(_); ++R < _; ) N[R] = L(R);
          return N;
        },
        L0 = function (_) {
          return Jn(_) && "[object Arguments]" == Kr(_);
        },
        hs = Object.prototype,
        ha = hs.hasOwnProperty,
        ho = hs.propertyIsEnumerable,
        hl = L0(
          (function () {
            return arguments;
          })(),
        )
          ? L0
          : function (_) {
              return Jn(_) && ha.call(_, "callee") && !ho.call(_, "callee");
            },
        hd =
          "object" == typeof exports && exports && !exports.nodeType && exports,
        hp =
          hd &&
          "object" == typeof module &&
          module &&
          !module.nodeType &&
          module,
        hv = hp && hp.exports === hd ? lM.Buffer : void 0,
        hx =
          (hv ? hv.isBuffer : void 0) ||
          function () {
            return !1;
          },
        hw = {};
      (hw["[object Float32Array]"] =
        hw["[object Float64Array]"] =
        hw["[object Int8Array]"] =
        hw["[object Int16Array]"] =
        hw["[object Int32Array]"] =
        hw["[object Uint8Array]"] =
        hw["[object Uint8ClampedArray]"] =
        hw["[object Uint16Array]"] =
        hw["[object Uint32Array]"] =
          !0),
        (hw["[object Arguments]"] =
          hw["[object Array]"] =
          hw["[object ArrayBuffer]"] =
          hw["[object Boolean]"] =
          hw["[object DataView]"] =
          hw["[object Date]"] =
          hw["[object Error]"] =
          hw["[object Function]"] =
          hw["[object Map]"] =
          hw["[object Number]"] =
          hw["[object Object]"] =
          hw["[object RegExp]"] =
          hw["[object Set]"] =
          hw["[object String]"] =
          hw["[object WeakMap]"] =
            !1);
      var yc = function (_) {
          return function (L) {
            return _(L);
          };
        },
        h_ =
          "object" == typeof exports && exports && !exports.nodeType && exports,
        hA =
          h_ &&
          "object" == typeof module &&
          module &&
          !module.nodeType &&
          module,
        hM = hA && hA.exports === h_ && l_.process,
        hE = (function () {
          try {
            return (
              (hA && hA.require && hA.require("util").types) ||
              (hM && hM.binding && hM.binding("util"))
            );
          } catch {}
        })(),
        hT = hE && hE.isTypedArray,
        hD = hT
          ? yc(hT)
          : function (_) {
              return Jn(_) && pc(_.length) && !!hw[Kr(_)];
            },
        hO = Object.prototype.hasOwnProperty,
        zp = function (_, L) {
          var R = lR(_),
            N = !R && hl(_),
            z = !R && !N && hx(_),
            F = !R && !N && !z && hD(_),
            U = R || N || z || F,
            k = U ? _A(_.length, String) : [],
            Y = k.length;
          for (var X in _)
            (L || hO.call(_, X)) &&
              !(
                U &&
                ("length" == X ||
                  (z && ("offset" == X || "parent" == X)) ||
                  (F &&
                    ("buffer" == X ||
                      "byteLength" == X ||
                      "byteOffset" == X)) ||
                  dc(X, Y))
              ) &&
              k.push(X);
          return k;
        },
        Vp = function (_, L) {
          return function (R) {
            return _(L(R));
          };
        },
        hL = Vp(Object.keys, Object),
        hR = Object.prototype.hasOwnProperty,
        RA = function (_) {
          if (!mc(_)) return hL(_);
          var L = [];
          for (var R in Object(_))
            hR.call(_, R) && "constructor" != R && L.push(R);
          return L;
        },
        vc = function (_) {
          return Gp(_) ? zp(_) : RA(_);
        },
        NA = function (_) {
          var L = [];
          if (null != _) for (var R in Object(_)) L.push(R);
          return L;
        },
        hI = Object.prototype.hasOwnProperty,
        BA = function (_) {
          if (!Hn(_)) return NA(_);
          var L = mc(_),
            R = [];
          for (var N in _)
            ("constructor" == N && (L || !hI.call(_, N))) || R.push(N);
          return R;
        },
        xc = function (_) {
          return Gp(_) ? zp(_, !0) : BA(_);
        },
        hB = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
        hN = /^\w*$/,
        FA = function (_, L) {
          if (lR(_)) return !1;
          var R = typeof _;
          return (
            !!(
              "number" == R ||
              "symbol" == R ||
              "boolean" == R ||
              null == _ ||
              Ro(_)
            ) ||
            hN.test(_) ||
            !hB.test(_) ||
            (null != L && _ in Object(L))
          );
        },
        hz = _r(Object, "create"),
        hF = Object.prototype.hasOwnProperty,
        hU = Object.prototype.hasOwnProperty;
      function bc(_) {
        var L = -1,
          R = null == _ ? 0 : _.length;
        for (this.clear(); ++L < R; ) {
          var N = _[L];
          this.set(N[0], N[1]);
        }
      }
      (bc.prototype.clear = function () {
        (this.__data__ = hz ? hz(null) : {}), (this.size = 0);
      }),
        (bc.prototype.delete = function (_) {
          var L = this.has(_) && delete this.__data__[_];
          return (this.size -= L ? 1 : 0), L;
        }),
        (bc.prototype.get = function (_) {
          var L = this.__data__;
          if (hz) {
            var R = L[_];
            return "__lodash_hash_undefined__" === R ? void 0 : R;
          }
          return hF.call(L, _) ? L[_] : void 0;
        }),
        (bc.prototype.has = function (_) {
          var L = this.__data__;
          return hz ? void 0 !== L[_] : hU.call(L, _);
        }),
        (bc.prototype.set = function (_, L) {
          var R = this.__data__;
          return (
            (this.size += this.has(_) ? 0 : 1),
            (R[_] = hz && void 0 === L ? "__lodash_hash_undefined__" : L),
            this
          );
        });
      var No = function (_, L) {
          for (var R = _.length; R--; ) if (hc(_[R][0], L)) return R;
          return -1;
        },
        hk = Array.prototype.splice;
      function Sc(_) {
        var L = -1,
          R = null == _ ? 0 : _.length;
        for (this.clear(); ++L < R; ) {
          var N = _[L];
          this.set(N[0], N[1]);
        }
      }
      (Sc.prototype.clear = function () {
        (this.__data__ = []), (this.size = 0);
      }),
        (Sc.prototype.delete = function (_) {
          var L = this.__data__,
            R = No(L, _);
          return (
            !(R < 0) &&
            (R == L.length - 1 ? L.pop() : hk.call(L, R, 1), --this.size, !0)
          );
        }),
        (Sc.prototype.get = function (_) {
          var L = this.__data__,
            R = No(L, _);
          return R < 0 ? void 0 : L[R][1];
        }),
        (Sc.prototype.has = function (_) {
          return No(this.__data__, _) > -1;
        }),
        (Sc.prototype.set = function (_, L) {
          var R = this.__data__,
            N = No(R, _);
          return N < 0 ? (++this.size, R.push([_, L])) : (R[N][1] = L), this;
        });
      var hG = _r(lM, "Map"),
        KA = function (_) {
          var L = typeof _;
          return "string" == L ||
            "number" == L ||
            "symbol" == L ||
            "boolean" == L
            ? "__proto__" !== _
            : null === _;
        },
        Uo = function (_, L) {
          var R = _.__data__;
          return KA(L) ? R["string" == typeof L ? "string" : "hash"] : R.map;
        };
      function wc(_) {
        var L = -1,
          R = null == _ ? 0 : _.length;
        for (this.clear(); ++L < R; ) {
          var N = _[L];
          this.set(N[0], N[1]);
        }
      }
      function B0(_, L) {
        if ("function" != typeof _ || (null != L && "function" != typeof L))
          throw TypeError("Expected a function");
        var e = function () {
          var R = arguments,
            N = L ? L.apply(this, R) : R[0],
            z = e.cache;
          if (z.has(N)) return z.get(N);
          var F = _.apply(this, R);
          return (e.cache = z.set(N, F) || z), F;
        };
        return (e.cache = new (B0.Cache || wc)()), e;
      }
      (wc.prototype.clear = function () {
        (this.size = 0),
          (this.__data__ = {
            hash: new bc(),
            map: new (hG || Sc)(),
            string: new bc(),
          });
      }),
        (wc.prototype.delete = function (_) {
          var L = Uo(this, _).delete(_);
          return (this.size -= L ? 1 : 0), L;
        }),
        (wc.prototype.get = function (_) {
          return Uo(this, _).get(_);
        }),
        (wc.prototype.has = function (_) {
          return Uo(this, _).has(_);
        }),
        (wc.prototype.set = function (_, L) {
          var R = Uo(this, _),
            N = R.size;
          return R.set(_, L), (this.size += R.size == N ? 0 : 1), this;
        }),
        (B0.Cache = wc);
      var hV =
          /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
        hH = /\\(\\)?/g,
        hW =
          ((cR = (cL = B0(
            function (_) {
              var L = [];
              return (
                46 === _.charCodeAt(0) && L.push(""),
                _.replace(hV, function (_, R, N, z) {
                  L.push(N ? z.replace(hH, "$1") : R || _);
                }),
                L
              );
            },
            function (_) {
              return 500 === cR.size && cR.clear(), _;
            },
          )).cache),
          cL),
        ui = function (_, L) {
          return lR(_) ? _ : FA(_, L) ? [_] : hW(null == _ ? "" : iA(_));
        },
        hY = 1 / 0,
        Go = function (_) {
          if ("string" == typeof _ || Ro(_)) return _;
          var L = _ + "";
          return "0" == L && 1 / _ == -hY ? "-0" : L;
        },
        Hp = function (_, L) {
          L = ui(L, _);
          for (var R = 0, N = L.length; null != _ && R < N; ) _ = _[Go(L[R++])];
          return R && R == N ? _ : void 0;
        },
        Ac = function (_, L) {
          for (var R = -1, N = L.length, z = _.length; ++R < N; )
            _[z + R] = L[R];
          return _;
        },
        hX = lE ? lE.isConcatSpreadable : void 0,
        s_ = function (_) {
          return lR(_) || hl(_) || !!(hX && _ && _[hX]);
        },
        a_ = function o_(_, L, R, N, z) {
          var F = -1,
            U = _.length;
          for (R || (R = s_), z || (z = []); ++F < U; ) {
            var k = _[F];
            L > 0 && R(k)
              ? L > 1
                ? o_(k, L - 1, R, N, z)
                : Ac(z, k)
              : N || (z[z.length] = k);
          }
          return z;
        },
        Wp = function (_) {
          var L;
          return l8(
            ((L = he(((L = void 0), _.length - 1), 0)),
            function () {
              for (
                var R,
                  N = arguments,
                  z = -1,
                  F = he(N.length - L, 0),
                  U = Array(F);
                ++z < F;

              )
                U[z] = N[L + z];
              z = -1;
              for (var k = Array(L + 1); ++z < L; ) k[z] = N[z];
              return (
                (k[L] = (null == (R = U) ? 0 : R.length) ? a_(R, 1) : []),
                mA(_, this, k)
              );
            }),
            _ + "",
          );
        },
        hq = Vp(Object.getPrototypeOf, Object),
        hQ = Object.prototype,
        hZ = Function.prototype.toString,
        hK = hQ.hasOwnProperty,
        hJ = hZ.call(Object),
        u_ = function (_) {
          if (!Jn(_) || "[object Object]" != Kr(_)) return !1;
          var L = hq(_);
          if (null === L) return !0;
          var R = hK.call(L, "constructor") && L.constructor;
          return "function" == typeof R && R instanceof R && hZ.call(R) == hJ;
        },
        d_ = function (_, L, R) {
          var N = -1,
            z = _.length;
          L < 0 && (L = -L > z ? 0 : z + L),
            (R = R > z ? z : R) < 0 && (R += z),
            (z = L > R ? 0 : (R - L) >>> 0),
            (L >>>= 0);
          for (var F = Array(z); ++N < z; ) F[N] = _[N + L];
          return F;
        };
      function Tc(_) {
        var L = (this.__data__ = new Sc(_));
        this.size = L.size;
      }
      (Tc.prototype.clear = function () {
        (this.__data__ = new Sc()), (this.size = 0);
      }),
        (Tc.prototype.delete = function (_) {
          var L = this.__data__,
            R = L.delete(_);
          return (this.size = L.size), R;
        }),
        (Tc.prototype.get = function (_) {
          return this.__data__.get(_);
        }),
        (Tc.prototype.has = function (_) {
          return this.__data__.has(_);
        }),
        (Tc.prototype.set = function (_, L) {
          var R = this.__data__;
          if (R instanceof Sc) {
            var N = R.__data__;
            if (!hG || N.length < 199)
              return N.push([_, L]), (this.size = ++R.size), this;
            R = this.__data__ = new wc(N);
          }
          return R.set(_, L), (this.size = R.size), this;
        });
      var h$ =
          "object" == typeof exports && exports && !exports.nodeType && exports,
        h0 =
          h$ &&
          "object" == typeof module &&
          module &&
          !module.nodeType &&
          module,
        h1 = h0 && h0.exports === h$ ? lM.Buffer : void 0,
        h2 = h1 ? h1.allocUnsafe : void 0,
        A_ = function (_, L) {
          if (L) return _.slice();
          var R = _.length,
            N = h2 ? h2(R) : new _.constructor(R);
          return _.copy(N), N;
        },
        __ = function (_, L) {
          for (
            var R = -1, N = null == _ ? 0 : _.length, z = 0, F = [];
            ++R < N;

          ) {
            var U = _[R];
            L(U, R, _) && (F[z++] = U);
          }
          return F;
        },
        jp = function () {
          return [];
        },
        h4 = Object.prototype.propertyIsEnumerable,
        h5 = Object.getOwnPropertySymbols,
        h6 = h5
          ? function (_) {
              return null == _
                ? []
                : __(h5((_ = Object(_))), function (L) {
                    return h4.call(_, L);
                  });
            }
          : jp,
        h8 = Object.getOwnPropertySymbols
          ? function (_) {
              for (var L = []; _; ) Ac(L, h6(_)), (_ = hq(_));
              return L;
            }
          : jp,
        Xp = function (_, L, R) {
          var N = L(_);
          return lR(_) ? N : Ac(N, R(_));
        },
        Zd = function (_) {
          return Xp(_, vc, h6);
        },
        Yp = function (_) {
          return Xp(_, xc, h8);
        },
        h9 = _r(lM, "DataView"),
        h7 = _r(lM, "Promise"),
        ce = _r(lM, "Set"),
        ct = "[object Map]",
        ci = "[object Promise]",
        cr = "[object Set]",
        cs = "[object WeakMap]",
        cn = "[object DataView]",
        ca = Xs(h9),
        co = Xs(hG),
        cl = Xs(h7),
        ch = Xs(ce),
        cc = Xs(l$),
        cd = Kr;
      ((h9 && cd(new h9(new ArrayBuffer(1))) != cn) ||
        (hG && cd(new hG()) != ct) ||
        (h7 && cd(h7.resolve()) != ci) ||
        (ce && cd(new ce()) != cr) ||
        (l$ && cd(new l$()) != cs)) &&
        (cd = function (_) {
          var L = Kr(_),
            R = "[object Object]" == L ? _.constructor : void 0,
            N = R ? Xs(R) : "";
          if (N)
            switch (N) {
              case ca:
                return cn;
              case co:
                return ct;
              case cl:
                return ci;
              case ch:
                return cr;
              case cc:
                return cs;
            }
          return L;
        });
      var cu = cd,
        cp = Object.prototype.hasOwnProperty,
        L_ = function (_) {
          var L = _.length,
            R = new _.constructor(L);
          return (
            L &&
              "string" == typeof _[0] &&
              cp.call(_, "index") &&
              ((R.index = _.index), (R.input = _.input)),
            R
          );
        },
        cf = lM.Uint8Array,
        Pc = function (_) {
          var L = new _.constructor(_.byteLength);
          return new cf(L).set(new cf(_)), L;
        },
        R_ = function (_, L) {
          var R = L ? Pc(_.buffer) : _.buffer;
          return new _.constructor(R, _.byteOffset, _.byteLength);
        },
        cm = /\w*$/,
        N_ = function (_) {
          var L = new _.constructor(_.source, cm.exec(_));
          return (L.lastIndex = _.lastIndex), L;
        },
        cg = lE ? lE.prototype : void 0,
        cv = cg ? cg.valueOf : void 0,
        G_ = function (_, L) {
          var R = L ? Pc(_.buffer) : _.buffer;
          return new _.constructor(R, _.byteOffset, _.length);
        },
        k_ = function (_, L, R) {
          var N = _.constructor;
          switch (L) {
            case "[object ArrayBuffer]":
              return Pc(_);
            case "[object Boolean]":
            case "[object Date]":
              return new N(+_);
            case "[object DataView]":
              return R_(_, R);
            case "[object Float32Array]":
            case "[object Float64Array]":
            case "[object Int8Array]":
            case "[object Int16Array]":
            case "[object Int32Array]":
            case "[object Uint8Array]":
            case "[object Uint8ClampedArray]":
            case "[object Uint16Array]":
            case "[object Uint32Array]":
              return G_(_, R);
            case "[object Map]":
            case "[object Set]":
              return new N();
            case "[object Number]":
            case "[object String]":
              return new N(_);
            case "[object RegExp]":
              return N_(_);
            case "[object Symbol]":
              return cv ? Object(cv.call(_)) : {};
          }
        },
        cy = hE && hE.isMap,
        cx = cy
          ? yc(cy)
          : function (_) {
              return Jn(_) && "[object Map]" == cu(_);
            },
        cb = hE && hE.isSet,
        cw = cb
          ? yc(cb)
          : function (_) {
              return Jn(_) && "[object Set]" == cu(_);
            },
        c_ = "[object Arguments]",
        cA = "[object Function]",
        cE = "[object Object]",
        cT = {};
      (cT[c_] =
        cT["[object Array]"] =
        cT["[object ArrayBuffer]"] =
        cT["[object DataView]"] =
        cT["[object Boolean]"] =
        cT["[object Date]"] =
        cT["[object Float32Array]"] =
        cT["[object Float64Array]"] =
        cT["[object Int8Array]"] =
        cT["[object Int16Array]"] =
        cT["[object Int32Array]"] =
        cT["[object Map]"] =
        cT["[object Number]"] =
        cT[cE] =
        cT["[object RegExp]"] =
        cT["[object Set]"] =
        cT["[object String]"] =
        cT["[object Symbol]"] =
        cT["[object Uint8Array]"] =
        cT["[object Uint8ClampedArray]"] =
        cT["[object Uint16Array]"] =
        cT["[object Uint32Array]"] =
          !0),
        (cT["[object Error]"] = cT[cA] = cT["[object WeakMap]"] = !1);
      var $p = function Jp(_, L, R, N, z, F) {
          var U,
            k = 1 & L,
            Y = 2 & L,
            X = 4 & L;
          if ((R && (U = z ? R(_, N, z, F) : R(_)), void 0 !== U)) return U;
          if (!Hn(_)) return _;
          var Q = lR(_);
          if (Q) {
            if (((U = L_(_)), !k)) return gA(_, U);
          } else {
            var K,
              J,
              $,
              ee,
              er = cu(_),
              en = er == cA || "[object GeneratorFunction]" == er;
            if (hx(_)) return A_(_, k);
            if (er == cE || er == c_ || (en && !z)) {
              if (
                ((U =
                  Y || en
                    ? {}
                    : "function" != typeof _.constructor || mc(_)
                      ? {}
                      : l2(hq(_))),
                !k)
              )
                return Y
                  ? ((J = (K = U) && ts(_, xc(_), K)), ts(_, h8(_), J))
                  : ((ee = ($ = U) && ts(_, vc(_), $)), ts(_, h6(_), ee));
            } else {
              if (!cT[er]) return z ? _ : {};
              U = k_(_, er, k);
            }
          }
          F || (F = new Tc());
          var ea = F.get(_);
          if (ea) return ea;
          F.set(_, U),
            cw(_)
              ? _.forEach(function (N) {
                  U.add(Jp(N, L, R, N, _, F));
                })
              : cx(_) &&
                _.forEach(function (N, z) {
                  U.set(z, Jp(N, L, R, z, _, F));
                });
          var eo = X ? (Y ? Yp : Zd) : Y ? xc : vc,
            el = Q ? void 0 : eo(_);
          return (
            SA(el || _, function (N, z) {
              el && (N = _[(z = N)]), fc(U, z, Jp(N, L, R, z, _, F));
            }),
            U
          );
        },
        Qs = function (_) {
          return $p(_, 5);
        };
      function em(_) {
        var L = -1,
          R = null == _ ? 0 : _.length;
        for (this.__data__ = new wc(); ++L < R; ) this.add(_[L]);
      }
      (em.prototype.add = em.prototype.push =
        function (_) {
          return this.__data__.set(_, "__lodash_hash_undefined__"), this;
        }),
        (em.prototype.has = function (_) {
          return this.__data__.has(_);
        });
      var cC,
        cD,
        cO,
        cL,
        cR,
        cI,
        eT = function (_, L) {
          for (var R = -1, N = null == _ ? 0 : _.length; ++R < N; )
            if (L(_[R], R, _)) return !0;
          return !1;
        },
        tm = function (_, L, R, N, z, F) {
          var U = 1 & R,
            k = _.length,
            Y = L.length;
          if (k != Y && !(U && Y > k)) return !1;
          var X = F.get(_),
            Q = F.get(L);
          if (X && Q) return X == L && Q == _;
          var K = -1,
            J = !0,
            $ = 2 & R ? new em() : void 0;
          for (F.set(_, L), F.set(L, _); ++K < k; ) {
            var ee = _[K],
              er = L[K];
            if (N) var en = U ? N(er, ee, K, L, _, F) : N(ee, er, K, _, L, F);
            if (void 0 !== en) {
              if (en) continue;
              J = !1;
              break;
            }
            if ($) {
              if (
                !eT(L, function (_, L) {
                  if (!$.has(L) && (ee === _ || z(ee, _, R, N, F)))
                    return $.push(L);
                })
              ) {
                J = !1;
                break;
              }
            } else if (!(ee === er || z(ee, er, R, N, F))) {
              J = !1;
              break;
            }
          }
          return F.delete(_), F.delete(L), J;
        },
        nT = function (_) {
          var L = -1,
            R = Array(_.size);
          return (
            _.forEach(function (_, N) {
              R[++L] = [N, _];
            }),
            R
          );
        },
        rT = function (_) {
          var L = -1,
            R = Array(_.size);
          return (
            _.forEach(function (_) {
              R[++L] = _;
            }),
            R
          );
        },
        cB = lE ? lE.prototype : void 0,
        cN = cB ? cB.valueOf : void 0,
        sT = function (_, L, R, N, z, F, U) {
          switch (R) {
            case "[object DataView]":
              if (_.byteLength != L.byteLength || _.byteOffset != L.byteOffset)
                break;
              (_ = _.buffer), (L = L.buffer);
            case "[object ArrayBuffer]":
              return !(
                _.byteLength != L.byteLength || !F(new cf(_), new cf(L))
              );
            case "[object Boolean]":
            case "[object Date]":
            case "[object Number]":
              return hc(+_, +L);
            case "[object Error]":
              return _.name == L.name && _.message == L.message;
            case "[object RegExp]":
            case "[object String]":
              return _ == L + "";
            case "[object Map]":
              var k = nT;
            case "[object Set]":
              var Y = 1 & N;
              if ((k || (k = rT), _.size != L.size && !Y)) break;
              var X = U.get(_);
              if (X) return X == L;
              (N |= 2), U.set(_, L);
              var Q = tm(k(_), k(L), N, z, F, U);
              return U.delete(_), Q;
            case "[object Symbol]":
              if (cN) return cN.call(_) == cN.call(L);
          }
          return !1;
        },
        cz = Object.prototype.hasOwnProperty,
        oT = function (_, L, R, N, z, F) {
          var U = 1 & R,
            k = Zd(_),
            Y = k.length;
          if (Y != Zd(L).length && !U) return !1;
          for (var X = Y; X--; ) {
            var Q = k[X];
            if (!(U ? Q in L : cz.call(L, Q))) return !1;
          }
          var K = F.get(_),
            J = F.get(L);
          if (K && J) return K == L && J == _;
          var $ = !0;
          F.set(_, L), F.set(L, _);
          for (var ee = U; ++X < Y; ) {
            var er = _[(Q = k[X])],
              en = L[Q];
            if (N) var ea = U ? N(en, er, Q, L, _, F) : N(er, en, Q, _, L, F);
            if (!(void 0 === ea ? er === en || z(er, en, R, N, F) : ea)) {
              $ = !1;
              break;
            }
            ee || (ee = "constructor" == Q);
          }
          if ($ && !ee) {
            var eo = _.constructor,
              el = L.constructor;
            eo != el &&
              "constructor" in _ &&
              "constructor" in L &&
              !(
                "function" == typeof eo &&
                eo instanceof eo &&
                "function" == typeof el &&
                el instanceof el
              ) &&
              ($ = !1);
          }
          return F.delete(_), F.delete(L), $;
        },
        cF = "[object Arguments]",
        cU = "[object Array]",
        ck = "[object Object]",
        cj = Object.prototype.hasOwnProperty,
        uT = function (_, L, R, N, z, F) {
          var U = lR(_),
            k = lR(L),
            Y = U ? cU : cu(_),
            X = k ? cU : cu(L);
          (Y = Y == cF ? ck : Y), (X = X == cF ? ck : X);
          var Q = Y == ck,
            K = X == ck,
            J = Y == X;
          if (J && hx(_)) {
            if (!hx(L)) return !1;
            (U = !0), (Q = !1);
          }
          if (J && !Q)
            return (
              F || (F = new Tc()),
              U || hD(_) ? tm(_, L, R, N, z, F) : sT(_, L, Y, R, N, z, F)
            );
          if (!(1 & R)) {
            var $ = Q && cj.call(_, "__wrapped__"),
              ee = K && cj.call(L, "__wrapped__");
            if ($ || ee) {
              var er = $ ? _.value() : _,
                en = ee ? L.value() : L;
              return F || (F = new Tc()), z(er, en, R, N, F);
            }
          }
          return !!J && (F || (F = new Tc()), oT(_, L, R, N, z, F));
        },
        fT = function (_, L) {
          return null != _ && L in Object(_);
        },
        pT = function (_, L, R) {
          L = ui(L, _);
          for (var N = -1, z = L.length, F = !1; ++N < z; ) {
            var U = Go(L[N]);
            if (!(F = null != _ && R(_, U))) break;
            _ = _[U];
          }
          return F || ++N != z
            ? F
            : !!(z = null == _ ? 0 : _.length) &&
                pc(z) &&
                dc(U, z) &&
                (lR(_) || hl(_));
        },
        rm = function () {
          return lM.Date.now();
        },
        cG = Math.max,
        cV = Math.min,
        Qd = function (_, L, R) {
          var N,
            z,
            F,
            U,
            k,
            Y,
            X = 0,
            Q = !1,
            K = !1,
            J = !0;
          if ("function" != typeof _) throw TypeError("Expected a function");
          function f(L) {
            var R = N,
              F = z;
            return (N = z = void 0), (X = L), (U = _.apply(F, R));
          }
          function m(_) {
            var R = _ - Y,
              N = _ - X;
            return void 0 === Y || R >= L || R < 0 || (K && N >= F);
          }
          function y() {
            var _,
              R,
              N,
              z = rm();
            if (m(z)) return v(z);
            k = setTimeout(
              y,
              ((_ = z - Y), (R = z - X), (N = L - _), K ? cV(N, F - R) : N),
            );
          }
          function v(_) {
            return (k = void 0), J && N ? f(_) : ((N = z = void 0), U);
          }
          function w() {
            var _,
              R = rm(),
              F = m(R);
            if (((N = arguments), (z = this), (Y = R), F)) {
              if (void 0 === k)
                return (X = _ = Y), (k = setTimeout(y, L)), Q ? f(_) : U;
              if (K) return clearTimeout(k), (k = setTimeout(y, L)), f(Y);
            }
            return void 0 === k && (k = setTimeout(y, L)), U;
          }
          return (
            (L = O0(L) || 0),
            Hn(R) &&
              ((Q = !!R.leading),
              (F = (K = "maxWait" in R) ? cG(O0(R.maxWait) || 0, L) : F),
              (J = "trailing" in R ? !!R.trailing : J)),
            (w.cancel = function () {
              void 0 !== k && clearTimeout(k),
                (X = 0),
                (N = Y = z = k = void 0);
            }),
            (w.flush = function () {
              return void 0 === k ? U : v(rm());
            }),
            w
          );
        },
        gT = function (_) {
          var L = null == _ ? 0 : _.length;
          return L ? _[L - 1] : void 0;
        },
        Ha = function (_, L) {
          return (function dT(_, L, R, N, z) {
            return (
              _ === L ||
              (null != _ && null != L && (Jn(_) || Jn(L))
                ? uT(_, L, R, N, dT, z)
                : _ != _ && L != L)
            );
          })(_, L);
        },
        vT = function (_, L) {
          var R, N;
          return (
            (L = ui(L, _)),
            (R = _),
            null == (_ = (N = L).length < 2 ? R : Hp(R, d_(N, 0, -1))) ||
              delete _[Go(gT(L))]
          );
        },
        xT = function (_) {
          return u_(_) ? void 0 : _;
        },
        cH = Wp(function (_, L) {
          var R = {};
          if (null == _) return R;
          var N = !1;
          (L = Rp(L, function (L) {
            return (L = ui(L, _)), N || (N = L.length > 1), L;
          })),
            ts(_, Yp(_), R),
            N && (R = $p(R, 7, xT));
          for (var z = L.length; z--; ) vT(R, L[z]);
          return R;
        }),
        bT = function (_, L, R, N) {
          if (!Hn(_)) return _;
          L = ui(L, _);
          for (
            var z = -1, F = L.length, U = F - 1, k = _;
            null != k && ++z < F;

          ) {
            var Y = Go(L[z]),
              X = R;
            if ("__proto__" === Y || "constructor" === Y || "prototype" === Y)
              break;
            if (z != U) {
              var Q = k[Y];
              void 0 === (X = N ? N(Q, Y, k) : void 0) &&
                (X = Hn(Q) ? Q : dc(L[z + 1]) ? [] : {});
            }
            fc(k, Y, X), (k = k[Y]);
          }
          return _;
        },
        ST = function (_, L, R) {
          for (var N = -1, z = L.length, F = {}; ++N < z; ) {
            var U = L[N],
              k = Hp(_, U);
            R(k, U) && bT(F, ui(U, _), k);
          }
          return F;
        },
        cW = Wp(function (_, L) {
          return null == _
            ? {}
            : ST(_, L, function (L, R) {
                return null != _ && pT(_, R, fT);
              });
        }),
        cY = new Promise((_) => {
          cI = _;
        }),
        cX = !1;
      async function ET() {
        if (cX) return;
        let _ = await R.e(6122).then(R.bind(R, 20330));
        await _.init(), cI(_), (cX = !0);
      }
      var cq = class {
        modifyById(_, L) {
          if (void 0 === this[_]) throw Error("not expected");
          {
            let R = { ...this, [_]: L };
            return Object.setPrototypeOf(R, cq.prototype), R;
          }
        }
        add(_, L) {
          return this.runOp({ type: 1, id: _, data: L })?.data ?? this;
        }
        runOp(_) {
          if (1 === _.type) {
            let L = this[_.id],
              R;
            R =
              void 0 === L
                ? { type: 2, id: _.id }
                : { type: 1, id: _.id, data: L };
            let { id: N, data: z } = _,
              F = { ...this, [N]: z };
            return (
              Object.setPrototypeOf(F, cq.prototype),
              { data: F, actual: _, reverse: R }
            );
          }
          if (2 === _.type) {
            let { id: L } = _,
              R = this[L];
            if (void 0 === R) return null;
            {
              let N = { ...this };
              return (
                Object.setPrototypeOf(N, cq.prototype),
                delete N[L],
                { data: N, actual: _, reverse: { type: 1, id: L, data: R } }
              );
            }
          }
          return null;
        }
      };
      function Jd(_) {
        if (void 0 !== _.deepFreeze) {
          _.deepFreeze(_);
          return;
        }
        for (let L of Object.getOwnPropertyNames(_)) {
          let R = _[L];
          R && "object" == typeof R && Jd(R);
        }
        return Object.freeze(_);
      }
      var cQ = class extends Error {};
      function im(_) {
        let L = { ..._ };
        return Object.setPrototypeOf(L, Object.getPrototypeOf(_)), L;
      }
      function ns(_, L, R) {
        if (
          (void 0 === _
            ? void 0 === L
              ? ((_ = 0), (L = 10))
              : (_ = L - 10)
            : void 0 === L && (L = _ + 10),
          _ > L)
        ) {
          let R = _;
          (_ = L), (L = R);
        }
        let N = [],
          z = 1 / (R + 1);
        for (let F = 0; F < R; F++) {
          let R = _ + (L - _) * (F + 0.75 + 0.5 * Math.random()) * z;
          N.push(R);
        }
        return N;
      }
      function Oc(_) {
        return (
          _ instanceof Uint8Array ||
          _ instanceof Uint16Array ||
          _ instanceof Uint32Array ||
          _ instanceof Int8Array ||
          _ instanceof Int16Array ||
          _ instanceof Int32Array ||
          _ instanceof Float32Array ||
          _ instanceof Float64Array
        );
      }
      var cZ = class extends Array {
        constructor(..._) {
          super(..._), Object.setPrototypeOf(this, cZ.prototype);
        }
        deepFreeze() {
          let _ = 0;
          for (; _ < this.length; ) Jd(this[_]), _++;
        }
        fillCaches0(_, L) {
          for (let R of (this.objCaches.set(_.id, _),
          this.parentCaches.set(_.id, L),
          _.children))
            this.fillCaches0(R, _.id);
        }
        fillCaches() {
          if (void 0 === this.objCaches)
            for (let _ of ((this.objCaches = new Map()),
            (this.parentCaches = new Map()),
            this))
              this.fillCaches0(_, null);
        }
        randomId() {
          this.fillCaches();
          let _ = Array.from(this.objCaches.keys());
          if (0 !== _.length)
            return _[Math.max(0, Math.floor(Math.random() * _.length) - 1)];
        }
        nonExistOrDescendantOf(_, L) {
          if (!this.has(_)) return !0;
          for (; _; ) {
            let R = this.parent(_);
            if (R === L) return !0;
            _ = R;
          }
          return !1;
        }
        isDescendantOf(_, L) {
          for (; _; ) {
            let R = this.parent(_);
            if (R === L) return !0;
            _ = R;
          }
          return !1;
        }
        data(_) {
          return this.get(_)?.data;
        }
        has(_) {
          return void 0 !== this.childrenOf(_);
        }
        get(_) {
          return this.fillCaches(), this.objCaches.get(_);
        }
        childrenOf(_) {
          return null === _ ? this : this.get(_)?.children;
        }
        traverseFrom(_, L) {
          if (null === _) this.traverse(L);
          else {
            let R = this.get(_);
            R &&
              (function IT(_, L) {
                if (!0 !== L(_.id, _.data)) for (let R of _.children) IT(R, L);
              })(R, L);
          }
        }
        traverse(_) {
          !(function PT(_, L) {
            for (let R of _) !0 !== L(R.id, R.data) && PT(R.children, L);
          })(this, _);
        }
        totalSize() {
          return this.fillCaches(), this.objCaches.size;
        }
        parent(_) {
          return this.fillCaches(), this.parentCaches.get(_);
        }
        childrenArray(_) {
          return null === _ ? this : this.get(_).children;
        }
        modifyById(_, L) {
          if (void 0 === this.get(_)) throw Error("not expected");
          {
            let R = this.parent(_),
              N = this.childrenArray(R),
              z = N.findIndex((L) => L.id === _);
            if (z < 0) throw Error("not expected");
            let F = N[z];
            return (
              ((N = [...N])[z] = { ...F, data: L }), this.modifyArrayBy(R, N)
            );
          }
        }
        modifyArrayBy(_, L) {
          let R = _,
            N = L;
          for (; null !== R; ) {
            let _ = N,
              L = R;
            if (void 0 === (R = this.parent(R))) throw Error();
            let z = (N = this.childrenArray(R)).findIndex((_) => _.id === L);
            if (z < 0) throw Error();
            (N = [...N])[z] = { ...N[z], children: _ };
          }
          Object.setPrototypeOf(N, cZ.prototype);
          let z = N;
          return z.fillCaches(), z;
        }
        runOp(_) {
          switch (_.type) {
            case 7:
              return this.addOp(_);
            case 8:
              return this.deleteOp(_);
            case 9:
              return this.moveOp(_);
          }
          return null;
        }
        checkDuplicatedIdRec({ id: _, children: L }) {
          if (void 0 !== this.get(_)) return !0;
          for (let _ of L) if (this.checkDuplicatedIdRec(_)) return !0;
          return !1;
        }
        addOp(_) {
          let { parent: L, fi: R, id: N, data: z, children: F } = _;
          if (
            (null !== L && void 0 === this.get(L)) ||
            this.checkDuplicatedIdRec(_)
          )
            return null;
          {
            let U = this.childrenArray(L),
              k = { fi: R, id: N, data: z, children: F };
            return (
              (U = [...U, k]).sort((_, L) => _.fi - L.fi),
              (_.localIndex = U.indexOf(k)),
              {
                data: this.modifyArrayBy(L, U),
                actual: _,
                reverse: { type: 8, id: N },
              }
            );
          }
        }
        deleteOp(_) {
          let { id: L } = _;
          if (null === this.get(L)) return null;
          {
            let R = this.parent(L);
            if (void 0 === R) return null;
            let N = this.childrenArray(R),
              z = N.findIndex((_) => _.id === L);
            _.localIndex = z;
            let F = (N = [...N]).splice(z, 1)[0];
            return {
              data: this.modifyArrayBy(R, N),
              actual: _,
              reverse: { type: 7, ...F, parent: R },
            };
          }
        }
        moveOp(_) {
          let { parent: L, fi: R, id: N } = _;
          if (null !== L && void 0 === this.get(L))
            return this.deleteOp({ type: 8, id: N });
          if (null !== L) {
            let _ = L;
            for (; null !== _; ) {
              if (void 0 === _) throw Error();
              if (_ === N) throw new cQ("cyclic tree");
              _ = this.parent(_);
            }
          }
          let z = this.parent(N);
          if (void 0 === z) return null;
          let F = z,
            U = this.childrenArray(z),
            k = U.findIndex((_) => _.id === N),
            Y = (U = [...U]).splice(k, 1)[0],
            X = this.modifyArrayBy(z, U);
          (z = L), (U = X.childrenArray(z));
          let Q = Y.fi;
          return (
            (U = [...U, (Y = { ...Y, fi: R })]).sort((_, L) => _.fi - L.fi),
            (_.localIndex = U.indexOf(Y)),
            {
              data: (X = X.modifyArrayBy(z, U)),
              actual: _,
              reverse: { type: 9, parent: F, fi: Q, id: N },
            }
          );
        }
        previous(_, L) {
          if (null === L) {
            let L = this.childrenArray(_);
            return 0 === L.length ? null : L[L.length - 1].id;
          }
          let R = null;
          for (let N of this.childrenArray(_)) {
            if (N.id === L) return R;
            R = N.id;
          }
          return null;
        }
        traverseSortNext(_) {
          let L = this.parent(_);
          if (void 0 !== L) {
            let R = this.childrenArray(L),
              N = R.findIndex((L) => L.id === _) + 1;
            if (N < R.length) return R[N].id;
            if (L) return this.traverseSortNext(L);
          }
        }
        sortNext(_) {
          let L = this.childrenArray(_);
          return L.length > 0 ? L[0].id : this.traverseSortNext(_);
        }
        traverseSortPrevious(_) {
          let L = this.childrenArray(_);
          return L.length > 0
            ? this.traverseSortPrevious(L[L.length - 1].id)
            : _;
        }
        sortPrevious(_) {
          let L = this.parent(_);
          if (void 0 !== L) {
            let R = this.childrenArray(L),
              N = R.findIndex((L) => L.id === _) - 1;
            return N >= 0 ? this.traverseSortPrevious(R[N].id) : L;
          }
        }
        getAllSorted(_) {
          let L = [];
          for (let R of _) {
            let _ = this.getWithSortKey(R.id);
            void 0 !== _ && L.push({ ...R, ..._ });
          }
          for (let _ of (L.sort((_, L) =>
            (function (_, L) {
              let R = 0;
              for (; R < _.length && R < L.length; ) {
                if (_[R] < L[R]) return -1;
                if (_[R] > L[R]) return 1;
                R += 1;
              }
              return R !== L.length ? -1 : R !== _.length ? 1 : 0;
            })(_.sortKey, L.sortKey),
          ),
          L))
            delete _.sortKey;
          return L;
        }
        getWithSortKey(_) {
          var L = _;
          let R = [],
            N = this.get(L),
            z = N;
          if (void 0 !== N) {
            for (; L; )
              R.splice(0, 0, N.fi),
                null !== (L = this.parent(L)) && (N = this.get(L));
            return { ...z, sortKey: R };
          }
        }
        insertBeforeHelper(_, L, R) {
          return this.insertAfterHelper(_, this.previous(_, L), R);
        }
        insertAfterHelper(_, L, R) {
          let N = this.childrenArray(_);
          if (null === L) {
            if (0 === N.length) return ns(0, R, R);
            {
              let _ = N[0].fi;
              return ns(_ - R, _, R);
            }
          }
          {
            let z = this.get(L);
            if (void 0 === z || this.parent(L) !== _)
              throw Error("illegal args");
            let F = N.find((_) => _.fi > z.fi);
            if (void 0 !== F) return ns(z.fi, F.fi, R);
            {
              let _ = N[N.length - 1].fi;
              return ns(_, _ + R, R);
            }
          }
        }
      };
      (cJ || (cJ = {})).runOp = function (_, L) {
        if (0 !== L.type) return null;
        if (Array.isArray(_)) {
          let R = L.props,
            N = {},
            z = [..._],
            F = !1;
          if (R)
            for (let _ of Object.keys(R)) {
              let L = parseInt(_);
              if (isNaN(L)) throw Error("wrong index");
              (N[_] = z[L]), (z[L] = R[_]), (F = !0);
            }
          return F
            ? { data: z, actual: L, reverse: { type: 0, props: N } }
            : null;
        }
        {
          let R = L.props,
            N = {},
            z = { ..._ },
            F = !1;
          if (R)
            for (let _ of Object.keys(R)) {
              N[_] = z[_];
              let L = R[_];
              void 0 === L ? delete z[_] : (z[_] = L), (F = !0);
            }
          return F
            ? { data: z, actual: L, reverse: { type: 0, props: N } }
            : null;
        }
      };
      var cK = class extends Array {
        constructor(..._) {
          super(..._), Object.setPrototypeOf(this, cK.prototype);
        }
        deepFreeze() {
          let _ = 0;
          for (; _ < this.length; ) Jd(this[_]), _++;
        }
        fillCaches0(_) {
          this.objCaches.set(_.id, _);
        }
        fillCaches() {
          if (void 0 === this.objCaches)
            for (let _ of ((this.objCaches = new Map()),
            (Object.getOwnPropertyDescriptor(this, "objCaches").enumerable =
              !1),
            this))
              this.fillCaches0(_);
        }
        randomId() {
          this.fillCaches();
          let _ = Array.from(this.objCaches.keys());
          if (0 !== _.length)
            return _[Math.max(0, Math.floor(Math.random() * _.length) - 1)];
        }
        data(_) {
          return this.get(_)?.data;
        }
        get(_) {
          return this.fillCaches(), this.objCaches.get(_);
        }
        modifyById(_, L) {
          if (void 0 === this.get(_)) throw Error("not expected");
          {
            let R = this,
              N = R.findIndex((L) => L.id === _);
            if (N < 0) throw Error("not expected");
            let z = R[N];
            return ((R = [...R])[N] = { ...z, data: L }), this.modifyArrayBy(R);
          }
        }
        modifyArrayBy(_) {
          return (
            Object.setPrototypeOf(_, cK.prototype),
            "u" > typeof t2 || _.fillCaches(),
            _
          );
        }
        runOp(_) {
          switch (_.type) {
            case 4:
              return this.addOp(_);
            case 5:
              return this.deleteOp(_);
            case 6:
              return this.moveOp(_);
          }
          return null;
        }
        addOp(_) {
          let { fi: L, id: R, data: N } = _,
            z = this,
            F = { fi: L, id: R, data: N };
          return (
            (z = [...z, F]).sort((_, L) => _.fi - L.fi),
            (_.localIndex = z.indexOf(F)),
            {
              data: this.modifyArrayBy(z),
              actual: _,
              reverse: { type: 5, id: R },
            }
          );
        }
        deleteOp(_) {
          let { id: L } = _,
            R = this,
            N = R.findIndex((_) => _.id === L);
          if (-1 === N) return null;
          _.localIndex = N;
          let z = (R = [...R]).splice(N, 1)[0];
          return {
            data: this.modifyArrayBy(R),
            actual: _,
            reverse: { type: 4, ...z },
          };
        }
        moveOp(_) {
          let { fi: L, id: R } = _,
            N = this,
            z = (N = [...N]).findIndex((_) => _.id === R);
          if (-1 === z) return null;
          let F = N[z].fi,
            U = { ...N[z], fi: L };
          return (
            (N[z] = U),
            N.sort((_, L) => _.fi - L.fi),
            (_.localIndex = N.indexOf(U)),
            {
              data: this.modifyArrayBy(N),
              actual: _,
              reverse: { type: 6, fi: F, id: R },
            }
          );
        }
        previous(_) {
          if (null === _)
            return 0 === this.length ? null : this[this.length - 1].id;
          let L = null;
          for (let R of this) {
            if (R.id === _) return L;
            L = R.id;
          }
          return null;
        }
        insertBeforeHelper(_, L) {
          return this.insertAfterHelper(this.previous(_), L);
        }
        insertAfterHelper(_, L) {
          if (null === _) {
            if (0 === this.length) return ns(0, L, L);
            {
              let _ = this[0].fi;
              return ns(_ - L, _, L);
            }
          }
          {
            let R = this.get(_);
            if (void 0 === R) throw Error("illegal args");
            let N = this.find((_) => _.fi > R.fi);
            if (void 0 !== N) return ns(R.fi, N.fi, L);
            {
              let _ = this[this.length - 1].fi;
              return ns(_, _ + L, L);
            }
          }
        }
      };
      function Rc(_) {
        return _ && "object" == typeof _ && _ instanceof c0;
      }
      var cJ,
        c$,
        c0 = class {
          unusedFunOverridesTable(_) {}
          runOp(_) {
            let L = [],
              R = this,
              N = 0,
              z = {};
            for (; N < _.path.length; ) {
              if (
                (L.push(R),
                void 0 !== (R = void 0 === R ? void 0 : R[_.path[N]]) && !Rc(R))
              )
                return null;
              N += 1;
            }
            for (let [L, N] of ((R = R ? im(R) : new c0()),
            Object.entries(_.props))) {
              let _ = R[L];
              (z[L] = _), void 0 === N ? delete R[L] : (R[L] = N);
            }
            for (; N > 0; ) {
              if (0 === Object.keys(R).length) {
                let z = L[N - 1];
                z && ((R = im(z)), delete R[_.path[N - 1]]);
              } else {
                let z = L[N - 1];
                if (z) {
                  let L = im(z);
                  (L[_.path[N - 1]] = R), (R = L);
                } else {
                  let L = new c0();
                  (L[_.path[N - 1]] = R), (R = L);
                }
              }
              N -= 1;
            }
            let F = Object.setPrototypeOf(R, c0.prototype),
              U = { ..._, props: z };
            return { data: F, actual: _, reverse: U };
          }
        };
      function U0(_, L) {
        if (void 0 === L) return;
        let R = !1,
          N = _.map((_) => {
            let N = _.id,
              z = $d(_.data, L[N]);
            if (
              ((R = R || void 0 !== z),
              void 0 === z && (z = _.data),
              !_.children)
            )
              return { ..._, id: N, data: z };
            {
              let F = U0(_.children, L);
              return (
                void 0 !== F ? (R = !0) : (F = _.children),
                { ..._, id: N, data: z, children: F }
              );
            }
          });
        if (R) return N;
      }
      function $d(_, L) {
        if (!Rc(L)) return L;
        if (_ instanceof cZ) {
          let R = U0(_, L);
          return (
            void 0 !== R && Object.setPrototypeOf(R, Object.getPrototypeOf(_)),
            R
          );
        }
        if (_ instanceof cK)
          return (function (_, L) {
            if (void 0 === L) return;
            let R = !1,
              N = _.map((_) => {
                let N = _.id,
                  z = $d(_.data, L[N]);
                return (
                  (R = R || void 0 !== z),
                  void 0 === z && (z = _.data),
                  { ..._, id: N, data: z }
                );
              });
            if (R) return Object.setPrototypeOf(N, Object.getPrototypeOf(_)), N;
          })(_, L);
        if (Array.isArray(_)) {
          let R = !1,
            N = _.map((_, N) => {
              let z = $d(_, L[N]);
              return (R = R || void 0 !== z), void 0 === z && (z = _), z;
            });
          return R
            ? (Object.setPrototypeOf(N, Object.getPrototypeOf(_)), N)
            : void 0;
        }
        if (_ instanceof c0) return G0(_, L);
        if (_ && "object" == typeof _) {
          let R = {},
            N = !1;
          for (let [z, F] of Object.entries(_)) {
            let _ = $d(F, L[z]);
            (N = N || void 0 !== _), void 0 === _ && (_ = F), (R[z] = _);
          }
          return N
            ? (Object.setPrototypeOf(R, Object.getPrototypeOf(_)), R)
            : void 0;
        }
      }
      function G0(_, L) {
        if (void 0 === _) return L;
        if (void 0 === L) return _;
        if (!Rc(L)) return L;
        if (!Rc(_)) return c$.apply(_, L);
        let R = new Set();
        for (let L of Object.keys(_)) R.add(L);
        for (let _ of Object.keys(L)) R.add(_);
        let N = new c0();
        for (let z of R) {
          let R = G0(
            void 0 === _ ? void 0 : _[z],
            void 0 === L ? void 0 : L[z],
          );
          N[z] = R;
        }
        return N;
      }
      function sm(_, L) {
        return null === _ ? null : ((_.cur[_.len] = L), (_.len += 1), _);
      }
      function om(_) {
        _ && (_.len -= 1);
      }
      ((dp = c$ || (c$ = {})).apply = function (_, L) {
        return $d(_, L) ?? _;
      }),
        (dp.merge = function (_, L) {
          return G0(_, L);
        }),
        (dp.filterOp = function (_, L) {
          let R = 0,
            N = L.path,
            z = _;
          for (; R < N.length && void 0 !== z; ) {
            if (void 0 === (z = dx.zoomOnce(z, N[R]))) return L;
            if (!Rc(z)) return;
            R += 1;
          }
          if (void 0 === z) return L;
          if (Rc(z)) {
            if (0 === L.type) {
              let _ = { ...L.props };
              for (let L of Object.keys(z)) delete _[L];
              return { ...L, props: _ };
            }
            {
              if (1 !== L.type && 4 !== L.type && 7 !== L.type) return L;
              let _ = U0([L], z);
              return _ ? (console.log(_), _) : L;
            }
          }
        }),
        ((dm || (dm = {})).replaceProps = function (_, L) {
          let R = dx.zoom(L, _.path);
          if ("object" != typeof R) return { ..._, props: {} };
          {
            let L = {};
            for (let N of Object.keys(_.props)) L[N] = R[N];
            return { ..._, props: L };
          }
        }),
        ((_) => {
          function e(_, L) {
            let R = L.path;
            for (var N = []; ; ) {
              let z;
              if (
                (_ instanceof c0 &&
                  0 === L.type &&
                  null === (z = _.runOp({ ...L, path: R.slice(N.length) })) &&
                  (z = void 0),
                N.length === R.length &&
                  (z =
                    _ instanceof cZ || _ instanceof cK || _ instanceof cq
                      ? _.runOp(L)
                      : cJ.runOp(_, L)),
                void 0 !== z)
              ) {
                if (null === z) return null;
                {
                  let _ = z.data;
                  for (let L = N.length - 1; L >= 0; L--) {
                    let z = R[L],
                      F = N[L];
                    if (F instanceof cZ) {
                      if ("number" == typeof z) throw Error("illegal arg");
                      _ = F.modifyById(z, _);
                    } else if (F instanceof cK) {
                      if ("number" == typeof z) throw Error("illegal arg");
                      _ = F.modifyById(z, _);
                    } else if (F instanceof cq) {
                      if ("number" == typeof z) throw Error("illegal arg");
                      _ = F.modifyById(z, _);
                    } else if (F instanceof c0)
                      _ = Object.setPrototypeOf({ ...F, [z]: _ }, c0.prototype);
                    else if ("object" != typeof F) return null;
                    else if (Array.isArray(F)) {
                      if ("string" == typeof z && isNaN((z = parseInt(z))))
                        throw Error("Invalid path");
                      let L = _;
                      (_ = [...F])[z] = L;
                    } else _ = { ...F, [z]: _ };
                  }
                  return {
                    data: _,
                    actual: { ...z.actual, path: R },
                    reverse: { ...z.reverse, path: R },
                  };
                }
              }
              let F = R[N.length],
                U;
              if (_ instanceof cZ) {
                if ("number" == typeof F) throw Error("");
                U = _.get(F)?.data;
              } else if (_ instanceof cK) {
                if ("number" == typeof F) throw Error("");
                U = _.get(F)?.data;
              } else null !== _ && (U = _[F]);
              if (void 0 === U) return null;
              N.push(_), (_ = U);
            }
          }
          function n(_, L) {
            for (let R = 0; R < _.length && R < L.length; R++)
              if (_[R] !== L[R]) return !0;
            return !1;
          }
          function i(_, L) {
            if (_.length !== L.length) return !1;
            for (let R = 0; R < _.length; R++) if (_[R] !== L[R]) return !1;
            return !0;
          }
          (_.drop = function (_, L) {
            return { ..._, path: _.path.slice(L) };
          }),
            (_.applySimple = function (_, L) {
              return e(_, L)?.data ?? _;
            }),
            (_.apply = e),
            (_.pathDisjoint = n),
            (_.pathEq = i),
            (_.commutative = function (_, L) {
              return n(_.path, L.path);
            }),
            (_.subsumed = function (_, L) {
              return (
                !!(0 === _.type && 0 === L.type && i(_.path, L.path)) &&
                Object.keys(_.props).every((_) => void 0 !== L.props[_])
              );
            });
        })(dg || (dg = {})),
        ((_) => {
          function a(_, L) {
            var R = _;
            let N = [],
              z = [];
            for (let _ of L)
              try {
                if (3 === _.type) {
                  let L = dx.zoom(R, [..._.path, _.id]),
                    F = dg.apply(R, { ..._, type: 2 });
                  if (null !== F) {
                    R = F.data;
                    let [U, k] = (function (_, L) {
                      let R = { cur: [], result: [], len: 0 };
                      return [
                        (_ =
                          (function eh(_, L, R) {
                            if (_ instanceof cZ) {
                              let N = (function OT(_, L, R) {
                                let N = !1,
                                  z = _.map((_) => {
                                    let z = _.id,
                                      F = L[z];
                                    if (
                                      void 0 !== F &&
                                      "string" == typeof F &&
                                      ((N = !0), (z = F), null !== R)
                                    )
                                      throw Error("not supported");
                                    let U = eh(_.data, L, sm(R, z));
                                    om(R),
                                      (N = N || void 0 !== U),
                                      void 0 === U && (U = _.data);
                                    let k = OT(_.children, L, R);
                                    return (
                                      void 0 !== k
                                        ? (N = !0)
                                        : (k = _.children),
                                      { ..._, id: z, data: U, children: k }
                                    );
                                  });
                                if (N) return z;
                              })(_, L, R);
                              return (
                                void 0 !== N &&
                                  Object.setPrototypeOf(
                                    N,
                                    Object.getPrototypeOf(_),
                                  ),
                                N
                              );
                            }
                            if (_ instanceof cK)
                              return (function (_, L, R) {
                                let N = !1,
                                  z = _.map((_) => {
                                    let z = _.id,
                                      F = L[z];
                                    if (
                                      void 0 !== F &&
                                      "string" == typeof F &&
                                      ((N = !0), (z = F), null !== R)
                                    )
                                      throw Error("not supported");
                                    let U = eh(_.data, L, sm(R, z));
                                    return (
                                      om(R),
                                      (N = N || void 0 !== U),
                                      void 0 === U && (U = _.data),
                                      { ..._, id: z, data: U }
                                    );
                                  });
                                if (N)
                                  return (
                                    Object.setPrototypeOf(
                                      z,
                                      Object.getPrototypeOf(_),
                                    ),
                                    z
                                  );
                              })(_, L, R);
                            if (Array.isArray(_)) {
                              let N = !1,
                                z = _.map((_, z) => {
                                  let F = eh(_, L, sm(R, z));
                                  return (
                                    om(R),
                                    (N = N || void 0 !== F),
                                    void 0 === F && (F = _),
                                    F
                                  );
                                });
                              return N
                                ? (Object.setPrototypeOf(
                                    z,
                                    Object.getPrototypeOf(_),
                                  ),
                                  z)
                                : void 0;
                            }
                            if (_ && "object" == typeof _ && !Oc(_)) {
                              let N = {},
                                z = !1;
                              for (let [F, U] of Object.entries(_))
                                if ("name" !== F && "text" !== F) {
                                  let _ = L[F];
                                  if ("string" == typeof _) {
                                    if (null !== R)
                                      throw Error("not supported");
                                    (z = !0), (F = _);
                                  }
                                  let k = eh(U, L, sm(R, F));
                                  om(R),
                                    (z = z || void 0 !== k),
                                    void 0 === k && (k = U),
                                    (N[F] = k);
                                } else N[F] = U;
                              return z
                                ? (Object.setPrototypeOf(
                                    N,
                                    Object.getPrototypeOf(_),
                                  ),
                                  N)
                                : void 0;
                            }
                            {
                              if ("string" != typeof _) return;
                              let z = L[_];
                              if (void 0 !== z) {
                                var N;
                                if (36 !== _.length)
                                  throw Error(
                                    "for now you should only call this method when the key is a uuid",
                                  );
                                (N = R),
                                  null !== N &&
                                    N.result.push(N.cur.slice(0, N.len));
                              }
                              return z;
                            }
                          })(_, L, R) ?? _),
                        R.result,
                      ];
                    })(R, { [_.id]: L });
                    for (let F of ((R = U), k)) {
                      let R = F[F.length - 1];
                      F.splice(F.length - 1, 1),
                        N.push({ type: 0, path: F, props: { [R]: L } }),
                        z.push({ type: 0, path: F, props: { [R]: _.id } });
                    }
                    z.push(F.reverse), N.push(F.actual);
                  }
                } else {
                  let L = dg.apply(R, _);
                  null !== L &&
                    (N.push(L.actual), (R = L.data), z.push(L.reverse));
                }
              } catch (_) {
                if (_ instanceof cQ) return null;
                throw _;
              }
            return { data: R, actual: N, reverse: z.reverse() };
          }
          (_.empty = function () {
            return [];
          }),
            (_.removePrefix = function (_, L) {
              let R = [];
              for (let N of _) {
                let [_, ...z] = N.path;
                _ === L && R.push({ ...N, path: z });
              }
              return R;
            }),
            (_.addPrefix = function (_, L) {
              return _.map((_) => ({ ..._, path: [L, ..._.path] }));
            }),
            (_.concat = function (_, L) {
              return [..._, ...L];
            }),
            (_.compress = function (_, L) {
              return [
                ..._.filter((_) => !L.some((L) => dg.subsumed(_, L))),
                ...L,
              ];
            }),
            (_.commutative = function (_, L) {
              return _.every((_) => L.every((L) => dg.commutative(_, L)));
            }),
            (_.applyAll = function (_, L) {
              for (let R of L) {
                let L = a(_, R);
                null !== L && (_ = L.data);
              }
              return _;
            }),
            (_.apply = a);
        })(dv || (dv = {}));
      var c4 = Symbol(),
        c5 = Symbol(),
        c6 = Symbol(),
        c8 = class {
          reportOp(_, L, R = []) {
            let N = this;
            if (null !== L) {
              for (N._current = L.data; !(N instanceof da); ) {
                let _ = N._path,
                  L = N._current;
                if (("" !== _ && R.splice(0, 0, _), null === (N = N._parent)))
                  return;
                N.update(_, L);
              }
              N.push(R, _, L.actual, L.reverse);
            }
          }
          deleteChildren(_) {
            if (this._children) {
              let L = this._children[_];
              if (L) {
                let R = L[c6];
                R && R(), delete this._children[_];
              }
            }
          }
        },
        c9 = class extends c8 {
          constructor(_, L, R) {
            super(), (this._parent = _), (this._path = L), (this._current = R);
          }
          update(_, L) {
            if (Array.isArray(this._current)) {
              if ("string" == typeof _ && isNaN((_ = parseInt(_))))
                throw Error("Invalid path");
              (this._current = [...this._current]), (this._current[_] = L);
            } else this._current = { ...this._current, [_]: L };
          }
          runOp(_) {
            this.reportOp(_, cJ.runOp(this._current, _), _.path);
          }
        },
        c7 = class extends c8 {
          constructor(_, L, R) {
            super(), (this._parent = _), (this._path = L), (this._current = R);
          }
          update(_, L) {
            (this._current = { ...this._current, [_]: L }),
              Object.setPrototypeOf(this._current, cq.prototype);
          }
          runOp(_) {
            this.reportOp(_, this._current.runOp(_));
          }
        },
        de = {
          get(_, L) {
            if (L === c6)
              return () => {
                _._parent = null;
              };
            if (L === c4) return _._current;
            if (L === c5) return _;
            let { _current: R, _children: N } = _;
            if ("push" === L && Array.isArray(R))
              throw Error("not supported to expand array");
            let z = void 0 === N ? void 0 : N[L];
            if (void 0 !== z) return z;
            let F = R[L],
              U = um(_, L, F);
            return U !== F
              ? (void 0 === N && ((N = {}), (_._children = N)), (N[L] = U), U)
              : F;
          },
          has: (_, L) => L in _._current,
          ownKeys: (_) => Reflect.ownKeys(_._current),
          defineProperty() {
            throw Error("not supported");
          },
          getPrototypeOf: (_) => Object.getPrototypeOf(_._current),
          setPrototypeOf() {
            throw Error("not supported");
          },
          getOwnPropertyDescriptor(_, L) {
            let R = _._current,
              N = Reflect.getOwnPropertyDescriptor(R, L);
            return (
              N && {
                writable: !0,
                configurable: !0,
                enumerable: N.enumerable,
                value: R[L],
              }
            );
          },
        },
        dt = {
          ...de,
          set(_, L, R) {
            let N = { type: 0, props: { [L]: Wn(R) ?? R } };
            return _.deleteChildren(L), _.runOp(N), !0;
          },
          deleteProperty: (_, L) => (
            _.deleteChildren(L),
            _.runOp({ type: 0, props: { [L]: void 0 } }),
            !0
          ),
        },
        di = {
          ...de,
          set(_, L, R) {
            return (
              void 0 === R
                ? this.deleteProperty(_, L)
                : (_.deleteChildren(L), _.runOp({ type: 1, id: L, data: R })),
              !0
            );
          },
          deleteProperty: (_, L) => (_.runOp({ type: 2, id: L }), !0),
        },
        ds = class extends c8 {
          constructor(_, L, R) {
            super(),
              (this._children = {}),
              (this._parent = _),
              (this._path = L),
              (this._current = R),
              (this[c6] = () => {
                this._parent = null;
              });
          }
          unproxy() {
            return this._current;
          }
          update(_, L) {
            this._current = this._current.modifyById(_, L);
          }
          runOp(_) {
            this.reportOp(_, this._current.runOp(_));
          }
          randomId() {
            return this._current.randomId();
          }
          isDescendantOf(_, L) {
            return this._current.isDescendantOf(_, L);
          }
          childrenOf(_) {
            return this._current.childrenOf(_);
          }
          traverse(_) {
            return this._current.traverse(_);
          }
          get(_) {
            return this._current.get(_);
          }
          parent(_) {
            return this._current.parent(_);
          }
          traverse(_) {
            this._current.traverse((L, R) => {
              _(L, this.data(L));
            });
          }
          data(_) {
            let { _current: L, _children: R } = this,
              N = void 0 === R ? void 0 : R[_];
            if (void 0 !== N) return N;
            let z = L.get(_)?.data,
              F = um(this, _, z);
            return F !== z
              ? (void 0 === R && ((R = {}), (this._children = R)),
                (R[_] = F),
                F)
              : z;
          }
          add(_, L, R, N, z) {
            this.runOp({
              type: 7,
              parent: _,
              fi: L,
              id: R,
              data: N,
              children: z,
            });
          }
          move(_, L, R) {
            this.runOp({ type: 9, parent: _, fi: L, id: R });
          }
          insertAfter(_, L, R) {
            let N = this._current.insertAfterHelper(_, L, R.length);
            for (let L = 0; L < R.length; L++) {
              let z = R[L];
              this.add(_, N[L], z.id, z.data, z.children);
            }
          }
          insertBefore(_, L, R) {
            let N = this._current.insertBeforeHelper(_, L, R.length);
            for (let L = 0; L < R.length; L++) {
              let z = R[L];
              this.add(_, N[L], z.id, z.data, z.children);
            }
          }
          moveAfter(_, L, R) {
            let N = this._current.insertAfterHelper(_, L, R.length);
            for (let L = 0; L < R.length; L++) {
              let z = R[L];
              this.move(_, N[L], z);
            }
          }
          moveBefore(_, L, R) {
            let N = this._current.insertBeforeHelper(_, L, R.length);
            for (let L = 0; L < R.length; L++) {
              let z = R[L];
              this.move(_, N[L], z);
            }
          }
          delete(_) {
            this.deleteChildren(_), this.runOp({ type: 8, id: _ });
          }
          sortNext(_) {
            return this._current.sortNext(_);
          }
          sortPrevious(_) {
            return this._current.sortPrevious(_);
          }
          getAllSorted(_) {
            return this._current.getAllSorted(_);
          }
        },
        dn = class extends c8 {
          constructor(_, L, R) {
            super(),
              (this._children = {}),
              (this._parent = _),
              (this._path = L),
              (this._current = R),
              (this[c6] = () => {
                this._parent = null;
              });
          }
          unproxy() {
            return this._current;
          }
          get length() {
            return this._current.length;
          }
          forEach(_) {
            let L = this.length;
            for (let R = 0; R < L; R++) {
              let L = this._current[R].id,
                N = this._current[R].fi;
              _(this.data(this._current[R].id), L, N);
            }
          }
          find(_) {
            let L = this.length;
            for (let R = 0; R < L; R++) {
              let L = this._current[R].id;
              if (_(this.data(L), L)) return this.get(L);
            }
          }
          update(_, L) {
            this._current = this._current.modifyById(_, L);
          }
          randomId() {
            return this._current.randomId();
          }
          get(_) {
            return { ...this._current.get(_), data: this.data(_) };
          }
          data(_) {
            let { _current: L, _children: R } = this,
              N = void 0 === R ? void 0 : R[_];
            if (void 0 !== N) return N;
            let z = L.get(_)?.data,
              F = um(this, _, z);
            return F !== z
              ? (void 0 === R && ((R = {}), (this._children = R)),
                (R[_] = F),
                F)
              : z;
          }
          runOp(_) {
            this.reportOp(_, this._current.runOp(_));
          }
          add(_, L, R) {
            this.runOp({ type: 4, fi: _, id: L, data: R });
          }
          move(_, L) {
            this.runOp({ type: 6, fi: _, id: L });
          }
          insertAfter(_, L) {
            let R = this._current.insertAfterHelper(_, L.length);
            for (let _ = 0; _ < L.length; _++) {
              let N = L[_];
              this.add(R[_], N.id, N.data);
            }
          }
          insertBefore(_, L) {
            let R = this._current.insertBeforeHelper(_, L.length);
            for (let _ = 0; _ < L.length; _++) {
              let N = L[_];
              this.add(R[_], N.id, N.data);
            }
          }
          moveAfter(_, L) {
            let R = this._current.insertAfterHelper(_, L.length);
            for (let _ = 0; _ < L.length; _++) {
              let N = L[_];
              this.move(R[_], N);
            }
          }
          moveBefore(_, L) {
            let R = this._current.insertBeforeHelper(_, L.length);
            for (let _ = 0; _ < L.length; _++) {
              let N = L[_];
              this.move(R[_], N);
            }
          }
          delete(_) {
            this.deleteChildren(_), this.runOp({ type: 5, id: _ });
          }
        };
      function z0(_, L, R) {
        if (_.length > 0) {
          let N = _[_.length - 1];
          if (0 === N.type && 0 === L.type && dx.equal(N.path, R)) {
            Object.assign(N.props, L.props);
            return;
          }
        }
        _.push({ ...L, path: R });
      }
      var da = class extends c8 {
        constructor(_) {
          super(),
            (this.ts = []),
            (this.actual = []),
            (this.reverse = []),
            (this._current = _);
        }
        update(_, L) {
          if ("" !== _) throw Error("");
          this._current = L;
        }
        push(_, L, R, N) {
          z0(this.ts, L, _), z0(this.actual, R, _), z0(this.reverse, N, _);
        }
        result() {
          return {
            data: this._current,
            ts: this.ts,
            actual: this.actual,
            reverse: this.reverse.reverse(),
          };
        }
      };
      function um(_, L, R) {
        return R instanceof cZ
          ? new ds(_, L, R)
          : R instanceof cK
            ? new dn(_, L, R)
            : R instanceof cq
              ? new Proxy(new c7(_, L, R), di)
              : null !== R && "object" == typeof R
                ? Oc(R)
                  ? R
                  : new Proxy(new c9(_, L, R), dt)
                : R;
      }
      function W0(_) {
        let L = new da(_);
        return [um(L, "", _), L];
      }
      function Fc(_, L) {
        let [R, N] = W0(_);
        return L(R), N.result();
      }
      function Wn(_) {
        return _ instanceof ds || _ instanceof dn
          ? _._current
          : null !== _ && "object" == typeof _
            ? _[c4]
            : _;
      }
      function Di(_, L) {
        let R = [];
        if (!(L.length <= _.length)) return null;
        for (var N = 0; N < L.length; ) {
          if ("*" === L[N]) R.push(_[N]);
          else if (_[N] !== L[N]) return null;
          N += 1;
        }
        return R;
      }
      ((_) => {
        function e(_, L) {
          return ((_ instanceof cZ || _ instanceof ds) &&
            "string" == typeof L) ||
            ((_ instanceof cK || _ instanceof dn) && "string" == typeof L)
            ? _.data(L)
            : ("number" == typeof L && Array.isArray(_)) ||
                ("string" == typeof L && "object" == typeof _ && null !== _)
              ? _[L]
              : void 0;
        }
        function n(_, L, R = 0) {
          for (; R < L.length && void 0 !== _; ) (_ = e(_, L[R])), (R += 1);
          return _;
        }
        (_.equal = function (_, L) {
          if (L.length !== _.length) return !1;
          for (var R = 0; R < _.length; ) {
            if (_[R] !== L[R]) return !1;
            R += 1;
          }
          return !0;
        }),
          (_.removeOverridden = function (_, L, R) {
            let N = n(R, _);
            if (void 0 === N || "object" != typeof N || null === N) return L;
            {
              let _ = { ...L };
              return (
                Object.keys(N).forEach((L) => {
                  delete _[L];
                }),
                _
              );
            }
          }),
          (_.zoomOnce = e),
          (_.zoom = n);
      })(dx || (dx = {}));
      var dl = class {},
        dh = class extends dl {
          constructor(_) {
            super(), (this.id = _);
          }
        },
        du = class extends dl {
          constructor(_) {
            super(), (this.data = _);
          }
        };
      try {
        db = new TextDecoder();
      } catch {}
      var dp,
        dm,
        dg,
        dv,
        dx,
        db,
        dw,
        dA,
        dM,
        dE,
        dD,
        dO,
        dL,
        dR = 0,
        dI = [],
        dB = dI,
        dz = 0,
        dF = {},
        dU = 0,
        dk = 0,
        dj = [],
        dG = { useRecords: !1, mapsAsObjects: !0 },
        dV = class {},
        dW = new dV();
      dW.name = "MessagePack 0xC1";
      var dY = !1,
        dX = class {
          constructor(_) {
            _ &&
              (!1 === _.useRecords &&
                void 0 === _.mapsAsObjects &&
                (_.mapsAsObjects = !0),
              _.structures
                ? (_.structures.sharedLength = _.structures.length)
                : _.getStructures &&
                  (((_.structures = []).uninitialized = !0),
                  (_.structures.sharedLength = 0))),
              Object.assign(this, _);
          }
          unpack(_, L) {
            if (dw)
              return YT(
                () => (
                  fm(),
                  this ? this.unpack(_, L) : dX.prototype.unpack.call(dG, _, L)
                ),
              );
            (dA = L > -1 ? L : _.length),
              (dR = 0),
              (dz = 0),
              (dk = 0),
              (dE = null),
              (dB = dI),
              (dD = null),
              (dw = _);
            try {
              dL =
                _.dataView ||
                (_.dataView = new DataView(
                  _.buffer,
                  _.byteOffset,
                  _.byteLength,
                ));
            } catch (L) {
              throw (
                ((dw = null),
                _ instanceof Uint8Array
                  ? L
                  : Error(
                      "Source must be a Uint8Array or Buffer but was a " +
                        (_ && "object" == typeof _
                          ? _.constructor.name
                          : typeof _),
                    ))
              );
            }
            if (this instanceof dX) {
              if (((dF = this), this.structures))
                return (dM = this.structures), hm();
              (!dM || dM.length > 0) && (dM = []);
            } else (dF = dG), (!dM || dM.length > 0) && (dM = []);
            return hm();
          }
          unpackMultiple(_, L) {
            let R,
              N = 0;
            try {
              dY = !0;
              let z = _.length,
                F = this ? this.unpack(_, z) : d5.unpack(_, z);
              if (L) {
                for (L(F); dR < z; ) if (((N = dR), !1 === L(hm()))) return;
              } else {
                for (R = [F]; dR < z; ) (N = dR), R.push(hm());
                return R;
              }
            } catch (_) {
              throw ((_.lastPosition = N), (_.values = R), _);
            } finally {
              (dY = !1), fm();
            }
          }
          _mergeStructures(_, L) {
            _ = _ || [];
            for (let L = 0, R = _.length; L < R; L++) {
              let R = _[L];
              R && ((R.isShared = !0), L >= 32 && (R.highByte = (L - 32) >> 5));
            }
            for (let R in ((_.sharedLength = _.length), L || []))
              if (R >= 0) {
                let N = _[R],
                  z = L[R];
                z &&
                  (N &&
                    ((_.restoreStructures || (_.restoreStructures = []))[R] =
                      N),
                  (_[R] = z));
              }
            return (this.structures = _);
          }
          decode(_, L) {
            return this.unpack(_, L);
          }
        };
      function hm() {
        try {
          if (!dF.trusted && !dY) {
            let _ = dM.sharedLength || 0;
            _ < dM.length && (dM.length = _);
          }
          let _ = sn();
          if (dR == dA)
            dM.restoreStructures && FT(),
              (dM = null),
              (dw = null),
              dO && (dO = null);
          else if (dR > dA) {
            let _ = Error("Unexpected end of MessagePack data");
            throw ((_.incomplete = !0), _);
          } else if (!dY)
            throw Error("Data read, but end of buffer not reached");
          return _;
        } catch (_) {
          throw (
            (dM.restoreStructures && FT(),
            fm(),
            (_ instanceof RangeError ||
              _.message.startsWith("Unexpected end of buffer")) &&
              (_.incomplete = !0),
            _)
          );
        }
      }
      function FT() {
        for (let _ in dM.restoreStructures) dM[_] = dM.restoreStructures[_];
        dM.restoreStructures = null;
      }
      function sn() {
        let _ = dw[dR++];
        if (_ < 160) {
          if (_ < 128) {
            if (_ < 64) return _;
            {
              let L = dM[63 & _] || (dF.getStructures && WT()[63 & _]);
              return L ? (L.read || (L.read = Q0(L, 63 & _)), L.read()) : _;
            }
          }
          if (_ < 144) {
            if (((_ -= 128), dF.mapsAsObjects)) {
              let L = {};
              for (let R = 0; R < _; R++) L[qT()] = sn();
              return L;
            }
            {
              let L = new Map();
              for (let R = 0; R < _; R++) L.set(sn(), sn());
              return L;
            }
          }
          {
            let L = Array((_ -= 144));
            for (let R = 0; R < _; R++) L[R] = sn();
            return L;
          }
        }
        if (_ < 192) {
          let L = _ - 160;
          if (dk >= dR) return dE.slice(dR - dU, (dR += L) - dU);
          if (0 == dk && dA < 140) {
            let _ = L < 16 ? J0(L) : jT(L);
            if (null != _) return _;
          }
          return dQ(L);
        }
        {
          let L;
          switch (_) {
            case 192:
              return null;
            case 193:
              return dD
                ? (L = sn()) > 0
                  ? dD[1].slice(dD.position1, (dD.position1 += L))
                  : dD[0].slice(dD.position0, (dD.position0 -= L))
                : dW;
            case 194:
              return !1;
            case 195:
              return !0;
            case 196:
              return j0(dw[dR++]);
            case 197:
              return (L = dL.getUint16(dR)), (dR += 2), j0(L);
            case 198:
              return (L = dL.getUint32(dR)), (dR += 4), j0(L);
            case 199:
              return ja(dw[dR++]);
            case 200:
              return (L = dL.getUint16(dR)), (dR += 2), ja(L);
            case 201:
              return (L = dL.getUint32(dR)), (dR += 4), ja(L);
            case 202:
              if (((L = dL.getFloat32(dR)), dF.useFloat32 > 2)) {
                let _ = d4[((127 & dw[dR]) << 1) | (dw[dR + 1] >> 7)];
                return (dR += 4), ((_ * L + (L > 0 ? 0.5 : -0.5)) >> 0) / _;
              }
              return (dR += 4), L;
            case 203:
              return (L = dL.getFloat64(dR)), (dR += 8), L;
            case 204:
              return dw[dR++];
            case 205:
              return (L = dL.getUint16(dR)), (dR += 2), L;
            case 206:
              return (L = dL.getUint32(dR)), (dR += 4), L;
            case 207:
              return (
                (L = dF.int64AsNumber
                  ? 4294967296 * dL.getUint32(dR) + dL.getUint32(dR + 4)
                  : dL.getBigUint64(dR)),
                (dR += 8),
                L
              );
            case 208:
              return dL.getInt8(dR++);
            case 209:
              return (L = dL.getInt16(dR)), (dR += 2), L;
            case 210:
              return (L = dL.getInt32(dR)), (dR += 4), L;
            case 211:
              return (
                (L = dF.int64AsNumber
                  ? 4294967296 * dL.getInt32(dR) + dL.getUint32(dR + 4)
                  : dL.getBigInt64(dR)),
                (dR += 8),
                L
              );
            case 212:
              if (114 == (L = dw[dR++])) return VT(63 & dw[dR++]);
              {
                let _ = dj[L];
                if (_)
                  return _.read
                    ? (dR++, _.read(sn()))
                    : _.noBuffer
                      ? (dR++, _())
                      : _(dw.subarray(dR, ++dR));
                throw Error("Unknown extension " + L);
              }
            case 213:
              return 114 == (L = dw[dR])
                ? (dR++, VT(63 & dw[dR++], dw[dR++]))
                : ja(2);
            case 214:
              return ja(4);
            case 215:
              return ja(8);
            case 216:
              return ja(16);
            case 217:
              return (
                (L = dw[dR++]),
                dk >= dR ? dE.slice(dR - dU, (dR += L) - dU) : dZ(L)
              );
            case 218:
              return (
                (L = dL.getUint16(dR)),
                (dR += 2),
                dk >= dR ? dE.slice(dR - dU, (dR += L) - dU) : dK(L)
              );
            case 219:
              return (
                (L = dL.getUint32(dR)),
                (dR += 4),
                dk >= dR ? dE.slice(dR - dU, (dR += L) - dU) : dJ(L)
              );
            case 220:
              return (L = dL.getUint16(dR)), (dR += 2), GT(L);
            case 221:
              return (L = dL.getUint32(dR)), (dR += 4), GT(L);
            case 222:
              return (L = dL.getUint16(dR)), (dR += 2), kT(L);
            case 223:
              return (L = dL.getUint32(dR)), (dR += 4), kT(L);
            default:
              if (_ >= 224) return _ - 256;
              if (void 0 === _) {
                let _ = Error("Unexpected end of MessagePack data");
                throw ((_.incomplete = !0), _);
              }
              throw Error("Unknown MessagePack token " + _);
          }
        }
      }
      var dq = /^[a-zA-Z_$][a-zA-Z\d_$]*$/;
      function Q0(_, L) {
        function e() {
          if (e.count++ > 2) {
            let R = (_.read = Function(
              "r",
              "return function(){return {" +
                _.map((_) =>
                  dq.test(_) ? _ + ":r()" : "[" + JSON.stringify(_) + "]:r()",
                ).join(",") +
                "}}",
            )(sn));
            return 0 === _.highByte && (_.read = UT(L, _.read)), R();
          }
          let R = {};
          for (let L = 0, N = _.length; L < N; L++) R[_[L]] = sn();
          return R;
        }
        return (e.count = 0), 0 === _.highByte ? UT(L, e) : e;
      }
      var UT = (_, L) =>
        function () {
          let R = dw[dR++];
          if (0 === R) return L();
          let N = _ < 32 ? -(_ + (R << 5)) : _ + (R << 5),
            z = dM[N] || WT()[N];
          if (!z) throw Error("Record id is not defined for " + N);
          return z.read || (z.read = Q0(z, _)), z.read();
        };
      function WT() {
        let _ = YT(() => ((dw = null), dF.getStructures()));
        return (dM = dF._mergeStructures(_, dM));
      }
      var dQ = pm,
        dZ = pm,
        dK = pm,
        dJ = pm;
      function pm(_) {
        let L;
        if (_ < 16 && (L = J0(_))) return L;
        if (_ > 64 && db) return db.decode(dw.subarray(dR, (dR += _)));
        let R = dR + _,
          N = [];
        for (L = ""; dR < R; ) {
          let _ = dw[dR++];
          if ((128 & _) == 0) N.push(_);
          else if ((224 & _) == 192) {
            let L = 63 & dw[dR++];
            N.push(((31 & _) << 6) | L);
          } else if ((240 & _) == 224) {
            let L = 63 & dw[dR++],
              R = 63 & dw[dR++];
            N.push(((31 & _) << 12) | (L << 6) | R);
          } else if ((248 & _) == 240) {
            let L =
              ((7 & _) << 18) |
              ((63 & dw[dR++]) << 12) |
              ((63 & dw[dR++]) << 6) |
              (63 & dw[dR++]);
            L > 65535 &&
              ((L -= 65536),
              N.push(((L >>> 10) & 1023) | 55296),
              (L = 56320 | (1023 & L))),
              N.push(L);
          } else N.push(_);
          N.length >= 4096 && ((L += d$.apply(String, N)), (N.length = 0));
        }
        return N.length > 0 && (L += d$.apply(String, N)), L;
      }
      function GT(_) {
        let L = Array(_);
        for (let R = 0; R < _; R++) L[R] = sn();
        return L;
      }
      function kT(_) {
        if (dF.mapsAsObjects) {
          let L = {};
          for (let R = 0; R < _; R++) L[qT()] = sn();
          return L;
        }
        {
          let L = new Map();
          for (let R = 0; R < _; R++) L.set(sn(), sn());
          return L;
        }
      }
      var d$ = String.fromCharCode;
      function jT(_) {
        let L = dR,
          R = Array(_);
        for (let N = 0; N < _; N++) {
          let _ = dw[dR++];
          if ((128 & _) > 0) {
            dR = L;
            return;
          }
          R[N] = _;
        }
        return d$.apply(String, R);
      }
      function J0(_) {
        if (_ < 4) {
          if (_ < 2) {
            if (0 === _) return "";
            {
              let _ = dw[dR++];
              if ((128 & _) > 1) {
                dR -= 1;
                return;
              }
              return d$(_);
            }
          }
          {
            let L = dw[dR++],
              R = dw[dR++];
            if ((128 & L) > 0 || (128 & R) > 0) {
              dR -= 2;
              return;
            }
            if (_ < 3) return d$(L, R);
            let N = dw[dR++];
            if ((128 & N) > 0) {
              dR -= 3;
              return;
            }
            return d$(L, R, N);
          }
        }
        {
          let L = dw[dR++],
            R = dw[dR++],
            N = dw[dR++],
            z = dw[dR++];
          if (
            (128 & L) > 0 ||
            (128 & R) > 0 ||
            (128 & N) > 0 ||
            (128 & z) > 0
          ) {
            dR -= 4;
            return;
          }
          if (_ < 6) {
            if (4 === _) return d$(L, R, N, z);
            {
              let _ = dw[dR++];
              if ((128 & _) > 0) {
                dR -= 5;
                return;
              }
              return d$(L, R, N, z, _);
            }
          }
          if (_ < 8) {
            let F = dw[dR++],
              U = dw[dR++];
            if ((128 & F) > 0 || (128 & U) > 0) {
              dR -= 6;
              return;
            }
            if (_ < 7) return d$(L, R, N, z, F, U);
            let k = dw[dR++];
            if ((128 & k) > 0) {
              dR -= 7;
              return;
            }
            return d$(L, R, N, z, F, U, k);
          }
          {
            let F = dw[dR++],
              U = dw[dR++],
              k = dw[dR++],
              Y = dw[dR++];
            if (
              (128 & F) > 0 ||
              (128 & U) > 0 ||
              (128 & k) > 0 ||
              (128 & Y) > 0
            ) {
              dR -= 8;
              return;
            }
            if (_ < 10) {
              if (8 === _) return d$(L, R, N, z, F, U, k, Y);
              {
                let _ = dw[dR++];
                if ((128 & _) > 0) {
                  dR -= 9;
                  return;
                }
                return d$(L, R, N, z, F, U, k, Y, _);
              }
            }
            if (_ < 12) {
              let X = dw[dR++],
                Q = dw[dR++];
              if ((128 & X) > 0 || (128 & Q) > 0) {
                dR -= 10;
                return;
              }
              if (_ < 11) return d$(L, R, N, z, F, U, k, Y, X, Q);
              let K = dw[dR++];
              if ((128 & K) > 0) {
                dR -= 11;
                return;
              }
              return d$(L, R, N, z, F, U, k, Y, X, Q, K);
            }
            {
              let X = dw[dR++],
                Q = dw[dR++],
                K = dw[dR++],
                J = dw[dR++];
              if (
                (128 & X) > 0 ||
                (128 & Q) > 0 ||
                (128 & K) > 0 ||
                (128 & J) > 0
              ) {
                dR -= 12;
                return;
              }
              if (_ < 14) {
                if (12 === _) return d$(L, R, N, z, F, U, k, Y, X, Q, K, J);
                {
                  let _ = dw[dR++];
                  if ((128 & _) > 0) {
                    dR -= 13;
                    return;
                  }
                  return d$(L, R, N, z, F, U, k, Y, X, Q, K, J, _);
                }
              }
              {
                let $ = dw[dR++],
                  ee = dw[dR++];
                if ((128 & $) > 0 || (128 & ee) > 0) {
                  dR -= 14;
                  return;
                }
                if (_ < 15)
                  return d$(L, R, N, z, F, U, k, Y, X, Q, K, J, $, ee);
                let er = dw[dR++];
                if ((128 & er) > 0) {
                  dR -= 15;
                  return;
                }
                return d$(L, R, N, z, F, U, k, Y, X, Q, K, J, $, ee, er);
              }
            }
          }
        }
      }
      function j0(_) {
        return dF.copyBuffers
          ? Uint8Array.prototype.slice.call(dw, dR, (dR += _))
          : dw.subarray(dR, (dR += _));
      }
      function ja(_) {
        let L = dw[dR++];
        if (dj[L]) return dj[L](dw.subarray(dR, (dR += _)));
        throw Error("Unknown extension type " + L);
      }
      var d0 = Array(4096);
      function qT() {
        let _ = dw[dR++];
        if (!(_ >= 160) || !(_ < 192)) return dR--, sn();
        if (((_ -= 160), dk >= dR)) return dE.slice(dR - dU, (dR += _) - dU);
        if (!(0 == dk && dA < 180)) return dQ(_);
        let L =
            ((_ << 5) ^ (_ > 1 ? dL.getUint16(dR) : _ > 0 ? dw[dR] : 0)) & 4095,
          R = d0[L],
          N = dR,
          z = dR + _ - 3,
          F,
          U = 0;
        if (R && R.bytes == _) {
          for (; N < z; ) {
            if ((F = dL.getUint32(N)) != R[U++]) {
              N = 1879048192;
              break;
            }
            N += 4;
          }
          for (z += 3; N < z; )
            if ((F = dw[N++]) != R[U++]) {
              N = 1879048192;
              break;
            }
          if (N === z) return (dR = N), R.string;
          (z -= 3), (N = dR);
        }
        for (R = [], d0[L] = R, R.bytes = _; N < z; )
          (F = dL.getUint32(N)), R.push(F), (N += 4);
        for (z += 3; N < z; ) (F = dw[N++]), R.push(F);
        let k = _ < 16 ? J0(_) : jT(_);
        return null != k ? (R.string = k) : (R.string = dQ(_));
      }
      var VT = (_, L) => {
          var R = sn();
          let N = _;
          void 0 !== L &&
            ((_ = _ < 32 ? -((L << 5) + _) : (L << 5) + _), (R.highByte = L));
          let z = dM[_];
          return (
            z &&
              z.isShared &&
              ((dM.restoreStructures || (dM.restoreStructures = []))[_] = z),
            (dM[_] = R),
            (R.read = Q0(R, N)),
            R.read()
          );
        },
        d1 = "object" == typeof self ? self : global;
      (dj[0] = () => {}),
        (dj[0].noBuffer = !0),
        (dj[101] = () => {
          let _ = sn();
          return (d1[_[0]] || Error)(_[1]);
        }),
        (dj[105] = (_) => {
          let L = dL.getUint32(dR - 4);
          dO || (dO = new Map());
          let R = dw[dR],
            N,
            z = {
              target: (N =
                (R >= 144 && R < 160) || 220 == R || 221 == R ? [] : {}),
            };
          dO.set(L, z);
          let F = sn();
          return z.used ? Object.assign(N, F) : ((z.target = F), F);
        }),
        (dj[112] = (_) => {
          let L = dL.getUint32(dR - 4),
            R = dO.get(L);
          return (R.used = !0), R.target;
        }),
        (dj[115] = () => new Set(sn()));
      var d2 = [
        "Int8",
        "Uint8",
        "Uint8Clamped",
        "Int16",
        "Uint16",
        "Int32",
        "Uint32",
        "Float32",
        "Float64",
        "BigInt64",
        "BigUint64",
      ].map((_) => _ + "Array");
      function YT(_) {
        let L = dA,
          R = dR,
          N = dz,
          z = dU,
          F = dk,
          U = dE,
          k = dB,
          Y = dO,
          X = dD,
          Q = new Uint8Array(dw.slice(0, dA)),
          K = dM,
          J = dM.slice(0, dM.length),
          $ = dF,
          ee = dY,
          er = _();
        return (
          (dA = L),
          (dR = R),
          (dz = N),
          (dU = z),
          (dk = F),
          (dE = U),
          (dB = k),
          (dO = Y),
          (dD = X),
          (dw = Q),
          (dY = ee),
          (dM = K).splice(0, dM.length, ...J),
          (dF = $),
          (dL = new DataView(dw.buffer, dw.byteOffset, dw.byteLength)),
          er
        );
      }
      function fm() {
        (dw = null), (dO = null), (dM = null);
      }
      (dj[116] = (_) => {
        let L = _[0],
          R = d2[L];
        if (!R) throw Error("Could not find typed array for code " + L);
        return new d1[R](Uint8Array.prototype.slice.call(_, 1).buffer);
      }),
        (dj[120] = () => {
          let _ = sn();
          return new RegExp(_[0], _[1]);
        }),
        (dj[98] = (_) => {
          let L = (_[0] << 24) + (_[1] << 16) + (_[2] << 8) + _[3],
            R = dR;
          (dR += L - 4),
            ((dD = [sn(), sn()]).position0 = 0),
            (dD.position1 = 0);
          let N = dR;
          dR = R;
          try {
            return sn();
          } finally {
            dR = N;
          }
        }),
        (dj[255] = (_) =>
          new Date(
            4 == _.length
              ? (16777216 * _[0] + (_[1] << 16) + (_[2] << 8) + _[3]) * 1e3
              : 8 == _.length
                ? ((_[0] << 22) + (_[1] << 14) + (_[2] << 6) + (_[3] >> 2)) /
                    1e6 +
                  ((3 & _[3]) * 4294967296 +
                    16777216 * _[4] +
                    (_[5] << 16) +
                    (_[6] << 8) +
                    _[7]) *
                    1e3
                : 12 == _.length
                  ? ((_[0] << 24) + (_[1] << 16) + (_[2] << 8) + _[3]) / 1e6 +
                    ((128 & _[4] ? -281474976710656 : 0) +
                      1099511627776 * _[6] +
                      4294967296 * _[7] +
                      16777216 * _[8] +
                      (_[9] << 16) +
                      (_[10] << 8) +
                      _[11]) *
                      1e3
                  : "invalid",
          ));
      var d4 = Array(147);
      for (let _ = 0; _ < 256; _++)
        d4[_] = +("1e" + Math.floor(45.15 - 0.30103 * _));
      var d5 = new dX({ useRecords: !1 }),
        d6 = (d5.unpack, d5.unpackMultiple, d5.unpack, new Float32Array(1));
      new Uint8Array(d6.buffer, 0, 4);
      try {
        d8 = new TextEncoder();
      } catch {}
      var d8,
        d9,
        d7,
        ue,
        ut,
        ur,
        us = "u" > typeof t4,
        un = us ? t4.allocUnsafeSlow : Uint8Array,
        ua = us ? t4 : Uint8Array,
        uo = us ? 4294967296 : 2144337920,
        ul = 0,
        uc = null,
        ud = /[\u0080-\uFFFF]/,
        uu = Symbol("record-id"),
        up = class extends dX {
          constructor(_) {
            super(_), (this.offset = 0);
            let L,
              R,
              N,
              z,
              F,
              U = 0,
              k = ua.prototype.utf8Write
                ? function (_, L, R) {
                    return ue.utf8Write(_, L, R);
                  }
                : !!d8 &&
                  !!d8.encodeInto &&
                  function (_, L) {
                    return d8.encodeInto(_, ue.subarray(L)).written;
                  },
              Y = this;
            _ || (_ = {});
            let X = _ && _.sequential,
              Q = _.structures || _.saveStructures,
              K = _.maxSharedStructures;
            if ((null == K && (K = Q ? 32 : 0), K > 8160))
              throw Error("Maximum maxSharedStructure is 8160");
            let J = _.maxOwnStructures;
            null == J && (J = Q ? 32 : 64),
              X && !_.saveStructures && (this.structures = []);
            let $ = K > 32 || J + K > 64,
              ee = K + 64,
              er = K + J + 64;
            if (er > 8256)
              throw Error(
                "Maximum maxSharedStructure + maxOwnStructure is 8192",
              );
            let en = [],
              ea = 0,
              eo = 0;
            this.pack = this.encode = function (_, k) {
              if (
                (ue ||
                  ((ue = new un(8192)),
                  (ut = new DataView(ue.buffer, 0, 8192)),
                  (ul = 0)),
                (ur = ue.length - 10) - ul < 2048
                  ? ((ue = new un(ue.length)),
                    (ut = new DataView(ue.buffer, 0, ue.length)),
                    (ur = ue.length - 10),
                    (ul = 0))
                  : (ul = (ul + 7) & 2147483640),
                (L = ul),
                (F = Y.structuredClone ? new Map() : null),
                Y.bundleStrings
                  ? ((uc = ["", ""]),
                    (ue[ul++] = 214),
                    (ue[ul++] = 98),
                    (uc.position = ul - L),
                    (ul += 4))
                  : (uc = null),
                (R = Y.structures))
              ) {
                R.uninitialized && (R = Y._mergeStructures(Y.getStructures()));
                let _ = R.sharedLength || 0;
                if (_ > K)
                  throw Error(
                    "Shared structures is larger than maximum shared structures, try increasing maxSharedStructures to " +
                      R.sharedLength,
                  );
                if (!R.transitions) {
                  R.transitions = Object.create(null);
                  for (let L = 0; L < _; L++) {
                    let _ = R[L];
                    if (!_) continue;
                    let N,
                      z = R.transitions;
                    for (let L = 0, R = _.length; L < R; L++) {
                      let R = _[L];
                      (N = z[R]) || (N = z[R] = Object.create(null)), (z = N);
                    }
                    z[uu] = L + 64;
                  }
                  U = _;
                }
                X || (R.nextId = _ + 64);
              }
              N && (N = !1), (z = R || []);
              try {
                if ((w(_), uc)) {
                  ut.setUint32(uc.position + L, ul - uc.position - L);
                  let _ = uc;
                  (uc = null), w(_[0]), w(_[1]);
                }
                if (((Y.offset = ul), F && F.idsToInsert)) {
                  (ul += 6 * F.idsToInsert.length) > ur && T(ul),
                    (Y.offset = ul);
                  let _ = (function (_, L) {
                    let R,
                      N = 6 * L.length,
                      z = _.length - N;
                    for (
                      L.sort((_, L) => (_.offset > L.offset ? 1 : -1));
                      (R = L.pop());

                    ) {
                      let L = R.offset,
                        F = R.id;
                      _.copyWithin(L + N, L, z);
                      let U = L + (N -= 6);
                      (_[U++] = 214),
                        (_[U++] = 105),
                        (_[U++] = F >> 24),
                        (_[U++] = (F >> 16) & 255),
                        (_[U++] = (F >> 8) & 255),
                        (_[U++] = 255 & F),
                        (z = L);
                    }
                    return _;
                  })(ue.subarray(L, ul), F.idsToInsert);
                  return (F = null), _;
                }
                return k & uw
                  ? ((ue.start = L), (ue.end = ul), ue)
                  : ue.subarray(L, ul);
              } finally {
                if (R) {
                  if ((eo < 10 && eo++, ea > 1e4))
                    (R.transitions = null),
                      (eo = 0),
                      (ea = 0),
                      en.length > 0 && (en = []);
                  else if (en.length > 0 && !X) {
                    for (let _ = 0, L = en.length; _ < L; _++) en[_][uu] = 0;
                    en = [];
                  }
                  if (N && Y.saveStructures) {
                    let N = R.sharedLength || K;
                    R.length > N && (R = R.slice(0, N));
                    let z = ue.subarray(L, ul);
                    return !1 === Y.saveStructures(R, U)
                      ? (Y._mergeStructures(Y.getStructures()), Y.pack(_))
                      : ((U = N), z);
                  }
                }
                k & uA && (ul = L);
              }
            };
            let w = (_) => {
                ul > ur && (ue = T(ul));
                var R,
                  N = typeof _;
                if ("string" === N) {
                  let L,
                    N = _.length;
                  if (uc && N >= 8 && N < 4096) {
                    let L = ud.test(_);
                    (uc[L ? 0 : 1] += _), (ue[ul++] = 193), w(L ? -N : N);
                    return;
                  }
                  L = N < 32 ? 1 : N < 256 ? 2 : N < 65536 ? 3 : 5;
                  let z = 3 * N;
                  if ((ul + z > ur && (ue = T(ul + z)), N < 64 || !k)) {
                    let z,
                      F,
                      U,
                      k = ul + L;
                    for (z = 0; z < N; z++)
                      (F = _.charCodeAt(z)) < 128
                        ? (ue[k++] = F)
                        : (F < 2048
                            ? (ue[k++] = (F >> 6) | 192)
                            : ((64512 & F) == 55296 &&
                              (64512 & (U = _.charCodeAt(z + 1))) == 56320
                                ? ((F =
                                    65536 + ((1023 & F) << 10) + (1023 & U)),
                                  z++,
                                  (ue[k++] = (F >> 18) | 240),
                                  (ue[k++] = ((F >> 12) & 63) | 128))
                                : (ue[k++] = (F >> 12) | 224),
                              (ue[k++] = ((F >> 6) & 63) | 128)),
                          (ue[k++] = (63 & F) | 128));
                    R = k - ul - L;
                  } else R = k(_, ul + L, z);
                  R < 32
                    ? (ue[ul++] = 160 | R)
                    : R < 256
                      ? (L < 2 && ue.copyWithin(ul + 2, ul + 1, ul + 1 + R),
                        (ue[ul++] = 217),
                        (ue[ul++] = R))
                      : R < 65536
                        ? (L < 3 && ue.copyWithin(ul + 3, ul + 2, ul + 2 + R),
                          (ue[ul++] = 218),
                          (ue[ul++] = R >> 8),
                          (ue[ul++] = 255 & R))
                        : (L < 5 && ue.copyWithin(ul + 5, ul + 3, ul + 3 + R),
                          (ue[ul++] = 219),
                          ut.setUint32(ul, R),
                          (ul += 4)),
                    (ul += R);
                } else if ("number" === N) {
                  if (_ >>> 0 === _)
                    _ < 64
                      ? (ue[ul++] = _)
                      : _ < 256
                        ? ((ue[ul++] = 204), (ue[ul++] = _))
                        : _ < 65536
                          ? ((ue[ul++] = 205),
                            (ue[ul++] = _ >> 8),
                            (ue[ul++] = 255 & _))
                          : ((ue[ul++] = 206), ut.setUint32(ul, _), (ul += 4));
                  else if (_ >> 0 === _)
                    _ >= -32
                      ? (ue[ul++] = 256 + _)
                      : _ >= -128
                        ? ((ue[ul++] = 208), (ue[ul++] = _ + 256))
                        : _ >= -32768
                          ? ((ue[ul++] = 209), ut.setInt16(ul, _), (ul += 2))
                          : ((ue[ul++] = 210), ut.setInt32(ul, _), (ul += 4));
                  else {
                    let L;
                    if (
                      (L = this.useFloat32) > 0 &&
                      _ < 4294967296 &&
                      _ >= -2147483648
                    ) {
                      let R;
                      if (
                        ((ue[ul++] = 202),
                        ut.setFloat32(ul, _),
                        L < 4 ||
                          (R =
                            _ *
                            d4[((127 & ue[ul]) << 1) | (ue[ul + 1] >> 7)]) >>
                            0 ===
                            R)
                      ) {
                        ul += 4;
                        return;
                      }
                      ul--;
                    }
                    (ue[ul++] = 203), ut.setFloat64(ul, _), (ul += 8);
                  }
                } else if ("object" === N) {
                  if (_) {
                    if (F) {
                      let R = F.get(_);
                      if (R) {
                        if (!R.id) {
                          let _ = F.idsToInsert || (F.idsToInsert = []);
                          R.id = _.push(R);
                        }
                        (ue[ul++] = 214),
                          (ue[ul++] = 112),
                          ut.setUint32(ul, R.id),
                          (ul += 4);
                        return;
                      }
                      F.set(_, { offset: ul - L });
                    }
                    let N = _.constructor;
                    if (N === Object) el(_, !0);
                    else if (N === Array) {
                      (R = _.length) < 16
                        ? (ue[ul++] = 144 | R)
                        : R < 65536
                          ? ((ue[ul++] = 220),
                            (ue[ul++] = R >> 8),
                            (ue[ul++] = 255 & R))
                          : ((ue[ul++] = 221), ut.setUint32(ul, R), (ul += 4));
                      for (let L = 0; L < R; L++) w(_[L]);
                    } else if (N === Map)
                      for (let [L, N] of ((R = _.size) < 16
                        ? (ue[ul++] = 128 | R)
                        : R < 65536
                          ? ((ue[ul++] = 222),
                            (ue[ul++] = R >> 8),
                            (ue[ul++] = 255 & R))
                          : ((ue[ul++] = 223), ut.setUint32(ul, R), (ul += 4)),
                      _))
                        w(L), w(N);
                    else {
                      for (let L = 0, R = d9.length; L < R; L++)
                        if (_ instanceof d7[L]) {
                          let R,
                            N = d9[L];
                          if (N.write) {
                            N.type &&
                              ((ue[ul++] = 212),
                              (ue[ul++] = N.type),
                              (ue[ul++] = 0)),
                              w(N.write.call(this, _));
                            return;
                          }
                          let z = ue,
                            F = ut,
                            U = ul;
                          ue = null;
                          try {
                            R = N.pack.call(
                              this,
                              _,
                              (_) => (
                                (ue = z),
                                (z = null),
                                (ul += _) > ur && T(ul),
                                { target: ue, targetView: ut, position: ul - _ }
                              ),
                              w,
                            );
                          } finally {
                            z &&
                              ((ue = z),
                              (ut = F),
                              (ul = U),
                              (ur = ue.length - 10));
                          }
                          R &&
                            (R.length + ul > ur && T(R.length + ul),
                            (ul = (function (_, L, R, N) {
                              let z = _.length;
                              switch (z) {
                                case 1:
                                  L[R++] = 212;
                                  break;
                                case 2:
                                  L[R++] = 213;
                                  break;
                                case 4:
                                  L[R++] = 214;
                                  break;
                                case 8:
                                  L[R++] = 215;
                                  break;
                                case 16:
                                  L[R++] = 216;
                                  break;
                                default:
                                  z < 256
                                    ? ((L[R++] = 199), (L[R++] = z))
                                    : (z < 65536
                                        ? ((L[R++] = 200), (L[R++] = z >> 8))
                                        : ((L[R++] = 201),
                                          (L[R++] = z >> 24),
                                          (L[R++] = (z >> 16) & 255),
                                          (L[R++] = (z >> 8) & 255)),
                                      (L[R++] = 255 & z));
                              }
                              return (L[R++] = N), L.set(_, R), (R += z);
                            })(R, ue, ul, N.type)));
                          return;
                        }
                      el(_, !_.hasOwnProperty);
                    }
                  } else ue[ul++] = 192;
                } else if ("boolean" === N) ue[ul++] = _ ? 195 : 194;
                else if ("bigint" === N) {
                  if (
                    _ < BigInt(1) << BigInt(63) &&
                    _ >= -(BigInt(1) << BigInt(63))
                  )
                    (ue[ul++] = 211), ut.setBigInt64(ul, _);
                  else if (_ < BigInt(1) << BigInt(64) && _ > 0)
                    (ue[ul++] = 207), ut.setBigUint64(ul, _);
                  else if (this.largeBigIntToFloat)
                    (ue[ul++] = 203), ut.setFloat64(ul, Number(_));
                  else
                    throw RangeError(
                      _ +
                        " was too large to fit in MessagePack 64-bit integer format, set largeBigIntToFloat to convert to float-64",
                    );
                  ul += 8;
                } else if ("undefined" === N)
                  this.encodeUndefinedAsNil
                    ? (ue[ul++] = 192)
                    : ((ue[ul++] = 212), (ue[ul++] = 0), (ue[ul++] = 0));
                else if ("function" === N)
                  w(this.writeFunction && this.writeFunction());
                else throw Error("Unknown type: " + N);
              },
              el =
                !1 === this.useRecords
                  ? this.variableMapSize
                    ? (_) => {
                        let L,
                          R = Object.keys(_),
                          N = R.length;
                        N < 16
                          ? (ue[ul++] = 128 | N)
                          : N < 65536
                            ? ((ue[ul++] = 222),
                              (ue[ul++] = N >> 8),
                              (ue[ul++] = 255 & N))
                            : ((ue[ul++] = 223),
                              ut.setUint32(ul, N),
                              (ul += 4));
                        for (let z = 0; z < N; z++) w((L = R[z])), w(_[L]);
                      }
                    : (_, R) => {
                        ue[ul++] = 222;
                        let N = ul - L;
                        ul += 2;
                        let z = 0;
                        for (let L in _)
                          (R || _.hasOwnProperty(L)) && (w(L), w(_[L]), z++);
                        (ue[N++ + L] = z >> 8), (ue[N + L] = 255 & z);
                      }
                  : (_) => {
                      let L = Object.keys(_),
                        R,
                        F =
                          z.transitions ||
                          (z.transitions = Object.create(null)),
                        U = 0;
                      for (let _ = 0, N = L.length; _ < N; _++) {
                        let N = L[_];
                        (R = F[N]) || ((R = F[N] = Object.create(null)), U++),
                          (F = R);
                      }
                      let k = F[uu];
                      if (k)
                        k >= 96 && $
                          ? ((ue[ul++] = (31 & (k -= 96)) + 96),
                            (ue[ul++] = k >> 5))
                          : (ue[ul++] = k);
                      else {
                        (k = z.nextId) || (k = 64),
                          k < ee &&
                          this.shouldShareStructure &&
                          !this.shouldShareStructure(L)
                            ? ((k = z.nextOwnId) < er || (k = ee),
                              (z.nextOwnId = k + 1))
                            : (k >= er && (k = ee), (z.nextId = k + 1));
                        let _ = (L.highByte =
                          k >= 96 && $ ? (k - 96) >> 5 : -1);
                        (F[uu] = k),
                          (z[k - 64] = L),
                          k < ee
                            ? ((L.isShared = !0),
                              (z.sharedLength = k - 63),
                              (N = !0),
                              _ >= 0
                                ? ((ue[ul++] = (31 & k) + 96), (ue[ul++] = _))
                                : (ue[ul++] = k))
                            : (_ >= 0
                                ? ((ue[ul++] = 213),
                                  (ue[ul++] = 114),
                                  (ue[ul++] = (31 & k) + 96),
                                  (ue[ul++] = _))
                                : ((ue[ul++] = 212),
                                  (ue[ul++] = 114),
                                  (ue[ul++] = k)),
                              U && (ea += eo * U),
                              en.length >= J && (en.shift()[uu] = 0),
                              en.push(F),
                              w(L));
                      }
                      for (let R = 0, N = L.length; R < N; R++) w(_[L[R]]);
                    },
              T = (_) => {
                let R;
                if (_ > 16777216) {
                  if (_ - L > uo)
                    throw Error(
                      "Packed buffer would be larger than maximum buffer size",
                    );
                  R = Math.min(
                    uo,
                    4096 *
                      Math.round(
                        Math.max((_ - L) * (_ > 67108864 ? 1.25 : 2), 4194304) /
                          4096,
                      ),
                  );
                } else
                  R = ((Math.max((_ - L) << 2, ue.length - 1) >> 12) + 1) << 12;
                let N = new un(R);
                return (
                  (ut = new DataView(N.buffer, 0, R)),
                  ue.copy ? ue.copy(N, 0, L, _) : N.set(ue.slice(L, _)),
                  (ul -= L),
                  (L = 0),
                  (ur = N.length - 10),
                  (ue = N)
                );
              };
          }
          useBuffer(_) {
            (ue = _),
              (ut = new DataView(ue.buffer, ue.byteOffset, ue.byteLength)),
              (ul = 0);
          }
        };
      function QT(_, L, R, N) {
        let z = _.byteLength;
        if (z + 1 < 256) {
          var { target: F, position: U } = R(4 + z);
          (F[U++] = 199), (F[U++] = z + 1);
        } else if (z + 1 < 65536) {
          var { target: F, position: U } = R(5 + z);
          (F[U++] = 200), (F[U++] = (z + 1) >> 8), (F[U++] = (z + 1) & 255);
        } else {
          var { target: F, position: U, targetView: k } = R(7 + z);
          (F[U++] = 201), k.setUint32(U, z + 1), (U += 4);
        }
        (F[U++] = 116),
          (F[U++] = L),
          F.set(new Uint8Array(_.buffer, _.byteOffset, _.byteLength), U);
      }
      function JT(_, L) {
        let R = _.byteLength;
        if (R < 256) {
          var N,
            z,
            { target: N, position: z } = L(R + 2);
          (N[z++] = 196), (N[z++] = R);
        } else if (R < 65536) {
          var { target: N, position: z } = L(R + 3);
          (N[z++] = 197), (N[z++] = R >> 8), (N[z++] = 255 & R);
        } else {
          var { target: N, position: z, targetView: F } = L(R + 5);
          (N[z++] = 198), F.setUint32(z, R), (z += 4);
        }
        N.set(_, z);
      }
      function Ho(_) {
        if (_.Class) {
          if (!_.pack && !_.write)
            throw Error("Extension has no pack or write function");
          if (_.pack && !_.type)
            throw Error(
              "Extension has no type (numeric code to identify the extension)",
            );
          d7.unshift(_.Class), d9.unshift(_);
        }
        _.unpack ? (dj[_.type] = _.unpack) : (dj[_.type] = _);
      }
      (d7 = [
        Date,
        Set,
        Error,
        RegExp,
        ArrayBuffer,
        Object.getPrototypeOf(Uint8Array.prototype).constructor,
        dV,
      ]),
        (d9 = [
          {
            pack(_, L, R) {
              let N = _.getTime() / 1e3;
              if (
                (this.useTimestamp32 || 0 === _.getMilliseconds()) &&
                N >= 0 &&
                N < 4294967296
              ) {
                let { target: _, targetView: R, position: z } = L(6);
                (_[z++] = 214), (_[z++] = 255), R.setUint32(z, N);
              } else if (N > 0 && N < 17179869184) {
                let { target: R, targetView: z, position: F } = L(10);
                (R[F++] = 215),
                  (R[F++] = 255),
                  z.setUint32(
                    F,
                    4e6 * _.getMilliseconds() + ((N / 1e3 / 4294967296) >> 0),
                  ),
                  z.setUint32(F + 4, N);
              } else if (isNaN(N)) {
                if (this.onInvalidDate) return L(0), R(this.onInvalidDate());
                let { target: _, targetView: N, position: z } = L(3);
                (_[z++] = 212), (_[z++] = 255), (_[z++] = 255);
              } else {
                let { target: R, targetView: z, position: F } = L(15);
                (R[F++] = 199),
                  (R[F++] = 12),
                  (R[F++] = 255),
                  z.setUint32(F, 1e6 * _.getMilliseconds()),
                  z.setBigInt64(F + 4, BigInt(Math.floor(N)));
              }
            },
          },
          {
            pack(_, L, R) {
              let N = Array.from(_),
                { target: z, position: F } = L(this.structuredClone ? 3 : 0);
              this.structuredClone &&
                ((z[F++] = 212), (z[F++] = 115), (z[F++] = 0)),
                R(N);
            },
          },
          {
            pack(_, L, R) {
              let { target: N, position: z } = L(this.structuredClone ? 3 : 0);
              this.structuredClone &&
                ((N[z++] = 212), (N[z++] = 101), (N[z++] = 0)),
                R([_.name, _.message]);
            },
          },
          {
            pack(_, L, R) {
              let { target: N, position: z } = L(this.structuredClone ? 3 : 0);
              this.structuredClone &&
                ((N[z++] = 212), (N[z++] = 120), (N[z++] = 0)),
                R([_.source, _.flags]);
            },
          },
          {
            pack(_, L) {
              this.structuredClone
                ? QT(_, 16, L)
                : JT(us ? t4.from(_) : new Uint8Array(_), L);
            },
          },
          {
            pack(_, L) {
              let R = _.constructor;
              R !== ua && this.structuredClone
                ? QT(_, d2.indexOf(R.name), L)
                : JT(_, L);
            },
          },
          {
            pack(_, L) {
              let { target: R, position: N } = L(1);
              R[N] = 193;
            },
          },
        ]);
      var uf = new up({ useRecords: !1 });
      uf.pack, uf.pack;
      var {
          NEVER: uv,
          ALWAYS: uy,
          DECIMAL_ROUND: ux,
          DECIMAL_FIT: ub,
        } = { NEVER: 0, ALWAYS: 1, DECIMAL_ROUND: 3, DECIMAL_FIT: 4 },
        uw = 512,
        uA = 1024,
        uM = new up({ structuredClone: !0 });
      Ho({
        Class: cq.prototype.constructor,
        type: 1,
        write: (_) => ({ ..._ }),
        read: (_) => (Object.setPrototypeOf(_, cq.prototype), _),
      }),
        Ho({
          Class: cK.prototype.constructor,
          type: 2,
          write: (_) => [..._],
          read: (_) => (Object.setPrototypeOf(_, cK.prototype), _),
        }),
        Ho({
          Class: cZ.prototype.constructor,
          type: 3,
          write: (_) => [..._],
          read: (_) => (Object.setPrototypeOf(_, cZ.prototype), _),
        }),
        Ho({
          Class: dh.prototype.constructor,
          type: 4,
          write: (_) => _.id,
          read: (_) => new dh(_),
        }),
        Ho({
          Class: du.prototype.constructor,
          type: 5,
          write: (_) => _.data,
          read: (_) => new du(_),
        }),
        Ho({
          Class: c0.prototype.constructor,
          type: 6,
          write: (_) => ({ ..._ }),
          read: (_) => (Object.setPrototypeOf(_, c0.prototype), _),
        }),
        ((_) => {
          function r(_) {
            return uM.pack(_);
          }
          (_.serialize = r),
            (_.deserialize = function (_) {
              return uM.unpack(_);
            }),
            (_.checksum = function (_) {
              return (function (_) {
                var L = 0;
                if (0 === _.length) return L;
                for (let R = 0; R < _.length; R++)
                  (L = (L << 5) - L + _[R]), (L &= L);
                return L;
              })(
                r(
                  (function nx(_) {
                    if (Oc(_)) return _;
                    if (Array.isArray(_)) return _.map(nx);
                    if ("object" != typeof _ || null === _) return _;
                    {
                      let L = {};
                      for (let R of Object.keys(_).sort()) L[R] = nx(_[R]);
                      return (
                        Object.setPrototypeOf(L, Object.getPrototypeOf(_)), L
                      );
                    }
                  })(_),
                ),
              ).toString();
            });
        })(uE || (uE = {}));
      var uE,
        uC,
        uD = {
          LookAt: [],
          Follow: [],
          MouseHover: ["Transition"],
          Scroll: ["Transition"],
          Start: ["Transition", "Audio", "Video"],
          Conditional: ["Transition", "Audio", "Video"],
          MouseDown: ["Transition", "Audio", "Video", "Link", "Reset"],
          MouseUp: ["Transition", "Audio", "Video", "Link", "Reset"],
          MousePress: ["Transition", "Audio", "Video", "Link", "Reset"],
          KeyDown: ["Transition", "Audio", "Video", "Link", "Reset"],
          KeyUp: ["Transition", "Audio", "Video", "Link", "Reset"],
          KeyPress: ["Transition", "Audio", "Video", "Link", "Reset"],
          GameControl: ["Transition", "Audio"],
          Collision: ["Transition", "Audio"],
        };
      ((uF = uC || (uC = {})).is = function (_) {
        return (
          "MouseDown" === _.type ||
          "MouseUp" === _.type ||
          "MousePress" === _.type ||
          "KeyDown" === _.type ||
          "KeyUp" === _.type ||
          "KeyPress" === _.type
        );
      }),
        (uF.defaultData = function (_) {
          return "MouseDown" === _ || "MouseUp" === _ || "MousePress" === _
            ? { type: _, disabled: !1, toggle: !1, actions: new cK() }
            : {
                type: _,
                disabled: !1,
                key: void 0,
                toggle: !1,
                actions: new cK(),
              };
        }),
        ((uU = u9 || (u9 = {})).propertyDefaultData = function (_) {
          return { type: "Property", value: [_ ?? null, "position", "x"] };
        }),
        (uU.valueDefaultData = { type: "Literal", value: 0 }),
        ((uk = u7 || (u7 = {})).comparisonDefaultData = function (_) {
          return {
            type: "Comparison",
            operator: "==",
            lOperand: u9.propertyDefaultData(_),
            rOperand: { ...u9.valueDefaultData },
          };
        }),
        (uk.distanceDefaultData = function (_) {
          return {
            type: "Distance",
            toObject: _ ?? null,
            fromObject: _ ?? null,
            distance: 200,
          };
        }),
        (uk.stateDefaultData = function (_, L) {
          return { type: "State", object: _ ?? null, state: L ?? null };
        }),
        ((uG = pi || (pi = {})).is = function (_) {
          return "Conditional" === _.type;
        }),
        (uG.defaultData = function (_) {
          return {
            type: "Conditional",
            disabled: !1,
            inActions: new cK(),
            outActions: new cK(),
            condition: u7.distanceDefaultData(_),
          };
        }),
        ((pr || (pr = {})).defaultData = {
          type: "Follow",
          disabled: !1,
          maxDelta: 0,
          dampingFactor: 1,
          target: "cursor",
          plane: "custom",
          resetOnPointerLeave: !0,
          resetAfterDistanceLimit: !0,
          enabledTranslation: [!0, !0, !0],
          limitDistanceEnabled: !1,
          limitDistance: 1e3,
          snapDelay: 0,
          resetSpeed: 5,
        }),
        ((pn || (pn = {})).defaultData = {
          type: "LookAt",
          disabled: !1,
          distance: 1e3,
          dampingFactor: 1,
          target: "cursor",
          tilt: "up",
          axis: "z",
          plane: "custom",
          resetOnPointerLeave: !0,
          resetAfterDistanceLimit: !0,
          enabledRotation: [!0, !0, !0],
          limitDistanceEnabled: !1,
          limitDistance: 1e3,
          snapDelay: 0,
          resetSpeed: 5,
        }),
        ((uV = pa || (pa = {})).is = function (_) {
          return "MouseHover" === _.type;
        }),
        (uV.defaultData = function () {
          return { type: "MouseHover", disabled: !1, actions: new cK() };
        }),
        ((uH = po || (po = {})).is = function (_) {
          return "Scroll" === _.type;
        }),
        (uH.defaultData = function () {
          return {
            type: "Scroll",
            disabled: !1,
            steps: 100,
            trigger: "load",
            startFrom: "enter",
            enterAnchor: "top",
            startOffset: 0,
            endAfter: 400,
            actions: new cK(),
          };
        }),
        ((uW = pd || (pd = {})).is = function (_) {
          return "Start" === _.type;
        }),
        (uW.defaultData = function () {
          return { type: "Start", disabled: !1, actions: new cK() };
        }),
        ((uY = pu || (pu = {})).is = function (_) {
          return "Collision" === _.type;
        }),
        (uY.defaultData = function () {
          return {
            type: "Collision",
            disabled: !1,
            toggle: !1,
            target: "character",
            actions: new cK(),
          };
        }),
        ((uX = pp || (pp = {})).isEqual = function (_, L) {
          return _[0] === L[0] && _[1] === L[1];
        }),
        (uX.lerp = function (_, L, R) {
          return [_[0] + (L[0] - _[0]) * R, _[1] + (L[1] - _[1]) * R];
        }),
        ((uq = pf || (pf = {})).isEqual = function (_, L) {
          return _[0] === L[0] && _[1] === L[1] && _[2] === L[2];
        }),
        (uq.add = function (_, L) {
          return [_[0] + L[0], _[1] + L[1], _[2] + L[2]];
        }),
        (uq.sub = function (_, L) {
          return [_[0] - L[0], _[1] - L[1], _[2] - L[2]];
        }),
        (uq.div = function (_, L) {
          return [_[0] / L[0], _[1] / L[1], _[2] / L[2]];
        }),
        (uq.mul = function (_, L) {
          return [_[0] * L[0], _[1] * L[1], _[2] * L[2]];
        }),
        (uq.dist = function (_, L) {
          return Math.hypot(_[0] - L[0], _[1] - L[1], _[2] - L[2]);
        }),
        (uq.lerp = function (_, L, R) {
          return [
            _[0] + (L[0] - _[0]) * R,
            _[1] + (L[1] - _[1]) * R,
            _[2] + (L[2] - _[2]) * R,
          ];
        }),
        ((uQ = pv || (pv = {})).isEqual = function (_, L) {
          return (
            _[0] === L[0] && _[1] === L[1] && _[2] === L[2] && _[3] === L[3]
          );
        }),
        (uQ.lerp = function (_, L, R) {
          return [
            _[0] + (L[0] - _[0]) * R,
            _[1] + (L[1] - _[1]) * R,
            _[2] + (L[2] - _[2]) * R,
            _[3] + (L[3] - _[3]) * R,
          ];
        }),
        ((uZ = px || (px = {})).identity = [
          1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1,
        ]),
        (uZ.isEqual = function (_, L) {
          for (let R = 0; R < 16; R++) if (_[R] !== L[R]) return !1;
          return !0;
        }),
        (uZ.simplify = function (_) {
          return _ ?? uZ.identity;
        }),
        (uZ.applyMatrix4 = function (_, L) {
          let R = L.slice(0);
          for (var N = 0, z = L.length; N < z; N += 3) {
            let z = _[3] * L[N] + _[7] * L[N + 1] + _[11] * L[N + 2] + _[15];
            (R[N] =
              (_[0] * L[N] + _[4] * L[N + 1] + _[8] * L[N + 2] + _[12]) / z),
              (R[N + 1] =
                (_[1] * L[N] + _[5] * L[N + 1] + _[9] * L[N + 2] + _[13]) / z),
              (R[N + 2] =
                (_[2] * L[N] + _[6] * L[N + 1] + _[10] * L[N + 2] + _[14]) / z);
          }
          return R;
        }),
        ((uK = pb || (pb = {})).isRGB = function (_) {
          return (
            "object" == typeof _ &&
            "number" == typeof _.r &&
            "number" == typeof _.g &&
            "number" == typeof _.b
          );
        }),
        (uK.white = { r: 1, g: 1, b: 1 }),
        (uK.red = { r: 1, g: 0, b: 0 }),
        (uK.black = { r: 0, g: 0, b: 0 }),
        (uK.toRgb255a1 = function (_) {
          return {
            r: Math.round(255 * _.r),
            g: Math.round(255 * _.g),
            b: Math.round(255 * _.b),
            a: 1,
          };
        }),
        (uK.clone = function (_) {
          return { r: _.r, g: _.g, b: _.b };
        }),
        (uK.fromHex = function (_) {
          return {
            r: (((_ = Math.floor(_)) >> 16) & 255) / 255,
            g: ((_ >> 8) & 255) / 255,
            b: (255 & _) / 255,
          };
        }),
        (uK.equals = function (_, L) {
          return _.r === L.r && _.g === L.g && _.b === L.b;
        }),
        (uK.lerp = function (_, L, R) {
          return {
            r: _.r + (L.r - _.r) * R,
            g: _.g + (L.g - _.g) * R,
            b: _.b + (L.b - _.b) * R,
          };
        }),
        ((uJ = pw || (pw = {})).white = { ...pb.white, a: 1 }),
        (uJ.transparent = { ...pb.white, a: 0 }),
        (uJ.from0to1 = function (_) {
          return { r: _[0], g: _[1], b: _[2], a: _[3] };
        }),
        (uJ.fromHexAndA = function (_, L) {
          return { ...pb.fromHex(_), a: L };
        }),
        (uJ.toRgb255a1 = function (_) {
          return {
            r: Math.round(255 * _.r),
            g: Math.round(255 * _.g),
            b: Math.round(255 * _.b),
            a: _.a,
          };
        }),
        (uJ.equals = function (_, L) {
          return pb.equals(_, L) && _.a === L.a;
        }),
        (uJ.lerp = function (_, L, R) {
          return {
            r: _.r + (L.r - _.r) * R,
            g: _.g + (L.g - _.g) * R,
            b: _.b + (L.b - _.b) * R,
            a: _.a + (L.a - _.a) * R,
          };
        }),
        ((p_ || (p_ = {})).identity = {
          position: [0, 0, 0],
          rotation: [0, 0, 0],
          scale: [1, 1, 1],
        }),
        ((pA || (pA = {})).defaultData = {
          mass: 1,
          stiffness: 80,
          damping: 10,
          velocity: 0,
        }),
        ((pE || (pE = {})).defaultData = {
          control1: [0.5, 0.05],
          control2: [0.1, 0.3],
        }),
        ((u$ = pC || (pC = {})).all = [
          "PerspectiveCamera",
          "OrthographicCamera",
        ]),
        (u$.is = function (_) {
          return u$.all.includes(_);
        }),
        ((u0 = pD || (pD = {})).DefaultUp = [0, 1, 0]),
        (u0.DefaultTargetOffset = 1e3),
        (u0.defaultData = {
          far: 1e5,
          type: "OrthographicCamera",
          perspective: { near: 70, fov: 45, zoom: 1 },
          orthographic: {
            near: -1e5,
            zoom: 1,
            autoZoom: !1,
            autoZoomFrustumSize: 790,
          },
          up: u0.DefaultUp,
          isUpVectorFlipped: !1,
          targetOffset: u0.DefaultTargetOffset,
        }),
        (u0.getZoom = function (_) {
          return "PerspectiveCamera" === _.type
            ? _.perspective.zoom
            : _.orthographic.zoom;
        }),
        ((u1 = pO || (pO = {})).defaultData = function (_, L = 0.1) {
          return {
            disabled: !1,
            type: "linear",
            hideBase: !1,
            count: 3,
            radial: {
              radius: 2 * Math.max(_[0], _[1]),
              start: 0,
              end: 360,
              alignment: !1,
              axis: "y",
              scale: [1, 1, 1],
              rotation: [0, 0, 0],
              position: [0, 0, 0],
            },
            toObject: {
              object: "",
              spreadType: "random",
              scale: [0, 0, 0],
              rotation: [0, 0, 0],
              position: [0, 0, 0],
              axis: "x",
              seed: 0,
              count: 99,
              align: "normal",
            },
            linear: {
              scale: [1, 1, 1],
              rotation: [0, 0, 0],
              position: [_[0] + _[0] * L, 0, 0],
            },
            grid: {
              count: [2, 2, 2],
              size: _.map((_) => _ * (1 + L)),
              useCenter: !0,
            },
            randomness: !1,
            randomnessObject: {
              strength: 100,
              scale: [0, 0, 0],
              rotation: [0, 0, 0],
              position: [0, 0, 0],
              movement: 1,
              seed: 0,
              freqScale: 10,
              noiseType: "perlin",
            },
          };
        }),
        (u1.merge = function (_, L) {
          let R = { ..._ };
          if (
            (uO.forEach((N) => {
              Object.assign(R, { [N]: L[N] ?? _[N] });
            }),
            (R.radial = { ..._.radial }),
            L.radial)
          ) {
            let N = _.radial,
              z = L.radial;
            uL.forEach((_) => {
              Object.assign(R.radial, { [_]: z[_] ?? N[_] });
            });
          }
          if (((R.linear = { ..._.linear }), L.linear)) {
            let N = _.linear,
              z = L.linear;
            uR.forEach((_) => {
              Object.assign(R.linear, { [_]: z[_] ?? N[_] });
            });
          }
          if (((R.grid = { ..._.grid }), L.grid)) {
            let N = _.grid,
              z = L.grid;
            uI.forEach((_) => {
              Object.assign(R.grid, { [_]: z[_] ?? N[_] });
            });
          }
          if (((R.toObject = { ..._.toObject }), L.toObject)) {
            let N = _.toObject,
              z = L.toObject;
            uB.forEach((_) => {
              Object.assign(R.toObject, { [_]: z[_] ?? N[_] });
            });
          }
          if (
            ((R.randomnessObject = { ..._.randomnessObject }),
            L.randomnessObject)
          ) {
            let N = _.randomnessObject,
              z = L.randomnessObject;
            uz.forEach((_) => {
              Object.assign(R.randomnessObject, { [_]: z[_] ?? N[_] });
            });
          }
          return R;
        }),
        ((u2 = pL || (pL = {})).defaultData = {
          radial: {},
          linear: {},
          grid: {},
          toObject: {},
          randomnessObject: {},
        }),
        (N = ["radial", "linear", "grid", "toObject", "randomnessObject"]),
        (u2.toOps = function (_, L) {
          let R = [];
          for (let z of (void 0 !== _.count &&
            R.push({ type: 0, path: L, props: { count: _.count } }),
          N)) {
            let N = _[z];
            N &&
              Object.keys(N).length > 0 &&
              R.push({ type: 0, path: [...L, z], props: N });
          }
          return R;
        });
      var uO = ["count"],
        uL = ["radius", "start", "end", "position", "scale", "rotation"],
        uR = ["position", "scale", "rotation"],
        uI = ["count", "size"],
        uB = ["count", "position", "scale", "rotation"],
        uz = [
          "strength",
          "scale",
          "rotation",
          "position",
          "movement",
          "seed",
          "freqScale",
        ];
      (z = { opacity: 1, blendFunction: 13, enabled: !1 }),
        ((pR || (pR = {})).defaultData = {
          enabled: !1,
          pixelation: { ...z, blendFunction: 16, granularity: 15 },
          bloom: {
            ...z,
            blendFunction: 16,
            intensity: 1,
            blurScale: 1,
            luminanceThreshold: 0.25,
            luminanceSmoothing: 0.025,
            kernelSize: 3,
          },
          chromaticAberration: { ...z, offset: [2, 2] },
          vignette: { ...z, darkness: 1, offset: 0 },
          hueSaturation: { ...z, hue: 3, saturation: 0 },
          brightnessContrast: { ...z, brightness: 0.25, contrast: 0 },
          depthOfField: {
            ...z,
            focalLength: 2,
            focusDistance: 2,
            bokehScale: 2,
          },
          noise: { ...z, blendFunction: 16 },
        }),
        ((u4 = pI || (pI = {})).all = [
          "PointLight",
          "SpotLight",
          "DirectionalLight",
          "HemisphereLight",
        ]),
        (u4.is = function (_) {
          return u4.all.includes(_);
        }),
        ((pB || (pB = {})).defaultData = function (_) {
          return (function (_) {
            if ("PointLight" === _)
              return {
                type: _,
                color: pw.white,
                intensity: 1,
                distance: 2e3,
                decay: 1,
                shadows: !0,
                shadowResolution: 1024,
                shadowRadius: 1,
                depth: 1e5,
              };
            if ("SpotLight" === _)
              return {
                type: _,
                color: pw.white,
                intensity: 1,
                distance: 2e3,
                decay: 1,
                shadows: !0,
                penumbra: 0,
                angle: (30 / 180) * Math.PI,
                depth: 1e5,
                shadowResolution: 1024,
                shadowRadius: 1,
              };
            if ("DirectionalLight" === _)
              return {
                type: _,
                color: pw.white,
                intensity: 1,
                shadows: !0,
                size: 2e3,
                depth: 1e5,
                shadowResolution: 1024,
                shadowRadius: 1,
              };
            throw Error("not implemented");
          })(_);
        }),
        ((u5 = pN || (pN = {})).defaultData = {
          castShadow: !0,
          receiveShadow: !0,
        }),
        (u5.equals = function (_, L) {
          return (
            _.castShadow === L.castShadow && _.receiveShadow === L.receiveShadow
          );
        }),
        ((u6 = pz || (pz = {})).defaultData = {
          flatShading: !1,
          wireframe: !1,
          side: 0,
        }),
        (u6.equals = function (_, L) {
          return (
            _.flatShading === L.flatShading &&
            _.side === L.side &&
            _.wireframe === L.wireframe
          );
        }),
        ((pF || (pF = {})).defaultData = {
          ...pz.defaultData,
          ...pN.defaultData,
        }),
        ((u8 = pU || (pU = {})).defaultVideo = {
          data: "",
          thumb: "/_assets/_videos/catThumb.png",
          type: "video",
          name: "Cat video",
        }),
        (u8.maxSize = 3e7),
        ((pk || (pk = {})).is = function (_) {
          return (
            "texture" === _ ||
            "video" === _ ||
            "color" === _ ||
            "depth" === _ ||
            "normal" === _ ||
            "gradient" === _ ||
            "noise" === _ ||
            "fresnel" === _ ||
            "rainbow" === _ ||
            "toon" === _ ||
            "outline" === _ ||
            "transmission" === _ ||
            "matcap" === _ ||
            "displace" === _ ||
            "light" === _
          );
        }),
        ((pj || (pj = {})).is = function (_) {
          return (
            "phong" === _ || "toon" === _ || "lambert" === _ || "physical" === _
          );
        });
      var uF,
        uU,
        uk,
        uG,
        uV,
        uH,
        uW,
        uY,
        uX,
        uq,
        uQ,
        uZ,
        uK,
        uJ,
        u$,
        u0,
        u1,
        u2,
        u4,
        u5,
        u6,
        u8,
        u9,
        u7,
        pi,
        pr,
        pn,
        pa,
        po,
        pd,
        pu,
        pp,
        pf,
        pv,
        px,
        pb,
        pw,
        p_,
        pA,
        pE,
        pC,
        pD,
        pO,
        pL,
        pR,
        pI,
        pB,
        pN,
        pz,
        pF,
        pU,
        pk,
        pj,
        pG,
        pV = [
          "mode",
          "gradientType",
          "noiseType",
          "displacementType",
          "projection",
          "cnormal",
          "crop",
          "axis",
          "side",
        ],
        pH = ["wrapping", "image", "video"];
      ((fO = pG || (pG = {})).patch = function (_, L) {
        let { texture: R, ...N } = L;
        if ((Object.assign(_, N), R)) {
          let L = _.texture;
          L && Object.assign(L, R);
        }
      }),
        (fO.defaultData = function (_, L) {
          return "light" === _ && L
            ? (function (_) {
                switch (_) {
                  case "phong":
                    return {
                      category: "phong",
                      specular: { r: 0.2, g: 0.2, b: 0.2 },
                      shininess: 5,
                      type: "light",
                      alpha: 0.6,
                      visible: !0,
                      mode: 0,
                    };
                  case "toon":
                    return {
                      category: "toon",
                      specular: { r: 0.2, g: 0.2, b: 0.2 },
                      shininess: 10,
                      type: "light",
                      alpha: 1,
                      visible: !0,
                      mode: 0,
                    };
                  case "lambert":
                    return {
                      category: "lambert",
                      emissive: { r: 0, g: 0, b: 0 },
                      type: "light",
                      alpha: 1,
                      visible: !0,
                      mode: 0,
                    };
                  case "physical":
                    return {
                      category: "physical",
                      roughness: 0.2,
                      metalness: 0.2,
                      reflectivity: 0.2,
                      type: "light",
                      alpha: 1,
                      visible: !0,
                      mode: 0,
                    };
                }
              })(L)
            : (function (_) {
                switch (_) {
                  case "texture":
                    return {
                      alpha: 1,
                      visible: !0,
                      size: [128, 128],
                      mode: 0,
                      axis: "x",
                      side: 2,
                      type: "texture",
                      projection: 0,
                      texture: {
                        image: "image_0",
                        wrapping: 1e3,
                        repeat: [1, 1],
                        offset: [0, 0],
                      },
                      crop: !1,
                    };
                  case "video":
                    return {
                      alpha: 1,
                      visible: !0,
                      size: [128, 128],
                      mode: 0,
                      axis: "x",
                      side: 2,
                      type: "video",
                      projection: 0,
                      texture: {
                        video: pU.defaultVideo,
                        wrapping: 1001,
                        repeat: [1, 1],
                        offset: [0, 0],
                      },
                      crop: !0,
                    };
                  case "color":
                    return {
                      type: "color",
                      alpha: 1,
                      visible: !0,
                      mode: 0,
                      color: pb.fromHex(5526619),
                    };
                  case "depth":
                    return {
                      type: "depth",
                      alpha: 1,
                      visible: !0,
                      mode: 0,
                      gradientType: 1,
                      smooth: !1,
                      isVector: !0,
                      isWorldSpace: !1,
                      origin: [0, 0, 0],
                      direction: [1, 0, 0],
                      colors: [
                        [1, 1, 1, 1],
                        [0, 0, 0, 1],
                      ],
                      steps: [0, 1],
                      near: 50,
                      far: 200,
                    };
                  case "normal":
                    return {
                      type: "normal",
                      alpha: 1,
                      visible: !0,
                      mode: 0,
                      cnormal: [1, 1, 1],
                    };
                  case "gradient":
                    return {
                      type: "gradient",
                      alpha: 1,
                      visible: !0,
                      mode: 0,
                      gradientType: 0,
                      smooth: !1,
                      colors: [
                        [0, 0, 0, 1],
                        [1, 1, 1, 1],
                        [1, 1, 1, 1],
                        [1, 1, 1, 1],
                        [1, 1, 1, 1],
                        [1, 1, 1, 1],
                        [1, 1, 1, 1],
                        [1, 1, 1, 1],
                        [1, 1, 1, 1],
                        [1, 1, 1, 1],
                      ],
                      steps: [0, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                      num: 2,
                      angle: 0,
                      offset: [0, 0],
                      morph: [0, 0],
                    };
                  case "noise":
                    return {
                      type: "noise",
                      alpha: 1,
                      visible: !0,
                      mode: 0,
                      size: [100, 100, 100],
                      noiseType: 0,
                      scale: 1,
                      move: 1,
                      colorA: { ...pb.fromHex(6710886), a: 1 },
                      colorB: { ...pb.fromHex(6710886), a: 1 },
                      colorC: { ...pb.fromHex(16777215), a: 1 },
                      colorD: { ...pb.fromHex(16777215), a: 1 },
                      distortion: [1, 1],
                      fA: [1.7, 9.2],
                      fB: [8.3, 2.8],
                    };
                  case "fresnel":
                    return {
                      type: "fresnel",
                      alpha: 1,
                      visible: !0,
                      mode: 0,
                      color: pw.fromHexAndA(16777215, 1),
                      bias: 0.1,
                      scale: 1,
                      intensity: 2,
                      factor: 1,
                    };
                  case "rainbow":
                    return {
                      type: "rainbow",
                      alpha: 1,
                      visible: !0,
                      mode: 0,
                      filmThickness: 30,
                      movement: 0,
                      wavelengths: [0, 0, 0],
                      noiseStrength: 0,
                      noiseScale: 1,
                      offset: [0, 0, 0],
                    };
                  case "toon":
                    return {
                      type: "toon",
                      alpha: 1,
                      visible: !0,
                      mode: 0,
                      positioning: 2,
                      colors: [
                        [0, 0, 0, 1],
                        [0.5, 0.5, 0.5, 1],
                        [0.5, 0.5, 0.5, 1],
                        [1, 1, 1, 1],
                        [1, 1, 1, 1],
                        [1, 1, 1, 1],
                        [1, 1, 1, 1],
                        [1, 1, 1, 1],
                        [1, 1, 1, 1],
                        [1, 1, 1, 1],
                      ],
                      steps: [0, 0.475, 0.525, 1, 1, 1, 1, 1, 1, 1],
                      num: 4,
                      source: [0, 1e3, 0],
                      isWorldSpace: !0,
                      noiseStrength: 0,
                      noiseScale: 1,
                      shadowColor: pw.fromHexAndA(0, 0),
                      offset: [0, 0, 0],
                    };
                  case "outline":
                    return {
                      type: "outline",
                      alpha: 1,
                      visible: !0,
                      mode: 0,
                      outlineColor: pw.fromHexAndA(0, 1),
                      contourColor: pw.fromHexAndA(0, 1),
                      outlineWidth: 2,
                      contourWidth: 5,
                      outlineThreshold: 0.4,
                      contourThreshold: 0,
                      outlineSmoothing: 0,
                      contourFrequency: 10,
                      contourDirection: [0, 1, 0],
                      positionalLines: !1,
                      compensation: !0,
                    };
                  case "matcap":
                    return {
                      type: "matcap",
                      alpha: 1,
                      visible: !0,
                      mode: 0,
                      texture: {
                        image: "matcap_0",
                        wrapping: 1001,
                        repeat: [1, 1],
                        offset: [0, 0],
                      },
                    };
                  case "transmission":
                    return {
                      type: "transmission",
                      alpha: 1,
                      visible: !0,
                      mode: 0,
                      thickness: 10,
                      ior: 1.5,
                      roughness: 1,
                    };
                  case "displace":
                    return {
                      type: "displace",
                      displacementType: "noise",
                      noiseType: 0,
                      scale: 10,
                      movement: 1,
                      offset: [0, 0, 0],
                      intensity: 8,
                      visible: !0,
                    };
                }
              })(_);
        }),
        ((_) => {
          function s(_, L = "layer1", R = "layer2") {
            let N = new cK();
            return (
              N.push({ fi: 0, data: pG.defaultData("light", _), id: L }),
              N.push({ fi: 1, data: pG.defaultData("color"), id: R }),
              { layers: N }
            );
          }
          (_.isMergable = function (_) {
            return !_.layers.some(
              (_) =>
                ("texture" === _.data.type && 0 !== _.data.projection) ||
                ("depth" === _.data.type && !_.data.isWorldSpace) ||
                "noise" === _.data.type ||
                "displace" === _.data.type,
            );
          }),
            (_.getHash = function (_) {
              let L = "";
              return (
                _.layers.forEach((_) => {
                  Object.entries(_.data).forEach(([_, R]) => {
                    (L += `${_}${R}`),
                      Array.isArray(R)
                        ? R.forEach((_) => (L += `${_}`))
                        : "object" == typeof R
                          ? Object.values(R).forEach((_) => {
                              "number" == typeof _
                                ? (L += `${_.toFixed(4)}`)
                                : (L += `${_}`);
                            })
                          : (L += `${R}`);
                  });
                }),
                L
              );
            }),
            (_.defaultEmptyData = function () {
              return { layers: new cK() };
            }),
            (_.defaultData = function (_ = "layer1", L = "layer2") {
              return s("phong", _, L);
            }),
            (_.withName = function (_, L) {
              return { ..._, name: L };
            }),
            (_.defaultTwoLayerData = s),
            (_.defaultTwoLayerTextureData = function (
              _,
              L = "phong",
              R = "layer1",
              N = "layer2",
            ) {
              let z = pG.defaultData("texture");
              Object.assign(z.texture, { image: _ });
              let F = new cK();
              return (
                F.push({ fi: 0, data: z, id: R }),
                F.push({ fi: 1, data: pG.defaultData("light", L), id: N }),
                { layers: F }
              );
            }),
            (_.defaultTwoLayerVideoTextureData = function (
              _,
              L = "phong",
              R = "layer1",
              N = "layer2",
            ) {
              let z = pG.defaultData("video");
              Object.assign(z.texture, { video: _ });
              let F = new cK();
              return (
                F.push({ fi: 0, data: z, id: R }),
                F.push({ fi: 1, data: pG.defaultData("light", L), id: N }),
                { layers: F }
              );
            });
        })(fU || (fU = {})),
        ((fk || (fk = {})).defaultData = function () {
          return {
            points: new cK(),
            roundness: 0,
            shapeHoles: [],
            isClosed: !1,
          };
        }),
        ((fj || (fj = {})).defaultData = function () {
          return {
            points: new cK(),
            lastInsertionPlane: null,
            subdivisions: 12,
            isClosed: !1,
          };
        });
      var pW = {
        type: "Ellipse",
        width: 100,
        height: 100,
        spikes: 64,
        angle: 360,
        innerRadius: 0,
      };
      (fG || (fG = {})).merge = function (_, L) {
        let R = { ..._ };
        return (
          pX.forEach((N) => {
            Object.assign(R, { [N]: L[N] ?? _[N] });
          }),
          R
        );
      };
      var pY = {
          shape: pW,
          depth: 1,
          offset: 0,
          bevel: 0,
          bevelSides: 1,
          angle: 0,
          twist: 0,
          startScale: 1,
          endScale: 1,
        },
        pX = ["depth", "offset", "angle", "twist", "startScale", "endScale"];
      ((fL = fV || (fV = {})).is2DParametricMesh = function (_) {
        return (
          "PolygonGeometry" === _ ||
          "RectangleGeometry" === _ ||
          "StarGeometry" === _ ||
          "TriangleGeometry" === _ ||
          "EllipseGeometry" === _
        );
      }),
        (fL.isParametricMesh = function (_) {
          return (
            "PolygonGeometry" === _ ||
            "PolygonGeometry" === _ ||
            "RectangleGeometry" === _ ||
            "StarGeometry" === _ ||
            "TriangleGeometry" === _ ||
            "EllipseGeometry" === _ ||
            "PathGeometry" === _ ||
            "VectorGeometry" === _ ||
            "ConeGeometry" === _ ||
            "CubeGeometry" === _ ||
            "CylinderGeometry" === _ ||
            "DodecahedronGeometry" === _ ||
            "HelixGeometry" === _ ||
            "IcosahedronGeometry" === _ ||
            "LatheGeometry" === _ ||
            "PyramidGeometry" === _ ||
            "SphereGeometry" === _ ||
            "PlaneGeometry" === _ ||
            "BackdropGeometry" === _ ||
            "TorusGeometry" === _ ||
            "TorusKnotGeometry" === _ ||
            "BooleanGeometry" === _ ||
            "TextGeometry" === _
          );
        }),
        ((fH || (fH = {})).merge = function (_, L) {
          let R = { ..._ };
          return (
            Object.assign(R, L),
            "PathGeometry" === R.type &&
              "extrusion" in L &&
              L.extrusion &&
              ((R.extrusion = { ..._.extrusion }),
              Object.assign(R.extrusion, fG.merge(R.extrusion, L.extrusion))),
            R
          );
        }),
        ((fW || (fW = {})).defaultData = function (_) {
          if ("RectangleGeometry" === _)
            return {
              width: 320,
              height: 320,
              type: _,
              cornerRadius: [0, 0, 0, 0],
              cornerType: 0,
              depth: 0,
              extrudeBevelSize: 0,
              extrudeBevelSegments: 1,
            };
          if ("PathGeometry" === _)
            return {
              type: _,
              width: 1,
              height: 1,
              depth: 1,
              path: fj.defaultData(),
              extrusion: pY,
            };
          if ("VectorGeometry" === _)
            return {
              width: 1,
              height: 1,
              type: _,
              subdivisions: 12,
              shape: fk.defaultData(),
              depth: 0,
              extrudeBevelSize: 0,
              extrudeBevelSegments: 1,
            };
          if ("BooleanGeometry" === _)
            return {
              type: _,
              operation: 2,
              width: 0,
              height: 0,
              depth: 0,
              phongAngle: 35,
            };
          if ("TextGeometry" === _)
            return {
              type: _,
              width: 100,
              height: 100,
              depth: 0,
              horizontalAlign: 1,
              verticalAlign: 1,
              fontSize: 16,
              lineHeight: 1.2,
              letterSpacing: 0,
              text: "",
              textTransform: 1,
              font: "Roboto_regular",
              extrudeBevelSize: 0,
              extrudeBevelSegments: 1,
            };
          throw Error("not implemented");
        });
      var pq = ["width", "height", "depth"];
      function Ri(_, L) {
        return Object.setPrototypeOf(_, L), _;
      }
      ((fR = fY || (fY = {})).isComponentRelated = function (_) {
        return "Component" === _ || "Instance" === _;
      }),
        (fR.isEmptyOrComponent = function (_) {
          return "Empty" === _ || "Instance" === _;
        }),
        ((fI = fX || (fX = {})).identity = {
          ...p_.identity,
          hiddenMatrix: px.identity,
        }),
        (fI.fromObject = function (_) {
          return {
            position: _.position,
            rotation: _.rotation,
            scale: _.scale,
            hiddenMatrix: _.hiddenMatrix,
          };
        }),
        (fI.merge = function (_, L) {
          return {
            position: L?.position || _.position,
            rotation: L?.rotation || _.rotation,
            scale: L?.scale || _.scale,
            hiddenMatrix: L?.hiddenMatrix || _.hiddenMatrix,
          };
        }),
        (fI.diff = function (_, L) {
          return {
            position: pf.isEqual(_.position, L.position) ? null : L.position,
            rotation: pf.isEqual(_.rotation, L.rotation) ? null : L.rotation,
            scale: pf.isEqual(_.scale, L.scale) ? null : L.scale,
            hiddenMatrix: px.isEqual(_.hiddenMatrix, L.hiddenMatrix)
              ? null
              : L.hiddenMatrix,
          };
        }),
        ((fq || (fq = {})).defaultData = {
          fusedBody: !0,
          rigidBody: "positioned",
          density: 1,
          pointMass: 0,
          gravityScale: 1,
          friction: 0.5,
          damping: 0,
          restitution: 0.2,
          colliderType: "convex",
          enabledRotation: [!0, !0, !0],
          enabledTranslation: [!0, !0, !0],
        }),
        ((fQ || (fQ = {})).defaultData = {
          states: new cK(),
          events: new cK(),
          visible: !0,
          raycastLock: !1,
          physics: null,
          pathSnapping: {
            pathId: null,
            slide: 0,
            offset: 0,
            orientation: "tangential",
          },
          ...fX.identity,
          cloner: null,
        }),
        ((fZ || (fZ = {})).defaultData = { type: "Empty", ...fQ.defaultData }),
        ((fK || (fK = {})).defaultData = {
          type: "Component",
          ...fQ.defaultData,
        }),
        ((fJ || (fJ = {})).defaultData = {
          type: "Mesh",
          ...fQ.defaultData,
          ...pF.defaultData,
        }),
        ((f$ || (f$ = {})).defaultData = {
          ...fQ.defaultData,
          ...fX.identity,
          ...pD.defaultData,
        }),
        ((f1 || (f1 = {})).defaultData = function (_) {
          return { ...fQ.defaultData, ...pB.defaultData(_) };
        }),
        ((_) => {
          function r(_, L, R = 0) {
            for (; R < L.length; ) {
              let N = _ ? _[L[R]] : void 0;
              if (L.length === R + 1) return N;
              if (!N) return;
              (_ = N.descendants), (R += 1);
            }
          }
          (_.resolveWithDes = r),
            (_.resolve = function (_, L, R = 0) {
              let N = r(_, L, R);
              if (N) {
                let _ = Object.keys(N);
                if (1 === _.length && "descendants" === _[0]) return;
              }
              return N;
            });
        })(f2 || (f2 = {})),
        ((_) => {
          function n(_, L) {
            return {
              ...fQ.defaultData,
              ...L,
              component: _,
              overrides: new c0(),
              physics: void 0,
              type: "Instance",
            };
          }
          (_.rootOverrideProps = ["physics"]),
            (_.compositeNonOptionalOverrideProps = ["geometry"]),
            (_.compositeEntireOverrideOverrideProps = ["material"]),
            (_.ofComponent = n),
            (_.fromComponentData = function (_) {
              let L = fX.fromObject(_.data);
              return n(_.id, L);
            });
        })(f4 || (f4 = {})),
        ((fB = f5 || (f5 = {})).defaultCamera = {
          position: [0, 0, 1e3],
          scale: [1, 1, 1],
          rotation: [0, 0, 0],
          hiddenMatrix: px.identity,
          name: "Play Camera",
          visible: !0,
          raycastLock: !1,
          physics: fq.defaultData,
          states: new cK(),
          events: new cK(),
          cloner: null,
          pathSnapping: {
            pathId: null,
            orientation: "tangential",
            slide: 0,
            offset: 0,
          },
          ...pD.defaultData,
        }),
        (fB.KeysByResetCategory = {
          States: ["states"],
          Events: ["events"],
          Material: ["material", "materials"],
          Geometry: ["geometry"],
          Position: ["position"],
          Rotation: ["rotation"],
          Scale: ["scale"],
          Transform: ["position", "scale", "rotation", "hiddenMatrix"],
          Name: ["name"],
          Visibility: [
            "visible",
            "raycastLock",
            "flatShading",
            "wireframe",
            "side",
          ],
          Shadows: ["castShadow", "receiveShadow"],
          Cloner: ["cloner"],
          Physics: ["physics"],
        }),
        (fB.defaultMeshObject = {
          name: "Rectangle",
          ...fQ.defaultData,
          ...fJ.defaultData,
          geometry: fW.defaultData("RectangleGeometry"),
          material: fU.defaultTwoLayerData("phong", "layer1", "layer2"),
        }),
        (fB.defaultBooleanObject = {
          name: "Boolean",
          ...fQ.defaultData,
          ...fJ.defaultData,
          geometry: fW.defaultData("BooleanGeometry"),
          material: fU.defaultTwoLayerData("phong", "layer1", "layer2"),
        }),
        (fB.defaultTextObject = {
          name: "Text",
          ...fQ.defaultData,
          ...fJ.defaultData,
          geometry: fW.defaultData("TextGeometry"),
          material: fU.defaultTwoLayerData("phong", "layer1", "layer2"),
        }),
        ((fN = f6 || (f6 = {})).newEmpty = function (_, L) {
          let R = { name: L };
          return (
            "Mesh" === _.type
              ? ((R.geometry = {}),
                "material" in _ && (R.material = { layers: new c0() }),
                "materials" in _ &&
                  (R.materials = _.materials.map((_) => ({
                    layers: new c0(),
                  }))))
              : pC.is(_.type) && ((R.perspective = {}), (R.orthographic = {})),
            R
          );
        }),
        (fN.toOps = function (_, L) {
          let R,
            N = [],
            z = { orthographic: 0, perspective: 0, geometry: 0 };
          function c(_, L) {
            for (let [R, z] of Object.entries(L.layers)) {
              let { texture: L, ...F } = z;
              if (void 0 !== L && Object.keys(L).length > 0) {
                let z = {
                  path: [..._, "layers", R, "texture"],
                  props: L,
                  type: 0,
                };
                N.push(z);
              }
              if (Object.keys(F).length > 0) {
                let L = { path: [..._, "layers", R], props: F, type: 0 };
                N.push(L);
              }
            }
          }
          for (let [_, F] of Object.entries(L))
            if ("name" !== _) {
              if ("cloner" === _) N.push(...pL.toOps(F, ["cloner"]));
              else if ("pathSnapping" === _)
                N.push({
                  path: [_],
                  props: { slide: F.slide, offset: F.offset },
                  type: 0,
                });
              else if ("material" === _) c(["material"], F);
              else if ("materials" === _)
                for (let [_, L] of Object.entries(F)) c(["materials", _], L);
              else if (0 === z[_]) {
                if ("geometry" === _ && void 0 !== F.extrusion) {
                  let L = {
                    path: [_, "extrusion"],
                    props: F.extrusion,
                    type: 0,
                  };
                  N.push(L), (F = { ...F }), delete F.extrusion;
                }
                if (Object.keys(F).length > 0) {
                  let L = { path: [_], props: F, type: 0 };
                  N.push(L);
                }
              } else
                void 0 === R &&
                  ((R = { path: [], props: {}, type: 0 }), N.push(R)),
                  (R.props[_] = F);
            }
          return N;
        }),
        (fN.patch = function (_, L) {
          if (void 0 === L) return _;
          let R = { ..._ };
          return (
            (Object.assign(R, fX.merge(R, L)),
            Object.assign(R, {
              pathSnapping: Object.assign({}, R.pathSnapping, {
                slide: L.pathSnapping?.slide ?? R.pathSnapping?.slide ?? 0,
                offset: L.pathSnapping?.offset ?? R.pathSnapping?.offset ?? 0,
              }),
            }),
            pC.is(_.type))
              ? ((R.orthographic = { ...R.orthographic }),
                (R.perspective = { ...R.perspective }),
                L.orthographic?.zoom !== void 0 &&
                  (R.orthographic.zoom = L.orthographic.zoom),
                L.perspective?.zoom !== void 0 &&
                  (R.perspective.zoom = L.perspective.zoom),
                void 0 !== L.isUpVectorFlipped &&
                  (R.isUpVectorFlipped = L.isUpVectorFlipped),
                void 0 !== L.targetOffset && (R.targetOffset = L.targetOffset))
              : "Mesh" === _.type
                ? ("geometry" in L &&
                    Object.assign(R, {
                      geometry: fH.merge(R.geometry, L.geometry),
                    }),
                  (L.material || L.materials) &&
                    (R = (function (_, L) {
                      if (void 0 === L) return _;
                      let R = { ..._ };
                      return (
                        "material" in R &&
                          "material" in L &&
                          L.material &&
                          (R.material = Fc(R.material, (_) => {
                            if ("string" != typeof _)
                              for (let [R, N] of Object.entries(
                                L.material.layers,
                              )) {
                                let L = _.layers.data(R);
                                L && pG.patch(L, N);
                              }
                          }).data),
                        R.materials &&
                          L.materials &&
                          (R.materials = Fc(R.materials, (_) => {
                            for (let N = 0; N < R.materials.length; N++) {
                              let R = L.materials[N];
                              if ("string" != typeof R)
                                for (let [L, z] of Object.entries(R.layers)) {
                                  let R = _[N]?.layers?.data(L);
                                  R && pG.patch(R, z);
                                }
                            }
                          }).data),
                        R
                      );
                    })(R, L)),
                  R.cloner &&
                    "cloner" in L &&
                    Object.assign(R, { cloner: pO.merge(R.cloner, L.cloner) }))
                : "Empty" === _.type
                  ? R.cloner &&
                    "cloner" in L &&
                    Object.assign(R, { cloner: pO.merge(R.cloner, L.cloner) })
                  : pI.is(_.type) &&
                    (void 0 !== L.intensity && (R.intensity = L.intensity),
                    void 0 !== L.color &&
                      ("string" == typeof L.color
                        ? (R.color = L.color)
                        : (R.color = pb.clone(L.color)))),
            R
          );
        }),
        ((f8 || (f8 = {})).defaultData = {
          enabled: !1,
          useBackgroundColor: !1,
          color: pb.white,
          near: 0.1,
          far: 2e3,
        }),
        ((f9 || (f9 = {})).defaultData = {
          enablePan: !0,
          enableZoom: !0,
          enableRotate: !0,
          enableDamping: !0,
          rotationLimitsMode: 0,
          rotationVerticalOffset: { min: Math.PI / 4, max: Math.PI / 4 },
          rotationHorizontalOffset: { min: Math.PI / 4, max: Math.PI / 4 },
          rotationSoftLimit: 2,
          panLimitsMode: 0,
          panVerticalOffset: { min: 250, max: 250 },
          panHorizontalOffset: { min: 250, max: 250 },
          panSoftLimit: 2,
          zoomLimitsEnabled: !1,
          zoomLimits: { min: 0.1, max: 2 },
          autoRotate: !1,
          autoRotateSpeed: 2,
          autoRotateClockwise: !0,
          hoverRotatePanMode: 0,
          hoverRotatePanStrength: 20,
          isTouchZoom: !0,
          orbitTouches: 2,
          panTouches: 3,
          resetHoverEffectOnPointerLeave: !0,
          autoZoom: !1,
        }),
        ((f7 || (f7 = {})).defaultData = {
          orbitControls: f9.defaultData,
          playCamera: null,
          withBackground: !0,
          preventScroll: !1,
          preventTouchScroll: !1,
          hideCursor: !1,
          mouseEventTarget: "canvas",
          settings: {
            image: { format: "jpg", ratio: 1 },
            video: {
              format: "mp4",
              imageFormat: "jpg",
              fps: 30,
              mbps: 80,
              ratio:
                "u" > typeof window ? Math.floor(window.devicePixelRatio) : 1,
              stopMode: "manual",
              duration: 5e3,
            },
            web: { logo: !0, compress: !0, preset: 1, preload: !0, hint: !1 },
          },
          stopRaycast: !0,
          joystickSizeAndXYOffset: Array(12)
            .fill(0)
            .map((_, L) => {
              let R = 0,
                N = 0;
              return (
                L < 5 ? (N = -30) : L < 10 && (N = 30),
                0 === L || 10 === L || 5 === L
                  ? (R = 30)
                  : (4 === L || 11 === L || 9 === L) && (R = -30),
                [120, [R, N], "show"]
              );
            }),
          gameControlObject: null,
        }),
        typeof window > "u" ||
          window.navigator.userAgent.toLowerCase().includes(" electron/");
      var pQ =
          !(typeof window > "u") &&
          window.navigator.platform.toUpperCase().includes("MAC"),
        pZ =
          !(typeof window > "u") &&
          (/iPad|iPhone|iPod/.test(window.navigator.userAgent) ||
            (pQ && "ontouchend" in document)),
        pK =
          !(typeof window > "u") &&
          window.navigator.userAgent.toLowerCase().indexOf("firefox") > -1,
        pJ =
          !(typeof window > "u") &&
          ("ontouchstart" in window || navigator.maxTouchPoints > 0),
        p$ = (() => {
          if (typeof window > "u") return !1;
          let _ = navigator.userAgent,
            L = navigator.vendor;
          return /Safari/i.test(_) && /Apple Computer/.test(L);
        })(),
        p0 = Number(
          (() => {
            if (typeof window > "u") return null;
            let _ = navigator.userAgent.match(/Version\/(\d+\.\d)/);
            return _ && _[1];
          })(),
        );
      function Bm(_) {
        return Array.isArray(_) ? _ : [_];
      }
      function uh(_) {
        return pQ ? _.metaKey : _.ctrlKey;
      }
      var p1 = [],
        p2 = {},
        p4 = {},
        p5 = {};
      function xE(_) {
        p1.includes(_) || p1.push(_);
      }
      function Xc(_) {
        delete p2[_.pointerId];
        for (let L = 0; L < p1.length; L++)
          if (p1[L].pointerId === _.pointerId) {
            p1.splice(L, 1);
            break;
          }
      }
      function Gm(_) {
        if ("touch" !== _.pointerType) return;
        let L = p2[_.pointerId];
        void 0 === L && ((L = { x: 0, y: 0 }), (p2[_.pointerId] = L)),
          (L.x = _.pageX),
          (L.y = _.pageY);
      }
      function km(_) {
        return p2[(_.pointerId === p1[0].pointerId ? p1[1] : p1[0]).pointerId];
      }
      function SE(_) {
        (p4[_.key] = !0),
          (p5[_.key] = void 0 === p5[_.key] ? 1 : p5[_.key] + 1);
      }
      function wE(_) {
        if (pQ && p4.Meta) for (let _ in p4) p4[_] = !1;
        else p4[_.key] = !1;
        p5 = {};
      }
      function TE(_) {
        _.layers.forEach((_) => {
          if ("depth" === _.type && void 0 !== _.colorA) {
            let L = _.colorA,
              R = _.colorB,
              N = [
                [L.r, L.g, L.b, L.a],
                [R.r, R.g, R.b, R.a],
              ],
              z = [0, 1];
            for (let _ = 2; _ < 10; _++) N.push(N[1]), z.push(1);
            let F = {
              ...cW(
                Wn(_),
                "type",
                "visible",
                "isVector",
                "isWorldSpace",
                "origin",
                "alpha",
                "mode",
              ),
              near: Math.max(0, _.near),
              far: Math.max(0, _.far),
              colors: N,
              steps: z,
              num: 2,
              direction: [1, 0, 0],
              smooth: !1,
              gradientType: 1,
            };
            Object.assign(_, F);
          } else if (
            "depth" === _.type &&
            1 === _.gradientType &&
            (_.near < 0 || _.far < 0)
          ) {
            let L = {
              ...Wn(_),
              near: Math.max(_.near, 0),
              far: Math.max(_.far, 0),
            };
            Object.assign(_, L);
          }
        });
      }
      function Vm(_, L) {
        Object.values(_.shared.materials).forEach((_) => L(_));
      }
      function Hm(_, L) {
        _.scene.objects.traverse((_, R) => {
          "materials" in R
            ? R.materials.forEach((_) => {
                "string" != typeof _ && L(_);
              })
            : "material" in R && "string" != typeof R.material && L(R.material);
        });
      }
      function EE(_) {
        void 0 === _.layers &&
          Object.assign(_, fU.defaultTwoLayerData("lambert"));
      }
      function vx(_) {
        _.layers &&
          _.layers.forEach((_) => {
            if ("depth" === _.type && 10 === _.colors.length) {
              let L = [..._.colors];
              L.push(_.colors[9]);
              let R = [..._.steps];
              R.push(_.steps[9]);
              let N = { ...Wn(_), colors: L, steps: R };
              Object.assign(_, N);
            }
          });
      }
      function ME(_) {
        _.scene.objects.traverse((_, L) => {
          "materials" in L
            ? L.materials.forEach((_) => {
                "string" != typeof _ && vx(_);
              })
            : "material" in L &&
              "string" != typeof L.material &&
              vx(L.material);
        }),
          Object.values(_.shared.materials).forEach((_) => vx(_));
      }
      function CE(_) {
        _.layers &&
          _.layers.forEach((_) => {
            "depth" === _.type &&
              void 0 !== _.num &&
              ((_.colors = _.colors.slice(0, _.num)),
              (_.steps = _.steps.slice(0, _.num)),
              delete _.num);
          });
      }
      function PE(_) {
        let L = _.layers.find((_) => "light" === _.type)?.data;
        L?.category === "basic" &&
          (Object.assign(L, pG.defaultData("light", "phong")),
          (L.visible = !1));
      }
      function IE(_) {
        Vm(_, PE), Hm(_, PE);
      }
      function no(_, L = !1) {
        let R = null !== _[0].index,
          N = new Set(Object.keys(_[0].attributes)),
          z = new Set(Object.keys(_[0].morphAttributes)),
          F = {},
          U = {},
          k = _[0].morphTargetsRelative,
          Y = new sP(),
          X = 0;
        for (let Q = 0; Q < _.length; ++Q) {
          let K = _[Q],
            J = 0;
          if (R !== (null !== K.index))
            return (
              console.error(
                "THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " +
                  Q +
                  ". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.",
              ),
              null
            );
          for (let _ in K.attributes) {
            if (!N.has(_))
              return (
                console.error(
                  "THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " +
                    Q +
                    '. All geometries must have compatible attributes; make sure "' +
                    _ +
                    '" attribute exists among all geometries, or in none of them.',
                ),
                null
              );
            void 0 === F[_] && (F[_] = []), F[_].push(K.attributes[_]), J++;
          }
          if (J !== N.size)
            return (
              console.error(
                "THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " +
                  Q +
                  ". Make sure all geometries have the same number of attributes.",
              ),
              null
            );
          if (k !== K.morphTargetsRelative)
            return (
              console.error(
                "THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " +
                  Q +
                  ". .morphTargetsRelative must be consistent throughout all geometries.",
              ),
              null
            );
          for (let _ in K.morphAttributes) {
            if (!z.has(_))
              return (
                console.error(
                  "THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " +
                    Q +
                    ".  .morphAttributes must be consistent throughout all geometries.",
                ),
                null
              );
            void 0 === U[_] && (U[_] = []), U[_].push(K.morphAttributes[_]);
          }
          if (L) {
            let _;
            if (R) _ = K.index.count;
            else {
              if (void 0 === K.attributes.position)
                return (
                  console.error(
                    "THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " +
                      Q +
                      ". The geometry must have either an index or a position attribute",
                  ),
                  null
                );
              _ = K.attributes.position.count;
            }
            Y.addGroup(X, _, Q), (X += _);
          }
        }
        if (R) {
          let L = 0,
            R = [];
          for (let N = 0; N < _.length; ++N) {
            let z = _[N].index;
            for (let _ = 0; _ < z.count; ++_) R.push(z.getX(_) + L);
            L += _[N].attributes.position.count;
          }
          Y.setIndex(R);
        }
        for (let _ in F) {
          let L = LE(F[_]);
          if (!L)
            return (
              console.error(
                "THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the " +
                  _ +
                  " attribute.",
              ),
              null
            );
          Y.setAttribute(_, L);
        }
        for (let _ in U) {
          let L = U[_][0].length;
          if (0 === L) break;
          (Y.morphAttributes = Y.morphAttributes || {}),
            (Y.morphAttributes[_] = []);
          for (let R = 0; R < L; ++R) {
            let L = [];
            for (let N = 0; N < U[_].length; ++N) L.push(U[_][N][R]);
            let N = LE(L);
            if (!N)
              return (
                console.error(
                  "THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the " +
                    _ +
                    " morphAttribute.",
                ),
                null
              );
            Y.morphAttributes[_].push(N);
          }
        }
        return Y;
      }
      function LE(_) {
        let L,
          R,
          N,
          z = 0;
        for (let F = 0; F < _.length; ++F) {
          let U = _[F];
          if (U.isInterleavedBufferAttribute)
            return (
              console.error(
                "THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported.",
              ),
              null
            );
          if (
            (void 0 === L && (L = U.array.constructor),
            L !== U.array.constructor)
          )
            return (
              console.error(
                "THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.",
              ),
              null
            );
          if ((void 0 === R && (R = U.itemSize), R !== U.itemSize))
            return (
              console.error(
                "THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.",
              ),
              null
            );
          if ((void 0 === N && (N = U.normalized), N !== U.normalized))
            return (
              console.error(
                "THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.",
              ),
              null
            );
          z += U.array.length;
        }
        let F = new L(z),
          U = 0;
        for (let L = 0; L < _.length; ++L)
          F.set(_[L].array, U), (U += _[L].array.length);
        return new sh(F, R, N);
      }
      ((mt || (mt = {})).defaultData = {
        ambientLight: {
          enabled: !0,
          color: {
            r: 0.8274509803921568,
            g: 0.8274509803921568,
            b: 0.8274509803921568,
          },
          intensity: 0.75,
          depth: 100,
          groundColor: {
            r: 0.5098039215686274,
            g: 0.5098039215686274,
            b: 0.5098039215686274,
          },
          softShadows: !0,
          softShadowQuality: "low",
        },
        usePhysics: !1,
        gravity: -10,
        pixelsPerMeter: 200,
        skinWidthRelative: 0.02,
        stepThreshRelative: 0.3,
        slopeThresh: 65,
      }),
        ((_) => {
          function t(_ = { withLight: !0, withSquare: !0 }) {
            let L = new cZ(),
              R = f5.defaultMeshObject;
            return (
              !0 === _.withLight &&
                L.push({
                  fi: -1,
                  data: {
                    ...f1.defaultData("DirectionalLight"),
                    position: [200, 300, 300],
                    name: "Directional Light",
                    intensity: 0.7,
                  },
                  id: "830a2708-8ed9-49cf-a68e-085299899103",
                  children: [],
                }),
              !0 === _.withSquare &&
                L.push({
                  fi: 1,
                  id: "7ba78968-2a55-48f2-b14c-5191da3e075e",
                  data: R,
                  children: [],
                }),
              L
            );
          }
          function i(L) {
            return { ..._.defaultData, objects: Ri(L, cZ.prototype) };
          }
          (_.TRASH_CAN_ID = "830a2708-8ed9-49cf-a68e-085299892222"),
            (_.defaultData = {
              backgroundColor: pw.fromHexAndA(2960946, 1),
              postprocessing: pR.defaultData,
              fog: f8.defaultData,
              objects: t(),
              environment: mt.defaultData,
              publish: f7.defaultData,
            }),
            (_.emptyData = function (_) {
              return {
                backgroundColor: pw.fromHexAndA(2960946, 1),
                postprocessing: pR.defaultData,
                fog: f8.defaultData,
                objects: _ ? t(_) : new cZ(),
                environment: mt.defaultData,
                publish: f7.defaultData,
              };
            }),
            (_.withObjs = i),
            (_.withObj = function (_, L) {
              return i([{ id: _, data: L, children: [], fi: 0 }]);
            });
        })(mi || (mi = {})),
        ((mr || (mr = {})).emptyImage = {
          data: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVQYV2NgYAAAAAMAAWgmWQ0AAAAASUVORK5CYII=",
        }),
        ((fz = ms || (ms = {})).defaultColors = function () {
          let _ = {};
          return (
            (_["89b10010-844c-11ec-a8a3-0242ac120002"] = {
              r: 0.5,
              g: 0.5,
              b: 0.5,
              a: 1,
              name: "Default Color",
            }),
            Ri(_, cq.prototype)
          );
        }),
        (fz.defaultImages = function (_) {
          let L = {};
          return (
            _?.withAITexture &&
              (L["a1b10010-844c-a8a3-11ec-0242ac2011ec"] = {
                ...mr.emptyImage,
                name: "AI generated image",
              }),
            Ri(L, cq.prototype)
          );
        }),
        (fz.emptyData = function () {
          return {
            materials: new cq(),
            images: new cq(),
            videos: new cq(),
            colors: new cq(),
            audios: new cq(),
            fonts: new cq(),
            penumbraSize: [2, 2, 2],
          };
        }),
        ((fF = mn || (mn = {})).defaultColliderData = {
          type: "capsule",
          height: 200,
          radius: 50,
          position: [0, 0, 0],
          rotation: [0, 0, 0],
        }),
        (fF.defaultDataThirdPerson = {
          moveMode: "walk",
          speedTranslate: 1e3,
          speedRotate: 100,
          rotationMode: "normal",
          rotBy: "keys",
          rotByTouch: "drag",
          delayPos: [0.3, 0.3],
          delayRot: [0.3, 0.3],
          keyAssignments: [
            ["moveNegZ", "W"],
            ["moveNegX", "A"],
            ["movePosZ", "S"],
            ["movePosX", "D"],
            ["rotPosX", ""],
            ["rotPosY", ""],
            ["rotNegX", ""],
            ["rotNegY", ""],
            ["jump", "Space"],
          ],
          touchControl: !0,
          joystickPosLoc: 5,
          joystickRotLoc: 11,
          jumpTouchButtonLoc: 9,
          collider: fF.defaultColliderData,
          colliderHelperVisible: !0,
          collisionEnabled: !0,
          jumpPower: 100,
          resetYPosition: 3e3,
          alignToGround: !1,
          autoOrientMove: !0,
          orientWith: "camera",
          orientMode: "radial",
          delayPosCamera: 0.3,
          delayRotCamera: 0.3,
          camera: "",
          cameraXAxis: "Limit",
          cameraYAxis: "Free",
          cameraRotXLimits: [0, Math.PI / 2],
          cameraRotYLimits: [-Math.PI / 2, Math.PI / 2],
          gameActions: { idle: new cK(), move: new cK(), jump: new cK() },
        });
      var p6 = class {
        constructor() {}
      };
      function hi(_, L, R) {
        return (
          (R.min.x = L[_]),
          (R.min.y = L[_ + 1]),
          (R.min.z = L[_ + 2]),
          (R.max.x = L[_ + 3]),
          (R.max.y = L[_ + 4]),
          (R.max.z = L[_ + 5]),
          R
        );
      }
      function xx(_) {
        let L = -1,
          R = -1 / 0;
        for (let N = 0; N < 3; N++) {
          let z = _[N + 3] - _[N];
          z > R && ((R = z), (L = N));
        }
        return L;
      }
      function Sx(_, L, R) {
        let N, z;
        for (let F = 0; F < 3; F++) {
          let U = F + 3;
          (N = _[F]),
            (z = L[F]),
            (R[F] = N < z ? N : z),
            (N = _[U]),
            (z = L[U]),
            (R[U] = N > z ? N : z);
        }
      }
      function hh(_, L, R) {
        for (let N = 0; N < 3; N++) {
          let z = L[_ + 2 * N],
            F = L[_ + 2 * N + 1],
            U = z - F,
            k = z + F;
          U < R[N] && (R[N] = U), k > R[N + 3] && (R[N + 3] = k);
        }
      }
      function Qc(_) {
        let L = _[3] - _[0],
          R = _[4] - _[1],
          N = _[5] - _[2];
        return 2 * (L * R + R * N + N * L);
      }
      function Ax(_, L, R, N, z = null) {
        let F = 1 / 0,
          U = 1 / 0,
          k = 1 / 0,
          Y = -1 / 0,
          X = -1 / 0,
          Q = -1 / 0,
          K = 1 / 0,
          J = 1 / 0,
          $ = 1 / 0,
          ee = -1 / 0,
          er = -1 / 0,
          en = -1 / 0,
          ea = null !== z;
        for (let N = 6 * L, z = (L + R) * 6; N < z; N += 6) {
          let L = _[N + 0],
            R = _[N + 1],
            z = L - R,
            eo = L + R;
          z < F && (F = z),
            eo > Y && (Y = eo),
            ea && L < K && (K = L),
            ea && L > ee && (ee = L);
          let el = _[N + 2],
            ec = _[N + 3],
            ed = el - ec,
            eu = el + ec;
          ed < U && (U = ed),
            eu > X && (X = eu),
            ea && el < J && (J = el),
            ea && el > er && (er = el);
          let ep = _[N + 4],
            ef = _[N + 5],
            ev = ep - ef,
            ex = ep + ef;
          ev < k && (k = ev),
            ex > Q && (Q = ex),
            ea && ep < $ && ($ = ep),
            ea && ep > en && (en = ep);
        }
        (N[0] = F),
          (N[1] = U),
          (N[2] = k),
          (N[3] = Y),
          (N[4] = X),
          (N[5] = Q),
          ea &&
            ((z[0] = K),
            (z[1] = J),
            (z[2] = $),
            (z[3] = ee),
            (z[4] = er),
            (z[5] = en));
      }
      var w4 = (_, L) => _.candidate - L.candidate,
        p8 = Array(32)
          .fill()
          .map(() => ({
            count: 0,
            bounds: new Float32Array(6),
            rightCacheBounds: new Float32Array(6),
            leftCacheBounds: new Float32Array(6),
            candidate: 0,
          })),
        p9 = new Float32Array(6),
        p7 = class {
          constructor() {
            (this.min = 1 / 0), (this.max = -1 / 0);
          }
          setFromPointsField(_, L) {
            let R = 1 / 0,
              N = -1 / 0;
            for (let z = 0, F = _.length; z < F; z++) {
              let F = _[z][L];
              (R = F < R ? F : R), (N = F > N ? F : N);
            }
            (this.min = R), (this.max = N);
          }
          setFromPoints(_, L) {
            let R = 1 / 0,
              N = -1 / 0;
            for (let z = 0, F = L.length; z < F; z++) {
              let F = L[z],
                U = _.dot(F);
              (R = U < R ? U : R), (N = U > N ? U : N);
            }
            (this.min = R), (this.max = N);
          }
          isSeparated(_) {
            return this.min > _.max || _.min > this.max;
          }
        };
      (p7.prototype.setFromBox =
        ((F = new iq()),
        function (_, L) {
          let R = L.min,
            N = L.max,
            z = 1 / 0,
            U = -1 / 0;
          for (let L = 0; L <= 1; L++)
            for (let k = 0; k <= 1; k++)
              for (let Y = 0; Y <= 1; Y++) {
                (F.x = R.x * L + N.x * (1 - L)),
                  (F.y = R.y * k + N.y * (1 - k)),
                  (F.z = R.z * Y + N.z * (1 - Y));
                let X = _.dot(F);
                (z = Math.min(X, z)), (U = Math.max(X, U));
              }
          (this.min = z), (this.max = U);
        })),
        new p7();
      var ft =
          ((U = new iq()),
          (k = new iq()),
          (Y = new iq()),
          function (_, L, R) {
            let N = _.start,
              z = L.start;
            Y.subVectors(N, z),
              U.subVectors(_.end, L.start),
              k.subVectors(L.end, L.start);
            let F = Y.dot(k),
              X = k.dot(U),
              Q = k.dot(k),
              K = Y.dot(U),
              J = U.dot(U) * Q - X * X,
              $,
              ee;
            ($ = 0 !== J ? (F * X - K * Q) / J : 0),
              (ee = (F + $ * X) / Q),
              (R.x = $),
              (R.y = ee);
          }),
        fr =
          ((X = new iT()),
          (Q = new iq()),
          (K = new iq()),
          function (_, L, R, N) {
            ft(_, L, X);
            let z = X.x,
              F = X.y;
            if (z >= 0 && z <= 1 && F >= 0 && F <= 1) {
              _.at(z, R), L.at(F, N);
              return;
            }
            if (z >= 0 && z <= 1) {
              F < 0 ? L.at(0, N) : L.at(1, N), _.closestPointToPoint(N, !0, R);
              return;
            }
            if (F >= 0 && F <= 1) {
              z < 0 ? _.at(0, R) : _.at(1, R), L.closestPointToPoint(R, !0, N);
              return;
            }
            {
              let U, k;
              if (
                ((U = z < 0 ? _.start : _.end),
                (k = F < 0 ? L.start : L.end),
                _.closestPointToPoint(k, !0, Q),
                L.closestPointToPoint(U, !0, K),
                Q.distanceToSquared(k) <= K.distanceToSquared(U))
              ) {
                R.copy(Q), N.copy(k);
                return;
              }
              R.copy(U), N.copy(K);
              return;
            }
          }),
        fs =
          ((J = new iq()),
          ($ = new iq()),
          (ee = new s6()),
          (er = new oH()),
          function (_, L) {
            let { radius: R, center: N } = _,
              { a: z, b: F, c: U } = L;
            if (
              ((er.start = z),
              (er.end = F),
              er.closestPointToPoint(N, !0, J).distanceTo(N) <= R ||
                ((er.start = z),
                (er.end = U),
                er.closestPointToPoint(N, !0, J).distanceTo(N) <= R) ||
                ((er.start = F),
                (er.end = U),
                er.closestPointToPoint(N, !0, J).distanceTo(N) <= R))
            )
              return !0;
            let k = L.getPlane(ee);
            if (Math.abs(k.distanceToPoint(N)) <= R) {
              let _ = k.projectPoint(N, $);
              if (L.containsPoint(_)) return !0;
            }
            return !1;
          });
      function Jc(_) {
        return 1e-15 > Math.abs(_);
      }
      var fa = class extends se {
        constructor(..._) {
          super(..._),
            (this.isExtendedTriangle = !0),
            (this.satAxes = [, , , ,].fill().map(() => new iq())),
            (this.satBounds = [, , , ,].fill().map(() => new p7())),
            (this.points = [this.a, this.b, this.c]),
            (this.sphere = new ro()),
            (this.plane = new s6()),
            (this.needsUpdate = !0);
        }
        intersectsSphere(_) {
          return fs(_, this);
        }
        update() {
          let _ = this.a,
            L = this.b,
            R = this.c,
            N = this.points,
            z = this.satAxes,
            F = this.satBounds,
            U = z[0],
            k = F[0];
          this.getNormal(U), k.setFromPoints(U, N);
          let Y = z[1],
            X = F[1];
          Y.subVectors(_, L), X.setFromPoints(Y, N);
          let Q = z[2],
            K = F[2];
          Q.subVectors(L, R), K.setFromPoints(Q, N);
          let J = z[3],
            $ = F[3];
          J.subVectors(R, _),
            $.setFromPoints(J, N),
            this.sphere.setFromPoints(this.points),
            this.plane.setFromNormalAndCoplanarPoint(U, _),
            (this.needsUpdate = !1);
        }
      };
      (fa.prototype.closestPointToSegment =
        ((en = new iq()),
        (ea = new iq()),
        (eo = new oH()),
        function (_, L = null, R = null) {
          let { start: N, end: z } = _,
            F = this.points,
            U,
            k = 1 / 0;
          for (let N = 0; N < 3; N++) {
            let z = (N + 1) % 3;
            eo.start.copy(F[N]),
              eo.end.copy(F[z]),
              fr(eo, _, en, ea),
              (U = en.distanceToSquared(ea)) < k &&
                ((k = U), L && L.copy(en), R && R.copy(ea));
          }
          return (
            this.closestPointToPoint(N, en),
            (U = N.distanceToSquared(en)) < k &&
              ((k = U), L && L.copy(en), R && R.copy(N)),
            this.closestPointToPoint(z, en),
            (U = z.distanceToSquared(en)) < k &&
              ((k = U), L && L.copy(en), R && R.copy(z)),
            Math.sqrt(k)
          );
        })),
        (fa.prototype.intersectsTriangle =
          ((el = new fa()),
          (ec = [, , ,]),
          (ed = [, , ,]),
          (eu = new p7()),
          (ep = new p7()),
          (ef = new iq()),
          (ev = new iq()),
          (ex = new iq()),
          (eb = new iq()),
          (ew = new oH()),
          (e_ = new oH()),
          (eA = new oH()),
          function (_, L = null) {
            this.needsUpdate && this.update(),
              _.isExtendedTriangle
                ? _.needsUpdate && _.update()
                : (el.copy(_), el.update(), (_ = el));
            let R = this.plane,
              N = _.plane;
            if (Math.abs(R.normal.dot(N.normal)) > 1 - 1e-10) {
              let R = this.satBounds,
                N = this.satAxes;
              (ed[0] = _.a), (ed[1] = _.b), (ed[2] = _.c);
              for (let _ = 0; _ < 4; _++) {
                let L = R[_],
                  z = N[_];
                if ((eu.setFromPoints(z, ed), L.isSeparated(eu))) return !1;
              }
              let z = _.satBounds,
                F = _.satAxes;
              (ec[0] = this.a), (ec[1] = this.b), (ec[2] = this.c);
              for (let _ = 0; _ < 4; _++) {
                let L = z[_],
                  R = F[_];
                if ((eu.setFromPoints(R, ec), L.isSeparated(eu))) return !1;
              }
              for (let _ = 0; _ < 4; _++) {
                let L = N[_];
                for (let _ = 0; _ < 4; _++) {
                  let R = F[_];
                  if (
                    (ef.crossVectors(L, R),
                    eu.setFromPoints(ef, ec),
                    ep.setFromPoints(ef, ed),
                    eu.isSeparated(ep))
                  )
                    return !1;
                }
              }
              return (
                L &&
                  (console.warn(
                    "ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0.",
                  ),
                  L.start.set(0, 0, 0),
                  L.end.set(0, 0, 0)),
                !0
              );
            }
            {
              let z = this.points,
                F = !1,
                U = 0;
              for (let _ = 0; _ < 3; _++) {
                let L = z[_],
                  R = z[(_ + 1) % 3];
                ew.start.copy(L), ew.end.copy(R), ew.delta(ev);
                let k = F ? e_.start : e_.end,
                  Y = Jc(N.distanceToPoint(L));
                if (Jc(N.normal.dot(ev)) && Y) {
                  e_.copy(ew), (U = 2);
                  break;
                }
                if ((N.intersectLine(ew, k) || Y) && !Jc(k.distanceTo(R))) {
                  if ((U++, F)) break;
                  F = !0;
                }
              }
              if (1 === U && this.containsPoint(e_.start))
                return L && (L.start.copy(e_.start), L.end.copy(e_.start)), !0;
              if (2 !== U) return !1;
              let k = _.points,
                Y = !1,
                X = 0;
              for (let _ = 0; _ < 3; _++) {
                let L = k[_],
                  N = k[(_ + 1) % 3];
                ew.start.copy(L), ew.end.copy(N), ew.delta(ex);
                let z = Y ? eA.start : eA.end,
                  F = Jc(R.distanceToPoint(L));
                if (Jc(R.normal.dot(ex)) && F) {
                  eA.copy(ew), (X = 2);
                  break;
                }
                if ((R.intersectLine(ew, z) || F) && !Jc(z.distanceTo(N))) {
                  if ((X++, Y)) break;
                  Y = !0;
                }
              }
              if (1 === X && this.containsPoint(eA.start))
                return L && (L.start.copy(eA.start), L.end.copy(eA.start)), !0;
              if (2 !== X) return !1;
              if ((e_.delta(ev), eA.delta(ex), 0 > ev.dot(ex))) {
                let _ = eA.start;
                (eA.start = eA.end), (eA.end = _);
              }
              let Q = e_.start.dot(ev),
                K = e_.end.dot(ev),
                J = eA.start.dot(ev),
                $ = eA.end.dot(ev);
              return (
                (Q === $ || J === K || K < J != Q < $) &&
                (L &&
                  (eb.subVectors(e_.start, eA.start),
                  eb.dot(ev) > 0
                    ? L.start.copy(e_.start)
                    : L.start.copy(eA.start),
                  eb.subVectors(e_.end, eA.end),
                  0 > eb.dot(ev) ? L.end.copy(e_.end) : L.end.copy(eA.end)),
                !0)
              );
            }
          })),
        (fa.prototype.distanceToPoint =
          ((eM = new iq()),
          function (_) {
            return this.closestPointToPoint(_, eM), _.distanceTo(eM);
          })),
        (fa.prototype.distanceToTriangle =
          ((eE = new iq()),
          (eC = new iq()),
          (eP = ["a", "b", "c"]),
          (eD = new oH()),
          (eO = new oH()),
          function (_, L = null, R = null) {
            let N = L || R ? eD : null;
            if (this.intersectsTriangle(_, N))
              return (L || R) && (L && N.getCenter(L), R && N.getCenter(R)), 0;
            let z = 1 / 0;
            for (let N = 0; N < 3; N++) {
              let F,
                U = eP[N],
                k = _[U];
              this.closestPointToPoint(k, eE),
                (F = k.distanceToSquared(eE)) < z &&
                  ((z = F), L && L.copy(eE), R && R.copy(k));
              let Y = this[U];
              _.closestPointToPoint(Y, eE),
                (F = Y.distanceToSquared(eE)) < z &&
                  ((z = F), L && L.copy(Y), R && R.copy(eE));
            }
            for (let N = 0; N < 3; N++) {
              let F = eP[N],
                U = eP[(N + 1) % 3];
              eD.set(this[F], this[U]);
              for (let N = 0; N < 3; N++) {
                let F = eP[N],
                  U = eP[(N + 1) % 3];
                eO.set(_[F], _[U]), fr(eD, eO, eE, eC);
                let k = eE.distanceToSquared(eC);
                k < z && ((z = k), L && L.copy(eE), R && R.copy(eC));
              }
            }
            return Math.sqrt(z);
          }));
      var fh = class extends iK {
        constructor(..._) {
          super(..._),
            (this.isOrientedBox = !0),
            (this.matrix = new rw()),
            (this.invMatrix = new rw()),
            (this.points = Array(8)
              .fill()
              .map(() => new iq())),
            (this.satAxes = [, , ,].fill().map(() => new iq())),
            (this.satBounds = [, , ,].fill().map(() => new p7())),
            (this.alignedSatBounds = [, , ,].fill().map(() => new p7())),
            (this.needsUpdate = !1);
        }
        set(_, L, R) {
          super.set(_, L), this.matrix.copy(R), (this.needsUpdate = !0);
        }
        copy(_) {
          super.copy(_), this.matrix.copy(_.matrix), (this.needsUpdate = !0);
        }
      };
      (fh.prototype.update = function () {
        let _ = this.matrix,
          L = this.min,
          R = this.max,
          N = this.points;
        for (let z = 0; z <= 1; z++)
          for (let F = 0; F <= 1; F++)
            for (let U = 0; U <= 1; U++) {
              let k = N[(1 * z) | (2 * F) | (4 * U)];
              (k.x = z ? R.x : L.x),
                (k.y = F ? R.y : L.y),
                (k.z = U ? R.z : L.z),
                k.applyMatrix4(_);
            }
        let z = this.satBounds,
          F = this.satAxes,
          U = N[0];
        for (let _ = 0; _ < 3; _++) {
          let L = F[_],
            R = z[_],
            k = N[1 << _];
          L.subVectors(U, k), R.setFromPoints(L, N);
        }
        let k = this.alignedSatBounds;
        k[0].setFromPointsField(N, "x"),
          k[1].setFromPointsField(N, "y"),
          k[2].setFromPointsField(N, "z"),
          this.invMatrix.copy(this.matrix).invert(),
          (this.needsUpdate = !1);
      }),
        (fh.prototype.intersectsBox =
          ((eL = new p7()),
          function (_) {
            this.needsUpdate && this.update();
            let L = _.min,
              R = _.max,
              N = this.satBounds,
              z = this.satAxes,
              F = this.alignedSatBounds;
            if (
              ((eL.min = L.x),
              (eL.max = R.x),
              F[0].isSeparated(eL) ||
                ((eL.min = L.y), (eL.max = R.y), F[1].isSeparated(eL)) ||
                ((eL.min = L.z), (eL.max = R.z), F[2].isSeparated(eL)))
            )
              return !1;
            for (let L = 0; L < 3; L++) {
              let R = z[L],
                F = N[L];
              if ((eL.setFromBox(R, _), F.isSeparated(eL))) return !1;
            }
            return !0;
          })),
        (fh.prototype.intersectsTriangle =
          ((eR = new fa()),
          (eI = [, , ,]),
          (eB = new p7()),
          (ez = new p7()),
          (eF = new iq()),
          function (_) {
            this.needsUpdate && this.update(),
              _.isExtendedTriangle
                ? _.needsUpdate && _.update()
                : (eR.copy(_), eR.update(), (_ = eR));
            let L = this.satBounds,
              R = this.satAxes;
            (eI[0] = _.a), (eI[1] = _.b), (eI[2] = _.c);
            for (let _ = 0; _ < 3; _++) {
              let N = L[_],
                z = R[_];
              if ((eB.setFromPoints(z, eI), N.isSeparated(eB))) return !1;
            }
            let N = _.satBounds,
              z = _.satAxes,
              F = this.points;
            for (let _ = 0; _ < 3; _++) {
              let L = N[_],
                R = z[_];
              if ((eB.setFromPoints(R, F), L.isSeparated(eB))) return !1;
            }
            for (let _ = 0; _ < 3; _++) {
              let L = R[_];
              for (let _ = 0; _ < 4; _++) {
                let R = z[_];
                if (
                  (eF.crossVectors(L, R),
                  eB.setFromPoints(eF, eI),
                  ez.setFromPoints(eF, F),
                  eB.isSeparated(ez))
                )
                  return !1;
              }
            }
            return !0;
          })),
        (fh.prototype.closestPointToPoint = function (_, L) {
          return (
            this.needsUpdate && this.update(),
            L.copy(_)
              .applyMatrix4(this.invMatrix)
              .clamp(this.min, this.max)
              .applyMatrix4(this.matrix),
            L
          );
        }),
        (fh.prototype.distanceToPoint =
          ((eU = new iq()),
          function (_) {
            return this.closestPointToPoint(_, eU), _.distanceTo(eU);
          })),
        (fh.prototype.distanceToBox =
          ((ek = ["x", "y", "z"]),
          (ej = Array(12)
            .fill()
            .map(() => new oH())),
          (eG = Array(12)
            .fill()
            .map(() => new oH())),
          (eV = new iq()),
          (eH = new iq()),
          function (_, L = 0, R = null, N = null) {
            if ((this.needsUpdate && this.update(), this.intersectsBox(_)))
              return (
                (R || N) &&
                  (_.getCenter(eH),
                  this.closestPointToPoint(eH, eV),
                  _.closestPointToPoint(eV, eH),
                  R && R.copy(eV),
                  N && N.copy(eH)),
                0
              );
            let z = L * L,
              F = _.min,
              U = _.max,
              k = this.points,
              Y = 1 / 0;
            for (let _ = 0; _ < 8; _++) {
              let L = k[_];
              eH.copy(L).clamp(F, U);
              let X = L.distanceToSquared(eH);
              if (X < Y && ((Y = X), R && R.copy(L), N && N.copy(eH), X < z))
                return Math.sqrt(X);
            }
            let X = 0;
            for (let _ = 0; _ < 3; _++)
              for (let L = 0; L <= 1; L++)
                for (let R = 0; R <= 1; R++) {
                  let N = (_ + 1) % 3,
                    z = (_ + 2) % 3,
                    Y = (L << N) | (R << z),
                    Q = (1 << _) | (L << N) | (R << z),
                    K = k[Y],
                    J = k[Q];
                  ej[X].set(K, J);
                  let $ = ek[_],
                    ee = ek[N],
                    er = ek[z],
                    en = eG[X],
                    ea = en.start,
                    eo = en.end;
                  (ea[$] = F[$]),
                    (ea[ee] = L ? F[ee] : U[ee]),
                    (ea[er] = R ? F[er] : U[ee]),
                    (eo[$] = U[$]),
                    (eo[ee] = L ? F[ee] : U[ee]),
                    (eo[er] = R ? F[er] : U[ee]),
                    X++;
                }
            for (let _ = 0; _ <= 1; _++)
              for (let L = 0; L <= 1; L++)
                for (let k = 0; k <= 1; k++) {
                  (eH.x = _ ? U.x : F.x),
                    (eH.y = L ? U.y : F.y),
                    (eH.z = k ? U.z : F.z),
                    this.closestPointToPoint(eH, eV);
                  let X = eH.distanceToSquared(eV);
                  if (
                    X < Y &&
                    ((Y = X), R && R.copy(eV), N && N.copy(eH), X < z)
                  )
                    return Math.sqrt(X);
                }
            for (let _ = 0; _ < 12; _++) {
              let L = ej[_];
              for (let _ = 0; _ < 12; _++) {
                fr(L, eG[_], eV, eH);
                let F = eV.distanceToSquared(eH);
                if (F < Y && ((Y = F), R && R.copy(eV), N && N.copy(eH), F < z))
                  return Math.sqrt(F);
              }
            }
            return Math.sqrt(Y);
          }));
      var fd = new iq(),
        fu = new iq(),
        fp = new iq(),
        ff = new iT(),
        fv = new iT(),
        fx = new iT(),
        fb = new iq();
      function Tx(_, L, R, N, z) {
        let F = 3 * N,
          U = _.index.getX(F),
          k = _.index.getX(F + 1),
          Y = _.index.getX(F + 2),
          X = (function (_, L, R, N, z, F, U) {
            fd.fromBufferAttribute(L, N),
              fu.fromBufferAttribute(L, z),
              fp.fromBufferAttribute(L, F);
            let k =
              null ===
              (1 === U
                ? _.intersectTriangle(fp, fu, fd, !0, fb)
                : _.intersectTriangle(fd, fu, fp, 2 !== U, fb))
                ? null
                : { distance: _.origin.distanceTo(fb), point: fb.clone() };
            if (k) {
              R &&
                (ff.fromBufferAttribute(R, N),
                fv.fromBufferAttribute(R, z),
                fx.fromBufferAttribute(R, F),
                (k.uv = se.getUV(fb, fd, fu, fp, ff, fv, fx, new iT())));
              let _ = { a: N, b: z, c: F, normal: new iq(), materialIndex: 0 };
              se.getNormal(fd, fu, fp, _.normal),
                (k.face = _),
                (k.faceIndex = N);
            }
            return k;
          })(R, _.attributes.position, _.attributes.uv, U, k, Y, L);
        return X ? ((X.faceIndex = N), z && z.push(X), X) : null;
      }
      function Ex(_, L, R) {
        return null === _ ||
          (_.point.applyMatrix4(L.matrixWorld),
          (_.distance = _.point.distanceTo(R.ray.origin)),
          (_.object = L),
          _.distance < R.near || _.distance > R.far)
          ? null
          : _;
      }
      function fi(_, L, R, N) {
        let z = _.a,
          F = _.b,
          U = _.c,
          k = L,
          Y = L + 1,
          X = L + 2;
        R && ((k = R.getX(L)), (Y = R.getX(L + 1)), (X = R.getX(L + 2))),
          (z.x = N.getX(k)),
          (z.y = N.getY(k)),
          (z.z = N.getZ(k)),
          (F.x = N.getX(Y)),
          (F.y = N.getY(Y)),
          (F.z = N.getZ(Y)),
          (U.x = N.getX(X)),
          (U.y = N.getY(X)),
          (U.z = N.getZ(X));
      }
      function Mx(_, L, R, N, z, F, U) {
        let k = R.index,
          Y = R.attributes.position;
        for (let R = _, X = L + _; R < X; R++)
          if ((fi(U, 3 * R, k, Y), (U.needsUpdate = !0), N(U, R, z, F)))
            return !0;
        return !1;
      }
      var fw = class {
        constructor(_) {
          (this._getNewPrimitive = _), (this._primitives = []);
        }
        getPrimitive() {
          let _ = this._primitives;
          return 0 === _.length ? this._getNewPrimitive() : _.pop();
        }
        releasePrimitive(_) {
          this._primitives.push(_);
        }
      };
      function io(_, L) {
        return 65535 === L[_ + 15];
      }
      var f_ = new iK(),
        fA = new iq(),
        fM = ["x", "y", "z"],
        fE =
          ((eX = []),
          (eq = new fw(() => new iK())),
          function (..._) {
            (eW = eq.getPrimitive()), (eY = eq.getPrimitive()), eX.push(eW, eY);
            let L = (function i(_, L, R, N, z = null, F = 0, U = 0) {
              function h(_) {
                let L = 2 * _,
                  R = ml,
                  N = mh;
                for (; !io(L, R); ) (_ += 8), (L = 2 * _);
                return N[_ + 6];
              }
              function f(_) {
                let L = 2 * _,
                  R = ml,
                  N = mh;
                for (; !io(L, R); ) L = 2 * (_ = N[_ + 6]);
                return N[_ + 6] + R[L + 14];
              }
              let k = 2 * _,
                Y = mo,
                X = ml,
                Q = mh;
              if (io(k, X)) {
                let L = Q[_ + 6],
                  R = X[k + 14];
                return hi(_, Y, eW), N(L, R, !1, U, F + _, eW);
              }
              {
                let k = _ + 8,
                  K = Q[_ + 6],
                  J = k,
                  $ = K,
                  ee,
                  er,
                  en,
                  ea;
                if (
                  z &&
                  ((en = eW),
                  (ea = eY),
                  hi(J, Y, en),
                  hi($, Y, ea),
                  (ee = z(en)),
                  (er = z(ea)) < ee)
                ) {
                  (J = K), ($ = k);
                  let _ = ee;
                  (ee = er), (er = _), (en = ea);
                }
                en || hi(J, Y, (en = eW));
                let eo = R(en, io(2 * J, X), ee, U + 1, F + J),
                  el;
                if (2 === eo) {
                  let _ = h(J),
                    L = f(J) - _;
                  el = N(_, L, !0, U + 1, F + J, en);
                } else el = eo && i(J, L, R, N, z, F, U + 1);
                if (el) return !0;
                hi($, Y, (ea = eY));
                let ec = R(ea, io(2 * $, X), er, U + 1, F + $),
                  ed;
                if (2 === ec) {
                  let _ = h($),
                    L = f($) - _;
                  ed = N(_, L, !0, U + 1, F + $, ea);
                } else ed = ec && i($, L, R, N, z, F, U + 1);
                return !!ed;
              }
            })(..._);
            eq.releasePrimitive(eW),
              eq.releasePrimitive(eY),
              eX.pop(),
              eX.pop();
            let R = eX.length;
            return R > 0 && ((eY = eX[R - 1]), (eW = eX[R - 2])), L;
          }),
        fD =
          ((eQ = new fa()),
          (eZ = new fa()),
          (eK = new rw()),
          (eJ = new fh()),
          (e$ = new fh()),
          function s(_, L, R, N, z = null) {
            let F = 2 * _,
              U = mo,
              k = ml,
              Y = mh;
            if (
              (null === z &&
                (R.boundingBox || R.computeBoundingBox(),
                eJ.set(R.boundingBox.min, R.boundingBox.max, N),
                (z = eJ)),
              io(F, k))
            ) {
              let z = L.index,
                X = L.attributes.position,
                Q = R.index,
                K = R.attributes.position,
                J = Y[_ + 6],
                $ = k[F + 14];
              if ((eK.copy(N).invert(), R.boundsTree))
                return (
                  hi(_, U, e$),
                  e$.matrix.copy(eK),
                  (e$.needsUpdate = !0),
                  R.boundsTree.shapecast({
                    intersectsBounds: (_) => e$.intersectsBox(_),
                    intersectsTriangle: (_) => {
                      _.a.applyMatrix4(N),
                        _.b.applyMatrix4(N),
                        _.c.applyMatrix4(N),
                        (_.needsUpdate = !0);
                      for (let L = 3 * J, R = ($ + J) * 3; L < R; L += 3)
                        if (
                          (fi(eZ, L, z, X),
                          (eZ.needsUpdate = !0),
                          _.intersectsTriangle(eZ))
                        )
                          return !0;
                      return !1;
                    },
                  })
                );
              for (let _ = 3 * J, L = $ + 3 * J; _ < L; _ += 3) {
                fi(eQ, _, z, X),
                  eQ.a.applyMatrix4(eK),
                  eQ.b.applyMatrix4(eK),
                  eQ.c.applyMatrix4(eK),
                  (eQ.needsUpdate = !0);
                for (let _ = 0, L = Q.count; _ < L; _ += 3)
                  if (
                    (fi(eZ, _, Q, K),
                    (eZ.needsUpdate = !0),
                    eQ.intersectsTriangle(eZ))
                  )
                    return !0;
              }
            } else {
              let F = _ + 8,
                k = Y[_ + 6];
              return (
                hi(F, U, f_),
                !!(
                  (z.intersectsBox(f_) && s(F, L, R, N, z)) ||
                  (hi(k, U, f_), z.intersectsBox(f_) && s(k, L, R, N, z))
                )
              );
            }
          });
      function eg(_, L, R, N) {
        return hi(_, L, f_), R.intersectBox(f_, N);
      }
      var fO,
        fL,
        fR,
        fI,
        fB,
        fN,
        fz,
        fF,
        fU,
        fk,
        fj,
        fG,
        fV,
        fH,
        fW,
        fY,
        fX,
        fq,
        fQ,
        fZ,
        fK,
        fJ,
        f$,
        f1,
        f2,
        f4,
        f5,
        f6,
        f8,
        f9,
        f7,
        mt,
        mi,
        mr,
        ms,
        mn,
        ma,
        mo,
        ml,
        mh,
        md = [];
      function su(_) {
        ma && md.push(ma),
          (ma = _),
          (mo = new Float32Array(_)),
          (ml = new Uint16Array(_)),
          (mh = new Uint32Array(_));
      }
      function ph() {
        (ma = null),
          (mo = null),
          (ml = null),
          (mh = null),
          md.length && su(md.pop());
      }
      var mu = Symbol("skip tree generation"),
        mp = new iK(),
        mm = new iK(),
        mg = new rw(),
        mv = new fh(),
        my = new fh(),
        mx = new iq(),
        mb = new iq(),
        mw = new iq(),
        m_ = new iq(),
        mE = new iq(),
        mT = new iK(),
        mC = new fw(() => new fa()),
        mD = class {
          static serialize(_, L = {}) {
            if (L.isBufferGeometry)
              return (
                console.warn(
                  "MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature.",
                ),
                mD.serialize(arguments[0], {
                  cloneBuffers: void 0 === arguments[2] || arguments[2],
                })
              );
            L = { cloneBuffers: !0, ...L };
            let R = _.geometry,
              N = _._roots,
              z = R.getIndex();
            return L.cloneBuffers
              ? { roots: N.map((_) => _.slice()), index: z.array.slice() }
              : { roots: N, index: z.array };
          }
          static deserialize(_, L, R = {}) {
            if ("boolean" == typeof R)
              return (
                console.warn(
                  "MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature.",
                ),
                mD.deserialize(arguments[0], arguments[1], {
                  setIndex: void 0 === arguments[2] || arguments[2],
                })
              );
            R = { setIndex: !0, ...R };
            let { index: N, roots: z } = _,
              F = new mD(L, { ...R, [mu]: !0 });
            if (((F._roots = z), R.setIndex)) {
              let R = L.getIndex();
              if (null === R) {
                let R = new sh(_.index, 1, !1);
                L.setIndex(R);
              } else R.array !== N && (R.array.set(N), (R.needsUpdate = !0));
            }
            return F;
          }
          constructor(_, L = {}) {
            if (_.isBufferGeometry) {
              if (_.index && _.index.isInterleavedBufferAttribute)
                throw Error(
                  "MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.",
                );
            } else throw Error("MeshBVH: Only BufferGeometries are supported.");
            if (
              (L = Object.assign(
                {
                  strategy: 0,
                  maxDepth: 40,
                  maxLeafTris: 10,
                  verbose: !0,
                  useSharedArrayBuffer: !1,
                  setBoundingBox: !0,
                  onProgress: null,
                  [mu]: !1,
                },
                L,
              )).useSharedArrayBuffer &&
              typeof SharedArrayBuffer > "u"
            )
              throw Error("MeshBVH: SharedArrayBuffer is not available.");
            (this._roots = null),
              L[mu] ||
                ((this._roots = (function (_, L) {
                  let R = (function (_, L) {
                      function e(_) {
                        Q && Q(_ / K);
                      }
                      function n(L, R, Q, K = null, $ = 0) {
                        if (
                          (!J &&
                            $ >= U &&
                            ((J = !0),
                            k &&
                              (console.warn(
                                `MeshBVH: Max depth of ${U} reached when generating BVH. Consider increasing maxDepth.`,
                              ),
                              console.warn(_))),
                          Q <= Y || $ >= U)
                        )
                          return e(R + Q), (L.offset = R), (L.count = Q), L;
                        let ee = (function (_, L, R, N, z, F) {
                          let U = -1,
                            k = 0;
                          if (0 === F)
                            -1 !== (U = xx(L)) && (k = (L[U] + L[U + 3]) / 2);
                          else if (1 === F)
                            -1 !== (U = xx(_)) &&
                              (k = (function (_, L, R, N) {
                                let z = 0;
                                for (let F = L, U = L + R; F < U; F++)
                                  z += _[6 * F + 2 * N];
                                return z / R;
                              })(R, N, z, U));
                          else if (2 === F) {
                            let F = Qc(_),
                              Y = 1.25 * z,
                              X = 6 * N,
                              Q = (N + z) * 6;
                            for (let _ = 0; _ < 3; _++) {
                              let N = L[_],
                                K = (L[_ + 3] - N) / 32;
                              if (z < 8) {
                                let L = [...p8];
                                L.length = z;
                                let N = 0;
                                for (let z = X; z < Q; z += 6, N++) {
                                  let F = L[N];
                                  (F.candidate = R[z + 2 * _]), (F.count = 0);
                                  let {
                                    bounds: U,
                                    leftCacheBounds: k,
                                    rightCacheBounds: Y,
                                  } = F;
                                  for (let _ = 0; _ < 3; _++)
                                    (Y[_] = 1 / 0),
                                      (Y[_ + 3] = -1 / 0),
                                      (k[_] = 1 / 0),
                                      (k[_ + 3] = -1 / 0),
                                      (U[_] = 1 / 0),
                                      (U[_ + 3] = -1 / 0);
                                  hh(z, R, U);
                                }
                                L.sort(w4);
                                let K = z;
                                for (let _ = 0; _ < K; _++) {
                                  let R = L[_];
                                  for (
                                    ;
                                    _ + 1 < K &&
                                    L[_ + 1].candidate === R.candidate;

                                  )
                                    L.splice(_ + 1, 1), K--;
                                }
                                for (let N = X; N < Q; N += 6) {
                                  let z = R[N + 2 * _];
                                  for (let _ = 0; _ < K; _++) {
                                    let F = L[_];
                                    z >= F.candidate
                                      ? hh(N, R, F.rightCacheBounds)
                                      : (hh(N, R, F.leftCacheBounds),
                                        F.count++);
                                  }
                                }
                                for (let R = 0; R < K; R++) {
                                  let N = L[R],
                                    X = N.count,
                                    Q = z - N.count,
                                    K = N.leftCacheBounds,
                                    J = N.rightCacheBounds,
                                    $ = 0;
                                  0 !== X && ($ = Qc(K) / F);
                                  let ee = 0;
                                  0 !== Q && (ee = Qc(J) / F);
                                  let er = 1 + 1.25 * ($ * X + ee * Q);
                                  er < Y &&
                                    ((U = _), (Y = er), (k = N.candidate));
                                }
                              } else {
                                for (let _ = 0; _ < 32; _++) {
                                  let L = p8[_];
                                  (L.count = 0), (L.candidate = N + K + _ * K);
                                  let R = L.bounds;
                                  for (let _ = 0; _ < 3; _++)
                                    (R[_] = 1 / 0), (R[_ + 3] = -1 / 0);
                                }
                                for (let L = X; L < Q; L += 6) {
                                  let z = ~~((R[L + 2 * _] - N) / K);
                                  z >= 32 && (z = 31);
                                  let F = p8[z];
                                  F.count++, hh(L, R, F.bounds);
                                }
                                let L = p8[31];
                                !(function (_, L) {
                                  L.set(_);
                                })(L.bounds, L.rightCacheBounds);
                                for (let _ = 30; _ >= 0; _--) {
                                  let L = p8[_],
                                    R = p8[_ + 1];
                                  Sx(
                                    L.bounds,
                                    R.rightCacheBounds,
                                    L.rightCacheBounds,
                                  );
                                }
                                let J = 0;
                                for (let L = 0; L < 31; L++) {
                                  let R = p8[L],
                                    N = R.count,
                                    X = R.bounds,
                                    Q = p8[L + 1].rightCacheBounds;
                                  0 !== N &&
                                    (0 === J
                                      ? (function (_, L) {
                                          L.set(_);
                                        })(X, p9)
                                      : Sx(X, p9, p9));
                                  let K = 0,
                                    $ = 0;
                                  0 !== (J += N) && (K = Qc(p9) / F);
                                  let ee = z - J;
                                  0 !== ee && ($ = Qc(Q) / F);
                                  let er = 1 + 1.25 * (K * J + $ * ee);
                                  er < Y &&
                                    ((U = _), (Y = er), (k = R.candidate));
                                }
                              }
                            }
                          } else
                            console.warn(
                              `MeshBVH: Invalid build strategy value ${F} used.`,
                            );
                          return { axis: U, pos: k };
                        })(L.boundingData, K, z, R, Q, X);
                        if (-1 === ee.axis)
                          return e(R + Q), (L.offset = R), (L.count = Q), L;
                        let er = (function (_, L, R, N, z) {
                          let F = R,
                            U = R + N - 1,
                            k = z.pos,
                            Y = 2 * z.axis;
                          for (;;) {
                            for (; F <= U && L[6 * F + Y] < k; ) F++;
                            for (; F <= U && L[6 * U + Y] >= k; ) U--;
                            if (!(F < U)) return F;
                            for (let R = 0; R < 3; R++) {
                              let N = _[3 * F + R];
                              (_[3 * F + R] = _[3 * U + R]), (_[3 * U + R] = N);
                              let z = L[6 * F + 2 * R + 0];
                              (L[6 * F + 2 * R + 0] = L[6 * U + 2 * R + 0]),
                                (L[6 * U + 2 * R + 0] = z);
                              let k = L[6 * F + 2 * R + 1];
                              (L[6 * F + 2 * R + 1] = L[6 * U + 2 * R + 1]),
                                (L[6 * U + 2 * R + 1] = k);
                            }
                            F++, U--;
                          }
                        })(F, z, R, Q, ee);
                        if (er === R || er === R + Q)
                          e(R + Q), (L.offset = R), (L.count = Q);
                        else {
                          L.splitAxis = ee.axis;
                          let _ = new p6(),
                            F = er - R;
                          (L.left = _),
                            (_.boundingData = new Float32Array(6)),
                            Ax(z, R, F, _.boundingData, N),
                            n(_, R, F, N, $ + 1);
                          let U = new p6(),
                            k = Q - F;
                          (L.right = U),
                            (U.boundingData = new Float32Array(6)),
                            Ax(z, er, k, U.boundingData, N),
                            n(U, er, k, N, $ + 1);
                        }
                        return L;
                      }
                      !(function (_, L) {
                        if (!_.index) {
                          let R = _.attributes.position.count,
                            N = L.useSharedArrayBuffer
                              ? SharedArrayBuffer
                              : ArrayBuffer,
                            z;
                          (z =
                            R > 65535
                              ? new Uint32Array(new N(4 * R))
                              : new Uint16Array(new N(2 * R))),
                            _.setIndex(new sh(z, 1));
                          for (let _ = 0; _ < R; _++) z[_] = _;
                        }
                      })(_, L);
                      let R = new Float32Array(6),
                        N = new Float32Array(6),
                        z = (function (_, L) {
                          let R = _.attributes.position,
                            N = R.array,
                            z = _.index.array,
                            F = z.length / 3,
                            U = new Float32Array(6 * F),
                            k = R.offset || 0,
                            Y = 3;
                          R.isInterleavedBufferAttribute && (Y = R.data.stride);
                          for (let _ = 0; _ < F; _++) {
                            let R = 3 * _,
                              F = 6 * _,
                              X = z[R + 0] * Y + k,
                              Q = z[R + 1] * Y + k,
                              K = z[R + 2] * Y + k;
                            for (let _ = 0; _ < 3; _++) {
                              let R = N[X + _],
                                z = N[Q + _],
                                k = N[K + _],
                                Y = R;
                              z < Y && (Y = z), k < Y && (Y = k);
                              let J = R;
                              z > J && (J = z), k > J && (J = k);
                              let $ = (J - Y) / 2,
                                ee = 2 * _;
                              (U[F + ee + 0] = Y + $),
                                (U[F + ee + 1] =
                                  $ + (Math.abs(Y) + $) * 5960464477539063e-23),
                                Y < L[_] && (L[_] = Y),
                                J > L[_ + 3] && (L[_ + 3] = J);
                            }
                          }
                          return U;
                        })(_, R),
                        F = _.index.array,
                        U = L.maxDepth,
                        k = L.verbose,
                        Y = L.maxLeafTris,
                        X = L.strategy,
                        Q = L.onProgress,
                        K = _.index.count / 3,
                        J = !1,
                        $ = [],
                        ee = (function (_) {
                          if (!_.groups || !_.groups.length)
                            return [{ offset: 0, count: _.index.count / 3 }];
                          let L = [],
                            R = new Set();
                          for (let L of _.groups)
                            R.add(L.start), R.add(L.start + L.count);
                          let N = Array.from(R.values()).sort((_, L) => _ - L);
                          for (let _ = 0; _ < N.length - 1; _++) {
                            let R = N[_],
                              z = N[_ + 1];
                            L.push({ offset: R / 3, count: (z - R) / 3 });
                          }
                          return L;
                        })(_);
                      if (1 === ee.length) {
                        let _ = ee[0],
                          L = new p6();
                        (L.boundingData = R),
                          (function (_, L, R, N) {
                            let z = 1 / 0,
                              F = 1 / 0,
                              U = 1 / 0,
                              k = -1 / 0,
                              Y = -1 / 0,
                              X = -1 / 0;
                            for (
                              let N = 6 * L, Q = (L + R) * 6;
                              N < Q;
                              N += 6
                            ) {
                              let L = _[N + 0];
                              L < z && (z = L), L > k && (k = L);
                              let R = _[N + 2];
                              R < F && (F = R), R > Y && (Y = R);
                              let Q = _[N + 4];
                              Q < U && (U = Q), Q > X && (X = Q);
                            }
                            (N[0] = z),
                              (N[1] = F),
                              (N[2] = U),
                              (N[3] = k),
                              (N[4] = Y),
                              (N[5] = X);
                          })(z, _.offset, _.count, N),
                          n(L, _.offset, _.count, N),
                          $.push(L);
                      } else
                        for (let _ of ee) {
                          let L = new p6();
                          (L.boundingData = new Float32Array(6)),
                            Ax(z, _.offset, _.count, L.boundingData, N),
                            n(L, _.offset, _.count, N),
                            $.push(L);
                        }
                      return $;
                    })(_, L),
                    N,
                    z,
                    F,
                    U = [],
                    k = L.useSharedArrayBuffer
                      ? SharedArrayBuffer
                      : ArrayBuffer;
                  for (let _ = 0; _ < R.length; _++) {
                    let L = R[_],
                      Y = (function l(_) {
                        return _.count ? 1 : 1 + l(_.left) + l(_.right);
                      })(L),
                      X = new k(32 * Y);
                    (N = new Float32Array(X)),
                      (z = new Uint32Array(X)),
                      (F = new Uint16Array(X)),
                      (function u(_, L) {
                        let R = _ / 4,
                          U = _ / 2,
                          k = !!L.count,
                          Y = L.boundingData;
                        for (let _ = 0; _ < 6; _++) N[R + _] = Y[_];
                        if (k) {
                          let N = L.offset,
                            k = L.count;
                          return (
                            (z[R + 6] = N),
                            (F[U + 14] = k),
                            (F[U + 15] = 65535),
                            _ + 32
                          );
                        }
                        {
                          let N = L.left,
                            F = L.right,
                            U = L.splitAxis,
                            k;
                          if ((k = u(_ + 32, N)) / 4 > 4294967296)
                            throw Error(
                              "MeshBVH: Cannot store child pointer greater than 32 bits.",
                            );
                          return (
                            (z[R + 6] = k / 4), (k = u(k, F)), (z[R + 7] = U), k
                          );
                        }
                      })(0, L),
                      U.push(X);
                  }
                  return U;
                })(_, L)),
                !_.boundingBox &&
                  L.setBoundingBox &&
                  (_.boundingBox = this.getBoundingBox(new iK()))),
              (this.geometry = _);
          }
          refit(_ = null) {
            _ && Array.isArray(_) && (_ = new Set(_));
            let L = this.geometry,
              R = L.index.array,
              N = L.attributes.position,
              z = N.array,
              F = N.offset || 0,
              U = 3;
            N.isInterleavedBufferAttribute && (U = N.data.stride);
            let k,
              Y,
              X,
              Q,
              K = 0,
              J = this._roots;
            for (let L = 0, N = J.length; L < N; L++)
              (k = J[L]),
                (Y = new Uint32Array(k)),
                (X = new Uint16Array(k)),
                (Q = new Float32Array(k)),
                (function g(L, N, k = !1) {
                  let K = 2 * L;
                  if (65535 === X[K + 15]) {
                    let _ = Y[L + 6],
                      N = X[K + 14],
                      k = 1 / 0,
                      J = 1 / 0,
                      $ = 1 / 0,
                      ee = -1 / 0,
                      er = -1 / 0,
                      en = -1 / 0;
                    for (let L = 3 * _, Y = 3 * (_ + N); L < Y; L++) {
                      let _ = R[L] * U + F,
                        N = z[_ + 0],
                        Y = z[_ + 1],
                        X = z[_ + 2];
                      N < k && (k = N),
                        N > ee && (ee = N),
                        Y < J && (J = Y),
                        Y > er && (er = Y),
                        X < $ && ($ = X),
                        X > en && (en = X);
                    }
                    return (
                      (Q[L + 0] !== k ||
                        Q[L + 1] !== J ||
                        Q[L + 2] !== $ ||
                        Q[L + 3] !== ee ||
                        Q[L + 4] !== er ||
                        Q[L + 5] !== en) &&
                      ((Q[L + 0] = k),
                      (Q[L + 1] = J),
                      (Q[L + 2] = $),
                      (Q[L + 3] = ee),
                      (Q[L + 4] = er),
                      (Q[L + 5] = en),
                      !0)
                    );
                  }
                  {
                    let R = L + 8,
                      z = Y[L + 6],
                      F = R + N,
                      U = z + N,
                      X = k,
                      K = !1,
                      J = !1;
                    _
                      ? X || ((K = _.has(F)), (J = _.has(U)), (X = !K && !J))
                      : ((K = !0), (J = !0));
                    let $ = X || K,
                      ee = X || J,
                      er = !1;
                    $ && (er = g(R, N, X));
                    let en = !1;
                    ee && (en = g(z, N, X));
                    let ea = er || en;
                    if (ea)
                      for (let _ = 0; _ < 3; _++) {
                        let N = R + _,
                          F = z + _,
                          U = Q[N],
                          k = Q[N + 3],
                          Y = Q[F],
                          X = Q[F + 3];
                        (Q[L + _] = U < Y ? U : Y),
                          (Q[L + _ + 3] = k > X ? k : X);
                      }
                    return ea;
                  }
                })(0, K),
                (K += k.byteLength);
          }
          traverse(_, L = 0) {
            let R = this._roots[L],
              N = new Uint32Array(R),
              z = new Uint16Array(R);
            !(function o(L, F = 0) {
              let U = 2 * L,
                k = 65535 === z[U + 15];
              if (k) {
                let Y = N[L + 6],
                  X = z[U + 14];
                _(F, k, new Float32Array(R, 4 * L, 6), Y, X);
              } else {
                let z = L + 8,
                  U = N[L + 6],
                  Y = N[L + 7];
                _(F, k, new Float32Array(R, 4 * L, 6), Y) ||
                  (o(z, F + 1), o(U, F + 1));
              }
            })(0);
          }
          raycast(_, L = 0) {
            let R = this._roots,
              N = this.geometry,
              z = [],
              F = L.isMaterial,
              U = Array.isArray(L),
              k = N.groups,
              Y = F ? L.side : L;
            for (let F = 0, X = R.length; F < X; F++) {
              let X = U ? L[k[F].materialIndex].side : Y,
                Q = z.length;
              if (
                (su(R[F]),
                (function Jm(_, L, R, N, z) {
                  let F = 2 * _,
                    U = mo,
                    k = ml,
                    Y = mh;
                  if (io(F, k))
                    !(function (_, L, R, N, z, F) {
                      for (let U = N, k = N + z; U < k; U++) Tx(_, L, R, U, F);
                    })(L, R, N, Y[_ + 6], k[F + 14], z);
                  else {
                    let F = _ + 8;
                    eg(F, U, N, fA) && Jm(F, L, R, N, z);
                    let k = Y[_ + 6];
                    eg(k, U, N, fA) && Jm(k, L, R, N, z);
                  }
                })(0, N, X, _, z),
                ph(),
                U)
              ) {
                let _ = k[F].materialIndex;
                for (let L = Q, R = z.length; L < R; L++)
                  z[L].face.materialIndex = _;
              }
            }
            return z;
          }
          raycastFirst(_, L = 0) {
            let R = this._roots,
              N = this.geometry,
              z = L.isMaterial,
              F = Array.isArray(L),
              U = null,
              k = N.groups,
              Y = z ? L.side : L;
            for (let z = 0, X = R.length; z < X; z++) {
              let X = F ? L[k[z].materialIndex].side : Y;
              su(R[z]);
              let Q = (function $m(_, L, R, N) {
                let z = 2 * _,
                  F = mo,
                  U = ml,
                  k = mh;
                if (io(z, U))
                  return (function (_, L, R, N, z) {
                    let F = 1 / 0,
                      U = null;
                    for (let k = N, Y = N + z; k < Y; k++) {
                      let N = Tx(_, L, R, k);
                      N && N.distance < F && ((U = N), (F = N.distance));
                    }
                    return U;
                  })(L, R, N, k[_ + 6], U[z + 14]);
                {
                  let z = k[_ + 7],
                    U = fM[z],
                    Y = N.direction[U] >= 0,
                    X,
                    Q;
                  Y
                    ? ((X = _ + 8), (Q = k[_ + 6]))
                    : ((X = k[_ + 6]), (Q = _ + 8));
                  let K = eg(X, F, N, fA) ? $m(X, L, R, N) : null;
                  if (K) {
                    let _ = K.point[U];
                    if (Y ? _ <= F[Q + z] : _ >= F[Q + z + 3]) return K;
                  }
                  let J = eg(Q, F, N, fA) ? $m(Q, L, R, N) : null;
                  return K && J
                    ? K.distance <= J.distance
                      ? K
                      : J
                    : K || J || null;
                }
              })(0, N, X, _);
              ph(),
                null != Q &&
                  (null == U || Q.distance < U.distance) &&
                  ((U = Q), F && (Q.face.materialIndex = k[z].materialIndex));
            }
            return U;
          }
          intersectsGeometry(_, L) {
            let R = this.geometry,
              N = !1;
            for (let z of this._roots)
              if ((su(z), (N = fD(0, R, _, L)), ph(), N)) break;
            return N;
          }
          shapecast(_, L, R) {
            let N = this.geometry;
            if (_ instanceof Function) {
              if (L) {
                let _ = L;
                L = (L, R, N, z) => {
                  let F = 3 * R;
                  return _(L, F, F + 1, F + 2, N, z);
                };
              }
              (_ = {
                boundsTraverseOrder: R,
                intersectsBounds: _,
                intersectsTriangle: L,
                intersectsRange: null,
              }),
                console.warn(
                  "MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.",
                );
            }
            let z = mC.getPrimitive(),
              {
                boundsTraverseOrder: F,
                intersectsBounds: U,
                intersectsRange: k,
                intersectsTriangle: Y,
              } = _;
            if (k && Y) {
              let _ = k;
              k = (L, R, F, U, k) =>
                !!_(L, R, F, U, k) || Mx(L, R, N, Y, F, U, z);
            } else
              k ||
                (k = Y
                  ? (_, L, R, F) => Mx(_, L, N, Y, R, F, z)
                  : (_, L, R) => R);
            let X = !1,
              Q = 0;
            for (let _ of this._roots) {
              if ((su(_), (X = fE(0, N, U, k, F, Q)), ph(), X)) break;
              Q += _.byteLength;
            }
            return mC.releasePrimitive(z), X;
          }
          bvhcast(_, L, R) {
            let { intersectsRanges: N, intersectsTriangles: z } = R,
              F = this.geometry.index,
              U = this.geometry.attributes.position,
              k = _.geometry.index,
              Y = _.geometry.attributes.position;
            mg.copy(L).invert();
            let X = mC.getPrimitive(),
              Q = mC.getPrimitive();
            if (z) {
              let f = function (_, R, N, K, J, $, ee, er) {
                for (let en = N, ea = N + K; en < ea; en++) {
                  fi(Q, 3 * en, k, Y),
                    Q.a.applyMatrix4(L),
                    Q.b.applyMatrix4(L),
                    Q.c.applyMatrix4(L),
                    (Q.needsUpdate = !0);
                  for (let L = _, N = _ + R; L < N; L++)
                    if (
                      (fi(X, 3 * L, F, U),
                      (X.needsUpdate = !0),
                      z(X, Q, L, en, J, $, ee, er))
                    )
                      return !0;
                }
                return !1;
              };
              if (N) {
                let _ = N;
                N = function (L, R, N, z, F, U, k, Y) {
                  return (
                    !!_(L, R, N, z, F, U, k, Y) || f(L, R, N, z, F, U, k, Y)
                  );
                };
              } else N = f;
            }
            _.getBoundingBox(mm), mm.applyMatrix4(L);
            let K = this.shapecast({
              intersectsBounds: (_) => mm.intersectsBox(_),
              intersectsRange: (L, R, z, F, U, k) => (
                mp.copy(k),
                mp.applyMatrix4(mg),
                _.shapecast({
                  intersectsBounds: (_) => mp.intersectsBox(_),
                  intersectsRange: (_, z, k, Y, X) => N(L, R, _, z, F, U, Y, X),
                })
              ),
            });
            return mC.releasePrimitive(X), mC.releasePrimitive(Q), K;
          }
          intersectsBox(_, L) {
            return (
              mv.set(_.min, _.max, L),
              (mv.needsUpdate = !0),
              this.shapecast({
                intersectsBounds: (_) => mv.intersectsBox(_),
                intersectsTriangle: (_) => mv.intersectsTriangle(_),
              })
            );
          }
          intersectsSphere(_) {
            return this.shapecast({
              intersectsBounds: (L) => _.intersectsBox(L),
              intersectsTriangle: (L) => L.intersectsSphere(_),
            });
          }
          closestPointToGeometry(_, L, R = {}, N = {}, z = 0, F = 1 / 0) {
            _.boundingBox || _.computeBoundingBox(),
              mv.set(_.boundingBox.min, _.boundingBox.max, L),
              (mv.needsUpdate = !0);
            let U = this.geometry,
              k = U.attributes.position,
              Y = U.index,
              X = _.attributes.position,
              Q = _.index,
              K = mC.getPrimitive(),
              J = mC.getPrimitive(),
              $ = null,
              ee = null;
            N && (($ = m_), (ee = mE));
            let er = 1 / 0,
              en = null,
              ea = null;
            return (
              mg.copy(L).invert(),
              my.matrix.copy(mg),
              this.shapecast({
                boundsTraverseOrder: (_) => mv.distanceToBox(_),
                intersectsBounds: (_, L, R) =>
                  R < er &&
                  R < F &&
                  (L &&
                    (my.min.copy(_.min),
                    my.max.copy(_.max),
                    (my.needsUpdate = !0)),
                  !0),
                intersectsRange: (R, N) => {
                  if (_.boundsTree)
                    return _.boundsTree.shapecast({
                      boundsTraverseOrder: (_) => my.distanceToBox(_),
                      intersectsBounds: (_, L, R) => R < er && R < F,
                      intersectsRange: (_, F) => {
                        for (let U = 3 * _, eo = (_ + F) * 3; U < eo; U += 3) {
                          fi(J, U, Q, X),
                            J.a.applyMatrix4(L),
                            J.b.applyMatrix4(L),
                            J.c.applyMatrix4(L),
                            (J.needsUpdate = !0);
                          for (let _ = 3 * R, L = (R + N) * 3; _ < L; _ += 3) {
                            fi(K, _, Y, k), (K.needsUpdate = !0);
                            let L = K.distanceToTriangle(J, mb, $);
                            if (
                              (L < er &&
                                (mw.copy(mb),
                                ee && ee.copy($),
                                (er = L),
                                (en = _ / 3),
                                (ea = U / 3)),
                              L < z)
                            )
                              return !0;
                          }
                        }
                      },
                    });
                  {
                    let _ = Q ? Q.count : X.count;
                    for (let F = 0; F < _; F += 3) {
                      fi(J, F, Q, X),
                        J.a.applyMatrix4(L),
                        J.b.applyMatrix4(L),
                        J.c.applyMatrix4(L),
                        (J.needsUpdate = !0);
                      for (let _ = 3 * R, L = (R + N) * 3; _ < L; _ += 3) {
                        fi(K, _, Y, k), (K.needsUpdate = !0);
                        let L = K.distanceToTriangle(J, mb, $);
                        if (
                          (L < er &&
                            (mw.copy(mb),
                            ee && ee.copy($),
                            (er = L),
                            (en = _ / 3),
                            (ea = F / 3)),
                          L < z)
                        )
                          return !0;
                      }
                    }
                  }
                },
              }),
              mC.releasePrimitive(K),
              mC.releasePrimitive(J),
              er === 1 / 0
                ? null
                : (R.point ? R.point.copy(mw) : (R.point = mw.clone()),
                  (R.distance = er),
                  (R.faceIndex = en),
                  N &&
                    (N.point ? N.point.copy(ee) : (N.point = ee.clone()),
                    N.point.applyMatrix4(mg),
                    mw.applyMatrix4(mg),
                    (N.distance = mw.sub(N.point).length()),
                    (N.faceIndex = ea)),
                  R)
            );
          }
          closestPointToPoint(_, L = {}, R = 0, N = 1 / 0) {
            let z = R * R,
              F = N * N,
              U = 1 / 0,
              k = null;
            if (
              (this.shapecast({
                boundsTraverseOrder: (L) => (
                  mx.copy(_).clamp(L.min, L.max), mx.distanceToSquared(_)
                ),
                intersectsBounds: (_, L, R) => R < U && R < F,
                intersectsTriangle: (L, R) => {
                  L.closestPointToPoint(_, mx);
                  let N = _.distanceToSquared(mx);
                  return N < U && (mb.copy(mx), (U = N), (k = R)), N < z;
                },
              }),
              U === 1 / 0)
            )
              return null;
            let Y = Math.sqrt(U);
            return (
              L.point ? L.point.copy(mb) : (L.point = mb.clone()),
              (L.distance = Y),
              (L.faceIndex = k),
              L
            );
          }
          getBoundingBox(_) {
            return (
              _.makeEmpty(),
              this._roots.forEach((L) => {
                hi(0, new Float32Array(L), mT), _.union(mT);
              }),
              _
            );
          }
        },
        mO = mD.prototype.raycast;
      mD.prototype.raycast = function (..._) {
        if (!_[0].isMesh) return mO.apply(this, _);
        {
          console.warn(
            'MeshBVH: The function signature and results frame for "raycast" has changed. See docs for new signature.',
          );
          let [L, R, N, z] = _;
          return (
            mO.call(this, N, L.material).forEach((_) => {
              (_ = Ex(_, L, R)) && z.push(_);
            }),
            z
          );
        }
      };
      var mL = mD.prototype.raycastFirst;
      mD.prototype.raycastFirst = function (..._) {
        if (!_[0].isMesh) return mL.apply(this, _);
        {
          console.warn(
            'MeshBVH: The function signature and results frame for "raycastFirst" has changed. See docs for new signature.',
          );
          let [L, R, N] = _;
          return Ex(mL.call(this, N, L.material), L, R);
        }
      };
      var mR = mD.prototype.closestPointToPoint;
      mD.prototype.closestPointToPoint = function (..._) {
        if (!_[0].isMesh) return mR.apply(this, _);
        {
          console.warn(
            'MeshBVH: The function signature and results frame for "closestPointToPoint" has changed. See docs for new signature.',
          ),
            _.unshift();
          let L = _[1],
            R = {};
          return (
            (_[1] = R), mR.apply(this, _), L && L.copy(R.point), R.distance
          );
        }
      };
      var mI = mD.prototype.closestPointToGeometry;
      mD.prototype.closestPointToGeometry = function (..._) {
        let L = _[2],
          R = _[3];
        if ((!L || !L.isVector3) && (!R || !R.isVector3))
          return mI.apply(this, _);
        {
          console.warn(
            'MeshBVH: The function signature and results frame for "closestPointToGeometry" has changed. See docs for new signature.',
          );
          let N = {},
            z = {},
            F = _[1];
          return (
            (_[2] = N),
            (_[3] = z),
            mI.apply(this, _),
            L && L.copy(N.point),
            R && R.copy(z.point).applyMatrix4(F),
            N.distance
          );
        }
      };
      var mB = mD.prototype.refit;
      (mD.prototype.refit = function (..._) {
        let L = _[0],
          R = _[1];
        if (R && (R instanceof Set || Array.isArray(R))) {
          console.warn(
            'MeshBVH: The function signature for "refit" has changed. See docs for new signature.',
          );
          let _ = new Set();
          R.forEach((L) => _.add(L)),
            L && L.forEach((L) => _.add(L)),
            mB.call(this, _);
        } else mB.apply(this, _);
      }),
        [
          "intersectsGeometry",
          "shapecast",
          "intersectsBox",
          "intersectsSphere",
        ].forEach((_) => {
          let L = mD.prototype[_];
          mD.prototype[_] = function (...R) {
            return (
              (null === R[0] || R[0].isMesh) &&
                (R.shift(),
                console.warn(
                  `MeshBVH: The function signature for "${_}" has changed and no longer takes Mesh. See docs for new signature.`,
                )),
              L.apply(this, R)
            );
          };
        });
      var mN = dd(it()),
        mz = 0.5 * (Math.sqrt(3) - 1),
        mF = (3 - Math.sqrt(3)) / 6,
        mU = 1 / 3,
        mk = 1 / 6,
        vh = (_) => 0 | Math.floor(_),
        mj = new Float64Array([
          1, 1, -1, 1, 1, -1, -1, -1, 1, 0, -1, 0, 1, 0, -1, 0, 0, 1, 0, -1, 0,
          1, 0, -1,
        ]),
        mG = new Float64Array([
          1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1, 0, 1, 0, 1, -1, 0, 1, 1, 0, -1,
          -1, 0, -1, 0, 1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1,
        ]);
      function ng(_ = Math.random) {
        let L = iM(_),
          R = new Float64Array(L).map((_) => mj[(_ % 12) * 2]),
          N = new Float64Array(L).map((_) => mj[(_ % 12) * 2 + 1]);
        return function (_, z) {
          let F = 0,
            U = 0,
            k = 0,
            Y = (_ + z) * mz,
            X = vh(_ + Y),
            Q = vh(z + Y),
            K = (X + Q) * mF,
            J = _ - (X - K),
            $ = z - (Q - K),
            ee,
            er;
          J > $ ? ((ee = 1), (er = 0)) : ((ee = 0), (er = 1));
          let en = J - ee + mF,
            ea = $ - er + mF,
            eo = J - 1 + 2 * mF,
            el = $ - 1 + 2 * mF,
            ec = 255 & X,
            ed = 255 & Q,
            eu = 0.5 - J * J - $ * $;
          if (eu >= 0) {
            let _ = ec + L[ed],
              z = R[_],
              U = N[_];
            (eu *= eu), (F = eu * eu * (z * J + U * $));
          }
          let ep = 0.5 - en * en - ea * ea;
          if (ep >= 0) {
            let _ = ec + ee + L[ed + er],
              z = R[_],
              F = N[_];
            (ep *= ep), (U = ep * ep * (z * en + F * ea));
          }
          let ef = 0.5 - eo * eo - el * el;
          if (ef >= 0) {
            let _ = ec + 1 + L[ed + 1],
              z = R[_],
              F = N[_];
            (ef *= ef), (k = ef * ef * (z * eo + F * el));
          }
          return 70 * (F + U + k);
        };
      }
      function iM(_) {
        let L = new Uint8Array(512);
        for (let _ = 0; _ < 256; _++) L[_] = _;
        for (let R = 0; R < 255; R++) {
          let N = R + ~~(_() * (256 - R)),
            z = L[R];
          (L[R] = L[N]), (L[N] = z);
        }
        for (let _ = 256; _ < 512; _++) L[_] = L[_ - 256];
        return L;
      }
      var mV,
        mH = new se(),
        mW = class {
          constructor(_) {
            this.weightAttribute = null;
            let L = _.geometry;
            if (!L.isBufferGeometry || 3 !== L.attributes.position.itemSize)
              throw Error(
                "THREE.MeshSurfaceSampler: Requires BufferGeometry triangle mesh.",
              );
            L.index && (L = L.toNonIndexed()),
              (this.geometry = L),
              (this.randomFunction = Math.random),
              (this.positionAttribute = this.geometry.getAttribute("position")),
              (this.distribution = null);
          }
          build() {
            let _ = this.positionAttribute,
              L = new Float32Array(_.count / 3);
            for (let R = 0; R < _.count; R += 3) {
              let N = 1;
              mH.a.fromBufferAttribute(_, R),
                mH.b.fromBufferAttribute(_, R + 1),
                mH.c.fromBufferAttribute(_, R + 2),
                (N *= mH.getArea()),
                (L[R / 3] = N);
            }
            this.distribution = new Float32Array(_.count / 3);
            let R = 0;
            for (let _ = 0; _ < L.length; _++)
              (R += L[_]), (this.distribution[_] = R);
            return this;
          }
          setRandomGenerator(_) {
            return (this.randomFunction = _), this;
          }
          sample(_, L) {
            if (this.distribution) {
              let R = this.distribution[this.distribution.length - 1],
                N = this.binarySearch(this.randomFunction() * R);
              return this.sampleFace(N, _, L);
            }
          }
          binarySearch(_) {
            if (!this.distribution) return 0;
            let L = this.distribution,
              R = 0,
              N = L.length - 1,
              z = -1;
            for (; R <= N; ) {
              let F = Math.ceil((R + N) / 2);
              if (0 === F || (L[F - 1] <= _ && L[F] > _)) {
                z = F;
                break;
              }
              _ < L[F] ? (N = F - 1) : (R = F + 1);
            }
            return z;
          }
          sampleFace(_, L, R) {
            let N = this.randomFunction(),
              z = this.randomFunction();
            return (
              N + z > 1 && ((N = 1 - N), (z = 1 - z)),
              mH.a.fromBufferAttribute(this.positionAttribute, 3 * _),
              mH.b.fromBufferAttribute(this.positionAttribute, 3 * _ + 1),
              mH.c.fromBufferAttribute(this.positionAttribute, 3 * _ + 2),
              L.set(0, 0, 0)
                .addScaledVector(mH.a, N)
                .addScaledVector(mH.b, z)
                .addScaledVector(mH.c, 1 - (N + z)),
              mH.getNormal(R),
              this
            );
          }
        },
        mY = dd(ii()),
        mX = new rw(),
        mq = new rw(),
        mQ = new rw();
      (mV || (mV = {})).is = function (_) {
        return _ && _.__isSPEObject;
      };
      var au = (_) =>
          class extends _ {
            constructor() {
              super(...arguments),
                (this.hiddenMatrix = new rw()),
                (this.matrixWorldRigid = new rw()),
                (this.shearScale = new rw()),
                (this.shearScaleInv = new rw());
            }
            get __isSPEObject() {
              return !0;
            }
            isDescendantOf(_) {
              _ instanceof rK && (_ = _.uuid);
              let L = this;
              for (; L.parent; ) {
                if (L.parent.uuid === _) return !0;
                L = L.parent;
              }
              return !1;
            }
            updateMatrixWorld(_) {
              for (let L of (this.matrixAutoUpdate && this.updateMatrix(),
              (this.matrixWorldNeedsUpdate || _) &&
                (null === this.parent
                  ? this.matrixWorld.multiplyMatrices(
                      this.hiddenMatrix,
                      this.matrix,
                    )
                  : (this.matrixWorld.multiplyMatrices(
                      this.parent.matrixWorld,
                      this.hiddenMatrix,
                    ),
                    this.matrixWorld.multiplyMatrices(
                      this.matrixWorld,
                      this.matrix,
                    )),
                (this.matrixWorldNeedsUpdate = !1),
                (_ = !0)),
              this.children))
                L.updateMatrixWorld(_);
            }
            updateWorldMatrix(_, L) {
              let R = this.parent;
              if (
                (_ && null !== R && R.updateWorldMatrix(!0, !1),
                this.matrixAutoUpdate && this.updateMatrix(),
                null === this.parent
                  ? this.matrixWorld.multiplyMatrices(
                      this.hiddenMatrix,
                      this.matrix,
                    )
                  : (this.matrixWorld.multiplyMatrices(
                      this.parent.matrixWorld,
                      this.hiddenMatrix,
                    ),
                    this.matrixWorld.multiplyMatrices(
                      this.matrixWorld,
                      this.matrix,
                    )),
                L)
              )
                for (let _ of this.children) _.updateWorldMatrix(!1, !0);
            }
            traverseObject(_, L = 0) {
              if (!0 !== _(this, L))
                for (let R of this.children)
                  mV.is(R) && R.traverseObject(_, L + 1);
            }
            updateMatrixWorldSVD() {
              let _ = this.matrixWorld.elements,
                L = [
                  [_[0], _[4], _[8]],
                  [_[1], _[5], _[9]],
                  [_[2], _[6], _[10]],
                ],
                { u: R, v: N, q: z } = (0, mY.SVD)(L),
                F = mX.set(
                  R[0][0],
                  R[0][1],
                  R[0][2],
                  0,
                  R[1][0],
                  R[1][1],
                  R[1][2],
                  0,
                  R[2][0],
                  R[2][1],
                  R[2][2],
                  0,
                  0,
                  0,
                  0,
                  1,
                ),
                U = mq.set(
                  N[0][0],
                  N[0][1],
                  N[0][2],
                  0,
                  N[1][0],
                  N[1][1],
                  N[1][2],
                  0,
                  N[2][0],
                  N[2][1],
                  N[2][2],
                  0,
                  0,
                  0,
                  0,
                  1,
                ),
                k = mQ.copy(U).transpose();
              this.shearScale
                .makeScale(z[0], z[1], z[2])
                .multiply(k)
                .premultiply(U),
                this.shearScaleInv.copy(this.shearScale).invert(),
                this.matrixWorldRigid
                  .multiplyMatrices(F, k)
                  .copyPosition(this.matrixWorld),
                z.every((_) => 0.01 > Math.abs(z[0] - _))
                  ? (this.hasNonUniformScale = !1)
                  : (this.hasNonUniformScale = !0);
            }
            attach(_, L) {
              this.updateWorldMatrix(!0, !1);
              let R = new rw().copy(this.matrixWorld).invert();
              return (
                null !== _.parent &&
                  (_.parent.updateWorldMatrix(!0, !1),
                  R.multiply(_.parent.matrixWorld)),
                "hiddenMatrix" in _ && _.hiddenMatrix instanceof rw
                  ? _.hiddenMatrix.premultiply(R)
                  : _.applyMatrix4(R),
                _.updateWorldMatrix(!1, !1),
                this.add(_),
                void 0 !== L &&
                  (this.children.pop(), this.children.splice(L, 0, _)),
                this
              );
            }
          },
        mZ = class extends au(rK) {},
        z4 = (_) => "Mesh" === _.type,
        mK = class extends mZ {
          constructor(_) {
            super(), (this.object = _), (this.matrixAutoUpdate = !1);
          }
          expand() {
            let _ = 0,
              L = this.object.entityChildren(_);
            for (; L; ) {
              let R = this.children[_];
              R?.object !== L &&
                (R && this.remove(R),
                (R = new mK(L)),
                this.add(R),
                this.children.splice(_, 0, this.children.pop()),
                (R.matrixWorldNeedsUpdate = !0),
                (R.matrixAutoUpdate = !1),
                (R.matrix = L.matrix),
                (R.hiddenMatrix = L.hiddenMatrix)),
                R.expand(),
                (_ += 1),
                (L = this.object.entityChildren(_));
            }
            for (; this.children.length > _; ) this.remove(this.children[_]);
          }
          get visible() {
            return (
              this.object.visible ||
              (this.object.dataPatched.visible &&
                this.object.dataPatched.cloner?.hideBase === !0)
            );
          }
          set visible(_) {}
          get castShadow() {
            return this.object.castShadow;
          }
          set castShadow(_) {}
          get receiveShadow() {
            return this.object.receiveShadow;
          }
          set receiveShadow(_) {}
          get isMesh() {
            return z4(this.object);
          }
          get isLight() {
            return this.object.isLight;
          }
          get layers() {
            return this.object.layers;
          }
          set layers(_) {}
          get isCamera() {
            return !1;
          }
          get geometry() {
            if (this.object.geometry) return this.object.geometry;
          }
          get material() {
            if (this.object.material) return this.object.material;
          }
        },
        mJ = new iq(),
        m$ = new iq(),
        m0 = new rw(),
        m4 = [
          new iq(-1, 1, 1),
          new iq(-1, -1, 1),
          new iq(1, -1, 1),
          new iq(1, 1, 1),
          new iq(-1, 1, -1),
          new iq(-1, -1, -1),
          new iq(1, -1, -1),
          new iq(1, 1, -1),
        ],
        m5 = [
          [0, 3],
          [1, 2],
          [5, 6],
          [4, 7],
          [0, 1],
          [3, 2],
          [7, 6],
          [4, 5],
          [0, 4],
          [1, 5],
          [2, 6],
          [3, 7],
        ],
        m6 = [
          [0, 2],
          [7, 5],
          [4, 1],
          [3, 6],
          [4, 3],
          [1, 6],
        ],
        aM = (_, L, R) => {
          _.updateEntityBoxSize(mJ, m$),
            m0.copy(L).multiply(_.matrixWorld),
            0 === m$.x && 0 === m$.y && 0 === m$.z
              ? R.push(new iq(mJ.x, mJ.y, mJ.z).applyMatrix4(m0))
              : m4.forEach((_) => {
                  R.push(_.clone().multiply(m$).add(mJ).applyMatrix4(m0));
                });
        },
        m8 = class extends iK {
          constructor() {
            super(...arguments),
              (this.matrix = new rw()),
              (this.vertices = []),
              (this.faces = []),
              (this.edges = []),
              (this.centerEdges = []);
          }
          copy(_) {
            return (
              super.copy(_),
              this.matrix.copy(_.matrix),
              (this.vertices = _.vertices.map((_) => _.clone())),
              (this.faces = _.faces.map((_) => _.clone())),
              (this.edges = _.edges.map((_) => _.clone())),
              (this.centerEdges = _.centerEdges.map((_) => _.clone())),
              this
            );
          }
          setFromObjectSize(_, L = !1) {
            _.updateWorldMatrix(!1, L),
              this.makeEmpty(),
              this.matrix.copy(_.matrixWorld);
            let R = new rw().copy(_.matrixWorld).invert();
            return this.expandByObjectSize(_, R, L);
          }
          expandByObjectSize(_, L, R = !1) {
            let N = [];
            return (
              !0 === R
                ? _.traverseEntity((_) => {
                    (_.visible || (_.cloner && _.data.visible)) && aM(_, L, N);
                  })
                : aM(_, L, N),
              this.setFromPoints(N)
            );
          }
          getCenter(_) {
            return (_ = super.getCenter(_)).applyMatrix4(this.matrix), _;
          }
          getPositionToCenter(_) {
            return (
              (_ = super.getCenter(_)).applyMatrix4(
                m0.copy(this.matrix).setPosition(0, 0, 0),
              ),
              _
            );
          }
          computeVertices() {
            this.getSize(m$).multiplyScalar(0.5),
              this.getCenter(mJ),
              m0.copy(this.matrix).setPosition(mJ),
              (this.vertices = m4.map((_) =>
                _.clone().multiply(m$).applyMatrix4(m0),
              ));
          }
          computeEdges() {
            this.vertices.length > 0 && this.computeVertices(),
              (this.edges = m5.map(
                ([_, L]) => new oH(this.vertices[_], this.vertices[L]),
              )),
              (this.centerEdges = this.edges.map((_) => _.getCenter(new iq())));
          }
          computeFaces() {
            this.vertices.length > 0 && this.computeVertices(),
              (this.faces = m6.map(([_, L]) =>
                this.vertices[_].clone()
                  .add(this.vertices[L])
                  .multiplyScalar(0.5),
              ));
          }
        },
        m9 = {
          Cloner: () => {},
          changeEntityProptotype: () => {},
          createEntity: () => {},
        },
        m7 = class extends aI {
          constructor() {
            super();
          }
          getPoints(_ = 12) {
            let L = [],
              R,
              N = this.getCurveLengths(),
              z = N[N.length - 1] / N.length;
            for (let F = 0, U = this.curves; F < U.length; F++) {
              let k = U[F],
                Y = Math.ceil((_ * (0 === F ? N[F] : N[F] - N[F - 1])) / z),
                X = k.getPoints(Y);
              for (let _ = 0; _ < X.length; _++) {
                let N = X[_];
                (R && R.equals(N)) || (L.push(N), (R = N));
              }
            }
            return (
              this.autoClose &&
                L.length > 1 &&
                !L[L.length - 1].equals(L[0]) &&
                L.push(L[0]),
              L
            );
          }
        };
      function Gx(_, L, R) {
        return 0.001 >= L.clone().sub(_).cross(L.clone().sub(R)).length();
      }
      function Bx(_, L) {
        let R = new iq(..._.position),
          N = new iq(..._.controlNext.position),
          z = new iq(...L.controlPrevious.position),
          F = new iq(...L.position);
        return Gx(R, N, F) && Gx(R, z, F);
      }
      function sg(_) {
        let L = _.points.map((_) => new iq(..._.data.position)),
          R = [_.points[0]],
          N = new iq(...R[0].data.position);
        for (let z = 0; z < _.points.length - 1; z++)
          Gx(N, L[z], L[z + 1]) || (R.push(_.points[z]), (N = L[z]));
        R.push(_.points[_.points.length - 1]);
        let z = _.isClosed,
          F = R.length - (z ? 0 : 1),
          U = R.length,
          k = [];
        for (let L = 0; L < U; L++) {
          let N = R[L].data,
            F = new iq(...N.position),
            Y = new iq(...N.controlPrevious.position),
            X = new iq(...N.controlNext.position),
            Q = {
              position: F,
              baseRoundness: N.roundness,
              controlPrevious: Y,
              controlNext: X,
            };
          if (0 === N.roundness || (!_.isClosed && (0 === L || L === U - 1))) {
            k[L] = { ...Q, removedLength: 0 };
            continue;
          }
          let K = z && 0 == L ? U - 1 : L - 1,
            J = z && L == U - 1 ? 0 : L + 1,
            $ = R[K].data,
            ee = R[J].data,
            er = new iq(...$.position),
            en = new iq(...ee.position),
            ea = er.clone().sub(F).normalize(),
            eo = en.clone().sub(F).normalize();
          Object.assign(Q, { prevDir: ea, nextDir: eo });
          let el = Bx($, N),
            ec = Bx(N, ee);
          if (el && ec) {
            let _ = ea.clone().add(eo).normalize(),
              R = _.clone().cross(ea).length() / ea.dot(_);
            k[L] = { ...Q, tan: R, removedLength: N.roundness / R };
          } else k[L] = { ...Q, removedLength: 0 };
        }
        for (let _ = 0; _ < F; _++) {
          let L = _,
            R = z && _ === U - 1 ? 0 : _ + 1,
            N = k[L],
            F = k[R];
          if (0 !== N.removedLength || 0 !== F.removedLength) {
            let _ = N.position.distanceTo(F.position);
            (N.removedLength = Math.min(N.removedLength, _ / 2)),
              (F.removedLength = Math.min(F.removedLength, _ / 2));
          }
        }
        let Y = [];
        for (let _ = 0; _ < F; _++) {
          let L = _,
            N = z && _ === U - 1 ? 0 : _ + 1,
            F = k[L],
            X = k[N],
            Q = null;
          if (Bx(R[L].data, R[N].data)) {
            let _ = F.position.clone(),
              L = X.position.clone();
            (0 !== F.removedLength || 0 !== X.removedLength) &&
              (F.nextDir && _.add(F.nextDir.clone().setLength(F.removedLength)),
              X.prevDir && L.add(X.prevDir.clone().setLength(X.removedLength))),
              _.distanceTo(L) > 0.001 &&
                (Q = new aE(
                  _,
                  _.clone().lerp(L, 0.3),
                  L.clone().lerp(_, 0.3),
                  L,
                ));
          } else
            F.position.distanceTo(X.position) > 0.001 &&
              (Q = new aE(
                F.position,
                F.controlNext,
                X.controlPrevious,
                X.position,
              ));
          Y[2 * _ + 1] = Q;
        }
        for (let _ = 0; _ < U; _++) {
          let L = k[_];
          if (0 === L.removedLength) {
            Y[2 * _] = null;
            continue;
          }
          let R = L.position,
            N = L.prevDir.clone().multiplyScalar(L.removedLength).add(R),
            z = L.nextDir.clone().multiplyScalar(L.removedLength).add(R),
            F = L.tan * L.removedLength,
            U = L.prevDir.clone().add(L.nextDir).normalize(),
            X = N.clone().lerp(z, 0.5),
            Q = N.distanceTo(z) / 2,
            K = U.clone()
              .multiplyScalar(Math.sqrt(Math.pow(F, 2) - Math.pow(Q, 2)))
              .add(X),
            J = U.clone().multiplyScalar(-F).add(K),
            $ = R.distanceTo(J) / R.distanceTo(X),
            ee = L.prevDir
              .clone()
              .multiplyScalar($ * R.distanceTo(N))
              .add(R),
            er = ee.clone().lerp(J, 2),
            en = N.clone().lerp(ee, 4 / 3),
            ea = z.clone().lerp(er, 4 / 3);
          Y[2 * _] = new aE(N, en, ea, z);
        }
        let X = new m7();
        return (
          Y.forEach((_) => {
            _ && X.add(_);
          }),
          X
        );
      }
      (vu || (vu = {})).is = function (_) {
        return _ && _.__isEntity;
      };
      var so = (_) => vu.is(_),
        ge = { type: "completeState", isfromEntity: !0 },
        og = (_) =>
          class extends au(_) {
            constructor() {
              super(...arguments),
                (this.raycastLock = !1),
                (this.scaleLock = !1),
                (this.disposed = !1),
                (this.stateSelection = null),
                (this.instances = []),
                (this.prevState = null),
                (this.currentState = null),
                (this.reversibleToState = null),
                (this.currentTransitionEvent = null),
                (this.previousAction = null),
                (this._singleBBox = new m8()),
                (this._recursiveBBox = new m8()),
                (this.singleBBoxNeedsUpdate = !0),
                (this.recursiveBBoxNeedsUpdate = !0),
                (this._needApplyPathSnapping = !0),
                (this.attachedPaths = new Set());
            }
            get __isEntity() {
              return !0;
            }
            entityChildren(_) {
              let L = this.children[_];
              if (vu.is(L)) return L;
            }
            get isConcreteEntity() {
              return "string" == typeof this.identity;
            }
            get isVirtualEntity() {
              return "string" != typeof this.identity;
            }
            get isInstanceRoot() {
              return this.isConcreteEntity && "Instance" === this.data.type;
            }
            nearestInstanceSelfOrParent() {
              let _ = this;
              for (; "Instance" !== _.data.type; ) {
                let L = _.parent;
                if (!vu.is(L)) return;
                _ = L;
              }
              return _;
            }
            forInstancesRec(_) {
              this.instances.forEach((L) => {
                L.disposed || _(L), L.forInstancesRec(_);
              });
            }
            super_Entity(_, L) {
              "string" == typeof _ && (this.uuid = _),
                (this.identity = _),
                (this.data = L),
                (this.matrixAutoUpdate = !1),
                (this.dataPatched = this.data);
            }
            changeSelectedState(_, L, R = !1) {
              if (!(0 === this.data.states.length && !R)) {
                for (let _ of this.data.states)
                  f6.toOps(this.data, _.data).forEach((_) => {
                    let R = dm.replaceProps(_, this.data);
                    (this.dataPatched = this.data),
                      this.updateByPatchedOp(R, this.data, L);
                  });
                if (null !== _) {
                  let R = this.data.states.data(_);
                  R &&
                    ((this.dataPatched = f6.patch(this.data, R)),
                    f6.toOps(this.data, R).forEach((_) => {
                      this.updateByPatchedOp(_, this.dataPatched, L);
                    }));
                }
                R && this.updateTransformState(this.dataPatched),
                  (this.stateSelection = _),
                  this.updatePathSnapping(this.dataPatched.pathSnapping);
              }
            }
            get singleBBox() {
              return (
                this.singleBBoxNeedsUpdate &&
                  ((this.singleBBoxNeedsUpdate = !1),
                  this._singleBBox.setFromObjectSize(this, !1),
                  this._singleBBox.computeVertices(),
                  this._singleBBox.computeEdges(),
                  this._singleBBox.computeFaces()),
                this._singleBBox
              );
            }
            get recursiveBBox() {
              return (
                this.recursiveBBoxNeedsUpdate &&
                  ((this.recursiveBBoxNeedsUpdate = !1),
                  this._recursiveBBox.setFromObjectSize(this, !0),
                  this._recursiveBBox.computeVertices(),
                  this._recursiveBBox.computeEdges(),
                  this._recursiveBBox.computeFaces()),
                this._recursiveBBox
              );
            }
            updateEntityBoxSize(_, L) {
              _.setScalar(0), L.setScalar(0);
            }
            resetBBoxNeedsUpdateSelf() {
              (this.singleBBoxNeedsUpdate = !0),
                (this.recursiveBBoxNeedsUpdate = !0);
            }
            resetBBoxNeedsUpdate() {
              this.resetBBoxNeedsUpdateSelf(),
                this.traverseAncestors((_) => {
                  so(_) && _.resetBBoxNeedsUpdateSelf();
                }),
                this.traverseEntity((_) => {
                  _.resetBBoxNeedsUpdateSelf();
                });
            }
            find(_) {
              let L;
              return (
                this.traverseEntity((R) => {
                  R.uuid === _ && (L = R);
                }),
                L
              );
            }
            traverseSortNextHelper() {
              let _ = this.parent;
              if (_) {
                let L = _.children,
                  R = L.indexOf(this) + 1;
                if (vu.is(L[R])) return L[R];
                if (vu.is(_)) return _.traverseSortNextHelper();
              }
            }
            sortNext() {
              let _ = this.children;
              return this.children.length > 0 && vu.is(this.children[0])
                ? _[0]
                : this.traverseSortNextHelper();
            }
            goUp(_) {
              let L = this;
              for (; _ > 0 && null !== L; ) (L = L.parent), (_ -= 1);
              return L;
            }
            hasAnccestorOrSelf(_) {
              return this === _ || this.hasAnccestor(_);
            }
            hasAnccestor(_) {
              let L = this.parent;
              for (; L; ) {
                if (_ === L) return !0;
                L = L.parent;
              }
              return !1;
            }
            countToAccestor(_) {
              let L = 0,
                R = this;
              for (; R !== _; ) {
                if (null === R) return -1;
                (R = R.parent), (L += 1);
              }
              return L;
            }
            forEachEntity(_) {
              for (let L of this.children) so(L) && _(L);
            }
            traverseEntityAncestors(_) {
              this.traverseAncestors((L) => {
                vu.is(L) && _(L);
              });
            }
            traverseEntity(_, L = 0) {
              if (!0 !== _(this, L))
                for (let R of this.children)
                  so(R) && R.traverseEntity(_, L + 1);
            }
            traverseVisibleEntity(_) {
              for (let L of (_(this), this.children))
                so(L) && L.visible && L.traverseVisibleEntity(_);
            }
            updateMatrix() {
              super.updateMatrix(),
                this.cloner && this.cloner.onObjUpdateMatrix(),
                this.dispatchEvent({ type: "updateMatrix" });
            }
            copy(_, L = !0) {
              return (
                super.copy(_, !1),
                (this.raycastLock = _.raycastLock),
                (this.scaleLock = _.scaleLock),
                this.hiddenMatrix.copy(_.hiddenMatrix),
                this
              );
            }
            hasEntityChild() {
              return this.children.some((_) => so(_));
            }
            isAncestorOf(_) {
              if (this.uuid === _) return !1;
              let L = !1;
              return (
                this.traverseEntity((R) => {
                  R.uuid === _ && (L = !0);
                }),
                L
              );
            }
            toObjectTransformState(_ = []) {
              return (
                this.updateWorldMatrix(!0, !1),
                cH(
                  {
                    position: this.position.toArray(),
                    rotation: [
                      this.rotation.x,
                      this.rotation.y,
                      this.rotation.z,
                    ],
                    scale: this.scale.toArray(),
                    hiddenMatrix: this.hiddenMatrix.toArray(),
                  },
                  _,
                )
              );
            }
            updateTransformState(_) {
              let L = !1;
              return (
                _.position && (this.position.fromArray(_.position), (L = !0)),
                _.rotation && (this.rotation.fromArray(_.rotation), (L = !0)),
                _.scale && ((L = !0), this.scale.fromArray(_.scale)),
                void 0 !== _.hiddenMatrix &&
                  ((L = !0),
                  this.hiddenMatrix.fromArray(_.hiddenMatrix ?? px.identity)),
                L &&
                  (this.updateMatrix(),
                  this.resetBBoxNeedsUpdate(),
                  this.invalidateClonerTransform(this),
                  this.traverseEntityAncestors((_) => {
                    _.invalidateClonerTransform(this);
                  })),
                _.position &&
                  _.rotation &&
                  _.scale &&
                  void 0 !== _.hiddenMatrix &&
                  this.updateWorldMatrix(!1, !0),
                L
              );
            }
            dispose() {
              (this.disposed = !0),
                this.cloner &&
                  (this.cloner.removeFromParent(), (this.cloner = void 0));
            }
            disposeChildrenRecursively() {
              for (let _ of this.children) vu.is(_) && _.disposeRecursively();
            }
            disposeRecursively() {
              this.dispose(),
                this.children.forEach((_) => {
                  vu.is(_) && _.disposeRecursively();
                });
            }
            toState(_ = []) {
              return cH(
                {
                  name: this.name,
                  visible: this.visible,
                  raycastLock: this.raycastLock,
                  ...this.toObjectTransformState(_),
                },
                _,
              );
            }
            updateByOp(_, L, R, N) {
              let z = this.data;
              this.data = L;
              let F = _,
                U = Di(_.path, ["states", "*"]);
              if (null !== U) {
                if (0 === _.type) {
                  let [L] = U;
                  if (this?.stateSelection === L) {
                    let L = { ..._.props };
                    if (Object.values(_.props).some((_) => void 0 === _)) {
                      let R = this.data;
                      if (void 0 !== R) {
                        let N = dx.zoom(R, _.path.slice(2));
                        if (N)
                          for (let R in _.props)
                            void 0 === _.props[R] && R in N && (L[R] = N[R]);
                      }
                    }
                    F = { ..._, props: L, path: _.path.slice(2) };
                  }
                }
              } else if (0 === _.type) {
                let L = this.stateSelection
                  ? this.data.states.data(this.stateSelection)
                  : void 0;
                if (void 0 !== L) {
                  if (void 0 !== _.props.name && L.name) {
                    let { name: _, ...R } = L;
                    L = R;
                  }
                  if (void 0 !== _.props.material && "material" in L) {
                    let { material: _, ...R } = L;
                    L = R;
                  }
                  let R = dx.removeOverridden(_.path, _.props, L);
                  F = { ..._, props: R };
                }
              }
              if (
                (this.updateByPatchedOpBase(
                  F,
                  f6.patch(
                    this.data,
                    this.stateSelection
                      ? this.data.states.data(this.stateSelection)
                      : void 0,
                  ),
                  R,
                ),
                Di(_.path, ["overrides"]))
              ) {
                let N = [],
                  z = [..._.path];
                for (
                  N.push(z[1]), z.splice(0, 2);
                  z.length > 0 && "descendants" === z[0];

                )
                  N.push(z[1]), z.splice(0, 2);
                if (void 0 === N[N.length - 1]) {
                  if (0 === _.type)
                    for (let L of Object.keys(_.props)) {
                      N[N.length - 1] = L;
                      let z = R.scene.findInstance([this.uuid, ...N]);
                      z &&
                        ((z.overrideData = _.props[L]),
                        z.updateState(
                          c$.apply(z.component.data, z.overrideData),
                          R,
                        ));
                    }
                } else {
                  let F = R.scene.findInstance([this.uuid, ...N]);
                  if (F) {
                    let U = dx.zoom(F.component.data, z);
                    if (0 === (_ = { ..._, path: z }).type) {
                      let L = _.props;
                      if (U)
                        for (let [R, N] of Object.entries(_.props))
                          void 0 === N &&
                            (L === _.props && (L = { ..._.props }),
                            (L[R] = U[R]));
                      _ = { ..._, props: L };
                    }
                    (F.overrideData = f2.resolve(L.overrides, N)),
                      F.updateByOp(_, dg.applySimple(F.data, _), R, !1);
                  }
                }
              } else if (this.instances.length > 0) {
                let N;
                if (0 === _.path.length && 0 === _.type) {
                  let L;
                  for (let R of f4.rootOverrideProps)
                    R in _.props &&
                      (void 0 === L && (L = {}), (L[R] = _.props[R]));
                  L && (N = { ..._, props: L });
                } else
                  for (let L of f4.rootOverrideProps)
                    if (Di(_.path, [L])) {
                      N = _;
                      break;
                    }
                void 0 !== N &&
                  this.instances.forEach((_) => {
                    if (_.isInstanceRoot) {
                      let L = c$.filterOp(_.overrideData, N);
                      L && _.updateByOp(L, dg.applySimple(_.data, L), R, !0);
                    }
                  }),
                  this.instances.forEach((N) => {
                    if (!N.isInstanceRoot) {
                      let F = c$.filterOp(N.overrideData, _);
                      if (F) {
                        let U;
                        (U =
                          z === N.data && _ === F
                            ? L
                            : dg.applySimple(N.data, F)),
                          N.updateByOp(F, U, R, !0);
                      }
                    }
                  });
              }
            }
            updateByPatchedOpBase(_, L, R) {
              if (((this.dataPatched = L), 0 === _.path.length && 0 === _.type))
                void 0 === _.props.type ||
                  pC.is(_.props.type) ||
                  m9.changeEntityProptotype(this, L, R);
              else if (
                1 === _.path.length &&
                "geometry" === _.path[0] &&
                0 === _.type &&
                "type" in _.props
              )
                for (let _ of (m9.changeEntityProptotype(this, L, R),
                this.children))
                  vu.is(_) && _.updateVisible();
              this.updateByPatchedOp(_, L, R);
            }
            updateByPatchedOp(_, L, R) {
              if (
                (0 === _.path.length &&
                  0 === _.type &&
                  this.updateState(_.props, R),
                null !== Di(_.path, ["pathSnapping"]) &&
                  this.updatePathSnapping(L.pathSnapping),
                null !== Di(_.path, ["cloner"]))
              ) {
                let N = dg.drop(_, 1);
                0 === N.path.length && 0 === N.type && !0 === N.props.disabled
                  ? this.setFromClonerState(null, R)
                  : this.cloner
                    ? this.cloner.updateState(L.cloner, R.scene)
                    : (this.setFromClonerState(L.cloner, R),
                      this.expandCloner(R.scene)),
                  this.updateVisible();
              }
            }
            updatePathSnapping(_) {
              (this._updatedPathSnapping = _),
                (this._needApplyPathSnapping = !0);
            }
            applyPathSnapping(_) {
              let L =
                  this._updatedPathSnapping?.pathId ??
                  this.dataPatched.pathSnapping.pathId,
                R =
                  this._updatedPathSnapping?.slide ??
                  this.dataPatched.pathSnapping.slide,
                N =
                  this._updatedPathSnapping?.offset ??
                  this.dataPatched.pathSnapping.offset,
                z =
                  this._updatedPathSnapping?.orientation ??
                  this.dataPatched.pathSnapping.orientation;
              if (null === L) return;
              let F = _.find(L);
              if (!F || !1 === this._needApplyPathSnapping) return;
              this._needApplyPathSnapping = !1;
              let U = F.data,
                k = sg(U.geometry.path),
                Y = (R + N) % 1,
                X = k.getPointAt(Y),
                Q = this.parent ? this.parent?.matrixWorld : new rw();
              F.updateMatrixWorld();
              let K = new rw().multiplyMatrices(
                Q.clone().invert(),
                F.matrixWorld,
              );
              X.applyMatrix4(K);
              let J = { position: X.toArray(), rotation: U.rotation };
              if ("tangential" === z) {
                let _ = new rw().extractRotation(F.matrixWorld),
                  L = k.getTangentAt(Y).applyMatrix4(_).add(X),
                  R = new rw().lookAt(X, L, new iq(0, 1, 0)),
                  N = new rN().setFromRotationMatrix(R);
                J = { ...J, rotation: [N.x, N.y, N.z] };
              }
              this.updateTransformState(J),
                this.traverseEntity((_) => {
                  _._cameraType && _.dispatchEvent(ge);
                });
            }
            updateVisible() {
              this.visible =
                this.dataPatched.visible &&
                (!this.dataPatched.cloner ||
                  (this.dataPatched.cloner.disabled ?? !1) ||
                  this.dataPatched.cloner?.hideBase !== !0);
            }
            updateState_Entity(_, L) {
              void 0 !== _.name && (this.name = _.name),
                void 0 !== _.raycastLock && (this.raycastLock = _.raycastLock),
                void 0 !== _.visible &&
                  (this.updateVisible(), this.resetBBoxNeedsUpdate()),
                "cloner" in _ &&
                  void 0 !== _.cloner &&
                  (this.setFromClonerState(_.cloner, L), this.updateVisible()),
                this.updateTransformState(_);
            }
            get attachedSurfaceCloners() {
              return this.children.filter(
                (_) =>
                  _ instanceof m9.Cloner && "toObject" === _.parameters.type,
              );
            }
            setFromClonerState(_, L) {
              this.disposed ||
                (null === _ || _.disabled
                  ? (this.cloner && this.cloner.removeFromParent(),
                    (this.cloner = void 0))
                  : void 0 === this.cloner
                    ? ((this.cloner = new m9.Cloner(this, _)),
                      L.scene.addPendingExpandCloner(this))
                    : this.cloner.updateState(_, L.scene));
            }
            expandCloner(_) {
              !this.disposed && this.cloner && this.cloner.expandClones(_);
            }
            invalidateClonerTransform(_) {
              this.cloner && this.cloner.invalidateTransform(_);
            }
          },
        gt = class {
          static create(_) {
            return this.build(this.normalizeInputs(_));
          }
          static normalizeInputs(_, L) {
            let R = Object.assign(
                {},
                L?.parameters ?? {
                  width: 100,
                  radialSegments: 64,
                  heightSegments: 1,
                  openEnded: !1,
                  thetaStart: 0,
                  thetaLength: 360,
                  cornerRadius: 8,
                  cornerSegments: 8,
                  hollow: 0,
                },
                _.parameters,
              ),
              N = R.width / 2,
              z = R.radiusTop ?? N,
              F = R.radiusBottom ?? N;
            return (
              z === F
                ? ((z = N), (F = N))
                : z > F
                  ? ((z = N), (F = (F * N) / z))
                  : ((z = (z * N) / F), (F = N)),
              {
                parameters: Object.assign(R, {
                  width: Math.abs(R.width),
                  height: Math.abs(R.height ?? R.width),
                  depth: Math.abs(R.depth ?? R.width),
                  radiusTop: z,
                  radiusBottom: F,
                }),
              }
            );
          }
          static build(_) {
            let {
                width: L,
                depth: R,
                height: N,
                radialSegments: z,
                heightSegments: F,
                openEnded: U,
                thetaStart: k,
                thetaLength: Y,
                radiusTop: X,
                radiusBottom: Q,
                cornerRadius: K,
                cornerSegments: J,
                hollow: $,
              } = _.parameters,
              ee;
            return (
              (ee =
                K || $
                  ? new gi(X, Q, N, z, F, U, k, (Y * Math.PI) / 180, K, K, J, $)
                  : new aF(X, Q, N, z, F, U, k, (Y * Math.PI) / 180)).scale(
                1,
                1,
                R / L,
              ),
              Object.assign(ee, {
                userData: { ..._, type: "CylinderGeometry" },
              })
            );
          }
        };
      function Zo(_, L, R) {
        (R.x = _.x * L.x), (R.y = _.y), (R.z = _.x * L.y);
      }
      function cM(_) {
        return new iT(_.y, -_.x);
      }
      var gi = class extends sP {
          constructor(_, L, R, N, z, F, U, k, Y, X, Q, K, J = !1) {
            super(),
              (this.type = "RoundedCylinderBufferGeometry"),
              (_ = void 0 !== _ ? _ : 1),
              (L = void 0 !== L ? L : 1),
              (R = R || 1),
              (N = Math.floor(N) || 8),
              (z = Math.floor(z) || 1),
              (F = void 0 !== F && F),
              (U = void 0 !== U ? U : 0),
              (k = void 0 !== k ? k : 2 * Math.PI),
              F && ((Y = 0), (X = 0));
            let $ = [],
              ee = [],
              er = [],
              en = [],
              ea = 0,
              eo = R / 2,
              el = new iq(),
              ec = new iq();
            J && 0 == _ && (_ = Y), J && 0 == L && (L = X);
            let ed = new iT(_, eo),
              eu = new iT(L, -eo),
              ep = null,
              ef = null,
              ev = null,
              ex = null,
              eb = ed.clone().sub(eu),
              ew = 0,
              e_ = 0,
              eA = 0;
            K > 0 &&
              ((ew = Math.min(_, L) * (1 - K)), (e_ = _ - ew), (eA = L - ew));
            let eM = ed.clone();
            eM.x -= ew;
            let eE = Math.PI - eb.angle(),
              eC = eb.angle(),
              eP = Math.tan(eC / 2),
              eD = Math.tan(eE / 2),
              eO = eP + eD;
            if (
              ((Y = Math.min(Y, (_ - e_) / (K ? eO : eD), eb.length() / eO)),
              (X = Math.min(X, (L - eA) / (K ? eO : eP), eb.length() / eO)),
              Y > 0)
            ) {
              let _ = Y / eP;
              (ep = ed.clone().sub(new iT(_, Y))),
                K && ((ev = ep.clone()), (ev.x -= ew - eO * Y)),
                ed.sub(eb.clone().setLength(_));
            }
            if (X > 0) {
              let _ = X / eD;
              (ef = eu.clone().sub(new iT(_, -X))),
                eu.add(eb.clone().setLength(_)),
                K &&
                  ((ex = ef.clone()),
                  (ex.x -= ew - eO * X),
                  eM.sub(eb.clone().setLength(_)));
            }
            let eL = 0.5 > (eb = ed.clone().sub(eu)).length(),
              eR = [];
            for (let Q = 0; Q <= N; Q++) {
              let J = [],
                $ = Q / N,
                eo = $ * k + U,
                ed = new iT(Math.sin(eo), Math.cos(eo));
              if (
                (ex && ef
                  ? (G(J, $, ed, eE, X, ex, -1, !0),
                    G(J, $, ed, eC, X, ef, -1, !1))
                  : ef
                    ? (re(J, ed, ef.x, 0, -1), G(J, $, ed, eC, X, ef, -1, !1))
                    : F || re(J, ed, L, eA, -1),
                Zo(cM(eb).normalize(), ed, el),
                !eL)
              )
                for (let _ = 0; _ <= z; _++) {
                  let L = _ / z;
                  Zo(eb.clone().multiplyScalar(L).add(eu), ed, ec),
                    ee.push(ec.x, ec.y, ec.z),
                    er.push(el.x, el.y, el.z),
                    en.push($, 0.5 + ec.y / R),
                    J.push(ea++);
                }
              if (
                (ev && ep
                  ? (G(J, $, ed, eE, Y, ep, 1, !1),
                    G(J, $, ed, eC, Y, ev, 1, !0))
                  : ep
                    ? (G(J, $, ed, eE, Y, ep, 1, !1), re(J, ed, ep.x, 0, 1))
                    : F || re(J, ed, _, e_, 1),
                K && !eL)
              ) {
                Zo(cM(eb).multiplyScalar(-1).normalize(), ed, el);
                for (let _ = 0; _ <= z; _++) {
                  let L = _ / z;
                  Zo(eb.clone().multiplyScalar(-L).add(eM), ed, ec),
                    ee.push(ec.x, ec.y, ec.z),
                    er.push(el.x, el.y, el.z),
                    en.push($, 0.5 + ec.y / R),
                    J.push(ea++);
                }
              }
              K && !F && J.push(J[0]), eR.push(J);
            }
            for (let _ = 0; _ < eR.length - 1; _++)
              for (let L = 0; L < eR[0].length - 1; L++) {
                if (F && K && L == z) continue;
                let R = eR[_][L],
                  N = eR[_ + 1][L],
                  U = eR[_ + 1][L + 1],
                  k = eR[_][L + 1],
                  Y = ee[3 * U + 0],
                  X = ee[3 * U + 2];
                $.push(R, N, k), (0 != Y || 0 != X) && $.push(N, U, k);
              }
            function G(_, L, N, z, F, U, k, Y) {
              for (let X = 0; X < Q + 1; X++) {
                let K = X / Q,
                  J = k < 0 ? K : 1 - K;
                Y && (J -= 1), (J *= z);
                let $ = new iT(Math.sin(J), Math.cos(J) * k);
                Zo($.clone().multiplyScalar(F).add(U), N, ec),
                  ee.push(ec.x, ec.y, ec.z),
                  Zo($, N, el),
                  er.push(el.x, el.y, el.z),
                  en.push(L, 0.5 + ec.y / R),
                  _.push(ea++);
              }
            }
            function re(_, L, R, N, z) {
              let F = new iq(),
                U = new iT(),
                k = [R, N];
              for (let R of (z < 0 && k.reverse(), k))
                U.set(R, eo * z),
                  Zo(U, L, F),
                  ee.push(F.x, F.y, F.z),
                  er.push(0, z, 0),
                  en.push(0.5, 0.5),
                  _.push(ea++);
            }
            function Z(R, N, z) {
              let F = new iT(Math.sin(z), Math.cos(z)),
                U = new iT(-Math.cos(z), Math.sin(z)),
                k = new iq(),
                Y =
                  R < 0
                    ? (_, L, R) => $.push(_, L, R)
                    : (_, L, R) => $.push(_, R, L);
              Zo(new iT((_ + L + e_ + eA) / 4, 0), F, k),
                ee.push(k.x, k.y, k.z),
                er.push(U.x, 0, U.y),
                en.push(0.5, 0.5);
              let X = ea++;
              for (let _ of N) {
                let L = ee.slice(3 * _, 3 * _ + 3);
                ee.push(...L), er.push(U.x, 0, U.y);
                let R = en.slice(2 * _, 2 * _ + 2);
                en.push(...R), ea++;
              }
              for (let _ = X + 1; _ < ea - 1; _++) Y(X, _, _ + 1);
              Y(X, ea - 1, X + 1);
            }
            k < 2 * Math.PI &&
              (Z(-1, eR[0], U), Z(1, eR[eR.length - 1], U + k)),
              this.setIndex($),
              this.setAttribute("position", new sv(ee, 3)),
              this.setAttribute("normal", new sv(er, 3)),
              this.setAttribute("uv", new sv(en, 2));
          }
        },
        gr = class {
          static create(_) {
            return this.build(this.normalizeInputs(_));
          }
          static normalizeInputs(_, L) {
            let R = Object.assign(
              {},
              L?.parameters ?? {
                width: 100,
                radialSegments: 32,
                heightSegments: 8,
                openEnded: !1,
                thetaStart: 0,
                thetaLength: 360,
                cornerRadiusTop: 8,
                cornerRadiusBottom: 8,
                cornerSegments: 8,
              },
              _.parameters,
            );
            return {
              parameters: Object.assign(R, {
                width: Math.abs(R.width),
                height: Math.abs(R.height ?? R.width),
                depth: Math.abs(R.depth ?? R.width),
              }),
            };
          }
          static build(_) {
            let {
                width: L,
                depth: R,
                height: N,
                radialSegments: z,
                heightSegments: F,
                openEnded: U,
                thetaStart: k,
                thetaLength: Y,
                cornerRadiusTop: X,
                cornerRadiusBottom: Q,
                cornerSegments: K,
              } = _.parameters,
              J;
            return (
              (J =
                X > 0 || Q > 0 || Y < 360
                  ? new gi(
                      0,
                      L / 2,
                      N,
                      z,
                      F,
                      U,
                      k,
                      (Y * Math.PI) / 180,
                      X,
                      Q,
                      K,
                      0,
                      !0,
                    )
                  : new aU(L / 2, N, z, F, U)).scale(1, 1, R / L),
              Object.assign(J, { userData: { ..._, type: "ConeGeometry" } })
            );
          }
        },
        gs = class {
          static create(_) {
            return this.build(this.normalizeInputs(_));
          }
          static normalizeInputs(_, L) {
            let R = Object.assign(
              {},
              L?.parameters ?? {
                width: 100,
                widthSegments: 1,
                heightSegments: 1,
                depthSegments: 1,
                cornerRadius: 8,
                cornerSegments: 8,
              },
              _.parameters,
            );
            return {
              parameters: Object.assign(R, {
                width: Math.abs(R.width),
                height: Math.abs(R.height ?? R.width),
                depth: Math.abs(R.depth ?? R.width),
              }),
            };
          }
          static build(_) {
            let {
              width: L,
              height: R,
              depth: N,
              widthSegments: z,
              heightSegments: F,
              depthSegments: U,
              cornerRadius: k,
              cornerSegments: Y,
            } = _.parameters;
            return Object.assign(
              0 == k
                ? new sW(L, R, N, z, F, U)
                : new ga(L, R, N, z, F, U, k, Y),
              { userData: { ..._, type: "CubeGeometry" } },
            );
          }
        },
        gn = Math.PI / 2,
        ga = class extends sP {
          constructor(_ = 1, L = 1, R = 1, N = 1, z = 1, F = 1, U = 0, k = 4) {
            super(), (this.type = "BoxGeometry");
            let Y = this;
            (N = Math.floor(N)),
              (z = Math.floor(z)),
              (F = Math.floor(F)),
              (k = Math.floor(k)),
              (U = Math.min(U, _ / 2, L / 2, R / 2));
            let X = [],
              Q = [],
              K = [],
              J = [],
              $ = 0,
              ee = 0;
            function m(_, L, R, N, z, F, k, er, en, ea, eo) {
              let el = (F - 2 * U) / en,
                ec = (k - 2 * U) / ea,
                ed = F / 2 - U,
                eu = k / 2 - U,
                ep = er / 2,
                ef = en + 1,
                ev = ea + 1,
                ex = 0,
                eb = 0,
                ew = new iq();
              for (let F = 0; F < ev; F++) {
                let U = F * ec - eu;
                for (let k = 0; k < ef; k++) {
                  let Y = k * el - ed;
                  (ew[_] = Y * N),
                    (ew[L] = U * z),
                    (ew[R] = ep),
                    Q.push(ew.x, ew.y, ew.z),
                    (ew[_] = 0),
                    (ew[L] = 0),
                    (ew[R] = er > 0 ? 1 : -1),
                    K.push(ew.x, ew.y, ew.z),
                    J.push(k / en),
                    J.push(1 - F / ea),
                    (ex += 1);
                }
              }
              for (let _ = 0; _ < ea; _++)
                for (let L = 0; L < en; L++) {
                  let R = $ + L + ef * _,
                    N = $ + L + ef * (_ + 1),
                    z = $ + (L + 1) + ef * (_ + 1),
                    F = $ + (L + 1) + ef * _;
                  X.push(R, N, F), X.push(N, z, F), (eb += 6);
                }
              Y.addGroup(ee, eb, eo), (ee += eb), ($ += ex);
            }
            function y(_, L, R, N, z, F, er, en, ea, eo, el) {
              let ec = (er - 2 * U) / eo,
                ed = er / 2 - U,
                eu = en / 2 - U,
                ep = ea / 2,
                ef = eo + 1,
                ev = 0,
                ex = 0,
                eb = new iq(),
                ew = new iq();
              for (let Y = 0; Y < k + 1; Y++) {
                let X = (Y / k) * gn,
                  $ = Math.sin(X) * U,
                  ee = (1 - Math.cos(X)) * U,
                  er = Math.sin(X),
                  en = Math.cos(X);
                (eb[L] = (eu + $) * z),
                  (eb[R] = (ep - ee) * F),
                  (ew[_] = 0),
                  (ew[L] = er * Math.sign(eb[L])),
                  (ew[R] = en * Math.sign(eb[R]));
                for (let L = 0; L < ef; L++) {
                  let R = L * ec - ed;
                  (eb[_] = R * N),
                    Q.push(eb.x, eb.y, eb.z),
                    K.push(ew.x, ew.y, ew.z),
                    J.push(L / eo),
                    J.push(0),
                    (ev += 1);
                }
              }
              for (let _ = 0; _ < k; _++)
                for (let L = 0; L < eo; L++) {
                  let R = $ + L + ef * _,
                    N = $ + L + ef * (_ + 1),
                    z = $ + (L + 1) + ef * (_ + 1),
                    F = $ + (L + 1) + ef * _;
                  X.push(R, N, F), X.push(N, z, F), (ex += 6);
                }
              Y.addGroup(ee, ex, el), (ee += ex), ($ += ev);
            }
            function v(N, z, F) {
              let Y = new iq(),
                ee = new iq(_ / 2, L / 2, R / 2);
              ee.subScalar(U);
              let er = [],
                en =
                  N * z * F > 0
                    ? (_, L, R) => X.push(_, L, R)
                    : (_, L, R) => X.push(_, R, L);
              for (let _ = 0; _ <= k; _++) {
                let L = [],
                  R = gn * (1 - _ / k),
                  X = Math.cos(R),
                  en = Math.sin(R),
                  ea = 0;
                for (let R = 0; R <= _; R++) {
                  let R = Math.cos(ea),
                    k = Math.sin(ea);
                  (Y.x = X * R), (Y.y = en), (Y.z = X * k);
                  let er = ee.clone().addScaledVector(Y, U);
                  Q.push(N * er.x, z * er.y, F * er.z),
                    K.push(N * Y.x, z * Y.y, F * Y.z),
                    J.push(0, 0),
                    L.push($++),
                    (ea += gn / _);
                }
                er.push(L);
              }
              let ea = er.length - 1;
              for (let _ = 0; _ < ea; _++) {
                let L = er[_],
                  R = er[_ + 1],
                  N = L.length - 1;
                en(L[0], R[1], R[0]);
                for (let _ = 1; _ <= N; _++)
                  en(L[_ - 1], L[_], R[_]), en(L[_], R[_ + 1], R[_]);
              }
            }
            m("z", "y", "x", -1, -1, R, L, _, F, z, 0),
              m("z", "y", "x", 1, -1, R, L, -_, F, z, 1),
              m("x", "z", "y", 1, 1, _, R, L, N, F, 2),
              m("x", "z", "y", 1, -1, _, R, -L, N, F, 3),
              m("x", "y", "z", 1, -1, _, L, R, N, z, 4),
              m("x", "y", "z", -1, -1, _, L, -R, N, z, 5),
              U > 0 &&
                (y("z", "y", "x", -1, -1, 1, R, L, _, F, 0),
                y("z", "y", "x", 1, -1, -1, R, L, _, F, 1),
                y("z", "y", "x", -1, 1, -1, R, L, _, F, 1),
                y("z", "y", "x", 1, 1, 1, R, L, _, F, 0),
                y("x", "y", "z", -1, -1, -1, _, L, R, N, 0),
                y("x", "y", "z", 1, -1, 1, _, L, R, N, 1),
                y("x", "y", "z", -1, 1, 1, _, L, R, N, 0),
                y("x", "y", "z", 1, 1, -1, _, L, R, N, 1),
                y("y", "x", "z", -1, -1, 1, L, _, R, z, 0),
                y("y", "x", "z", 1, -1, -1, L, _, R, z, 1),
                y("y", "x", "z", 1, 1, 1, L, _, R, z, 1),
                y("y", "x", "z", -1, 1, -1, L, _, R, z, 0),
                v(1, 1, 1),
                v(-1, 1, 1),
                v(1, -1, 1),
                v(-1, -1, 1),
                v(1, 1, -1),
                v(-1, 1, -1),
                v(1, -1, -1),
                v(-1, -1, -1)),
              this.setIndex(X),
              this.setAttribute("position", new sv(Q, 3)),
              this.setAttribute("normal", new sv(K, 3)),
              this.setAttribute("uv", new sv(J, 2));
          }
        },
        go = class extends sP {
          constructor(_ = [], L = [], R = "", N = 1, z = 0.2, F = 4) {
            super(), (this.type = "PolyhedronGeometryRound");
            let U = [],
              k = [],
              Y = [];
            (function () {
              0 == (z = Math.min(1 - 1e-5, z)) && (F = 0);
              let k = {
                  IcosahedronGeometry: 5,
                  DodecahedronGeometry: 3,
                  HexahedronGeometry: 3,
                  OctahedronGeometry: 4,
                  TetrahedronGeometry: 3,
                }[R],
                X = new iq(),
                Q = X.clone(),
                K = new se(),
                J = z * N,
                $ = N - J,
                ee = F + 1,
                er = new iq(),
                w = (_, L) => er.subVectors(_, L).normalize(),
                A = (_, L) =>
                  Array(_)
                    .fill(void 0)
                    .map(L),
                en = A(_.length / 3, (L, R) =>
                  new iq().fromArray(_, 3 * R).setLength(N),
                ),
                ea = [];
              for (let _ = 0; _ < en.length; _++) {
                let R = en[_],
                  N = [],
                  z,
                  F,
                  U,
                  k = 1e10,
                  Y = -1;
                for (; -1 != (Y = L.indexOf(_, Y + 1)); ) {
                  let _ = Y - (Y % 3);
                  (z = L[_ + ((Y + 1) % 3)]),
                    (F = L[_ + ((Y + 2) % 3)]),
                    (k = Math.min(k, (U = R.distanceToSquared(en[z])))),
                    N.push([z, F, U]);
                }
                k += 1e-6;
                let X = [],
                  Q = 0,
                  K = N.length;
                for (let L = 0; L < K; L++) {
                  [z, F, U] = N[Q];
                  let L = ea[z]?.includes(_) == !0;
                  U <= k && X.push(z + 1e6 * +L),
                    (Q = N.findIndex((_) => _[0] == F));
                }
                ea.push(X);
              }
              let eo = [];
              {
                let _ = 0,
                  L = 0,
                  R,
                  N,
                  z = 3 == k;
                for (let U = 0; U <= F; U++) {
                  (R = (U * (U + 1)) / 2), (N = ((U + 1) * (U + 2)) / 2);
                  for (let k = 0; k < F - U; k++)
                    ([_, L] = [R + k + U + 2, N + k + U + 3]),
                      eo.push(R, N, ...(z ? [L, R] : [_, N]), L, _),
                      ([R, N] = [_, L]);
                  eo.push(R, N, R + F + 2);
                }
              }
              let el = X.clone(),
                ec = X.clone(),
                ed = X.clone(),
                eu = X.clone(),
                ep = X.clone(),
                ef = [],
                ev = A(en.length, () => A(k, () => X.clone()));
              for (let _ = 0; _ < en.length; _++) {
                X.copy(en[_]).normalize(), el.copy(X).multiplyScalar($);
                let L = ea[_];
                for (let R = 0; R < L.length; R++) {
                  let N = L[R],
                    z = L[(R + 1) % k];
                  K.setFromPointsAndIndices(en, _, N % 1e6, z % 1e6),
                    K.b.sub(K.a).setLength(1e10).add(K.a),
                    K.c.sub(K.a).setLength(1e10).add(K.a),
                    K.closestPointToPoint(el, ev[_][R]);
                }
                let R = [],
                  N = [],
                  z = [],
                  ex = new iq();
                0 == F &&
                  [...ev[_]]
                    .reduce((_, L) => _.add(L), ex)
                    .multiplyScalar(1 / k);
                for (let L = 0; L < k; L++) {
                  let U = [],
                    Y = (L - 1 + k) % k,
                    K = ev[_][Y],
                    en = ev[_][L];
                  X.copy(K).sub(el), Q.copy(en).sub(el);
                  let ea = el.angleTo(X),
                    eo = X.angleTo(Q),
                    ef = Math.cos(ea) * J;
                  0 == F ? ec.copy(ex) : ec.copy(el).setLength($ + ef),
                    N.push(ef);
                  let eb = [ec, K, en];
                  for (let _ = 0; _ < 2; _++) {
                    let L = eb[_],
                      N = eb[_ + 1];
                    eu.subVectors(L, el),
                      ep.subVectors(N, el),
                      ed.crossVectors(eu, ep).normalize();
                    for (let N = 0; N < ee; N++) {
                      let z = ([ea, eo][_] * N) / ee;
                      X.copy(eu).applyAxisAngle(ed, z).add(el),
                        R.push(X.clone()),
                        _ &&
                          (w(X, el),
                          U.push([0 == N ? L : X.clone(), er.clone()]));
                    }
                    _ && (w(N, el), U.push([N, er.clone()]));
                  }
                  z.push(U);
                }
                ef.push(z);
                let eb = 2 * ee;
                for (let _ = 0; _ < k; _++) {
                  let L = eb * _,
                    z = eb * ((_ + 1) % k),
                    F = [R[L]];
                  for (let U = 1; U < ee; U++) {
                    (eu = R[L + U]), (ep = R[z + U]), F.push(eu);
                    for (let L = 1, R = U - 2 + 1; L <= R; L++)
                      X.lerpVectors(eu, ep, L / (R + 1)),
                        X.sub(el).setLength(N[_]).add(el),
                        F.push(X.clone());
                    F.push(ep);
                  }
                  for (let _ = 0; _ < ee; _++) F.push(R[_ + ee + L]);
                  F.push(R[z + ee]);
                  let Q = eo.map((_) => F[_]);
                  U.push(...Q.map((_) => [_.x, _.y, _.z]).flat()),
                    Y.push(
                      ...Q.map((_) => (w(_, el), [er.x, er.y, er.z])).flat(),
                    );
                }
              }
              let ex = [];
              for (let _ = 0; _ < ea.length; _++)
                for (let L = 0; L < k; L++) {
                  let R = ea[_][L];
                  if (R < 1e6) {
                    let N = ea[R].findIndex((L) => L % 1e6 == _),
                      z = ef[_][L],
                      F = ef[R][N];
                    for (let _ = 0; _ < ee; _++) {
                      let L = z[_],
                        R = F[ee - _],
                        N = z[_ + 1];
                      [L, R, N, N, R, F[ee - (_ + 1)]].forEach((_) => {
                        U.push(_[0].x, _[0].y, _[0].z),
                          Y.push(_[1].x, _[1].y, _[1].z);
                      });
                    }
                    ex.push(z[0][0], F[ee][0], z[ee][0], F[0][0]);
                  }
                }
              for (; ex.length; ) {
                let _, L, R, N;
                [_, L] = ex.splice(0, 2);
                let z = [_];
                for (; _ != L; )
                  z.push(L),
                    (N = (R = ex.indexOf(L)) % 2),
                    (L = ex.splice(R - N, 2)[1 - N]);
                er.subVectors(z[0], z[1])
                  .cross(X.subVectors(z[0], z[2]))
                  .normalize();
                let F = 0 > er.dot(z[0]);
                F && er.negate();
                for (let _ = 1; _ <= z.length - 2; _++)
                  [z[_ + +F], z[_ + 1 - +F], z[0]].forEach((_) => {
                    U.push(_.x, _.y, _.z), Y.push(er.x, er.y, er.z);
                  });
              }
            })(),
              (function () {
                let _ = new iq();
                for (let L = 0; L < U.length; L += 3) {
                  (_.x = U[L + 0]), (_.y = U[L + 1]), (_.z = U[L + 2]);
                  let R = w(_) / 2 / Math.PI + 0.5,
                    N =
                      Math.atan2(-_.y, Math.sqrt(_.x * _.x + _.z * _.z)) /
                        Math.PI +
                      0.5;
                  k.push(R, 1 - N);
                }
                let L = new iq(),
                  R = new iq(),
                  N = new iq(),
                  z = new iq(),
                  F = new iT(),
                  Y = new iT(),
                  X = new iT(),
                  b = (_, L, R, N) => {
                    N < 0 && 1 === _.x && (k[L] = _.x - 1),
                      0 === R.x && 0 === R.z && (k[L] = N / 2 / Math.PI + 0.5);
                  };
                for (let _ = 0, Q = 0; _ < U.length; _ += 9, Q += 6) {
                  L.set(U[_ + 0], U[_ + 1], U[_ + 2]),
                    R.set(U[_ + 3], U[_ + 4], U[_ + 5]),
                    N.set(U[_ + 6], U[_ + 7], U[_ + 8]),
                    F.set(k[Q + 0], k[Q + 1]),
                    Y.set(k[Q + 2], k[Q + 3]),
                    X.set(k[Q + 4], k[Q + 5]),
                    z.copy(L).add(R).add(N).divideScalar(3);
                  let K = w(z);
                  b(F, Q + 0, L, K), b(Y, Q + 2, R, K), b(X, Q + 4, N, K);
                }
                for (let _ = 0; _ < k.length; _ += 6) {
                  let L = k[_ + 0],
                    R = k[_ + 2],
                    N = k[_ + 4],
                    z = Math.max(L, R, N),
                    F = Math.min(L, R, N);
                  z > 0.9 &&
                    F < 0.1 &&
                    (L < 0.2 && (k[_ + 0] += 1),
                    R < 0.2 && (k[_ + 2] += 1),
                    N < 0.2 && (k[_ + 4] += 1));
                }
                function w(_) {
                  return Math.atan2(_.z, -_.x);
                }
              })(),
              this.setAttribute("position", new sv(U, 3)),
              this.setAttribute("normal", new sv(Y, 3)),
              this.setAttribute("uv", new sv(k, 2));
          }
          static fromJSON(_) {
            return new go(
              _.vertices,
              _.indices,
              _.radius,
              _.corner,
              _.cornerSides,
            );
          }
        },
        gl = class {
          static create(_) {
            return this.build(this.normalizeInputs(_));
          }
          static normalizeInputs(_, L) {
            let R = Object.assign(
              {},
              L?.parameters ?? {
                width: 100,
                detail: 0,
                corner: 0,
                cornerSides: 4,
              },
              _.parameters,
            );
            return {
              parameters: Object.assign(R, {
                width: Math.abs(R.width),
                height: Math.abs(R.height ?? R.width),
                depth: Math.abs(R.depth ?? R.width),
              }),
            };
          }
          static build(_) {
            let {
                width: L,
                height: R,
                depth: N,
                detail: z,
                corner: F,
                cornerSides: U,
              } = _.parameters,
              k =
                0 === z && 0 !== F ? new gh(0.5 * L, F, U) : new aj(0.5 * L, z);
            return (
              k.scale(1, R / L, N / L),
              Object.assign(k, {
                userData: { ..._, type: "DodecahedronGeometry" },
              })
            );
          }
        },
        gh = class extends go {
          constructor(_ = 1, L = 0.2, R = 4) {
            let N = (1 + Math.sqrt(5)) / 2,
              z = 1 / N,
              F = "DodecahedronGeometry";
            super(
              [
                -1,
                -1,
                -1,
                -1,
                -1,
                1,
                -1,
                1,
                -1,
                -1,
                1,
                1,
                1,
                -1,
                -1,
                1,
                -1,
                1,
                1,
                1,
                -1,
                1,
                1,
                1,
                0,
                -z,
                -N,
                0,
                -z,
                N,
                0,
                z,
                -N,
                0,
                z,
                N,
                -z,
                -N,
                0,
                -z,
                N,
                0,
                z,
                -N,
                0,
                z,
                N,
                0,
                -N,
                0,
                -z,
                N,
                0,
                -z,
                -N,
                0,
                z,
                N,
                0,
                z,
              ],
              [
                3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15,
                17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0,
                12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2,
                16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4,
                14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19,
                5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9,
              ],
              F,
              _,
              L,
              R,
            ),
              (this.type = F);
          }
          static fromJSON(_) {
            return new gh(_.radius, _.corner, _.cornerSides);
          }
        },
        gc = class {
          constructor(_) {
            (this.position = new iT()),
              (this.startPosition = new iT()),
              (this.uuid = iE.generateUUID()),
              (this.position = _.clone());
          }
          start() {
            this.reset();
          }
          reset() {
            this.startPosition.copy(this.position);
          }
          applyOffset(_) {
            this.position.copy(this.startPosition).add(_);
          }
          copy(_) {
            return (
              this.position.copy(_.position),
              this.startPosition.copy(_.startPosition),
              this
            );
          }
          clone() {
            return new gc(this.position).copy(this);
          }
          toJSON() {
            return [this.position.x, this.position.y];
          }
        },
        gd = class extends gc {
          constructor(_) {
            super(_.position), (this.parent = _);
          }
          copy(_) {
            return super.copy(_), this;
          }
          clone() {
            return new gd(this.parent).copy(this);
          }
        },
        gp = class extends gc {
          constructor(_, L) {
            super(L),
              (this.controls = []),
              (this.roundness = 0),
              (this.areControlsDirectionsMirrored = !0),
              (this.uuid = _),
              this.controls.push(new gd(this), new gd(this));
          }
          static create(_, L) {
            let R = new gp(_, new iT(...L.position));
            return (
              R.controls[0].position.set(...L.controlPrevious.position),
              R.controls[1].position.set(...L.controlNext.position),
              (R.roundness = L.roundness),
              (R.areControlsDirectionsMirrored =
                L.areControlsDirectionsMirrored),
              R
            );
          }
          getOppositeControl(_) {
            let L = this.controls.indexOf(_);
            return 0 === L
              ? this.controls[1]
              : 1 === L
                ? this.controls[0]
                : null;
          }
          applyOffsetToControls(_, L = 1) {
            for (let R = 0, N = this.controls.length; R < N; R++) {
              let N = this.controls[R];
              this.position.distanceTo(N.position) <= L
                ? N.position.copy(this.position)
                : N.applyOffset(_);
            }
          }
          controlsMoved() {
            return !(
              this.position.equals(this.controls[0].position) &&
              this.position.equals(this.controls[1].position)
            );
          }
          copy(_) {
            return (
              super.copy(_),
              this.controls[0].copy(_.controls[0]),
              this.controls[1].copy(_.controls[1]),
              (this.roundness = _.roundness),
              (this.uuid = _.uuid),
              this
            );
          }
          clone() {
            return new gp(this.uuid, this.position).copy(this);
          }
          toJSON() {
            return super
              .toJSON()
              .concat(this.controls[0].toJSON(), this.controls[1].toJSON(), [
                this.roundness,
              ]);
          }
          computeTangents() {
            return [
              this.curveBefore?.getTangentAt(1),
              this.curveAfter?.getTangentAt(0),
            ];
          }
          computeNormals(_ = new iT(), L = new iT()) {
            let [R, N] = this.computeTangents();
            return R && N && (pM(R, _), pM(N, L)), [_, L];
          }
          computeTangent(_ = new iT()) {
            let [L, R] = this.computeTangents();
            return L && R && _.copy(L).add(R).normalize(), _;
          }
          computeNormal(_ = new iT()) {
            let [L, R] = this.computeNormals();
            return _.copy(L).add(R).normalize(), _;
          }
        };
      function pM(_, L = new iT()) {
        let R = _.length();
        return L.set(-_.y / R, _.x / R);
      }
      var Hx = (_) => _,
        gm = new iT(),
        gg = new iT(),
        gv = new iT(),
        gy = new iT(),
        gx = new iT(),
        gb = new iT(),
        gw = new iq(),
        g_ = new iq();
      function _h(_, L, R = Number.EPSILON) {
        return Math.abs(_ - L) < R;
      }
      function Wx(_, L, R) {
        let N = Math.sqrt(Math.pow(L.x - _.x, 2) + Math.pow(L.y - _.y, 2)),
          z = Math.sqrt(Math.pow(L.x - R.x, 2) + Math.pow(L.y - R.y, 2)),
          F = Math.sqrt(Math.pow(R.x - _.x, 2) + Math.pow(R.y - _.y, 2));
        return Math.acos((z * z + N * N - F * F) / (2 * z * N));
      }
      function Vx(_, L, R) {
        return 0 === gm.copy(L).sub(_).cross(gg.copy(R).sub(_));
      }
      function jx(_, L) {
        return (
          _.position.equals(_.controls[1].position) &&
          L.position.equals(L.controls[0].position)
        );
      }
      function mM(_, L) {
        return (
          Vx(_.position, _.controls[1].position, L.position) &&
          Vx(_.position, L.controls[0].position, L.position)
        );
      }
      function qx(_, L = 12, R = !1) {
        let N = [];
        for (let z = 0, F = _.length; z < F; z++) {
          let F = _[z],
            U = 0;
          if (R && void 0 !== F.roundedCurveCorner) {
            let _ = 0.5 * Jo(F.roundedCurveCorner, L);
            z > 0 && (N[z - 1] += _), (U += _);
          }
          void 0 !== F.curveAfter && (U += Jo(F.curveAfter, L)), N.push(U);
        }
        return (
          _.length > 0 &&
            R &&
            void 0 !== _[0].roundedCurveCorner &&
            (N[_.length - 1] += 0.5 * Jo(_[0].roundedCurveCorner, L)),
          N
        );
      }
      function Jo(_, L = 12) {
        return _ && _ instanceof af
          ? 2 * L
          : _ && (_ instanceof aT || _ instanceof aC)
            ? 1
            : _ && _ instanceof aL
              ? L * _.points.length
              : L;
      }
      var gM = new iT(),
        gE = new iT(),
        gC = new iT(),
        gP = new iT(),
        gD = new iT(),
        gO = new iT(),
        gL = class extends aG {
          constructor(_ = 100, L = 100) {
            super(),
              (this.points = []),
              (this.shapeHoles = []),
              (this.plane = new s6(new iq(0, 0, -1))),
              (this.subdivision = 0),
              (this.controlSnapDistance = 4),
              (this.pointIDs = 0),
              (this.isMesh2D = !1),
              (this._roundness = 0),
              (this.isClosed = !1),
              (this.useCubicForRoundedCorners = !0),
              (this.uuid = iE.generateUUID()),
              (this.needsUpdate = !1),
              (this.roundedCurves = []),
              (this._width = _),
              (this._height = L);
          }
          static createFromState(_, L, R) {
            let N = new gL();
            return (
              (N.isClosed = _.isClosed),
              (N.points = _.points.map((_) => gp.create(_.id, _.data))),
              "number" == typeof _.roundness && (N.roundness = _.roundness),
              (N.shapeHoles = _.shapeHoles.map((_) => gL.createFromState(_))),
              void 0 !== L && void 0 !== R && N.applySize(L, R),
              N.update(),
              N
            );
          }
          get width() {
            return this._width;
          }
          get height() {
            return this._height;
          }
          get roundness() {
            return this._roundness;
          }
          set roundness(_) {
            if (this._roundness !== _) {
              this._roundness = _;
              for (let L = 0, R = this.points.length; L < R; L++)
                this.points[L].roundness = _;
              this.needsUpdate = !0;
            }
          }
          getPointsIndexesByIds(_) {
            return _.map((_) => this.getPointIndexById(_)).filter(
              (_) => _ >= 0,
            );
          }
          getPointIndexById(_) {
            let L = this.points.length,
              R = this.points.findIndex((L) => L.uuid === _);
            if (R < 0) {
              let R = L;
              for (let L = 0, N = this.shapeHoles.length; L < N; L++) {
                let N = this.shapeHoles[L],
                  z = N.points.length,
                  F = N.getPointIndexById(_);
                if (!(F < 0)) return F + R;
                R += z;
              }
            }
            return R;
          }
          getLineIndexById(_) {
            return this.getPointIndexById(_);
          }
          getBezierPoint(_) {
            if (_ <= this.points.length - 1) return this.points[_];
            if (this.shapeHoles.length > 0) {
              let L = this.points.length;
              for (let R = 0, N = this.shapeHoles.length; R < N; R++) {
                let N = this.shapeHoles[R],
                  z = _ - L;
                if (z <= N.points.length - 1) return N.points[z];
                L += N.points.length;
              }
            }
            throw Error(
              "This shape does not have a point for this index: " + _,
            );
          }
          getBezierPointIndex(_) {
            let L = this.points.indexOf(_);
            if (L >= 0) return L;
            if (((L = this.points.length), this.shapeHoles.length > 0))
              for (let R = 0, N = this.shapeHoles.length; R < N; R++) {
                let N = this.shapeHoles[R],
                  z = N.points.indexOf(_);
                if (z >= 0) return L + z;
                L += N.points.length;
              }
            return -1;
          }
          getAllPoints() {
            let _ = [].concat(...this.shapeHoles.map((_) => _.points));
            return [...this.points, ..._];
          }
          applySize(_, L) {
            0 === _ && (_ = 0.001),
              0 === L && (L = 0.001),
              (this._width = _),
              (this._height = L);
          }
          applyScale(_, L) {
            let R = gM.set(_, L);
            for (let _ = 0, L = this.points.length; _ < L; _++) {
              let L = this.points[_];
              L.position.multiply(R),
                L.controls[0].position.multiply(R),
                L.controls[1].position.multiply(R);
            }
            for (let R = 0, N = this.shapeHoles.length; R < N; R++)
              this.shapeHoles[R].applyScale(_, L);
            this._update();
          }
          createPoint(_, L = 0, R = iE.generateUUID()) {
            let N;
            N = _ instanceof iT ? _ : new iT(_, L);
            let z = new gp(R, N);
            return (z.roundness = this.roundness), z;
          }
          addPoint(_) {
            this.points.push(_), (this.needsUpdate = !0);
          }
          addPointAt(_, L) {
            this.points.splice(L, 0, _), (this.needsUpdate = !0);
          }
          getPointByUuid(_) {
            for (let L = 0, R = this.points.length; L < R; L++) {
              let R = this.points[L];
              if (R.uuid === _) return R;
            }
            for (let L = 0, R = this.shapeHoles.length; L < R; L++) {
              let R = this.shapeHoles[L].getPointByUuid(_);
              if (R) return R;
            }
          }
          getFirstPoint() {
            return this.points[0];
          }
          getLastPoint() {
            return this.points[this.points.length - 1];
          }
          removePoint(_) {
            let L = this.points.indexOf(_);
            L >= 0 && this.points.splice(L, 1), (this.needsUpdate = !0);
          }
          removePointById(_) {
            let L = this.points.find((L) => L.uuid === _);
            L && this.removePoint(L);
          }
          update() {
            for (let _ = 0, L = this.shapeHoles.length; _ < L; _++)
              this.shapeHoles[_].update();
            this._update();
          }
          extractShapePointsToBuffer(_, L = 12, R = !1) {
            (this.subdivision = L),
              void 0 === this.curveDivisions && this.computeCurveDivisions(L);
            let N = R ? this.roundedCurveDivisions : this.curveDivisions;
            return (
              (function (_, L, R = 12, N = !0) {
                let z = g_.set(0, 0, 0),
                  F,
                  U = 0,
                  k = [];
                for (let N = 0; N < L.length; N++) {
                  let Y = Hx(L[N]),
                    X = Jo(Y, R);
                  k.push(X);
                  for (let L = 0; L <= X; L++)
                    if (Y instanceof aA || Y instanceof aD || Y instanceof aT) {
                      if (
                        (Y.getPoint(L / X, gm),
                        z.set(gm.x, gm.y, 0),
                        void 0 !== F &&
                          (function (_, L, R = Number.EPSILON) {
                            return _.distanceTo(L) < R;
                          })(F, z))
                      )
                        continue;
                      void 0 === F && (F = gw),
                        F.copy(z),
                        _.setXYZ(U, z.x, z.y, z.z),
                        U++;
                    }
                }
                N &&
                  U > 1 &&
                  !(
                    _.getX(U - 1) === _.getX(0) &&
                    _.getY(U - 1) === _.getY(0) &&
                    _.getZ(U - 1) === _.getZ(0)
                  ) &&
                  (_.setXYZ(U, _.getX(0), _.getY(0), _.getZ(0)), U++);
              })(_, R ? this.roundedCurves : this.curves, L, this.autoClose),
              N.reduce((_, L) => _ + L, 0) + 1
            );
          }
          computeCurveDivisions(_ = 12) {
            return (
              (this.curveDivisions = qx(this.points, _, !1)),
              (this.roundedCurveDivisions = qx(this.points, _, !0)),
              this.curveDivisions
            );
          }
          extractFilteredShapePointsToBuffer(_, L, R = 12) {
            return (
              2 *
              (function (_, L, R, N = 12, z = !0) {
                let F = g_.set(0, 0, 0),
                  U = 0,
                  k = [];
                for (let z = 0; z < L.length; z++) {
                  if (!1 === R[z]) continue;
                  let Y,
                    X = Hx(L[z]),
                    Q = Jo(X, N);
                  k.push(Q);
                  for (let L = 0; L <= Q; L++)
                    if (X instanceof aA || X instanceof aD || X instanceof aT) {
                      if (
                        (X.getPoint(L / Q, gm),
                        F.set(gm.x, gm.y, 0),
                        Y?.equals(F))
                      )
                        continue;
                      void 0 === Y
                        ? (Y = gw)
                        : (_.setXYZ(U, Y.x, Y.y, Y.z),
                          U++,
                          _.setXYZ(U, F.x, F.y, F.z),
                          U++),
                        Y.copy(F);
                    }
                }
                return (
                  z &&
                    U > 1 &&
                    !(
                      _.getX(U - 1) === _.getX(0) &&
                      _.getY(U - 1) === _.getY(0) &&
                      _.getZ(U - 1) === _.getZ(0)
                    ) &&
                    (_.setXYZ(U, _.getX(0), _.getY(0), _.getZ(0)), U++),
                  k
                );
              })(_, this.curves, L, R, this.autoClose).reduce(
                (_, L) => _ + L,
                0,
              )
            );
          }
          extractShapePointsToFlatArray(_, L = 12) {
            return (
              (this.subdivision = L),
              void 0 === this.curveDivisions && this.computeCurveDivisions(L),
              (function (_, L, R = 12, N = !0) {
                let z,
                  F = 0;
                for (let N = 0; N < L.length; N++) {
                  let U = Hx(L[N]),
                    k = Jo(U, R);
                  for (let L = 0; L <= k; L++)
                    if (U instanceof aA || U instanceof aD || U instanceof aT) {
                      if (
                        (U.getPoint(L / k, gm),
                        void 0 !== z &&
                          (function (_, L, R = Number.EPSILON) {
                            return _.distanceTo(L) < R;
                          })(z, gm, 1e-12))
                      )
                        continue;
                      void 0 === z && (z = gg),
                        z.copy(gm),
                        _.push(gm.x, gm.y),
                        F++;
                    }
                }
                return (
                  _h(_[0], _[_.length - 2], 1e-12) &&
                    _h(_[1], _[_.length - 1], 1e-12) &&
                    (_.pop(), _.pop()),
                  N &&
                    F > 1 &&
                    !(_h(_[F - 1], _[1], 1e-12) && _h(_[F - 2], _[0], 1e-12)) &&
                    (_.push(_[0], _[1]), F++),
                  _
                );
              })(_, this.roundedCurves, L, this.autoClose)
            );
          }
          getCurveIndexFromVertexId(_, L = !1) {
            let R = 0;
            void 0 === this.curveDivisions &&
              this.computeCurveDivisions(this.subdivision);
            let N = L ? this.roundedCurveDivisions : this.curveDivisions,
              z = 0;
            L &&
              void 0 !== this.points[0].roundedCurveCorner &&
              (z =
                0.5 * Jo(this.points[0].roundedCurveCorner, this.subdivision));
            let F = _ - z;
            F < 0 && (F += N.reduce((_, L) => _ + L, 0));
            for (let _ = 0, L = N.length; _ < L; _++) {
              let L = N[_];
              if (F < R + L) return [_, (F - R + 1) / L];
              R += L;
            }
            return [0, 1];
          }
          getCurveT(_, L, R) {
            let N = this.points[_],
              z = this.points[_ >= this.points.length - 1 ? 0 : _ + 1],
              F = this.curveDivisions,
              U = F[_];
            if (jx(N, z)) {
              let _ = N.position.distanceTo(z.position);
              return N.position.distanceTo(gM.set(R.x, R.y)) / _;
            }
            let k = 0;
            for (let L = 0; L < _; L++) k += F[L];
            return (L - k) / U;
          }
          dispose() {}
          _applyCurveForPoint(_, L) {
            jx(L, _)
              ? this.lineTo(_.position.x, _.position.y)
              : this.bezierCurveTo(
                  L.controls[1].position.x,
                  L.controls[1].position.y,
                  _.controls[0].position.x,
                  _.controls[0].position.y,
                  _.position.x,
                  _.position.y,
                );
            let R = this.curves[this.curves.length - 1];
            (_.curveBefore = R), (L.curveAfter = R);
            let N = R.clone();
            (_.roundedCurveBefore = N),
              (L.roundedCurveAfter = N),
              (_.roundedCurveCorner = void 0),
              this.roundedCurves.push(N);
          }
          _update() {
            if (
              ((this.curves = []),
              (this.roundedCurves = []),
              !this.points.length)
            )
              return;
            for (let _ = 0, L = this.points.length; _ < L; _++) {
              let L = this.points[_];
              if (0 === _) this.moveTo(L.position.x, L.position.y);
              else {
                let R = this.points[_ - 1];
                this._applyCurveForPoint(L, R);
              }
            }
            let _ = this.getLastPoint();
            if ((_?.curveAfter && (_.curveAfter = void 0), this.isClosed)) {
              let _ = this.points[0],
                L = this.points[this.points.length - 1];
              this._applyCurveForPoint(_, L);
            }
            if (this.points.length > 2) {
              let _ = 0;
              for (let R = 0, N = this.points.length; R < N; R++) {
                var L;
                let N = this.points[R],
                  z = this.points[R - 1] ?? this.points[this.points.length - 1],
                  F = this.points[R + 1] ?? this.points[0],
                  U = N.roundness,
                  k =
                    z &&
                    F &&
                    mM(z, N) &&
                    mM(N, F) &&
                    Vx(z.position, N.position, F.position);
                if (!N.controlsMoved() && U > 0 && !k) {
                  let z,
                    F = N.curveBefore,
                    k = N.curveAfter;
                  if (void 0 === F || void 0 === k) continue;
                  let Y = N.roundedCurveBefore,
                    X = N.roundedCurveAfter,
                    Q = F.getLength(),
                    K = k.getLength(),
                    J = Math.min(
                      Math.min(U, 0.499 * Q),
                      Math.min(U, 0.499 * K),
                    ),
                    $ = 1 - J / Q,
                    ee = J / K,
                    er = F.getPointAt($, gM),
                    en = k.getPointAt(ee, gE);
                  if (
                    (this._subSplitCurve(F, Y, $, er, void 0),
                    this._subSplitCurve(k, X, ee, void 0, en),
                    this.useCubicForRoundedCorners)
                  ) {
                    let _ =
                        Math.tan(Wx(er, N.position, en) / 2) *
                        er.distanceTo(N.position),
                      [R, F] = (function (_, L, R, N, z) {
                        let F = Math.sqrt(
                            Math.pow(L.x - _.x, 2) + Math.pow(L.y - _.y, 2),
                          ),
                          U = (_.y + L.y) / 2,
                          k = (_.x + L.x) / 2,
                          Y =
                            (Math.sqrt(Math.pow(R, 2) - Math.pow(F / 2, 2)) *
                              (_.y - L.y)) /
                            F,
                          X =
                            (Math.sqrt(Math.pow(R, 2) - Math.pow(F / 2, 2)) *
                              (L.x - _.x)) /
                            F;
                        return N.set(k + Y, U + X), z.set(k - Y, U - X), [N, z];
                      })(er, en, _, gC, gP),
                      [U, k] = (function (_, L, R, N, z, F) {
                        let U = L.x - _.x,
                          k = L.y - _.y,
                          Y = R.x - _.x,
                          X = R.y - _.y,
                          Q = Math.sqrt((U + Y) * (U + Y) + (k + X) * (k + X)),
                          K;
                        return (
                          Wx(L, _, R) > Math.PI && (Q *= -1),
                          (K = _h(X, k)
                            ? ((k + X) * (N / Q - 0.5) * 8) / 3 / (U - Y)
                            : ((U + Y) * (N / Q - 0.5) * 8) / 3 / (X - k)),
                          z.set(L.x - K * k, L.y + K * U),
                          F.set(R.x + K * X, R.y - K * Y),
                          [z, F]
                        );
                      })(
                        ((L = N.position),
                        R.distanceTo(L) < F.distanceTo(L) ? F : R),
                        er,
                        en,
                        _,
                        gD,
                        gO,
                      );
                    z = new aA(er.clone(), U.clone(), k.clone(), en.clone());
                  } else z = new aD(er.clone(), N.position.clone(), en.clone());
                  (N.roundedCurveCorner = z),
                    this.roundedCurves.splice(R + _, 0, z),
                    _++;
                }
              }
            }
          }
          _subSplitCurve(_, L, R, N, z) {
            if (_ instanceof aT)
              void 0 !== N && L.v2.copy(N), void 0 !== z && L.v1.copy(z);
            else {
              let F = _.getUtoTmapping(R, 0),
                U = (function (_, L, R, N, z = 0.5) {
                  let F = gm.subVectors(L, _).multiplyScalar(z).add(_),
                    U = gg.subVectors(R, L).multiplyScalar(z).add(L),
                    k = gv.subVectors(N, R).multiplyScalar(z).add(R),
                    Y = gy.subVectors(U, F).multiplyScalar(z).add(F),
                    X = gx.subVectors(k, U).multiplyScalar(z).add(U),
                    Q = gb.subVectors(X, Y).multiplyScalar(z).add(Y);
                  return [
                    _.x,
                    _.y,
                    F.x,
                    F.y,
                    Y.x,
                    Y.y,
                    Q.x,
                    Q.y,
                    X.x,
                    X.y,
                    k.x,
                    k.y,
                    N.x,
                    N.y,
                  ];
                })(_.v0, _.v1, _.v2, _.v3, F);
              return (
                void 0 !== N &&
                  (L.v0.set(U[0], U[1]),
                  L.v1.set(U[2], U[3]),
                  L.v2.set(U[4], U[5]),
                  L.v3.set(U[6], U[7])),
                void 0 !== z &&
                  (L.v0.set(U[6], U[7]),
                  L.v1.set(U[8], U[9]),
                  L.v2.set(U[10], U[11]),
                  L.v3.set(U[12], U[13])),
                L
              );
            }
            return L;
          }
          clone() {
            let _ = new gL(this._width, this._height);
            return (
              (_.points = this.points.map((_) => _.clone())),
              (_.isClosed = this.isClosed),
              (_.roundness = this.roundness),
              (_.isMesh2D = this.isMesh2D),
              (_.shapeHoles = this.shapeHoles.map((_) => _.clone())),
              _
            );
          }
          toJSON() {
            return {
              points: this.points.reduce((_, L) => _.concat(L.toJSON()), []),
              shapeHoles: this.shapeHoles.map((_) => _.toJSON()),
              isClosed: this.isClosed,
              roundness: this.roundness,
            };
          }
          fromJSON(_) {
            (this.points = []), (this.pointIDs = 0);
            let L = _.points.length / 7;
            for (let R = 0; R < L; R++) {
              let L = 7 * R,
                N = _.points[L + 0],
                z = _.points[L + 1],
                F = _.points[L + 2],
                U = _.points[L + 3],
                k = _.points[L + 4],
                Y = _.points[L + 5],
                X = _.points[L + 6],
                Q = new gp(iE.generateUUID(), new iT(N, z));
              Q.controls[0].position.set(F, U),
                Q.controls[1].position.set(k, Y),
                (Q.roundness = X),
                this.points.push(Q);
            }
            return (
              (this.shapeHoles = _.shapeHoles?.length
                ? _.shapeHoles.map((_) => {
                    let L = new gL();
                    return L.fromJSON(_), L;
                  })
                : []),
              (this.isClosed = _.isClosed),
              (this._roundness = _.roundness),
              this._update(),
              this
            );
          }
          fromShape(_) {
            let n = (_, L) => {
              L instanceof aA &&
                L.v3.equals(_.position) &&
                _.controls[0].position.copy(L.v2);
            };
            return (
              (this.points = ((_) => {
                let L = [],
                  R,
                  N;
                for (R = 0, N = _.length; R < N; R++)
                  _[R] instanceof aD &&
                    (_[R] = (function (_) {
                      let L = new iT();
                      L.addVectors(
                        _.v0,
                        gm.subVectors(_.v1, _.v0).multiplyScalar(2 / 3),
                      );
                      let R = new iT();
                      return (
                        R.addVectors(
                          _.v2,
                          gg.subVectors(_.v1, _.v2).multiplyScalar(2 / 3),
                        ),
                        new aA(_.v0, L, R, _.v2)
                      );
                    })(_[R]));
                for (R = 0, N = _.length; R < N; R++) {
                  let N = _[R],
                    z = R > 0 ? _[R - 1] : null,
                    F;
                  N instanceof aA
                    ? (F = this.createPoint(N.v0)).controls[1].position.copy(
                        N.v1,
                      )
                    : N instanceof aT && (F = this.createPoint(N.v1)),
                    void 0 !== F && (null !== z && n(F, z), L.push(F));
                }
                let z = _[_.length - 1],
                  F = !1;
                return (
                  z instanceof aA
                    ? z.v3.equals(L[0].position) &&
                      (L[0].controls[0].position.copy(z.v2), (F = !0))
                    : z instanceof aT && z.v2.equals(L[0].position) && (F = !0),
                  (this.isClosed = F),
                  L
                );
              })(_.curves)),
              _ instanceof aG &&
                (this.shapeHoles = _.holes.map((_) => {
                  let L = new gL();
                  return L.fromShape(_), L;
                })),
              this.update(),
              this
            );
          }
          updatePoint(_, L) {
            let R = this.getPointByUuid(_);
            R &&
              (void 0 !== L.position && R.position.fromArray(L.position),
              void 0 !== L.roundness && (R.roundness = L.roundness),
              void 0 !== L.areControlsDirectionsMirrored &&
                (R.areControlsDirectionsMirrored =
                  L.areControlsDirectionsMirrored),
              (this.needsUpdate = !0));
          }
          updatePreviousControl(_, L) {
            let R = this.getPointByUuid(_)?.controls[0];
            R &&
              (L.position && R.position.fromArray(L.position),
              (this.needsUpdate = !0));
          }
          updateNextControl(_, L) {
            let R = this.getPointByUuid(_)?.controls[1];
            R &&
              (L.position && R.position.fromArray(L.position),
              (this.needsUpdate = !0));
          }
        },
        gR = 2 * Math.PI;
      function Yx({ x: _, y: L }, R, N, z, F) {
        return { x: _ * R + z, y: L * N + F };
      }
      function MM(_, L, R, N) {
        let z = Math.min(1, Math.max(-1, _ * R + L * N));
        return (_ * N - L * R < 0 ? -1 : 1) * Math.acos(z);
      }
      function Ye(_, L) {
        if (!_) throw L || "Assertion Failed!";
      }
      ((vl = vp || (vp = {}))[(vl.ODD = 0)] = "ODD"),
        (vl[(vl.NONZERO = 1)] = "NONZERO"),
        (vl[(vl.POSITIVE = 2)] = "POSITIVE"),
        (vl[(vl.NEGATIVE = 3)] = "NEGATIVE"),
        (vl[(vl.ABS_GEQ_TWO = 4)] = "ABS_GEQ_TWO"),
        ((vd = vf || (vf = {}))[(vd.POLYGONS = 0)] = "POLYGONS"),
        (vd[(vd.CONNECTED_POLYGONS = 1)] = "CONNECTED_POLYGONS"),
        (vd[(vd.BOUNDARY_CONTOURS = 2)] = "BOUNDARY_CONTOURS");
      var gI = (function () {
          function r() {}
          return (
            (r.vertEq = function (_, L) {
              return _.s === L.s && _.t === L.t;
            }),
            (r.vertLeq = function (_, L) {
              return _.s < L.s || (_.s === L.s && _.t <= L.t);
            }),
            (r.transLeq = function (_, L) {
              return _.t < L.t || (_.t === L.t && _.s <= L.s);
            }),
            (r.edgeGoesLeft = function (_) {
              return r.vertLeq(_.Dst, _.Org);
            }),
            (r.edgeGoesRight = function (_) {
              return r.vertLeq(_.Org, _.Dst);
            }),
            (r.vertL1dist = function (_, L) {
              return Math.abs(_.s - L.s) + Math.abs(_.t - L.t);
            }),
            (r.edgeEval = function (_, L, R) {
              Ye(r.vertLeq(_, L) && r.vertLeq(L, R));
              var N = L.s - _.s,
                z = R.s - L.s;
              return N + z > 0
                ? N < z
                  ? L.t - _.t + (_.t - R.t) * (N / (N + z))
                  : L.t - R.t + (R.t - _.t) * (z / (N + z))
                : 0;
            }),
            (r.edgeSign = function (_, L, R) {
              Ye(r.vertLeq(_, L) && r.vertLeq(L, R));
              var N = L.s - _.s,
                z = R.s - L.s;
              return N + z > 0 ? (L.t - R.t) * N + (L.t - _.t) * z : 0;
            }),
            (r.transEval = function (_, L, R) {
              Ye(r.transLeq(_, L) && r.transLeq(L, R));
              var N = L.t - _.t,
                z = R.t - L.t;
              return N + z > 0
                ? N < z
                  ? L.s - _.s + (_.s - R.s) * (N / (N + z))
                  : L.s - R.s + (R.s - _.s) * (z / (N + z))
                : 0;
            }),
            (r.transSign = function (_, L, R) {
              Ye(r.transLeq(_, L) && r.transLeq(L, R));
              var N = L.t - _.t,
                z = R.t - L.t;
              return N + z > 0 ? (L.s - R.s) * N + (L.s - _.s) * z : 0;
            }),
            (r.vertCCW = function (_, L, R) {
              return (
                _.s * (L.t - R.t) + L.s * (R.t - _.t) + R.s * (_.t - L.t) >= 0
              );
            }),
            (r.interpolate = function (_, L, R, N) {
              return (_ = _ < 0 ? 0 : _) <= (R = R < 0 ? 0 : R)
                ? 0 === R
                  ? (L + N) / 2
                  : L + (N - L) * (_ / (_ + R))
                : N + (L - N) * (R / (_ + R));
            }),
            (r.intersect = function (_, L, R, N, z) {
              var F, U, k;
              r.vertLeq(_, L) || ((k = _), (_ = L), (L = k)),
                r.vertLeq(R, N) || ((k = R), (R = N), (N = k)),
                r.vertLeq(_, R) ||
                  ((k = _), (_ = R), (R = k), (k = L), (L = N), (N = k)),
                r.vertLeq(R, L)
                  ? r.vertLeq(L, N)
                    ? ((F = r.edgeEval(_, R, L)) + (U = r.edgeEval(R, L, N)) <
                        0 && ((F = -F), (U = -U)),
                      (z.s = r.interpolate(F, R.s, U, L.s)))
                    : ((F = r.edgeSign(_, R, L)) + (U = -r.edgeSign(_, N, L)) <
                        0 && ((F = -F), (U = -U)),
                      (z.s = r.interpolate(F, R.s, U, N.s)))
                  : (z.s = (R.s + L.s) / 2),
                r.transLeq(_, L) || ((k = _), (_ = L), (L = k)),
                r.transLeq(R, N) || ((k = R), (R = N), (N = k)),
                r.transLeq(_, R) ||
                  ((k = _), (_ = R), (R = k), (k = L), (L = N), (N = k)),
                r.transLeq(R, L)
                  ? r.transLeq(L, N)
                    ? ((F = r.transEval(_, R, L)) + (U = r.transEval(R, L, N)) <
                        0 && ((F = -F), (U = -U)),
                      (z.t = r.interpolate(F, R.t, U, L.t)))
                    : ((F = r.transSign(_, R, L)) +
                        (U = -r.transSign(_, N, L)) <
                        0 && ((F = -F), (U = -U)),
                      (z.t = r.interpolate(F, R.t, U, N.t)))
                  : (z.t = (R.t + L.t) / 2);
            }),
            r
          );
        })(),
        Th = function () {
          (this.next = null),
            (this.prev = null),
            (this.anEdge = null),
            (this.trail = null),
            (this.n = 0),
            (this.marked = !1),
            (this.inside = !1);
        },
        gB = (function () {
          function r(_) {
            (this.side = _),
              (this.next = null),
              (this.Org = null),
              (this.Sym = null),
              (this.Onext = null),
              (this.Lnext = null),
              (this.Lface = null),
              (this.activeRegion = null),
              (this.winding = 0);
          }
          return (
            Object.defineProperty(r.prototype, "Rface", {
              get: function () {
                return this.Sym.Lface;
              },
              set: function (_) {
                this.Sym.Lface = _;
              },
              enumerable: !0,
              configurable: !0,
            }),
            Object.defineProperty(r.prototype, "Dst", {
              get: function () {
                return this.Sym.Org;
              },
              set: function (_) {
                this.Sym.Org = _;
              },
              enumerable: !0,
              configurable: !0,
            }),
            Object.defineProperty(r.prototype, "Oprev", {
              get: function () {
                return this.Sym.Lnext;
              },
              set: function (_) {
                this.Sym.Lnext = _;
              },
              enumerable: !0,
              configurable: !0,
            }),
            Object.defineProperty(r.prototype, "Lprev", {
              get: function () {
                return this.Onext.Sym;
              },
              set: function (_) {
                this.Onext.Sym = _;
              },
              enumerable: !0,
              configurable: !0,
            }),
            Object.defineProperty(r.prototype, "Dprev", {
              get: function () {
                return this.Lnext.Sym;
              },
              set: function (_) {
                this.Lnext.Sym = _;
              },
              enumerable: !0,
              configurable: !0,
            }),
            Object.defineProperty(r.prototype, "Rprev", {
              get: function () {
                return this.Sym.Onext;
              },
              set: function (_) {
                this.Sym.Onext = _;
              },
              enumerable: !0,
              configurable: !0,
            }),
            Object.defineProperty(r.prototype, "Dnext", {
              get: function () {
                return this.Sym.Onext.Sym;
              },
              set: function (_) {
                this.Sym.Onext.Sym = _;
              },
              enumerable: !0,
              configurable: !0,
            }),
            Object.defineProperty(r.prototype, "Rnext", {
              get: function () {
                return this.Sym.Lnext.Sym;
              },
              set: function (_) {
                this.Sym.Lnext.Sym = _;
              },
              enumerable: !0,
              configurable: !0,
            }),
            r
          );
        })(),
        hu = function () {
          (this.next = null),
            (this.prev = null),
            (this.anEdge = null),
            (this.coords = [0, 0, 0]),
            (this.s = 0),
            (this.t = 0),
            (this.pqHandle = 0),
            (this.n = 0),
            (this.idx = 0);
        },
        gN = (function () {
          function r() {
            var _ = new hu(),
              L = new Th(),
              R = new gB(0),
              N = new gB(1);
            (_.next = _.prev = _),
              (_.anEdge = null),
              (L.next = L.prev = L),
              (R.next = R),
              (R.Sym = N),
              (N.next = N),
              (N.Sym = R),
              (this.vHead = _),
              (this.fHead = L),
              (this.eHead = R),
              (this.eHeadSym = N);
          }
          return (
            (r.prototype.makeEdge_ = function (_) {
              var L = new gB(0),
                R = new gB(1);
              _.Sym.side < _.side && (_ = _.Sym);
              var N = _.Sym.next;
              return (
                (R.next = N),
                (N.Sym.next = L),
                (L.next = _),
                (_.Sym.next = R),
                (L.Sym = R),
                (L.Onext = L),
                (L.Lnext = R),
                (L.Org = null),
                (L.Lface = null),
                (L.winding = 0),
                (L.activeRegion = null),
                (R.Sym = L),
                (R.Onext = R),
                (R.Lnext = L),
                (R.Org = null),
                (R.Lface = null),
                (R.winding = 0),
                (R.activeRegion = null),
                L
              );
            }),
            (r.prototype.splice_ = function (_, L) {
              var R = _.Onext,
                N = L.Onext;
              (R.Sym.Lnext = L),
                (N.Sym.Lnext = _),
                (_.Onext = N),
                (L.Onext = R);
            }),
            (r.prototype.makeVertex_ = function (_, L, R) {
              Ye(_, "Vertex can't be null!");
              var N = R.prev;
              (_.prev = N),
                (N.next = _),
                (_.next = R),
                (R.prev = _),
                (_.anEdge = L);
              var z = L;
              do (z.Org = _), (z = z.Onext);
              while (z !== L);
            }),
            (r.prototype.makeFace_ = function (_, L, R) {
              Ye(_, "Face can't be null");
              var N = R.prev;
              (_.prev = N),
                (N.next = _),
                (_.next = R),
                (R.prev = _),
                (_.anEdge = L),
                (_.trail = null),
                (_.marked = !1),
                (_.inside = R.inside);
              var z = L;
              do (z.Lface = _), (z = z.Lnext);
              while (z !== L);
            }),
            (r.prototype.killEdge_ = function (_) {
              _.Sym.side < _.side && (_ = _.Sym);
              var L = _.next,
                R = _.Sym.next;
              (L.Sym.next = R), (R.Sym.next = L);
            }),
            (r.prototype.killVertex_ = function (_, L) {
              var R = _.anEdge,
                N = R;
              do (N.Org = L), (N = N.Onext);
              while (N !== R);
              var z = _.prev,
                F = _.next;
              (F.prev = z), (z.next = F);
            }),
            (r.prototype.killFace_ = function (_, L) {
              var R = _.anEdge,
                N = R;
              do (N.Lface = L), (N = N.Lnext);
              while (N !== R);
              var z = _.prev,
                F = _.next;
              (F.prev = z), (z.next = F);
            }),
            (r.prototype.makeEdge = function () {
              var _ = new hu(),
                L = new hu(),
                R = new Th(),
                N = this.makeEdge_(this.eHead);
              return (
                this.makeVertex_(_, N, this.vHead),
                this.makeVertex_(L, N.Sym, this.vHead),
                this.makeFace_(R, N, this.fHead),
                N
              );
            }),
            (r.prototype.splice = function (_, L) {
              var R = !1,
                N = !1;
              if (_ !== L) {
                if (
                  (L.Org !== _.Org &&
                    ((N = !0), this.killVertex_(L.Org, _.Org)),
                  L.Lface !== _.Lface &&
                    ((R = !0), this.killFace_(L.Lface, _.Lface)),
                  this.splice_(L, _),
                  !N)
                ) {
                  var z = new hu();
                  this.makeVertex_(z, L, _.Org), (_.Org.anEdge = _);
                }
                if (!R) {
                  var F = new Th();
                  this.makeFace_(F, L, _.Lface), (_.Lface.anEdge = _);
                }
              }
            }),
            (r.prototype.delete = function (_) {
              var L = _.Sym,
                R = !1;
              if (
                (_.Lface !== _.Rface &&
                  ((R = !0), this.killFace_(_.Lface, _.Rface)),
                _.Onext === _)
              )
                this.killVertex_(_.Org, null);
              else if (
                ((_.Rface.anEdge = _.Oprev),
                (_.Org.anEdge = _.Onext),
                this.splice_(_, _.Oprev),
                !R)
              ) {
                var N = new Th();
                this.makeFace_(N, _, _.Lface);
              }
              L.Onext === L
                ? (this.killVertex_(L.Org, null), this.killFace_(L.Lface, null))
                : ((_.Lface.anEdge = L.Oprev),
                  (L.Org.anEdge = L.Onext),
                  this.splice_(L, L.Oprev)),
                this.killEdge_(_);
            }),
            (r.prototype.addEdgeVertex = function (_) {
              var L = this.makeEdge_(_),
                R = L.Sym;
              this.splice_(L, _.Lnext), (L.Org = _.Dst);
              var N = new hu();
              return (
                this.makeVertex_(N, R, L.Org), (L.Lface = R.Lface = _.Lface), L
              );
            }),
            (r.prototype.splitEdge = function (_) {
              var L = this.addEdgeVertex(_).Sym;
              return (
                this.splice_(_.Sym, _.Sym.Oprev),
                this.splice_(_.Sym, L),
                (_.Dst = L.Org),
                (L.Dst.anEdge = L.Sym),
                (L.Rface = _.Rface),
                (L.winding = _.winding),
                (L.Sym.winding = _.Sym.winding),
                (L.idx = _.idx),
                (L.Sym.idx = _.Sym.idx),
                L
              );
            }),
            (r.prototype.connect = function (_, L) {
              var R = !1,
                N = this.makeEdge_(_),
                z = N.Sym;
              if (
                (L.Lface !== _.Lface &&
                  ((R = !0), this.killFace_(L.Lface, _.Lface)),
                this.splice_(N, _.Lnext),
                this.splice_(z, L),
                (N.Org = _.Dst),
                (z.Org = L.Org),
                (N.Lface = z.Lface = _.Lface),
                (_.Lface.anEdge = z),
                !R)
              ) {
                var F = new Th();
                this.makeFace_(F, N, _.Lface);
              }
              return N;
            }),
            (r.prototype.zapFace = function (_) {
              var L,
                R,
                N,
                z,
                F,
                U = _.anEdge;
              R = U.Lnext;
              do
                (R = (L = R).Lnext),
                  (L.Lface = null),
                  null === L.Rface &&
                    (L.Onext === L
                      ? this.killVertex_(L.Org, null)
                      : ((L.Org.anEdge = L.Onext), this.splice_(L, L.Oprev)),
                    (N = L.Sym).Onext === N
                      ? this.killVertex_(N.Org, null)
                      : ((N.Org.anEdge = N.Onext), this.splice_(N, N.Oprev)),
                    this.killEdge_(L));
              while (L != U);
              (z = _.prev), ((F = _.next).prev = z), (z.next = F);
            }),
            (r.prototype.countFaceVerts_ = function (_) {
              var L = _.anEdge,
                R = 0;
              do R++, (L = L.Lnext);
              while (L !== _.anEdge);
              return R;
            }),
            (r.prototype.mergeConvexFaces = function (_) {
              var L, R, N, z, F;
              for (L = this.fHead.next; L !== this.fHead; L = L.next)
                if (L.inside)
                  for (
                    F = (R = L.anEdge).Org;
                    (N = R.Lnext),
                      (z = R.Sym) &&
                        z.Lface &&
                        z.Lface.inside &&
                        this.countFaceVerts_(L) +
                          this.countFaceVerts_(z.Lface) -
                          2 <=
                          _ &&
                        gI.vertCCW(R.Lprev.Org, R.Org, z.Lnext.Lnext.Org) &&
                        gI.vertCCW(z.Lprev.Org, z.Org, R.Lnext.Lnext.Org) &&
                        ((N = z.Lnext), this.delete(z), (R = null), (z = null)),
                      !(R && R.Lnext.Org === F);

                  )
                    R = N;
              return !0;
            }),
            (r.prototype.check = function () {
              var _,
                L,
                R,
                N,
                z,
                F,
                U = this.fHead,
                k = this.vHead,
                Y = this.eHead;
              for (L = U, L = U; (_ = L.next) !== U; L = _) {
                Ye(_.prev === L), (z = _.anEdge);
                do
                  Ye(z.Sym !== z),
                    Ye(z.Sym.Sym === z),
                    Ye(z.Lnext.Onext.Sym === z),
                    Ye(z.Onext.Sym.Lnext === z),
                    Ye(z.Lface === _),
                    (z = z.Lnext);
                while (z !== _.anEdge);
              }
              for (
                Ye(_.prev === L && null === _.anEdge), N = k, N = k;
                (R = N.next) !== k;
                N = R
              ) {
                Ye(R.prev === N), (z = R.anEdge);
                do
                  Ye(z.Sym !== z),
                    Ye(z.Sym.Sym === z),
                    Ye(z.Lnext.Onext.Sym === z),
                    Ye(z.Onext.Sym.Lnext === z),
                    Ye(z.Org === R),
                    (z = z.Onext);
                while (z !== R.anEdge);
              }
              for (
                Ye(R.prev === N && null === R.anEdge), F = Y, F = Y;
                (z = F.next) !== Y;
                F = z
              )
                Ye(z.Sym.next === F.Sym),
                  Ye(z.Sym !== z),
                  Ye(z.Sym.Sym === z),
                  Ye(null !== z.Org),
                  Ye(null !== z.Dst),
                  Ye(z.Lnext.Onext.Sym === z),
                  Ye(z.Onext.Sym.Lnext === z);
              Ye(
                z.Sym.next === F.Sym &&
                  z.Sym === this.eHeadSym &&
                  z.Sym.Sym === z &&
                  null === z.Org &&
                  null === z.Dst &&
                  null === z.Lface &&
                  null === z.Rface,
              );
            }),
            r
          );
        })(),
        IM = function () {
          this.handle = null;
        },
        DM = function () {
          (this.key = null), (this.node = 0);
        },
        gz = (function () {
          function r(_, L) {
            (this.leq = L),
              (this.max = 0),
              (this.nodes = []),
              (this.handles = []),
              (this.initialized = !1),
              (this.freeList = 0),
              (this.size = 0),
              (this.max = _),
              (this.nodes = []),
              (this.handles = []);
            for (var R = 0; R < _ + 1; R++)
              (this.nodes[R] = new IM()), (this.handles[R] = new DM());
            (this.initialized = !1),
              (this.nodes[1].handle = 1),
              (this.handles[1].key = null);
          }
          return (
            (r.prototype.floatDown_ = function (_) {
              var L,
                R,
                N,
                z = this.nodes,
                F = this.handles;
              for (L = z[_].handle; ; ) {
                if (
                  ((N = _ << 1) < this.size &&
                    this.leq(F[z[N + 1].handle].key, F[z[N].handle].key) &&
                    ++N,
                  Ye(N <= this.max),
                  (R = z[N].handle),
                  N > this.size || this.leq(F[L].key, F[R].key))
                ) {
                  (z[_].handle = L), (F[L].node = _);
                  break;
                }
                (z[_].handle = R), (F[R].node = _), (_ = N);
              }
            }),
            (r.prototype.floatUp_ = function (_) {
              var L,
                R,
                N,
                z = this.nodes,
                F = this.handles;
              for (L = z[_].handle; ; ) {
                if (
                  ((R = z[(N = _ >> 1)].handle),
                  0 === N || this.leq(F[R].key, F[L].key))
                ) {
                  (z[_].handle = L), (F[L].node = _);
                  break;
                }
                (z[_].handle = R), (F[R].node = _), (_ = N);
              }
            }),
            (r.prototype.init = function () {
              for (var _ = this.size; _ >= 1; --_) this.floatDown_(_);
              this.initialized = !0;
            }),
            (r.prototype.min = function () {
              return this.handles[this.nodes[1].handle].key;
            }),
            (r.prototype.insert = function (_) {
              var L, R, N, z;
              if (2 * (L = ++this.size) > this.max) {
                for (
                  this.max *= 2,
                    z = this.nodes.length,
                    this.nodes.length = this.max + 1,
                    N = z;
                  N < this.nodes.length;
                  N++
                )
                  this.nodes[N] = new IM();
                for (
                  z = this.handles.length,
                    this.handles.length = this.max + 1,
                    N = z;
                  N < this.handles.length;
                  N++
                )
                  this.handles[N] = new DM();
              }
              return (
                0 === this.freeList
                  ? (R = L)
                  : ((R = this.freeList),
                    (this.freeList = this.handles[R].node)),
                (this.nodes[L].handle = R),
                (this.handles[R].node = L),
                (this.handles[R].key = _),
                this.initialized && this.floatUp_(L),
                R
              );
            }),
            (r.prototype.extractMin = function () {
              var _ = this.nodes,
                L = this.handles,
                R = _[1].handle,
                N = L[R].key;
              return (
                this.size > 0 &&
                  ((_[1].handle = _[this.size].handle),
                  (L[_[1].handle].node = 1),
                  (L[R].key = null),
                  (L[R].node = this.freeList),
                  (this.freeList = R),
                  --this.size,
                  this.size > 0 && this.floatDown_(1)),
                N
              );
            }),
            (r.prototype.delete = function (_) {
              var L,
                R = this.nodes,
                N = this.handles;
              Ye(_ >= 1 && _ <= this.max && null !== N[_].key),
                (R[(L = N[_].node)].handle = R[this.size].handle),
                (N[R[L].handle].node = L),
                --this.size,
                L <= this.size &&
                  (L <= 1 ||
                  this.leq(N[R[L >> 1].handle].key, N[R[L].handle].key)
                    ? this.floatDown_(L)
                    : this.floatUp_(L)),
                (N[_].key = null),
                (N[_].node = this.freeList),
                (this.freeList = _);
            }),
            r
          );
        })(),
        Zx = function () {
          (this.eUp = null),
            (this.nodeUp = null),
            (this.windingNumber = 0),
            (this.inside = !1),
            (this.sentinel = !1),
            (this.dirty = !1),
            (this.fixUpperEdge = !1);
        },
        OM = function () {
          (this.key = null), (this.next = null), (this.prev = null);
        },
        gF = (function () {
          function r(_, L) {
            (this.frame = _),
              (this.leq = L),
              (this.head = new OM()),
              (this.head.next = this.head),
              (this.head.prev = this.head);
          }
          return (
            (r.prototype.min = function () {
              return this.head.next;
            }),
            (r.prototype.max = function () {
              return this.head.prev;
            }),
            (r.prototype.insert = function (_) {
              return this.insertBefore(this.head, _);
            }),
            (r.prototype.search = function (_) {
              var L = this.head;
              do L = L.next;
              while (null !== L.key && !this.leq(this.frame, _, L.key));
              return L;
            }),
            (r.prototype.insertBefore = function (_, L) {
              do _ = _.prev;
              while (null !== _.key && !this.leq(this.frame, _.key, L));
              var R = new OM();
              return (
                (R.key = L),
                (R.next = _.next),
                (_.next.prev = R),
                (R.prev = _),
                (_.next = R),
                R
              );
            }),
            (r.prototype.delete = function (_) {
              (_.next.prev = _.prev), (_.prev.next = _.next);
            }),
            r
          );
        })(),
        gU = (function () {
          function r() {}
          return (
            (r.regionBelow = function (_) {
              return _.nodeUp.prev.key;
            }),
            (r.regionAbove = function (_) {
              return _.nodeUp.next.key;
            }),
            (r.debugEvent = function (_) {}),
            (r.addWinding = function (_, L) {
              (_.winding += L.winding), (_.Sym.winding += L.Sym.winding);
            }),
            (r.edgeLeq = function (_, L, R) {
              var N = _.event,
                z = L.eUp,
                F = R.eUp;
              return z.Dst === N
                ? F.Dst === N
                  ? gI.vertLeq(z.Org, F.Org)
                    ? 0 >= gI.edgeSign(F.Dst, z.Org, F.Org)
                    : gI.edgeSign(z.Dst, F.Org, z.Org) >= 0
                  : 0 >= gI.edgeSign(F.Dst, N, F.Org)
                : F.Dst === N
                  ? gI.edgeSign(z.Dst, N, z.Org) >= 0
                  : gI.edgeEval(z.Dst, N, z.Org) >=
                    gI.edgeEval(F.Dst, N, F.Org);
            }),
            (r.deleteRegion = function (_, L) {
              L.fixUpperEdge && Ye(0 === L.eUp.winding),
                (L.eUp.activeRegion = null),
                _.dict.delete(L.nodeUp);
            }),
            (r.fixUpperEdge = function (_, L, R) {
              Ye(L.fixUpperEdge),
                _.mesh.delete(L.eUp),
                (L.fixUpperEdge = !1),
                (L.eUp = R),
                (R.activeRegion = L);
            }),
            (r.topLeftRegion = function (_, L) {
              var R,
                N = L.eUp.Org;
              do L = r.regionAbove(L);
              while (L.eUp.Org === N);
              if (L.fixUpperEdge) {
                if (
                  null ===
                  (R = _.mesh.connect(r.regionBelow(L).eUp.Sym, L.eUp.Lnext))
                )
                  return null;
                r.fixUpperEdge(_, L, R), (L = r.regionAbove(L));
              }
              return L;
            }),
            (r.topRightRegion = function (_) {
              var L = _.eUp.Dst;
              do _ = r.regionAbove(_);
              while (_.eUp.Dst === L);
              return _;
            }),
            (r.addRegionBelow = function (_, L, R) {
              var N = new Zx();
              return (
                (N.eUp = R),
                (N.nodeUp = _.dict.insertBefore(L.nodeUp, N)),
                (N.fixUpperEdge = !1),
                (N.sentinel = !1),
                (N.dirty = !1),
                (R.activeRegion = N),
                N
              );
            }),
            (r.isWindingInside = function (_, L) {
              switch (_.windingRule) {
                case vp.ODD:
                  return (1 & L) != 0;
                case vp.NONZERO:
                  return 0 !== L;
                case vp.POSITIVE:
                  return L > 0;
                case vp.NEGATIVE:
                  return L < 0;
                case vp.ABS_GEQ_TWO:
                  return L >= 2 || L <= -2;
              }
              throw Error("Invalid winding rulle");
            }),
            (r.computeWinding = function (_, L) {
              (L.windingNumber =
                r.regionAbove(L).windingNumber + L.eUp.winding),
                (L.inside = r.isWindingInside(_, L.windingNumber));
            }),
            (r.finishRegion = function (_, L) {
              var R = L.eUp,
                N = R.Lface;
              (N.inside = L.inside), (N.anEdge = R), r.deleteRegion(_, L);
            }),
            (r.finishLeftRegions = function (_, L, R) {
              for (var N, z = null, F = L, U = L.eUp; F !== R; ) {
                if (
                  ((F.fixUpperEdge = !1),
                  (N = (z = r.regionBelow(F)).eUp).Org != U.Org)
                ) {
                  if (!z.fixUpperEdge) {
                    r.finishRegion(_, F);
                    break;
                  }
                  (N = _.mesh.connect(U.Lprev, N.Sym)), r.fixUpperEdge(_, z, N);
                }
                U.Onext !== N &&
                  (_.mesh.splice(N.Oprev, N), _.mesh.splice(U, N)),
                  r.finishRegion(_, F),
                  (U = z.eUp),
                  (F = z);
              }
              return U;
            }),
            (r.addRightEdges = function (_, L, R, N, z, F) {
              var U,
                k,
                Y,
                X,
                Q = !0;
              Y = R;
              do
                Ye(gI.vertLeq(Y.Org, Y.Dst)),
                  r.addRegionBelow(_, L, Y.Sym),
                  (Y = Y.Onext);
              while (Y !== N);
              for (
                null === z && (z = r.regionBelow(L).eUp.Rprev), k = L, X = z;
                (Y = (U = r.regionBelow(k)).eUp.Sym).Org === X.Org;

              )
                Y.Onext !== X &&
                  (_.mesh.splice(Y.Oprev, Y), _.mesh.splice(X.Oprev, Y)),
                  (U.windingNumber = k.windingNumber - Y.winding),
                  (U.inside = r.isWindingInside(_, U.windingNumber)),
                  (k.dirty = !0),
                  !Q &&
                    r.checkForRightSplice(_, k) &&
                    (r.addWinding(Y, X),
                    r.deleteRegion(_, k),
                    _.mesh.delete(X)),
                  (Q = !1),
                  (k = U),
                  (X = Y);
              (k.dirty = !0),
                Ye(k.windingNumber - Y.winding === U.windingNumber),
                F && r.walkDirtyRegions(_, k);
            }),
            (r.spliceMergeVertices = function (_, L, R) {
              _.mesh.splice(L, R);
            }),
            (r.vertexWeights = function (_, L, R) {
              var N = gI.vertL1dist(L, _),
                z = gI.vertL1dist(R, _),
                F = (0.5 * z) / (N + z),
                U = (0.5 * N) / (N + z);
              (_.coords[0] += F * L.coords[0] + U * R.coords[0]),
                (_.coords[1] += F * L.coords[1] + U * R.coords[1]),
                (_.coords[2] += F * L.coords[2] + U * R.coords[2]);
            }),
            (r.getIntersectData = function (_, L, R, N, z, F) {
              (L.coords[0] = L.coords[1] = L.coords[2] = 0),
                (L.idx = -1),
                r.vertexWeights(L, R, N),
                r.vertexWeights(L, z, F);
            }),
            (r.checkForRightSplice = function (_, L) {
              var R = r.regionBelow(L),
                N = L.eUp,
                z = R.eUp;
              if (gI.vertLeq(N.Org, z.Org)) {
                if (gI.edgeSign(z.Dst, N.Org, z.Org) > 0) return !1;
                gI.vertEq(N.Org, z.Org)
                  ? N.Org !== z.Org &&
                    (_.pq.delete(N.Org.pqHandle),
                    r.spliceMergeVertices(_, z.Oprev, N))
                  : (_.mesh.splitEdge(z.Sym),
                    _.mesh.splice(N, z.Oprev),
                    (L.dirty = R.dirty = !0));
              } else {
                if (0 > gI.edgeSign(N.Dst, z.Org, N.Org)) return !1;
                (r.regionAbove(L).dirty = L.dirty = !0),
                  _.mesh.splitEdge(N.Sym),
                  _.mesh.splice(z.Oprev, N);
              }
              return !0;
            }),
            (r.checkForLeftSplice = function (_, L) {
              var R,
                N = r.regionBelow(L),
                z = L.eUp,
                F = N.eUp;
              if ((Ye(!gI.vertEq(z.Dst, F.Dst)), gI.vertLeq(z.Dst, F.Dst))) {
                if (0 > gI.edgeSign(z.Dst, F.Dst, z.Org)) return !1;
                (r.regionAbove(L).dirty = L.dirty = !0),
                  (R = _.mesh.splitEdge(z)),
                  _.mesh.splice(F.Sym, R),
                  (R.Lface.inside = L.inside);
              } else {
                if (gI.edgeSign(F.Dst, z.Dst, F.Org) > 0) return !1;
                (L.dirty = N.dirty = !0),
                  (R = _.mesh.splitEdge(F)),
                  _.mesh.splice(z.Lnext, F.Sym),
                  (R.Rface.inside = L.inside);
              }
              return !0;
            }),
            (r.checkForIntersect = function (_, L) {
              var R,
                N,
                z = r.regionBelow(L),
                F = L.eUp,
                U = z.eUp,
                k = F.Org,
                Y = U.Org,
                X = F.Dst,
                Q = U.Dst,
                K = new hu();
              if (
                (Ye(!gI.vertEq(Q, X)),
                Ye(0 >= gI.edgeSign(X, _.event, k)),
                Ye(gI.edgeSign(Q, _.event, Y) >= 0),
                Ye(k !== _.event && Y !== _.event),
                Ye(!L.fixUpperEdge && !z.fixUpperEdge),
                k === Y || Math.min(k.t, X.t) > Math.max(Y.t, Q.t))
              )
                return !1;
              if (gI.vertLeq(k, Y)) {
                if (gI.edgeSign(Q, k, Y) > 0) return !1;
              } else if (0 > gI.edgeSign(X, Y, k)) return !1;
              return (
                r.debugEvent(_),
                gI.intersect(X, k, Q, Y, K),
                Ye(Math.min(k.t, X.t) <= K.t),
                Ye(K.t <= Math.max(Y.t, Q.t)),
                Ye(Math.min(Q.s, X.s) <= K.s),
                Ye(K.s <= Math.max(Y.s, k.s)),
                gI.vertLeq(K, _.event) &&
                  ((K.s = _.event.s), (K.t = _.event.t)),
                (R = gI.vertLeq(k, Y) ? k : Y),
                gI.vertLeq(R, K) && ((K.s = R.s), (K.t = R.t)),
                gI.vertEq(K, k) || gI.vertEq(K, Y)
                  ? (r.checkForRightSplice(_, L), !1)
                  : (!gI.vertEq(X, _.event) &&
                        gI.edgeSign(X, _.event, K) >= 0) ||
                      (!gI.vertEq(Q, _.event) &&
                        0 >= gI.edgeSign(Q, _.event, K))
                    ? Q === _.event
                      ? (_.mesh.splitEdge(F.Sym),
                        _.mesh.splice(U.Sym, F),
                        (L = r.topLeftRegion(_, L)),
                        (F = r.regionBelow(L).eUp),
                        r.finishLeftRegions(_, r.regionBelow(L), z),
                        r.addRightEdges(_, L, F.Oprev, F, F, !0),
                        !0)
                      : X === _.event
                        ? (_.mesh.splitEdge(U.Sym),
                          _.mesh.splice(F.Lnext, U.Oprev),
                          (z = L),
                          (L = r.topRightRegion(L)),
                          (N = r.regionBelow(L).eUp.Rprev),
                          (z.eUp = U.Oprev),
                          (U = r.finishLeftRegions(_, z, null)),
                          r.addRightEdges(_, L, U.Onext, F.Rprev, N, !0),
                          !0)
                        : (gI.edgeSign(X, _.event, K) >= 0 &&
                            ((r.regionAbove(L).dirty = L.dirty = !0),
                            _.mesh.splitEdge(F.Sym),
                            (F.Org.s = _.event.s),
                            (F.Org.t = _.event.t)),
                          0 >= gI.edgeSign(Q, _.event, K) &&
                            ((L.dirty = z.dirty = !0),
                            _.mesh.splitEdge(U.Sym),
                            (U.Org.s = _.event.s),
                            (U.Org.t = _.event.t)),
                          !1)
                    : (_.mesh.splitEdge(F.Sym),
                      _.mesh.splitEdge(U.Sym),
                      _.mesh.splice(U.Oprev, F),
                      (F.Org.s = K.s),
                      (F.Org.t = K.t),
                      (F.Org.pqHandle = _.pq.insert(F.Org)),
                      r.getIntersectData(_, F.Org, k, X, Y, Q),
                      (r.regionAbove(L).dirty = L.dirty = z.dirty = !0),
                      !1)
              );
            }),
            (r.walkDirtyRegions = function (_, L) {
              for (var R, N, z = r.regionBelow(L); ; ) {
                for (; z.dirty; ) (L = z), (z = r.regionBelow(z));
                if (
                  !L.dirty &&
                  ((z = L), null === (L = r.regionAbove(L)) || !L.dirty)
                )
                  return;
                if (
                  ((L.dirty = !1),
                  (R = L.eUp),
                  (N = z.eUp),
                  R.Dst !== N.Dst &&
                    r.checkForLeftSplice(_, L) &&
                    (z.fixUpperEdge
                      ? (r.deleteRegion(_, z),
                        _.mesh.delete(N),
                        (N = (z = r.regionBelow(L)).eUp))
                      : L.fixUpperEdge &&
                        (r.deleteRegion(_, L),
                        _.mesh.delete(R),
                        (R = (L = r.regionAbove(z)).eUp))),
                  R.Org !== N.Org)
                ) {
                  if (
                    R.Dst === N.Dst ||
                    L.fixUpperEdge ||
                    z.fixUpperEdge ||
                    (R.Dst !== _.event && N.Dst !== _.event)
                  )
                    r.checkForRightSplice(_, L);
                  else if (r.checkForIntersect(_, L)) return;
                }
                R.Org === N.Org &&
                  R.Dst === N.Dst &&
                  (r.addWinding(N, R),
                  r.deleteRegion(_, L),
                  _.mesh.delete(R),
                  (L = r.regionAbove(z)));
              }
            }),
            (r.connectRightVertex = function (_, L, R) {
              var N,
                z = R.Onext,
                F = r.regionBelow(L),
                U = L.eUp,
                k = F.eUp,
                Y = !1;
              if (
                (U.Dst !== k.Dst && r.checkForIntersect(_, L),
                gI.vertEq(U.Org, _.event) &&
                  (_.mesh.splice(z.Oprev, U),
                  (L = r.topLeftRegion(_, L)),
                  (z = r.regionBelow(L).eUp),
                  r.finishLeftRegions(_, r.regionBelow(L), F),
                  (Y = !0)),
                gI.vertEq(k.Org, _.event) &&
                  (_.mesh.splice(R, k.Oprev),
                  (R = r.finishLeftRegions(_, F, null)),
                  (Y = !0)),
                Y)
              ) {
                r.addRightEdges(_, L, R.Onext, z, z, !0);
                return;
              }
              (N = gI.vertLeq(k.Org, U.Org) ? k.Oprev : U),
                (N = _.mesh.connect(R.Lprev, N)),
                r.addRightEdges(_, L, N, N.Onext, N.Onext, !1),
                (N.Sym.activeRegion.fixUpperEdge = !0),
                r.walkDirtyRegions(_, L);
            }),
            (r.connectLeftDegenerate = function (_, L, R) {
              var N, z, F, U, k;
              if (((N = L.eUp), gI.vertEq(N.Org, R))) {
                Ye(!1), r.spliceMergeVertices(_, N, R.anEdge);
                return;
              }
              if (!gI.vertEq(N.Dst, R)) {
                _.mesh.splitEdge(N.Sym),
                  L.fixUpperEdge &&
                    (_.mesh.delete(N.Onext), (L.fixUpperEdge = !1)),
                  _.mesh.splice(R.anEdge, N),
                  r.sweepEvent(_, R);
                return;
              }
              Ye(!1),
                (L = r.topRightRegion(L)),
                (z = U = (F = (k = r.regionBelow(L)).eUp.Sym).Onext),
                k.fixUpperEdge &&
                  (Ye(z !== F),
                  r.deleteRegion(_, k),
                  _.mesh.delete(F),
                  (F = z.Oprev)),
                _.mesh.splice(R.anEdge, F),
                gI.edgeGoesLeft(z) || (z = null),
                r.addRightEdges(_, L, F.Onext, U, z, !0);
            }),
            (r.connectLeftVertex = function (_, L) {
              var R,
                N,
                z,
                F,
                U,
                k,
                Y = new Zx();
              if (
                ((Y.eUp = L.anEdge.Sym),
                (R = _.dict.search(Y).key),
                (N = r.regionBelow(R)))
              ) {
                if (
                  ((F = R.eUp), (U = N.eUp), 0 === gI.edgeSign(F.Dst, L, F.Org))
                ) {
                  r.connectLeftDegenerate(_, R, L);
                  return;
                }
                ((z = gI.vertLeq(U.Dst, F.Dst) ? R : N),
                R.inside || z.fixUpperEdge)
                  ? ((k =
                      z === R
                        ? _.mesh.connect(L.anEdge.Sym, F.Lnext)
                        : _.mesh.connect(U.Dnext, L.anEdge).Sym),
                    z.fixUpperEdge
                      ? r.fixUpperEdge(_, z, k)
                      : r.computeWinding(_, r.addRegionBelow(_, R, k)),
                    r.sweepEvent(_, L))
                  : r.addRightEdges(_, R, L.anEdge, L.anEdge, null, !0);
              }
            }),
            (r.sweepEvent = function (_, L) {
              (_.event = L), r.debugEvent(_);
              for (var R = L.anEdge; null === R.activeRegion; )
                if ((R = R.Onext) === L.anEdge) {
                  r.connectLeftVertex(_, L);
                  return;
                }
              var N = r.topLeftRegion(_, R.activeRegion);
              Ye(null !== N);
              var z = r.regionBelow(N),
                F = z.eUp,
                U = r.finishLeftRegions(_, z, null);
              U.Onext === F
                ? r.connectRightVertex(_, N, U)
                : r.addRightEdges(_, N, U.Onext, F, F, !0);
            }),
            (r.addSentinel = function (_, L, R, N) {
              var z = new Zx(),
                F = _.mesh.makeEdge();
              (F.Org.s = R),
                (F.Org.t = N),
                (F.Dst.s = L),
                (F.Dst.t = N),
                (_.event = F.Dst),
                (z.eUp = F),
                (z.windingNumber = 0),
                (z.inside = !1),
                (z.fixUpperEdge = !1),
                (z.sentinel = !0),
                (z.dirty = !1),
                (z.nodeUp = _.dict.insert(z));
            }),
            (r.initEdgeDict = function (_) {
              _.dict = new gF(_, r.edgeLeq);
              var L = _.bmax[0] - _.bmin[0],
                R = _.bmax[1] - _.bmin[1],
                N = _.bmin[0] - L,
                z = _.bmax[0] + L,
                F = _.bmin[1] - R,
                U = _.bmax[1] + R;
              r.addSentinel(_, N, z, F), r.addSentinel(_, N, z, U);
            }),
            (r.doneEdgeDict = function (_) {
              for (var L, R = 0; null !== (L = _.dict.min().key); )
                L.sentinel || (Ye(L.fixUpperEdge), Ye(1 == ++R)),
                  Ye(0 === L.windingNumber),
                  r.deleteRegion(_, L);
            }),
            (r.removeDegenerateEdges = function (_) {
              var L,
                R,
                N,
                z = _.mesh.eHead;
              for (L = z.next; L !== z; L = R)
                (R = L.next),
                  (N = L.Lnext),
                  gI.vertEq(L.Org, L.Dst) &&
                    L.Lnext.Lnext !== L &&
                    (r.spliceMergeVertices(_, N, L),
                    _.mesh.delete(L),
                    (N = (L = N).Lnext)),
                  N.Lnext === L &&
                    (N !== L &&
                      ((N === R || N === R.Sym) && (R = R.next),
                      _.mesh.delete(N)),
                    (L === R || L === R.Sym) && (R = R.next),
                    _.mesh.delete(L));
            }),
            (r.initPriorityQ = function (_) {
              var L,
                R,
                N,
                z = 0;
              for (R = (N = _.mesh.vHead).next; R !== N; R = R.next) z++;
              for (
                z += 8,
                  L = _.pq = new gz(z, gI.vertLeq),
                  R = (N = _.mesh.vHead).next;
                R !== N;
                R = R.next
              )
                R.pqHandle = L.insert(R);
              return R === N && (L.init(), !0);
            }),
            (r.donePriorityQ = function (_) {
              _.pq = null;
            }),
            (r.removeDegenerateFaces = function (_, L) {
              var R, N, z;
              for (R = L.fHead.next; R !== L.fHead; R = N)
                (N = R.next),
                  Ye((z = R.anEdge).Lnext !== z),
                  z.Lnext.Lnext === z &&
                    (r.addWinding(z.Onext, z), _.mesh.delete(z));
              return !0;
            }),
            (r.computeInterior = function (_, L) {
              var R, N;
              if (
                (void 0 === L && (L = !0),
                r.removeDegenerateEdges(_),
                !r.initPriorityQ(_))
              )
                return !1;
              for (r.initEdgeDict(_); null !== (R = _.pq.extractMin()); ) {
                for (; !(null === (N = _.pq.min()) || !gI.vertEq(N, R)); )
                  (N = _.pq.extractMin()),
                    r.spliceMergeVertices(_, R.anEdge, N.anEdge);
                r.sweepEvent(_, R);
              }
              return (
                (_.event = _.dict.min().key.eUp.Org),
                r.debugEvent(_),
                r.doneEdgeDict(_),
                r.donePriorityQ(_),
                !!r.removeDegenerateFaces(_, _.mesh) &&
                  (L && _.mesh.check(), !0)
              );
            }),
            r
          );
        })(),
        gk = (function () {
          function r() {
            (this.mesh = new gN()),
              (this.normal = [0, 0, 0]),
              (this.sUnit = [0, 0, 0]),
              (this.tUnit = [0, 0, 0]),
              (this.bmin = [0, 0]),
              (this.bmax = [0, 0]),
              (this.windingRule = vp.ODD),
              (this.dict = null),
              (this.pq = null),
              (this.event = null),
              (this.vertexIndexCounter = 0),
              (this.vertices = []),
              (this.vertexIndices = []),
              (this.vertexCount = 0),
              (this.elements = []),
              (this.elementCount = 0);
          }
          return (
            (r.prototype.dot_ = function (_, L) {
              return _[0] * L[0] + _[1] * L[1] + _[2] * L[2];
            }),
            (r.prototype.normalize_ = function (_) {
              var L = _[0] * _[0] + _[1] * _[1] + _[2] * _[2];
              if (!L) throw "Zero-size vector!";
              (L = Math.sqrt(L)), (_[0] /= L), (_[1] /= L), (_[2] /= L);
            }),
            (r.prototype.longAxis_ = function (_) {
              var L = 0;
              return (
                Math.abs(_[1]) > Math.abs(_[0]) && (L = 1),
                Math.abs(_[2]) > Math.abs(_[L]) && (L = 2),
                L
              );
            }),
            (r.prototype.computeNormal_ = function (_) {
              var L,
                R,
                N,
                z,
                F,
                U,
                k = [0, 0, 0],
                Y = [0, 0, 0],
                X = [0, 0, 0],
                Q = [0, 0, 0],
                K = [0, 0, 0],
                J = [null, null, null],
                $ = [null, null, null],
                ee = this.mesh.vHead;
              L = ee.next;
              for (var er = 0; er < 3; ++er)
                (z = L.coords[er]),
                  (Y[er] = z),
                  ($[er] = L),
                  (k[er] = z),
                  (J[er] = L);
              for (L = ee.next; L !== ee; L = L.next)
                for (var en = 0; en < 3; ++en)
                  (z = L.coords[en]) < Y[en] && ((Y[en] = z), ($[en] = L)),
                    z > k[en] && ((k[en] = z), (J[en] = L));
              var ea = 0;
              if (
                (k[1] - Y[1] > k[0] - Y[0] && (ea = 1),
                k[2] - Y[2] > k[ea] - Y[ea] && (ea = 2),
                Y[ea] >= k[ea])
              ) {
                (_[0] = 0), (_[1] = 0), (_[2] = 1);
                return;
              }
              for (
                U = 0,
                  R = $[ea],
                  N = J[ea],
                  X[0] = R.coords[0] - N.coords[0],
                  X[1] = R.coords[1] - N.coords[1],
                  X[2] = R.coords[2] - N.coords[2],
                  L = ee.next;
                L !== ee;
                L = L.next
              )
                (Q[0] = L.coords[0] - N.coords[0]),
                  (Q[1] = L.coords[1] - N.coords[1]),
                  (Q[2] = L.coords[2] - N.coords[2]),
                  (K[0] = X[1] * Q[2] - X[2] * Q[1]),
                  (K[1] = X[2] * Q[0] - X[0] * Q[2]),
                  (K[2] = X[0] * Q[1] - X[1] * Q[0]),
                  (F = K[0] * K[0] + K[1] * K[1] + K[2] * K[2]) > U &&
                    ((U = F), (_[0] = K[0]), (_[1] = K[1]), (_[2] = K[2]));
              U <= 0 && ((_[0] = _[1] = _[2] = 0), (_[this.longAxis_(X)] = 1));
            }),
            (r.prototype.checkOrientation_ = function () {
              for (
                var _,
                  L,
                  R = this.mesh.fHead,
                  N = this.mesh.vHead,
                  z = 0,
                  F = R.next;
                F !== R;
                F = F.next
              )
                if (!((L = F.anEdge).winding <= 0))
                  do
                    (z += (L.Org.s - L.Dst.s) * (L.Org.t + L.Dst.t)),
                      (L = L.Lnext);
                  while (L !== F.anEdge);
              if (z < 0) {
                for (_ = N.next; _ !== N; _ = _.next) _.t = -_.t;
                (this.tUnit[0] = -this.tUnit[0]),
                  (this.tUnit[1] = -this.tUnit[1]),
                  (this.tUnit[2] = -this.tUnit[2]);
              }
            }),
            (r.prototype.projectPolygon_ = function () {
              var _,
                L,
                R = this.mesh.vHead,
                N = [0, 0, 0],
                z = !1;
              (N[0] = this.normal[0]),
                (N[1] = this.normal[1]),
                (N[2] = this.normal[2]),
                N[0] || N[1] || N[2] || (this.computeNormal_(N), (z = !0)),
                (_ = this.sUnit),
                (L = this.tUnit);
              var F = this.longAxis_(N);
              (_[F] = 0),
                (_[(F + 1) % 3] = 1),
                (_[(F + 2) % 3] = 0),
                (L[F] = 0),
                (L[(F + 1) % 3] = 0),
                (L[(F + 2) % 3] = N[F] > 0 ? 1 : -1);
              for (var U = R.next; U !== R; U = U.next)
                (U.s = this.dot_(U.coords, _)), (U.t = this.dot_(U.coords, L));
              z && this.checkOrientation_();
              for (var k = !0, Y = R.next; Y !== R; Y = Y.next)
                k
                  ? ((this.bmin[0] = this.bmax[0] = Y.s),
                    (this.bmin[1] = this.bmax[1] = Y.t),
                    (k = !1))
                  : (Y.s < this.bmin[0] && (this.bmin[0] = Y.s),
                    Y.s > this.bmax[0] && (this.bmax[0] = Y.s),
                    Y.t < this.bmin[1] && (this.bmin[1] = Y.t),
                    Y.t > this.bmax[1] && (this.bmax[1] = Y.t));
            }),
            (r.prototype.addWinding_ = function (_, L) {
              (_.winding += L.winding), (_.Sym.winding += L.Sym.winding);
            }),
            (r.prototype.tessellateMonoRegion_ = function (_, L) {
              var R, N;
              if (!((R = L.anEdge).Lnext !== R && R.Lnext.Lnext !== R))
                throw "Mono region invalid";
              for (; gI.vertLeq(R.Dst, R.Org); R = R.Lprev);
              for (; gI.vertLeq(R.Org, R.Dst); R = R.Lnext);
              for (N = R.Lprev; R.Lnext !== N; )
                if (gI.vertLeq(R.Dst, N.Org)) {
                  for (
                    ;
                    N.Lnext !== R &&
                    (gI.edgeGoesLeft(N.Lnext) ||
                      0 >= gI.edgeSign(N.Org, N.Dst, N.Lnext.Dst));

                  )
                    N = _.connect(N.Lnext, N).Sym;
                  N = N.Lprev;
                } else {
                  for (
                    ;
                    N.Lnext !== R &&
                    (gI.edgeGoesRight(R.Lprev) ||
                      gI.edgeSign(R.Dst, R.Org, R.Lprev.Org) >= 0);

                  )
                    R = _.connect(R, R.Lprev).Sym;
                  R = R.Lnext;
                }
              if (N.Lnext === R) throw "Mono region invalid";
              for (; N.Lnext.Lnext !== R; ) N = _.connect(N.Lnext, N).Sym;
              return !0;
            }),
            (r.prototype.tessellateInterior_ = function (_) {
              for (var L, R = _.fHead.next; R !== _.fHead; R = L)
                if (
                  ((L = R.next), R.inside && !this.tessellateMonoRegion_(_, R))
                )
                  return !1;
              return !0;
            }),
            (r.prototype.discardExterior_ = function (_) {
              for (var L, R = _.fHead.next; R !== _.fHead; R = L)
                (L = R.next), R.inside || _.zapFace(R);
            }),
            (r.prototype.setWindingNumber_ = function (_, L, R) {
              for (var N, z = _.eHead.next; z !== _.eHead; z = N)
                (N = z.next),
                  z.Rface.inside !== z.Lface.inside
                    ? (z.winding = z.Lface.inside ? L : -L)
                    : R
                      ? _.delete(z)
                      : (z.winding = 0);
            }),
            (r.prototype.getNeighbourFace_ = function (_) {
              return _.Rface && _.Rface.inside ? _.Rface.n : -1;
            }),
            (r.prototype.outputPolymesh_ = function (_, L, R, N) {
              var z,
                F,
                U = 0,
                k = 0;
              R > 3 && _.mergeConvexFaces(R);
              for (var Y = _.vHead.next; Y !== _.vHead; Y = Y.next) Y.n = -1;
              for (var X = _.fHead.next; X !== _.fHead; X = X.next)
                if (((X.n = -1), X.inside)) {
                  (z = X.anEdge), (F = 0);
                  do {
                    var Y = z.Org;
                    -1 === Y.n && ((Y.n = k), k++), F++, (z = z.Lnext);
                  } while (z !== X.anEdge);
                  if (F > R) throw "Face vertex greater that support polygon";
                  (X.n = U), ++U;
                }
              (this.elementCount = U),
                L === vf.CONNECTED_POLYGONS && (U *= 2),
                (this.elements = []),
                (this.elements.length = U * R),
                (this.vertexCount = k),
                (this.vertices = []),
                (this.vertices.length = k * N),
                (this.vertexIndices = []),
                (this.vertexIndices.length = k);
              for (var Y = _.vHead.next; Y !== _.vHead; Y = Y.next)
                if (-1 !== Y.n) {
                  var Q = Y.n * N;
                  (this.vertices[Q + 0] = Y.coords[0]),
                    (this.vertices[Q + 1] = Y.coords[1]),
                    N > 2 && (this.vertices[Q + 2] = Y.coords[2]),
                    (this.vertexIndices[Y.n] = Y.idx);
                }
              for (var K = 0, X = _.fHead.next; X !== _.fHead; X = X.next)
                if (X.inside) {
                  (z = X.anEdge), (F = 0);
                  do {
                    var Y = z.Org;
                    (this.elements[K++] = Y.n), F++, (z = z.Lnext);
                  } while (z !== X.anEdge);
                  for (var J = F; J < R; ++J) this.elements[K++] = -1;
                  if (L === vf.CONNECTED_POLYGONS) {
                    z = X.anEdge;
                    do
                      (this.elements[K++] = this.getNeighbourFace_(z)),
                        (z = z.Lnext);
                    while (z !== X.anEdge);
                    for (var $ = F; $ < R; ++$) this.elements[K++] = -1;
                  }
                }
            }),
            (r.prototype.outputContours_ = function (_, L) {
              var R,
                N,
                z = 0,
                F = 0;
              (this.vertexCount = 0), (this.elementCount = 0);
              for (var U = _.fHead.next; U !== _.fHead; U = U.next)
                if (U.inside) {
                  N = R = U.anEdge;
                  do this.vertexCount++, (R = R.Lnext);
                  while (R !== N);
                  this.elementCount++;
                }
              (this.elements = []),
                (this.elements.length = 2 * this.elementCount),
                (this.vertices = []),
                (this.vertices.length = this.vertexCount * L),
                (this.vertexIndices = []),
                (this.vertexIndices.length = this.vertexCount);
              var k = 0,
                Y = 0,
                X = 0;
              z = 0;
              for (var U = _.fHead.next; U !== _.fHead; U = U.next)
                if (U.inside) {
                  (F = 0), (N = R = U.anEdge);
                  do
                    (this.vertices[k++] = R.Org.coords[0]),
                      (this.vertices[k++] = R.Org.coords[1]),
                      L > 2 && (this.vertices[k++] = R.Org.coords[2]),
                      (this.vertexIndices[Y++] = this.vertexIdCallback
                        ? this.vertexIdCallback(R)
                        : R.Org.idx),
                      F++,
                      (R = R.Lnext);
                  while (R !== N);
                  (this.elements[X++] = z), (this.elements[X++] = F), (z += F);
                }
            }),
            (r.prototype.addContour = function (_, L) {
              null === this.mesh && (this.mesh = new gN()),
                _ < 2 && (_ = 2),
                _ > 3 && (_ = 3);
              for (var R = null, N = 0; N < L.length; N += _)
                null === R
                  ? ((R = this.mesh.makeEdge()), this.mesh.splice(R, R.Sym))
                  : (this.mesh.splitEdge(R), (R = R.Lnext)),
                  (R.Org.coords[0] = L[N + 0]),
                  (R.Org.coords[1] = L[N + 1]),
                  _ > 2 ? (R.Org.coords[2] = L[N + 2]) : (R.Org.coords[2] = 0),
                  (R.Org.idx = this.vertexIndexCounter++),
                  this.edgeCreateCallback && this.edgeCreateCallback(R),
                  (R.winding = 1),
                  (R.Sym.winding = -1);
            }),
            (r.prototype.tesselate = function (_, L, R, N, z, F) {
              if (
                (void 0 === _ && (_ = vp.ODD),
                void 0 === L && (L = vf.POLYGONS),
                void 0 === F && (F = !0),
                (this.vertices = []),
                (this.elements = []),
                (this.vertexIndices = []),
                (this.vertexIndexCounter = 0),
                z &&
                  ((this.normal[0] = z[0]),
                  (this.normal[1] = z[1]),
                  (this.normal[2] = z[2])),
                (this.windingRule = _),
                N < 2 && (N = 2),
                N > 3 && (N = 3),
                !this.mesh)
              )
                return !1;
              this.projectPolygon_(), gU.computeInterior(this, F);
              var U = this.mesh;
              return (
                L === vf.BOUNDARY_CONTOURS
                  ? this.setWindingNumber_(U, 1, !0)
                  : this.tessellateInterior_(U),
                F && U.check(),
                L === vf.BOUNDARY_CONTOURS
                  ? this.outputContours_(U, N)
                  : this.outputPolymesh_(U, L, R, N),
                !0
              );
            }),
            r
          );
        })();
      function Ui(_) {
        var L = _.windingRule,
          R = void 0 === L ? vp.ODD : L,
          N = _.elementType,
          z = void 0 === N ? vf.POLYGONS : N,
          F = _.polySize,
          U = _.vertexSize,
          k = void 0 === U ? 2 : U,
          Y = _.normal,
          X = _.contours,
          Q = void 0 === X ? [] : X,
          K = _.strict,
          J = void 0 === K || K,
          $ = _.debug;
        if (!Q && J) throw Error("Contours can't be empty");
        if (Q) {
          var ee = new gk();
          _.edgeCreateCallback &&
            (ee.edgeCreateCallback = _.edgeCreateCallback),
            _.vertexIdCallback && (ee.vertexIdCallback = _.vertexIdCallback);
          for (var er = 0; er < Q.length; er++) ee.addContour(k || 2, Q[er]);
          return (
            ee.tesselate(
              R,
              z,
              void 0 === F ? 3 : F,
              k,
              void 0 === Y ? [0, 0, 1] : Y,
              J,
            ),
            {
              vertices: ee.vertices,
              vertexIndices: ee.vertexIndices,
              vertexCount: ee.vertexCount,
              elements: ee.elements,
              elementCount: ee.elementCount,
              mesh: void 0 !== $ && $ ? ee.mesh : void 0,
            }
          );
        }
      }
      vp.ODD,
        vp.NONZERO,
        vp.POSITIVE,
        vp.NEGATIVE,
        vp.ABS_GEQ_TWO,
        vf.POLYGONS,
        vf.CONNECTED_POLYGONS,
        vf.BOUNDARY_CONTOURS;
      var gj = class {
        constructor(_ = 256, L = !1) {
          (this.capacity = _),
            (this.size = 0),
            (this.debug = L),
            this.debug && console.log(`allocating with cap ${_}`);
          let R = _ * gj.eSize;
          this.buffer = new ArrayBuffer(R);
          let N = Float32Array.BYTES_PER_ELEMENT,
            z = 0;
          (this.positions = new Float32Array(this.buffer, z * N, 3 * _)),
            (z += 3 * _),
            (this.normals = new Float32Array(this.buffer, z * N, 3 * _)),
            (z += 3 * _),
            (this.uvs = new Float32Array(this.buffer, z * N, 2 * _));
        }
        realloc(_, L = !1) {
          if (_ < this.size) throw Error("cannot shrink buffer");
          if (_ <= this.capacity && !L) return;
          this.debug &&
            console.log(`resizing from ${this.capacity} \u2192 ${_}`);
          let R = _ * gj.eSize,
            N = new ArrayBuffer(R),
            z = Float32Array.BYTES_PER_ELEMENT,
            F = 0,
            U = new Float32Array(N, F * z, 3 * _);
          F += 3 * _;
          let k = new Float32Array(N, F * z, 3 * _);
          F += 3 * _;
          let Y = new Float32Array(N, F * z, 2 * _);
          U.set(this.positions.slice(0, 3 * this.size)),
            k.set(this.normals.slice(0, 3 * this.size)),
            Y.set(this.uvs.slice(0, 2 * this.size)),
            (this.buffer = N),
            (this.positions = U),
            (this.normals = k),
            (this.uvs = Y),
            (this.capacity = _);
        }
        get(_ = 1) {
          let L = this.size + _;
          if (L > this.capacity) {
            let _ = this.capacity;
            for (; L > _; ) _ *= 2;
            this.realloc(_);
          }
          let R = this.size;
          return (this.size = L), R;
        }
        reserve(_) {
          let L = this.size + _;
          L > this.capacity && this.realloc(L);
        }
        shrink() {
          this.debug &&
            console.log(`shrinking ${this.capacity} \u2192 ${this.size}`),
            this.realloc(this.size, !0);
        }
      };
      gj.eSize = 8 * Float32Array.BYTES_PER_ELEMENT;
      var gG = {
          vertices: [160, 160, -160, 160, -160, -160, 160, -160],
          vertexIndices: [1, 0, 3, 2],
          vertexCount: 4,
          elements: [0, 4],
          elementCount: 1,
          mesh: void 0,
        },
        gV = {
          vertices: [],
          vertexIndices: [],
          vertexCount: 0,
          elements: [],
          elementCount: 0,
          mesh: void 0,
        },
        gH = {
          vertices: [-160, 160, 160, -160, 160, 160, -160, -160],
          vertexIndices: [1, 3, 0, 2],
          vertexCount: 4,
          elements: [0, 1, 2, 1, 0, 3],
          elementCount: 2,
          mesh: void 0,
        },
        Qx =
          (_, L) =>
          ([R, N]) => (N < R && (N += L), (_ >= R ? _ : _ + L) <= N),
        gW = class extends sP {
          constructor(_, L, R = 0, N = 12, z = 3, F = vp.ODD) {
            let U;
            super(),
              (this.type = "ShapeGeometry"),
              (this.vertexCache = {}),
              (this._shape = _),
              (this._depth = L),
              (this._bevel = R),
              (this._curveSegments = N),
              (this._bevelSegmentsInput = z),
              R <= 0
                ? ((this._bevelSize = 0), (this._bevelSegments = 0))
                : ((this._bevelSize = Math.min(R, L / 2 - 1e-12)),
                  (this._bevelSegments = Math.floor(z)));
            let k = this._shape.extractShapePointsToFlatArray([], N),
              Y = this._shape.shapeHoles.map((_) => {
                let L = _.extractShapePointsToFlatArray([], N),
                  R = [];
                for (let _ = L.length - 1; _ >= 1; _ -= 2) {
                  let N = L[_ - 1],
                    z = L[_ - 0];
                  R.push(N, z);
                }
                return R;
              }),
              X;
            try {
              X = Ui({
                windingRule: F,
                elementType: vf.BOUNDARY_CONTOURS,
                vertexSize: 2,
                strict: !0,
                contours: [k],
              });
            } catch {
              X = gG;
            }
            try {
              U = Ui({
                windingRule: vp.ODD,
                elementType: vf.BOUNDARY_CONTOURS,
                vertexSize: 2,
                strict: !0,
                contours: [...Y],
              });
            } catch {
              U = gV;
            }
            if (!X) throw Error("error generating geometry");
            let Q = X.elementCount;
            if (U) {
              X.elementCount += U.elementCount;
              for (let _ = 0; _ < U.elements.length; _++) {
                let L = U.elements[_],
                  R = _ % 2 == 0 ? X.vertexCount : 0;
                X.elements.push(L + R);
              }
              for (let _ = 0; _ < U.vertexIndices.length; _++) {
                let L = U.vertexIndices[_],
                  R = X.vertexCount;
                X.vertexIndices.push(L + R);
              }
              for (let _ = 0; _ < U.vertices.length; _++) {
                let L = U.vertices[_];
                X.vertices.push(L);
              }
            }
            let K = 1 / 0,
              J = -1 / 0,
              $ = 1 / 0,
              ee = -1 / 0;
            for (let _ = 0, L = X.vertexCount; _ < L; _++) {
              let L = 2 * _,
                R = X.vertices[L + 0],
                N = X.vertices[L + 1];
              R < K && (K = R),
                R > J && (J = R),
                N < $ && ($ = N),
                N > ee && (ee = N);
            }
            (this._minX = K),
              (this._minY = $),
              (this._width = J - K),
              (this._height = ee - $),
              (this._buffer = new gj(this._computeBufferEstimatedSize(X)));
            let er = [],
              en = [];
            for (let _ = X.elementCount - 1; _ >= 0; _--) {
              let L = _ >= Q,
                R = 2 * _,
                z = X.elements[R + 0],
                F = X.elements[R + 1],
                U = z + F,
                k = {
                  start: z,
                  count: F,
                  normals: [],
                  continuous: [],
                  concave: [],
                },
                K = z,
                J = U - 1,
                $ = z + 1,
                ee = this._shape.roundedCurves.length;
              do {
                let _ = K - z,
                  R = X.vertices[2 * J + 0],
                  N = X.vertices[2 * J + 1],
                  Y = X.vertices[2 * K + 0],
                  Q = X.vertices[2 * K + 1],
                  er = X.vertices[2 * $ + 0],
                  en = X.vertices[2 * $ + 1],
                  ea = Y - R,
                  eo = Q - N,
                  el = Math.sqrt(ea * ea + eo * eo);
                (ea /= el), (eo /= el);
                let ec = Y - er,
                  ed = Q - en,
                  eu = Math.sqrt(ec * ec + ed * ed);
                (ec /= eu),
                  (ed /= eu),
                  (k.normals[2 * _ + 0] = -ed),
                  (k.normals[2 * _ + 1] = ec),
                  (k.concave[_] = ea * ed - eo * ec > 0);
                let ep = X.vertexIndices[K];
                if (Array.isArray(ep)) k.continuous[_] = !1;
                else {
                  let [L, R] = this._shape.getCurveIndexFromVertexId(
                    ep - 1,
                    !0,
                  );
                  if (R > 0 && R < 1) k.continuous[_] = !0;
                  else {
                    let N = 1 === R ? L + 1 : L - 1;
                    N = (N + ee) % ee;
                    let z = 1 === R ? 0 : 1,
                      F = this._shape.roundedCurves[L].getTangent(R),
                      U = this._shape.roundedCurves[N].getTangent(z);
                    k.continuous[_] = F.dot(U) > 0.95;
                  }
                }
                L &&
                  ((k.normals[2 * _ + 0] *= -1), (k.normals[2 * _ + 1] *= -1)),
                  ([J, K, $] = [K, $, $ + 1]),
                  $ >= U && ($ -= F);
              } while ($ !== z + 1);
              let ea = [];
              ea.push({
                bevelI: 0,
                angle: 0,
                size: 0,
                boundary: {
                  vertices: X.vertices.slice(2 * z, 2 * U),
                  vertexCount: F,
                  vertexIndices: Array(F)
                    .fill(!0)
                    .map((_, L) => [L, L]),
                  elements: [0, F],
                  elementCount: 1,
                  mesh: null,
                },
                reverseMap: [],
                insetPoints: X.vertices.slice(2 * z, 2 * U),
              });
              for (let _ = 1; _ <= this._bevelSegments; _++) {
                let R = ((_ / this._bevelSegments) * Math.PI) / 2,
                  z = (1 - Math.cos(R)) * this._bevelSize,
                  U = [],
                  Y = [],
                  Q = [],
                  K = [],
                  J = 0;
                for (let _ = 0; _ < F; _++) {
                  let R = 2 * _,
                    $ = ((_ - 1 + F) % F) * 2,
                    ee = X.vertices[2 * k.start + R + 0],
                    er = X.vertices[2 * k.start + R + 1],
                    en = -k.normals[$ + 0] * z,
                    ea = -k.normals[$ + 1] * z,
                    eo = -k.normals[R + 0] * z,
                    el = -k.normals[R + 1] * z;
                  if (k.concave[_] || (!k.concave[_] && L)) {
                    let R = Math.atan2(ea, en),
                      F = Math.atan2(el, eo);
                    F > R && (F -= 2 * Math.PI);
                    let Y = F - R;
                    if (k.continuous[_] || L) {
                      let N = R + Y / 2,
                        F = Math.cos(N) * z,
                        k = Math.sin(N) * z;
                      (U[2 * J + 0] = ee + F * (L ? -1 : 1)),
                        (U[2 * J + 1] = er + k * (L ? -1 : 1)),
                        (K[J] = _),
                        J++;
                    } else {
                      let L = Math.max(
                        1,
                        Math.floor(((N / 4) * Math.abs(Y)) / Math.PI),
                      );
                      for (let N = 0; N <= L; N++) {
                        let F = R + Y * (N / L),
                          k = Math.cos(F) * z,
                          X = Math.sin(F) * z;
                        (U[2 * J + 0] = ee + k),
                          (U[2 * J + 1] = er + X),
                          (K[J] = _),
                          J++;
                      }
                    }
                  } else
                    (U[2 * J + 0] = ee + en),
                      (U[2 * J + 1] = er + ea),
                      (K[J] = _),
                      (Y[_] = J),
                      (U[2 * ++J + 0] = ee),
                      (U[2 * J + 1] = er),
                      (K[J] = _),
                      (U[2 * ++J + 0] = ee + eo),
                      (U[2 * J + 1] = er + el),
                      (K[J] = _),
                      (Q[_] = J),
                      J++;
                }
                let $ = Ui({
                  windingRule: vp.POSITIVE,
                  elementType: vf.BOUNDARY_CONTOURS,
                  vertexSize: 2,
                  strict: !0,
                  contours: [U],
                  edgeCreateCallback: (_) => {
                    let L = _.Org.idx,
                      R = K[L],
                      N = K[(L + 1) % K.length];
                    (_.idx = [R, N]), (_.Sym.idx = [N, R]);
                  },
                  vertexIdCallback: (_) => {
                    let L = _.Lprev.idx;
                    return [L ? L[1] : 0, _.idx ? _.idx[0] : 0];
                  },
                });
                if (!$)
                  throw (
                    (console.log("Error"),
                    Error(`error generating bevel geometry for ${_}'th loop`))
                  );
                if (!$.vertexCount) break;
                for (let _ = 0; _ < $.vertexIndices.length; _++) {
                  let [L, R] = $.vertexIndices[_];
                  if (L === R) continue;
                  let N = R;
                  R < L && (N += F);
                  for (let z = L; z < N; z++) {
                    let N = z % F,
                      U = (z + 1) % F;
                    if (!k.continuous[N] || !k.continuous[U]) {
                      ($.vertexIndices[_] = [L, N]),
                        $.vertexIndices.splice(_ + 1, 0, [U, R]),
                        $.vertices.splice(
                          (_ + 1) * 2,
                          0,
                          $.vertices[2 * _],
                          $.vertices[2 * _ + 1],
                        );
                      break;
                    }
                  }
                }
                ea.push({
                  bevelI: _,
                  angle: R,
                  size: z,
                  boundary: $,
                  reverseMap: K,
                  insetPoints: U,
                });
              }
              let q = (_, L, R) => {
                  let N = 0,
                    z = _.boundary.vertexIndices.length;
                  for (; N < z && R(_.boundary.vertexIndices[L]); )
                    (L = (L + 1) % z), N++;
                  return N;
                },
                eo = er.length;
              for (let _ = 1; _ < ea.length; _++) {
                let L = ea[_ - 1],
                  R = ea[_],
                  N = L.boundary.vertexIndices.length,
                  z = R.boundary.vertexIndices.length;
                if (!N || !z) break;
                let U = k.concave.length,
                  Y = 0,
                  X = Qx(0, F);
                for (
                  ;
                  !L.boundary.vertexIndices.filter(X).length ||
                  !R.boundary.vertexIndices.filter(X).length;

                )
                  X = Qx(++Y, F);
                let Q = L.boundary.vertexIndices.findIndex(X),
                  K = R.boundary.vertexIndices.findIndex(X);
                do Q = (Q + 1) % N;
                while (X(L.boundary.vertexIndices[Q]));
                do K = (K + 1) % z;
                while (X(R.boundary.vertexIndices[K]));
                let J = (Y = (Y + 1) % F),
                  $ = this._buildBevelVert(k, L, (Q - 1 + N) % N),
                  ee = this._buildBevelVert(k, R, (K - 1 + z) % z),
                  en = $,
                  eo = ee,
                  el,
                  ec,
                  ed = !1;
                do {
                  let _ = q(L, Q, (X = Qx(Y, F))),
                    J = q(R, K, X),
                    $ = ed;
                  if (((ed = !1), _ && !J)) {
                    for (let R = 0; R < _; R++)
                      (el = this._buildBevelVert(
                        k,
                        L,
                        (Q + R) % N,
                        R / (_ - 1),
                      )),
                        er.push(en.topN, el.topP, eo.topN),
                        er.push(el.bottomP, en.bottomN, eo.bottomN),
                        (en = el);
                    ed = !0;
                  } else if (!_ && J)
                    for (let _ = 0; _ < J; _++)
                      (ec = this._buildBevelVert(
                        k,
                        R,
                        (K + _) % z,
                        _ / (J - 1),
                      )),
                        er.push(eo.topN, en.topP, ec.topP),
                        er.push(en.bottomP, eo.bottomN, ec.bottomP),
                        (eo = ec);
                  else if (_ && J) {
                    if (
                      ((el = this._buildBevelVert(k, L, Q, 0)),
                      (ec = this._buildBevelVert(k, R, K, 0)),
                      $
                        ? (er.push(en.topN, ec.topP, eo.topN),
                          er.push(en.topN, el.topP, ec.topP),
                          er.push(ec.bottomP, en.bottomN, eo.bottomN),
                          er.push(ec.bottomP, el.bottomP, en.bottomN))
                        : (er.push(eo.topN, en.topN, el.topP),
                          er.push(eo.topN, el.topP, ec.topP),
                          er.push(el.bottomP, en.bottomN, eo.bottomN),
                          er.push(el.bottomP, eo.bottomN, ec.bottomP)),
                      (en = el),
                      (eo = ec),
                      _ === J)
                    )
                      for (let F = 1; F < _; F++)
                        (el = this._buildBevelVert(
                          k,
                          L,
                          (Q + F) % N,
                          F / (_ - 1),
                        )),
                          (ec = this._buildBevelVert(
                            k,
                            R,
                            (K + F) % z,
                            F / (J - 1),
                          )),
                          er.push(en.topN, el.topP, eo.topN),
                          er.push(eo.topN, el.topP, ec.topP),
                          er.push(el.bottomP, en.bottomN, eo.bottomN),
                          er.push(el.bottomP, eo.bottomN, ec.bottomP),
                          (en = el),
                          (eo = ec);
                    else if (_ > J) {
                      let F = _ / J,
                        U = 0;
                      for (let Y = 1; Y < _; Y++)
                        (el = this._buildBevelVert(
                          k,
                          L,
                          (Q + Y) % N,
                          Y / (_ - 1),
                        )),
                          er.push(en.topN, el.topP, eo.topN),
                          er.push(el.bottomP, en.bottomN, eo.bottomN),
                          (en = el),
                          Y > (U + 1) * F &&
                            (U++,
                            (ec = this._buildBevelVert(
                              k,
                              R,
                              (K + U) % z,
                              U / (J - 1),
                            )),
                            er.push(eo.topN, el.topP, ec.topP),
                            er.push(el.bottomP, eo.bottomN, ec.bottomP),
                            (eo = ec));
                    } else {
                      let F = J / _,
                        U = 0;
                      for (let Y = 1; Y < J; Y++)
                        (ec = this._buildBevelVert(
                          k,
                          R,
                          (K + Y) % z,
                          Y / (J - 1),
                        )),
                          er.push(eo.topN, el.topP, ec.topP),
                          er.push(el.bottomP, eo.bottomN, ec.bottomP),
                          (eo = ec),
                          Y > (U + 1) * F &&
                            (U++,
                            (el = this._buildBevelVert(
                              k,
                              L,
                              (Q + U) % N,
                              U / (_ - 1),
                            )),
                            er.push(en.topN, el.topP, eo.topN),
                            er.push(el.bottomP, en.bottomN, eo.bottomN),
                            (en = el));
                    }
                  }
                  (Q = (Q + _) % N), (K = (K + J) % z), (Y = (Y + 1) % U);
                } while (Y !== J);
              }
              if ((this._buildWall(ea, k, er), L)) {
                let _ = [];
                for (let L = er.length - 1; L >= eo + 2; L -= 3) {
                  let R = er[L - 2],
                    N = er[L - 1],
                    z = er[L - 0];
                  _.push(z, N, R);
                }
                er.splice(eo, er.length - eo, ..._);
              }
              if (L) {
                let _ = [];
                for (
                  let L = ea[ea.length - 1].boundary.vertices.length - 1;
                  L >= 1;
                  L -= 2
                ) {
                  let R = ea[ea.length - 1].boundary.vertices[L - 1],
                    N = ea[ea.length - 1].boundary.vertices[L - 0];
                  _.push(R, N);
                }
                en.push(_);
              }
              if (!L) {
                let _ = ea[ea.length - 1],
                  L;
                try {
                  L = Ui({
                    windingRule: ea.length > 1 ? vp.POSITIVE : vp.ODD,
                    elementType: vf.POLYGONS,
                    vertexSize: 2,
                    strict: !0,
                    contours: [_.insetPoints, ...en],
                  });
                } catch {
                  L = gH;
                }
                if (!L) throw Error("Error generating geometry for surface");
                0 === Y.length &&
                  Object.assign(this, { capStartIndex: er.length });
                for (let _ = 0; _ < 3 * L.elementCount; _ += 3) {
                  let R = this._buildSurfaceVert(L, L.elements[_ + 0]),
                    N = this._buildSurfaceVert(L, L.elements[_ + 1]),
                    z = this._buildSurfaceVert(L, L.elements[_ + 2]);
                  er.push(R.top, N.top, z.top),
                    er.push(z.bottom, N.bottom, R.bottom);
                }
              }
              this.vertexCache = {};
            }
            this._buffer.shrink();
            let ea = new sh(Uint32Array.from(er), 1),
              eo = new sh(this._buffer.positions, 3),
              el = new sh(this._buffer.normals, 3),
              ec = new sh(this._buffer.uvs, 2);
            (eo.needsUpdate = !0),
              (el.needsUpdate = !0),
              (ec.needsUpdate = !0),
              (ea.needsUpdate = !0),
              this.setAttribute("position", eo),
              this.setAttribute("normal", el),
              this.setAttribute("uv", ec),
              this.setIndex(ea);
          }
          _computeBufferEstimatedSize(_) {
            return 2 * _.vertexCount * (2 + this._bevelSegments);
          }
          _buildWall(_, L, R) {
            let N = _[0];
            for (let _ = 0, z = N.boundary.vertexCount; _ < z; _++) {
              let F = this._buildBevelVert(L, N, _),
                U = this._buildBevelVert(L, N, (_ + 1) % z);
              R.push(U.topP, F.topN, F.bottomN),
                R.push(U.topP, F.bottomN, U.bottomP);
            }
          }
          _buildSurfaceVert(_, L) {
            let R = L.toString();
            if (R in this.vertexCache) return this.vertexCache[R];
            let N = _.vertices[2 * L + 0],
              z = _.vertices[2 * L + 1],
              F = (N - this._minX) / this._width,
              U = (z - this._minY) / this._height,
              k = this._buffer.get(2),
              Y = 3 * k,
              X = 2 * k,
              Q = { top: k + 0, bottom: k + 1 };
            return (
              (this._buffer.positions[Y + 0] = N),
              (this._buffer.positions[Y + 1] = z),
              (this._buffer.positions[Y + 2] = this._depth),
              (this._buffer.normals[Y + 0] = 0),
              (this._buffer.normals[Y + 1] = 0),
              (this._buffer.normals[Y + 2] = 1),
              (this._buffer.uvs[X + 0] = F),
              (this._buffer.uvs[X + 1] = U),
              (this._buffer.positions[Y + 3] = N),
              (this._buffer.positions[Y + 4] = z),
              (this._buffer.positions[Y + 5] = 0),
              (this._buffer.normals[Y + 3] = 0),
              (this._buffer.normals[Y + 4] = 0),
              (this._buffer.normals[Y + 5] = -1),
              (this._buffer.uvs[X + 2] = F),
              (this._buffer.uvs[X + 3] = U),
              (this.vertexCache[R] = Q),
              Q
            );
          }
          _buildBevelVert(_, L, R, N = 1) {
            let z = `${L.bevelI}:${R}`;
            if (z in this.vertexCache) return this.vertexCache[z];
            let [F, U] = L.boundary.vertexIndices[R],
              k,
              Y,
              X,
              Q;
            F !== U
              ? ((Y = F),
                (k = U),
                (Q = !1),
                (X = _.continuous[Y] && _.continuous[k]))
              : ((Y = ((k = F) - 1 + _.count) % _.count),
                (Q = _.concave[k] && L.bevelI > 0),
                (X = _.continuous[k] || Q));
            let K = Math.cos(L.angle),
              J = Math.sin(L.angle),
              $ = 2 * R,
              ee = 2 * k,
              er = 2 * Y,
              en = L.boundary.vertices[$ + 0],
              ea = L.boundary.vertices[$ + 1],
              eo = (1 - J) * this._bevelSize,
              el = (en - this._minX) / this._width,
              ec = (ea - this._minY) / this._height,
              ed = _.normals[ee + 0],
              eu = _.normals[ee + 1],
              ep = _.normals[er + 0],
              ef = _.normals[er + 1];
            if (Q) {
              let _ = ep - ed,
                L = ef - eu,
                R = Math.sqrt(
                  (ed += _ * (1 - N)) * ed + (eu += L * (1 - N)) * eu,
                );
              (ed /= R), (eu /= R);
            }
            let ev = this._buffer.get(X ? 2 : 4),
              ex = 3 * ev,
              eb = 2 * ev,
              ew = {
                i: R,
                fi: k,
                topP: ev + 0,
                topN: ev + 0,
                bottomP: ev + 1,
                bottomN: ev + 1,
              };
            return (
              (this._buffer.positions[ex + 0] = en),
              (this._buffer.positions[ex + 1] = ea),
              (this._buffer.positions[ex + 2] = this._depth - eo),
              (this._buffer.normals[ex + 0] = ed * K),
              (this._buffer.normals[ex + 1] = eu * K),
              (this._buffer.normals[ex + 2] = J),
              (this._buffer.uvs[eb + 0] = el),
              (this._buffer.uvs[eb + 1] = ec),
              (this._buffer.positions[ex + 3] = en),
              (this._buffer.positions[ex + 4] = ea),
              (this._buffer.positions[ex + 5] = eo),
              (this._buffer.normals[ex + 3] = ed * K),
              (this._buffer.normals[ex + 4] = eu * K),
              (this._buffer.normals[ex + 5] = -J),
              (this._buffer.uvs[eb + 2] = ec),
              (this._buffer.uvs[eb + 3] = el),
              X ||
                ((ev += 2),
                (ex += 6),
                (eb += 4),
                (ew.topP = ev + 0),
                (ew.bottomP = ev + 1),
                (this._buffer.positions[ex + 0] = en),
                (this._buffer.positions[ex + 1] = ea),
                (this._buffer.positions[ex + 2] = this._depth - eo),
                (this._buffer.normals[ex + 0] = ep * K),
                (this._buffer.normals[ex + 1] = ef * K),
                (this._buffer.normals[ex + 2] = J),
                (this._buffer.uvs[eb + 0] = el),
                (this._buffer.uvs[eb + 1] = ec),
                (this._buffer.positions[ex + 3] = en),
                (this._buffer.positions[ex + 4] = ea),
                (this._buffer.positions[ex + 5] = eo),
                (this._buffer.normals[ex + 3] = ep * K),
                (this._buffer.normals[ex + 4] = ef * K),
                (this._buffer.normals[ex + 5] = -J),
                (this._buffer.uvs[eb + 2] = ec),
                (this._buffer.uvs[eb + 3] = el)),
              (this.vertexCache[z] = ew),
              ew
            );
          }
          clone() {
            let _ = new gW(
              this._shape,
              this._depth,
              this._bevel,
              this._curveSegments,
              this._bevelSegmentsInput,
            );
            return (_.userData = Qs(this.userData)), _;
          }
        },
        gY = class extends sP {
          constructor(_, L = 12, R = {}) {
            super(),
              (this.type = "ShapeGeometry"),
              (this.windingRule = vp.ODD),
              (this.elementType = vf.POLYGONS),
              (this.polySize = 3),
              (this.vertexSize = 2),
              (this.strict = !0),
              (this._shape = _),
              (this._curveSegments = L),
              (this._triangulationOptions = Object.assign(
                {
                  windingRule: vp.ODD,
                  elementType: vf.POLYGONS,
                  polySize: 3,
                  vertexSize: 2,
                  strict: !0,
                },
                R,
              ));
            let N = this._shape.extractShapePointsToFlatArray(
                [],
                this._curveSegments,
              ),
              z = this._shape.shapeHoles.map((_) =>
                _.extractShapePointsToFlatArray([], this._curveSegments),
              ),
              F,
              U = !0,
              k = !0,
              Y,
              X;
            for (let _ = 0, L = N.length / 2; _ < L; _++) {
              let L = 2 * _,
                R = N[L + 0],
                z = N[L + 1];
              if (
                (void 0 !== Y && R !== Y && (U = !1),
                void 0 !== X && z !== X && (k = !1),
                (Y = R),
                (X = z),
                !U && !k)
              )
                break;
            }
            if (!U && !k)
              try {
                F = Ui({
                  contours: [N, ...z],
                  windingRule: this._triangulationOptions.windingRule,
                  elementType: this._triangulationOptions.elementType,
                  polySize: this._triangulationOptions.polySize,
                  vertexSize: this._triangulationOptions.vertexSize,
                  strict: this._triangulationOptions.strict,
                });
              } catch {
                F = gG;
              }
            let Q = F?.vertexCount ?? 1,
              K = F?.elementCount ?? 1;
            if (
              ((this._positionAttribute = new sh(new Float32Array(3 * Q), 3)),
              (this._normalAttribute = new sh(new Float32Array(3 * Q), 3)),
              (this._uvAttribute = new sh(new Float32Array(2 * Q), 2)),
              (this._indexAttribute = new sh(new Uint32Array(3 * K), 1)),
              F)
            ) {
              let _ = 1 / 0,
                L = -1 / 0,
                R = 1 / 0,
                N = -1 / 0;
              for (let z = 0; z < Q; z++) {
                let U = 2 * z,
                  k = F.vertices[U + 0],
                  Y = F.vertices[U + 1];
                k < _ && (_ = k),
                  k > L && (L = k),
                  Y < R && (R = Y),
                  Y > N && (N = Y);
              }
              let z = L - _,
                U = N - R;
              for (let L = 0; L < Q; L++) {
                let N = 2 * L,
                  k = F.vertices[N + 0],
                  Y = F.vertices[N + 1],
                  X = (k - _) / z,
                  Q = (Y - R) / U;
                this._positionAttribute.setXYZ(L, k, Y, 0),
                  this._normalAttribute.setXYZ(L, 0, 0, 1),
                  this._uvAttribute.setXY(L, X, Q);
              }
              for (let _ = 0; _ < K; _++) {
                let L = 3 * _,
                  R = F.elements[L + 0],
                  N = F.elements[L + 1],
                  z = F.elements[L + 2];
                this._indexAttribute.setX(L + 0, R),
                  this._indexAttribute.setX(L + 1, N),
                  this._indexAttribute.setX(L + 2, z);
              }
            }
            this.setAttribute("position", this._positionAttribute),
              this.setAttribute("normal", this._normalAttribute),
              this.setAttribute("uv", this._uvAttribute),
              this.setIndex(this._indexAttribute),
              this.setDrawRange(0, (F?.elementCount ?? 1) * 3);
          }
          clone() {
            let _ = new gY(this._shape, this._curveSegments);
            return (_.userData = Qs(this.userData)), _;
          }
        },
        gX = class extends gW {
          constructor(_, L, R = 0, N = 12, z = 3, F = vp.ODD) {
            super(_, L, R, N, z, F), (this.type = "ShapeGeometry");
          }
          _computeBufferEstimatedSize(_) {
            return 2 * _.vertexCount * (2 + this._bevelSegments);
          }
          _buildWall(_, L, R) {
            let N = _[0];
            for (let _ = 0, z = N.boundary.vertexCount; _ < z; _++) {
              let F = this._buildBevelVert(L, N, _),
                U = this._buildBevelVert(L, N, (_ + 1) % z);
              R.push(U.topP, F.topN, F.bottomN),
                R.push(U.topP, F.bottomN, U.bottomP);
            }
          }
          clone() {
            let _ = new gX(
              this._shape,
              this._depth,
              this._bevel,
              this._curveSegments,
              this._bevelSegmentsInput,
            );
            return (_.userData = Qs(this.userData)), _;
          }
        },
        gq = class {
          static create(_) {
            return this.build(this.normalizeInputs(_));
          }
          static normalizeInputs(_, L) {
            let R = Object.assign(
                {},
                L?.parameters ?? {
                  width: 100,
                  subdivisions: 40,
                  roundness: 0,
                  extrudeBevelSize: 0,
                  extrudeBevelSegments: 3,
                  windingRule: vp.ODD,
                },
                _.parameters,
              ),
              N = Math.abs(R.width),
              z = Math.abs(R.height ?? R.width),
              F = Math.abs(R.depth ?? 0),
              U = _.shape ?? L?.shape,
              k = U?.roundness ?? R.roundness;
            void 0 !== U &&
              (U instanceof gL
                ? (U.width !== N || U.height !== z) && U.applySize(N, z)
                : (U = new gL(N, z).fromJSON(U)),
              _.parameters?.roundness !== void 0 &&
                _.parameters?.roundness > 0 &&
                U.update());
            let Y = U ?? new gL(N, z);
            return {
              parameters: Object.assign(R, {
                width: N,
                height: z,
                depth: F,
                roundness: k,
              }),
              shape: Y,
            };
          }
          static build(_) {
            let {
              depth: L,
              extrudeBevelSize: R,
              extrudeBevelSegments: N,
              subdivisions: z,
              roundness: F,
              windingRule: U,
            } = _.parameters;
            return (
              (_.shape.roundness = F),
              Object.assign(
                L <= 0
                  ? new gY(_.shape, z, { windingRule: U })
                  : new gX(_.shape, L, R, z, N, U),
                { userData: { ..._, type: "VectorGeometry" } },
              )
            );
          }
        },
        gQ = 2 * Math.PI,
        gZ = class {
          static create(_) {
            return this.build(this.normalizeInputs(_));
          }
          static normalizeInputs(_, L) {
            let R = Object.assign(
              {},
              L?.parameters ?? {
                width: 100,
                depth: 0,
                spikes: 64,
                angle: 360,
                innerRadius: 0,
                extrudeBevelSize: 0,
                extrudeBevelSegments: 1,
              },
              _.parameters,
            );
            return {
              shape: _.shape && _.shape instanceof gL ? _.shape : new gL(),
              parameters: Object.assign(R, {
                width: Math.abs(R.width),
                height: Math.abs(R.height ?? R.width),
                depth: Math.abs(R.depth ?? 0),
              }),
            };
          }
          static build(_) {
            let {
                width: L,
                height: R,
                spikes: N,
                angle: z,
                innerRadius: F,
                depth: U,
                extrudeBevelSize: k,
                extrudeBevelSegments: Y,
              } = _.parameters,
              X = _.shape,
              Q = (function (_, L, R, N, z, F) {
                if (N >= gQ)
                  return z > 30 || z % 4 == 0
                    ? ((function (_, L, R, N = 0, z = 0, F = 0) {
                        let U = 0.5522847498 * L,
                          k = 0.5522847498 * R;
                        _.addPoint(ug(z - L, F, z - L, F - k, z - L, F + k)),
                          _.addPoint(ug(z, F + R, z - U, F + R, z + U, F + R)),
                          _.addPoint(ug(z + L, F, z + L, F + k, z + L, F - k)),
                          _.addPoint(ug(z, F - R, z + U, F - R, z - U, F - R)),
                          N > 0 && BM(_, L, R, N);
                      })(_, L, R, F),
                      Math.round(z / 4))
                    : LM(_, N, z, L, R, F);
                let U = { x: 0, y: R },
                  k = (N = Math.max(N, 0.001)) + 0.5 * Math.PI,
                  Y = { x: Math.cos(k) * L, y: Math.sin(k) * R },
                  X = (function ({
                    px: _,
                    py: L,
                    cx: R,
                    cy: N,
                    rx: z,
                    ry: F,
                    largeArcFlag: U,
                    sweepFlag: k,
                  }) {
                    var Y, X;
                    let Q,
                      K,
                      J,
                      $,
                      ee,
                      er,
                      en,
                      ea,
                      eo,
                      el,
                      ec,
                      ed = [];
                    if (0 === z || 0 === F) return [];
                    let eu = (_ - R) / 2,
                      ep = (L - N) / 2;
                    if (0 === eu && 0 === ep) return [];
                    let ef =
                      Math.pow(eu, 2) / Math.pow((z = Math.abs(z)), 2) +
                      Math.pow(ep, 2) / Math.pow((F = Math.abs(F)), 2);
                    ef > 1 && ((z *= Math.sqrt(ef)), (F *= Math.sqrt(ef)));
                    let ev =
                        ((Y = z),
                        (X = F),
                        (Q = Math.pow(Y, 2)),
                        (K = Math.pow(X, 2)),
                        (J = Math.pow(eu, 2)),
                        (ee = Q * K - Q * ($ = Math.pow(ep, 2)) - K * J) < 0 &&
                          (ee = 0),
                        (ee /= Q * $ + K * J),
                        (er =
                          (((ee = Math.sqrt(ee) * (U === k ? -1 : 1)) * Y) /
                            X) *
                          ep),
                        (en = (-(ee * X) / Y) * eu),
                        (el = MM(
                          1,
                          0,
                          (ea = (eu - er) / Y),
                          (eo = (ep - en) / X),
                        )),
                        (ec = MM(ea, eo, (-eu - er) / Y, (-ep - en) / X)),
                        !k && ec > 0 && (ec -= gR),
                        k && ec < 0 && (ec += gR),
                        {
                          centerx: er + (_ + R) / 2,
                          centery: en + (L + N) / 2,
                          ang1: el,
                          ang2: ec,
                        }),
                      { ang1: ex, ang2: eb } = ev,
                      { centerx: ew, centery: e_ } = ev,
                      eA = Math.abs(eb) / (gR / 4);
                    1e-7 > Math.abs(1 - eA) && (eA = 1);
                    let eM = Math.max(Math.ceil(eA), 1);
                    eb /= eM;
                    for (let _ = 0; _ < eM; _++)
                      ed.push(
                        (function (_, L) {
                          let R =
                              1.5707963267948966 === L
                                ? 0.551915024494
                                : -1.5707963267948966 === L
                                  ? -0.551915024494
                                  : 1.3333333333333333 * Math.tan(L / 4),
                            N = Math.cos(_),
                            z = Math.sin(_),
                            F = Math.cos(_ + L),
                            U = Math.sin(_ + L);
                          return [
                            { x: N - z * R, y: z + N * R },
                            { x: F + U * R, y: U - F * R },
                            { x: F, y: U },
                          ];
                        })(ex, eb),
                      ),
                        (ex += eb);
                    return ed.map((_) => {
                      let { x: L, y: R } = Yx(_[0], z, F, ew, e_),
                        { x: N, y: U } = Yx(_[1], z, F, ew, e_),
                        { x: k, y: Y } = Yx(_[2], z, F, ew, e_);
                      return { x1: L, y1: R, x2: N, y2: U, x: k, y: Y };
                    });
                  })({
                    px: U.x,
                    py: U.y,
                    cx: Y.x,
                    cy: Y.y,
                    rx: L,
                    ry: R,
                    largeArcFlag: N > Math.PI,
                    sweepFlag: !0,
                  });
                return z > 30 || z % X.length == 0
                  ? (function (_, L, R, N, z, F, U, k) {
                      let Y = Math.round(z / N.length);
                      _.addPoint(gu(L, R));
                      for (let L = 0, R = N.length; L < R; L++) {
                        let R = N[L],
                          z = _.points[L],
                          F = gu(R.x, R.y);
                        z.controls[1].position.set(R.x1, R.y1),
                          F.controls[0].position.set(R.x2, R.y2),
                          _.addPoint(F);
                      }
                      return k > 0 ? NM(_, F, U, k) : _.addPoint(gu(0, 0)), Y;
                    })(_, U.x, U.y, X, z, L, R, F)
                  : LM(_, N, z, L, R, F);
              })(X, 0.5 * L, 0.5 * R, (z * Math.PI) / 180, N, F);
            return (
              (X.isClosed = !0),
              X.update(),
              Object.assign(
                gq.create({
                  shape: X,
                  parameters: {
                    subdivisions: Q,
                    depth: U,
                    extrudeBevelSize: k,
                    extrudeBevelSegments: Y,
                  },
                }),
                { userData: { ..._, type: "EllipseGeometry" } },
              )
            );
          }
        };
      function LM(_, L, R, N, z, F) {
        let U = -L / R;
        for (let L = 0; L <= R; L++) {
          let R = U * L,
            F = Math.sin(R) * N,
            k = Math.cos(R) * z;
          _.addPoint(gu(F, k));
        }
        return (
          L < gQ
            ? F > 0
              ? NM(_, N, z, F)
              : _.addPoint(gu(0, 0))
            : (_.removePoint(_.points[_.points.length - 1]),
              F > 0 && BM(_, N, z, F)),
          1
        );
      }
      function gu(_, L) {
        return new gp(iE.generateUUID(), new iT(_, L));
      }
      function ug(_, L, R, N, z, F) {
        let U = gu(_, L);
        return (
          U.controls[0].position.set(R, N), U.controls[1].position.set(z, F), U
        );
      }
      function NM(_, L, R, N) {
        FM(_, L, R, N).forEach((L) => _.addPoint(L));
      }
      function BM(_, L, R, N) {
        let z = FM(_, L, R, N),
          F = new gL();
        z.forEach((_) => F.addPoint(_)),
          (F.isClosed = !0),
          _.shapeHoles.push(F);
      }
      function FM(_, L, R, N) {
        let z = (N * L) / 100,
          F = z * (Math.abs(R) / Math.abs(L)),
          U = new iT(z / L, F / R),
          k = _.points
            .map((_) => {
              let L = _.clone();
              return (L.uuid = iE.generateUUID()), L;
            })
            .reverse();
        return (
          k.forEach((_) => {
            _.position.multiply(U);
            let L = _.controls[0].position.clone().multiply(U),
              R = _.controls[1].position.clone().multiply(U);
            _.controls[0].position.copy(R), _.controls[1].position.copy(L);
          }),
          k
        );
      }
      var gK = class {
          static create(_) {
            return this.build(this.normalizeInputs(_));
          }
          static normalizeInputs(_, L) {
            let R = Object.assign(
                {},
                L?.parameters ?? {
                  width: 100,
                  revolutions: 2,
                  segments: 40,
                  pathRadius: 10,
                  pathType: 0,
                  pathSegments: 30,
                  cornerRadius: 30,
                  cornerSegments: 4,
                },
                _.parameters,
              ),
              N = Math.abs(R.width),
              z = Math.abs(R.height ?? N),
              F = Math.abs(R.depth ?? N),
              U = Math.abs(Math.min(N, F)) / 2;
            return {
              parameters: Object.assign(R, {
                width: N,
                height: z,
                depth: F,
                radius: U,
                segments: Math.round(R.segments),
                pathSegments: Math.round(R.pathSegments),
                cornerSegments: Math.round(R.cornerSegments),
              }),
            };
          }
          static build(_) {
            let {
              width: L,
              height: R,
              depth: N,
              radius: z,
              revolutions: F,
              segments: U,
              pathRadius: k,
              pathType: Y,
              pathSegments: X,
              cornerRadius: Q,
              cornerSegments: K,
            } = _.parameters;
            return Object.assign(new gJ(!1, L, R, N, z, F, U, k, Y, X, Q, K), {
              userData: { ..._, type: "HelixGeometry" },
            });
          }
        },
        gJ = class extends sP {
          constructor(
            _ = !0,
            L = 1,
            R = 1,
            N = 1,
            z = 1,
            F = 1,
            U = 1,
            k = 1,
            Y = 1,
            X = 1,
            Q = 1,
            K = 1,
            J = !1,
          ) {
            super();
            let $ = _ && 1 === F;
            $ && (K = 0), Q > 100 && (Q = 100);
            let p = () => new iq(),
              ee = new iq(),
              er = p(),
              en = p(),
              ea = p(),
              eo,
              el,
              ec,
              ed,
              eu,
              ep,
              ef,
              ev,
              ex = p(),
              eb = p(),
              ew = p(),
              e_ = p(),
              eA = p(),
              eM = p(),
              eE = p(),
              eC = p(),
              eP = R - 2 * k + 0.001,
              eD = eP / F,
              eO = Math.ceil(U * F),
              eL = eO + 1,
              eR = eP / eO,
              eI = -eP / 2,
              eB = X + 1,
              ez = (2 * Math.PI) / X,
              eF = Math.PI / 2 / K,
              eU = Math.min((1 - Q / 100) * k, k - 0.01),
              ek = k - eU,
              ej = 0,
              eG = 2 * K + 2,
              eV = (eB * eG) / 2,
              eH = eV + eB * eL,
              eW = eB * (eL + eG),
              [eY, eX, eq] = [3, 3, 2].map((_) => Array(eW * _).fill(0)),
              eQ = [],
              eZ = z - k;
            function O(L, R) {
              let N = Math.PI / 2;
              (ev = (2 * Math.PI * ((ep = R * eR) % eD)) / eD + N),
                (ep += eI),
                (ef = Math.sin(ev) * eZ),
                (eu = Math.cos(ev) * eZ),
                _ ? L.set(eu, ef, ep) : L.set(eu, ep, ef);
            }
            O(ee, -0.0000000001), O(er, 0), ex.copy(ee), O(ee, 1);
            let eK = ee.distanceTo(er),
              eJ = $ ? 0 : ek + eU,
              e$ = eK * eO + 2 * eJ,
              e0 = e$ - eJ;
            for (let L = 0; L <= eO; L++) {
              O(en, L),
                eC.subVectors(en, ex).normalize(),
                ex.copy(en),
                eM
                  .copy(en)
                  .setComponent(+_ + 1, 0)
                  .normalize(),
                eE.crossVectors(eC, eM).normalize();
              let R = 0 === L,
                N = L === eO,
                z = R ? (3 * Math.PI) / 2 : eF,
                F = R ? eU : e0,
                U = R ? eB : eH,
                Y = R ? 0 : eW - eB,
                Q = eC
                  .clone()
                  .multiplyScalar(R ? -ek : ek)
                  .add(en),
                J = eC
                  .clone()
                  .multiplyScalar(R ? -1 : 1)
                  .normalize();
              for (let _ = 0; _ < eB; _++) {
                let eo = _ * ez;
                if (
                  (eb.addVectors(
                    ee.copy(eM).multiplyScalar(k * Math.cos(eo)),
                    er.copy(eE).multiplyScalar(k * Math.sin(eo)),
                  ),
                  ew.copy(eb).normalize(),
                  R || N)
                ) {
                  $ ||
                    ((ej = Y + _),
                    [0, 1, 2].forEach((_) => {
                      (eY[3 * ej + _] = Q.getComponent(_)),
                        (eX[3 * ej + _] = J.getComponent(_));
                    }),
                    (eq[2 * ej] = +N),
                    (eq[2 * ej + 1] = _ / X)),
                    er.copy(ew).multiplyScalar(eU),
                    ea.addVectors(en, er);
                  for (let L = 0; L < K; L++) {
                    let N = L * eF + z;
                    e_.addVectors(
                      ee.copy(eC).multiplyScalar(ek * Math.sin(N)),
                      er.copy(ew).multiplyScalar(ek * Math.cos(N)),
                    ),
                      eA.copy(e_).normalize(),
                      er.addVectors(ea, e_),
                      e_.normalize(),
                      (ej = U + L * eB + _),
                      [0, 1, 2].forEach((_) => {
                        (eY[3 * ej + _] = er.getComponent(_)),
                          (eX[3 * ej + _] = eA.getComponent(_));
                      });
                    let k = +R + Math.sin(N);
                    (eq[2 * ej] = (F + ek * k) / e$), (eq[2 * ej + 1] = _ / X);
                  }
                }
                er.addVectors(en, eb),
                  (ej = eV + L * eB + _),
                  [0, 1, 2].forEach((_) => {
                    (eY[3 * ej + _] = er.getComponent(_)),
                      (eX[3 * ej + _] = ew.getComponent(_));
                  }),
                  (eq[2 * ej] = (eJ + L * eK) / e$),
                  (eq[2 * ej + 1] = _ / X);
              }
            }
            let e2 = eL + 2 * K + 2,
              [e4, e6] = [+$, e2 - 1];
            J && (e6 -= 1);
            for (let _ = e4; _ <= e6 - 1; _++) {
              let L = $ && _ === e6 - 1;
              for (let R = 0; R < eB - 1; R++)
                (el = (eo = _ * eB + R) + 1),
                  (ec = (L ? R : eo) + eB),
                  (ed = (L ? R + 1 : el) + eB),
                  0 === _
                    ? eQ.push(el, ed, ec)
                    : _ === e2 - 2
                      ? eQ.push(eo, el, ec)
                      : eQ.push(eo, el, ec, el, ed, ec);
            }
            this.setIndex(eQ),
              this.setAttribute("position", new sv(eY, 3)),
              this.setAttribute("normal", new sv(eX, 3)),
              this.setAttribute("uv", new sv(eq, 2));
          }
        },
        g$ = class {
          static create(_) {
            return this.build(this.normalizeInputs(_));
          }
          static normalizeInputs(_, L) {
            let R = Object.assign(
              {},
              L?.parameters ?? {
                width: 100,
                detail: 0,
                corner: 0,
                cornerSides: 4,
              },
              _.parameters,
            );
            return {
              parameters: Object.assign(R, {
                width: Math.abs(R.width),
                height: Math.abs(R.height ?? R.width),
                depth: Math.abs(R.depth ?? R.width),
              }),
            };
          }
          static build(_) {
            let {
                width: L,
                height: R,
                depth: N,
                detail: z,
                corner: F,
                cornerSides: U,
              } = _.parameters,
              k =
                0 === z && 0 !== F ? new g4(0.5 * L, F, U) : new aW(0.5 * L, z);
            return (
              k.scale(1, R / L, N / L),
              Object.assign(k, {
                userData: { ..._, type: "IcosahedronGeometry" },
              })
            );
          }
        },
        g4 = class extends go {
          constructor(_ = 1, L = 0.2, R = 4) {
            let N = (1 + Math.sqrt(5)) / 2,
              z = "IcosahedronGeometry";
            super(
              [
                -1,
                N,
                0,
                1,
                N,
                0,
                -1,
                -N,
                0,
                1,
                -N,
                0,
                0,
                -1,
                N,
                0,
                1,
                N,
                0,
                -1,
                -N,
                0,
                1,
                -N,
                N,
                0,
                -1,
                N,
                0,
                1,
                -N,
                0,
                -1,
                -N,
                0,
                1,
              ],
              [
                0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11,
                4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3,
                6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1,
              ],
              z,
              _,
              L,
              R,
            ),
              (this.type = z);
          }
          static fromJSON(_) {
            return new g4(_.radius, _.corner, _.cornerSides);
          }
        },
        g5 = class {
          static create(_) {
            return this.build(this.normalizeInputs(_));
          }
          static normalizeInputs(_, L) {
            (_.parameters?.points ?? []).forEach((_) => {
              Array.isArray(_) && ((_.x = _[0]), (_.y = _[1]));
            });
            let R = Object.assign(
              {},
              L?.parameters ?? {
                width: 100,
                segments: 64,
                verticalSegments: 64,
                points: [
                  { x: 0, y: -50, id: 0 },
                  { x: 50, y: -50, id: 1 },
                  { x: 50, y: 50, id: 2 },
                  { x: 0, y: 50, id: 3 },
                ],
              },
              _.parameters,
            );
            return {
              parameters: Object.assign(R, {
                width: Math.abs(R.width),
                height: Math.abs(R.height ?? R.width),
                depth: Math.abs(R.depth ?? R.width),
              }),
            };
          }
          static build(_) {
            let { points: L, segments: R, verticalSegments: N } = _.parameters,
              z = new aG();
            z.moveTo(L[0].x, L[0].y),
              z.bezierCurveTo(L[1].x, L[1].y, L[2].x, L[2].y, L[3].x, L[3].y);
            let F = new az(z.extractPoints(N).shape, R);
            return (
              F.rotateZ(Math.PI),
              Object.assign(F, { userData: { ..._, type: "LatheGeometry" } })
            );
          }
        },
        g6 = new rw(),
        g8 = new rK(),
        g9 = new iq(),
        g7 = class extends ig {
          constructor() {
            super(),
              (this.uuid = iE.generateUUID()),
              (this.name = ""),
              (this.type = "Geometry"),
              (this.vertices = []),
              (this.colors = []),
              (this.faces = []),
              (this.faceVertexUvs = [[]]),
              (this.morphTargets = []),
              (this.morphNormals = []),
              (this.skinWeights = []),
              (this.skinIndices = []),
              (this.lineDistances = []),
              (this.boundingBox = null),
              (this.boundingSphere = null),
              (this.elementsNeedUpdate = !1),
              (this.verticesNeedUpdate = !1),
              (this.uvsNeedUpdate = !1),
              (this.normalsNeedUpdate = !1),
              (this.colorsNeedUpdate = !1),
              (this.lineDistancesNeedUpdate = !1),
              (this.groupsNeedUpdate = !1);
          }
          applyMatrix4(_) {
            let L = new iC().getNormalMatrix(_);
            for (let L = 0, R = this.vertices.length; L < R; L++)
              this.vertices[L].applyMatrix4(_);
            for (let _ = 0, R = this.faces.length; _ < R; _++) {
              let R = this.faces[_];
              R.normal.applyMatrix3(L).normalize();
              for (let _ = 0, N = R.vertexNormals.length; _ < N; _++)
                R.vertexNormals[_].applyMatrix3(L).normalize();
            }
            return (
              null !== this.boundingBox && this.computeBoundingBox(),
              null !== this.boundingSphere && this.computeBoundingSphere(),
              (this.verticesNeedUpdate = !0),
              (this.normalsNeedUpdate = !0),
              this
            );
          }
          rotateX(_) {
            return g6.makeRotationX(_), this.applyMatrix4(g6), this;
          }
          rotateY(_) {
            return g6.makeRotationY(_), this.applyMatrix4(g6), this;
          }
          rotateZ(_) {
            return g6.makeRotationZ(_), this.applyMatrix4(g6), this;
          }
          translate(_, L, R) {
            return g6.makeTranslation(_, L, R), this.applyMatrix4(g6), this;
          }
          scale(_, L, R) {
            return g6.makeScale(_, L, R), this.applyMatrix4(g6), this;
          }
          lookAt(_) {
            return (
              g8.lookAt(_),
              g8.updateMatrix(),
              this.applyMatrix4(g8.matrix),
              this
            );
          }
          fromBufferGeometry(_) {
            let L = this,
              R = null !== _.index ? _.index : void 0,
              N = _.attributes;
            if (void 0 === N.position)
              return (
                console.error(
                  "THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.",
                ),
                this
              );
            let z = N.position,
              F = N.normal,
              U = N.color,
              k = N.uv,
              Y = N.uv2;
            void 0 !== Y && (this.faceVertexUvs[1] = []);
            for (let _ = 0; _ < z.count; _++)
              L.vertices.push(new iq().fromBufferAttribute(z, _)),
                void 0 !== U &&
                  L.colors.push(new iz().fromBufferAttribute(U, _));
            function c(_, R, N, z) {
              let X =
                  void 0 === U
                    ? []
                    : [
                        L.colors[_].clone(),
                        L.colors[R].clone(),
                        L.colors[N].clone(),
                      ],
                Q =
                  void 0 === F
                    ? []
                    : [
                        new iq().fromBufferAttribute(F, _),
                        new iq().fromBufferAttribute(F, R),
                        new iq().fromBufferAttribute(F, N),
                      ],
                K = new vt(_, R, N, Q, X, z);
              L.faces.push(K),
                void 0 !== k &&
                  L.faceVertexUvs[0].push([
                    new iT().fromBufferAttribute(k, _),
                    new iT().fromBufferAttribute(k, R),
                    new iT().fromBufferAttribute(k, N),
                  ]),
                void 0 !== Y &&
                  L.faceVertexUvs[1].push([
                    new iT().fromBufferAttribute(Y, _),
                    new iT().fromBufferAttribute(Y, R),
                    new iT().fromBufferAttribute(Y, N),
                  ]);
            }
            let X = _.groups;
            if (X.length > 0)
              for (let _ = 0; _ < X.length; _++) {
                let L = X[_],
                  N = L.start,
                  z = L.count;
                for (let _ = N, F = N + z; _ < F; _ += 3)
                  void 0 !== R
                    ? c(
                        R.getX(_),
                        R.getX(_ + 1),
                        R.getX(_ + 2),
                        L.materialIndex,
                      )
                    : c(_, _ + 1, _ + 2, L.materialIndex);
              }
            else if (void 0 !== R)
              for (let _ = 0; _ < R.count; _ += 3)
                c(R.getX(_), R.getX(_ + 1), R.getX(_ + 2));
            else for (let _ = 0; _ < z.count; _ += 3) c(_, _ + 1, _ + 2);
            return (
              this.computeFaceNormals(),
              null !== _.boundingBox &&
                (this.boundingBox = _.boundingBox.clone()),
              null !== _.boundingSphere &&
                (this.boundingSphere = _.boundingSphere.clone()),
              this
            );
          }
          center() {
            return (
              this.computeBoundingBox(),
              this.boundingBox.getCenter(g9).negate(),
              this.translate(g9.x, g9.y, g9.z),
              this
            );
          }
          normalize() {
            this.computeBoundingSphere();
            let _ = this.boundingSphere.center,
              L = this.boundingSphere.radius,
              R = 0 === L ? 1 : 1 / L,
              N = new rw();
            return (
              N.set(
                R,
                0,
                0,
                -R * _.x,
                0,
                R,
                0,
                -R * _.y,
                0,
                0,
                R,
                -R * _.z,
                0,
                0,
                0,
                1,
              ),
              this.applyMatrix4(N),
              this
            );
          }
          computeFaceNormals() {
            let _ = new iq(),
              L = new iq();
            for (let R = 0, N = this.faces.length; R < N; R++) {
              let N = this.faces[R],
                z = this.vertices[N.a],
                F = this.vertices[N.b],
                U = this.vertices[N.c];
              _.subVectors(U, F),
                L.subVectors(z, F),
                _.cross(L),
                _.normalize(),
                N.normal.copy(_);
            }
          }
          computeVertexNormals(_ = !0) {
            let L = Array(this.vertices.length);
            for (let _ = 0, R = this.vertices.length; _ < R; _++)
              L[_] = new iq();
            if (_) {
              let _ = new iq(),
                R = new iq();
              for (let N = 0, z = this.faces.length; N < z; N++) {
                let z = this.faces[N],
                  F = this.vertices[z.a],
                  U = this.vertices[z.b],
                  k = this.vertices[z.c];
                _.subVectors(k, U),
                  R.subVectors(F, U),
                  _.cross(R),
                  L[z.a].add(_),
                  L[z.b].add(_),
                  L[z.c].add(_);
              }
            } else {
              this.computeFaceNormals();
              for (let _ = 0, R = this.faces.length; _ < R; _++) {
                let R = this.faces[_];
                L[R.a].add(R.normal),
                  L[R.b].add(R.normal),
                  L[R.c].add(R.normal);
              }
            }
            for (let _ = 0, R = this.vertices.length; _ < R; _++)
              L[_].normalize();
            for (let _ = 0, R = this.faces.length; _ < R; _++) {
              let R = this.faces[_],
                N = R.vertexNormals;
              3 === N.length
                ? (N[0].copy(L[R.a]), N[1].copy(L[R.b]), N[2].copy(L[R.c]))
                : ((N[0] = L[R.a].clone()),
                  (N[1] = L[R.b].clone()),
                  (N[2] = L[R.c].clone()));
            }
            this.faces.length > 0 && (this.normalsNeedUpdate = !0);
          }
          computeFlatVertexNormals() {
            this.computeFaceNormals();
            for (let _ = 0, L = this.faces.length; _ < L; _++) {
              let L = this.faces[_],
                R = L.vertexNormals;
              3 === R.length
                ? (R[0].copy(L.normal),
                  R[1].copy(L.normal),
                  R[2].copy(L.normal))
                : ((R[0] = L.normal.clone()),
                  (R[1] = L.normal.clone()),
                  (R[2] = L.normal.clone()));
            }
            this.faces.length > 0 && (this.normalsNeedUpdate = !0);
          }
          computeMorphNormals() {
            for (let _ = 0, L = this.faces.length; _ < L; _++) {
              let L = this.faces[_];
              L.__originalFaceNormal
                ? L.__originalFaceNormal.copy(L.normal)
                : (L.__originalFaceNormal = L.normal.clone()),
                L.__originalVertexNormals || (L.__originalVertexNormals = []);
              for (let _ = 0, R = L.vertexNormals.length; _ < R; _++)
                L.__originalVertexNormals[_]
                  ? L.__originalVertexNormals[_].copy(L.vertexNormals[_])
                  : (L.__originalVertexNormals[_] = L.vertexNormals[_].clone());
            }
            let _ = new g7();
            _.faces = this.faces;
            for (let L = 0, R = this.morphTargets.length; L < R; L++) {
              if (!this.morphNormals[L]) {
                (this.morphNormals[L] = {}),
                  (this.morphNormals[L].faceNormals = []),
                  (this.morphNormals[L].vertexNormals = []);
                let _ = this.morphNormals[L].faceNormals,
                  R = this.morphNormals[L].vertexNormals;
                for (let L = 0, N = this.faces.length; L < N; L++) {
                  let L = new iq(),
                    N = { a: new iq(), b: new iq(), c: new iq() };
                  _.push(L), R.push(N);
                }
              }
              let R = this.morphNormals[L];
              (_.vertices = this.morphTargets[L].vertices),
                _.computeFaceNormals(),
                _.computeVertexNormals();
              for (let _ = 0, L = this.faces.length; _ < L; _++) {
                let L = this.faces[_],
                  N = R.faceNormals[_],
                  z = R.vertexNormals[_];
                N.copy(L.normal),
                  z.a.copy(L.vertexNormals[0]),
                  z.b.copy(L.vertexNormals[1]),
                  z.c.copy(L.vertexNormals[2]);
              }
            }
            for (let _ = 0, L = this.faces.length; _ < L; _++) {
              let L = this.faces[_];
              (L.normal = L.__originalFaceNormal),
                (L.vertexNormals = L.__originalVertexNormals);
            }
          }
          computeBoundingBox() {
            null === this.boundingBox && (this.boundingBox = new iK()),
              this.boundingBox.setFromPoints(this.vertices);
          }
          computeBoundingSphere() {
            null === this.boundingSphere && (this.boundingSphere = new ro()),
              this.boundingSphere.setFromPoints(this.vertices);
          }
          merge(_, L, R = 0) {
            if (!(_ && _.isGeometry)) {
              console.error(
                "THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.",
                _,
              );
              return;
            }
            let N,
              z = this.vertices.length,
              F = this.vertices,
              U = _.vertices,
              k = this.faces,
              Y = _.faces,
              X = this.colors,
              Q = _.colors;
            void 0 !== L && (N = new iC().getNormalMatrix(L));
            for (let _ = 0, R = U.length; _ < R; _++) {
              let R = U[_].clone();
              void 0 !== L && R.applyMatrix4(L), F.push(R);
            }
            for (let _ = 0, L = Q.length; _ < L; _++) X.push(Q[_].clone());
            for (let _ = 0, L = Y.length; _ < L; _++) {
              let L = Y[_],
                F,
                U,
                X = L.vertexNormals,
                Q = L.vertexColors,
                K = new vt(L.a + z, L.b + z, L.c + z);
              K.normal.copy(L.normal),
                void 0 !== N && K.normal.applyMatrix3(N).normalize();
              for (let _ = 0, L = X.length; _ < L; _++)
                (F = X[_].clone()),
                  void 0 !== N && F.applyMatrix3(N).normalize(),
                  K.vertexNormals.push(F);
              K.color.copy(L.color);
              for (let _ = 0, L = Q.length; _ < L; _++)
                (U = Q[_]), K.vertexColors.push(U.clone());
              (K.materialIndex = L.materialIndex + R), k.push(K);
            }
            for (let L = 0, R = _.faceVertexUvs.length; L < R; L++) {
              let R = _.faceVertexUvs[L];
              void 0 === this.faceVertexUvs[L] && (this.faceVertexUvs[L] = []);
              for (let _ = 0, N = R.length; _ < N; _++) {
                let N = R[_],
                  z = [];
                for (let _ = 0, L = N.length; _ < L; _++) z.push(N[_].clone());
                this.faceVertexUvs[L].push(z);
              }
            }
          }
          mergeMesh(_) {
            if (!(_ && _.isMesh)) {
              console.error(
                "THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.",
                _,
              );
              return;
            }
            _.matrixAutoUpdate && _.updateMatrix(),
              this.merge(_.geometry, _.matrix);
          }
          mergeVertices(_ = 4) {
            let L = {},
              R = [],
              N = [],
              z = Math.pow(10, _);
            for (let _ = 0, F = this.vertices.length; _ < F; _++) {
              let F = this.vertices[_],
                U =
                  Math.round(F.x * z) +
                  "_" +
                  Math.round(F.y * z) +
                  "_" +
                  Math.round(F.z * z);
              void 0 === L[U]
                ? ((L[U] = _), R.push(this.vertices[_]), (N[_] = R.length - 1))
                : (N[_] = N[L[U]]);
            }
            let F = [];
            for (let _ = 0, L = this.faces.length; _ < L; _++) {
              let L = this.faces[_];
              (L.a = N[L.a]), (L.b = N[L.b]), (L.c = N[L.c]);
              let R = [L.a, L.b, L.c];
              for (let L = 0; L < 3; L++)
                if (R[L] === R[(L + 1) % 3]) {
                  F.push(_);
                  break;
                }
            }
            for (let _ = F.length - 1; _ >= 0; _--) {
              let L = F[_];
              this.faces.splice(L, 1);
              for (let _ = 0, R = this.faceVertexUvs.length; _ < R; _++)
                this.faceVertexUvs[_].splice(L, 1);
            }
            let U = this.vertices.length - R.length;
            return (this.vertices = R), U;
          }
          setFromPoints(_) {
            this.vertices = [];
            for (let L = 0, R = _.length; L < R; L++) {
              let R = _[L];
              this.vertices.push(new iq(R.x, R.y, R.z || 0));
            }
            return this;
          }
          sortFacesByMaterialIndex() {
            let _ = this.faces,
              L = _.length;
            for (let R = 0; R < L; R++) _[R]._id = R;
            _.sort(function (_, L) {
              return _.materialIndex - L.materialIndex;
            });
            let R = this.faceVertexUvs[0],
              N = this.faceVertexUvs[1],
              z,
              F;
            R && R.length === L && (z = []), N && N.length === L && (F = []);
            for (let U = 0; U < L; U++) {
              let L = _[U]._id;
              z && z.push(R[L]), F && F.push(N[L]);
            }
            z && (this.faceVertexUvs[0] = z), F && (this.faceVertexUvs[1] = F);
          }
          toJSON() {
            let _ = {
              metadata: {
                version: 4.5,
                type: "Geometry",
                generator: "Geometry.toJSON",
              },
            };
            if (
              ((_.uuid = this.uuid),
              (_.type = this.type),
              "" !== this.name && (_.name = this.name),
              void 0 !== this.parameters)
            ) {
              let L = this.parameters;
              for (let R in L) void 0 !== L[R] && (_[R] = L[R]);
              return _;
            }
            let L = [];
            for (let _ = 0; _ < this.vertices.length; _++) {
              let R = this.vertices[_];
              L.push(R.x, R.y, R.z);
            }
            let R = [],
              N = [],
              z = {},
              F = [],
              U = {},
              k = [],
              Y = {};
            for (let _ = 0; _ < this.faces.length; _++) {
              let L = this.faces[_],
                N = void 0 !== this.faceVertexUvs[0][_],
                z = L.normal.length() > 0,
                F = L.vertexNormals.length > 0,
                U = 1 !== L.color.r || 1 !== L.color.g || 1 !== L.color.b,
                k = L.vertexColors.length > 0,
                Y = 0;
              if (
                ((Y = c(0, 0, 0)),
                (Y = c(Y, 1, !0)),
                (Y = c(Y, 2, !1)),
                (Y = c(Y, 3, N)),
                (Y = c(Y, 4, z)),
                (Y = c(Y, 5, F)),
                (Y = c(Y, 6, U)),
                (Y = c(Y, 7, k)),
                R.push(Y),
                R.push(L.a, L.b, L.c),
                R.push(L.materialIndex),
                N)
              ) {
                let L = this.faceVertexUvs[0][_];
                R.push(f(L[0]), f(L[1]), f(L[2]));
              }
              if ((z && R.push(d(L.normal)), F)) {
                let _ = L.vertexNormals;
                R.push(d(_[0]), d(_[1]), d(_[2]));
              }
              if ((U && R.push(h(L.color)), k)) {
                let _ = L.vertexColors;
                R.push(h(_[0]), h(_[1]), h(_[2]));
              }
            }
            function c(_, L, R) {
              return R ? _ | (1 << L) : _ & ~(1 << L);
            }
            function d(_) {
              let L = _.x.toString() + _.y.toString() + _.z.toString();
              return (
                void 0 !== z[L] ||
                  ((z[L] = N.length / 3), N.push(_.x, _.y, _.z)),
                z[L]
              );
            }
            function h(_) {
              let L = _.r.toString() + _.g.toString() + _.b.toString();
              return (
                void 0 !== U[L] || ((U[L] = F.length), F.push(_.getHex())), U[L]
              );
            }
            function f(_) {
              let L = _.x.toString() + _.y.toString();
              return (
                void 0 !== Y[L] || ((Y[L] = k.length / 2), k.push(_.x, _.y)),
                Y[L]
              );
            }
            return (
              (_.data = {}),
              (_.data.vertices = L),
              (_.data.normals = N),
              F.length > 0 && (_.data.colors = F),
              k.length > 0 && (_.data.uvs = [k]),
              (_.data.faces = R),
              _
            );
          }
          clone() {
            return new g7().copy(this);
          }
          copy(_) {
            (this.vertices = []),
              (this.colors = []),
              (this.faces = []),
              (this.faceVertexUvs = [[]]),
              (this.morphTargets = []),
              (this.morphNormals = []),
              (this.skinWeights = []),
              (this.skinIndices = []),
              (this.lineDistances = []),
              (this.boundingBox = null),
              (this.boundingSphere = null),
              (this.name = _.name);
            let L = _.vertices;
            for (let _ = 0, R = L.length; _ < R; _++)
              this.vertices.push(L[_].clone());
            let R = _.colors;
            for (let _ = 0, L = R.length; _ < L; _++)
              this.colors.push(R[_].clone());
            let N = _.faces;
            for (let _ = 0, L = N.length; _ < L; _++)
              this.faces.push(N[_].clone());
            for (let L = 0, R = _.faceVertexUvs.length; L < R; L++) {
              let R = _.faceVertexUvs[L];
              void 0 === this.faceVertexUvs[L] && (this.faceVertexUvs[L] = []);
              for (let _ = 0, N = R.length; _ < N; _++) {
                let N = R[_],
                  z = [];
                for (let _ = 0, L = N.length; _ < L; _++) {
                  let L = N[_];
                  z.push(L.clone());
                }
                this.faceVertexUvs[L].push(z);
              }
            }
            let z = _.morphTargets;
            for (let _ = 0, L = z.length; _ < L; _++) {
              let L = {};
              if (((L.name = z[_].name), void 0 !== z[_].vertices)) {
                L.vertices = [];
                for (let R = 0, N = z[_].vertices.length; R < N; R++)
                  L.vertices.push(z[_].vertices[R].clone());
              }
              if (void 0 !== z[_].normals) {
                L.normals = [];
                for (let R = 0, N = z[_].normals.length; R < N; R++)
                  L.normals.push(z[_].normals[R].clone());
              }
              this.morphTargets.push(L);
            }
            let F = _.morphNormals;
            for (let _ = 0, L = F.length; _ < L; _++) {
              let L = {};
              if (void 0 !== F[_].vertexNormals) {
                L.vertexNormals = [];
                for (let R = 0, N = F[_].vertexNormals.length; R < N; R++) {
                  let N = F[_].vertexNormals[R],
                    z = {};
                  (z.a = N.a.clone()),
                    (z.b = N.b.clone()),
                    (z.c = N.c.clone()),
                    L.vertexNormals.push(z);
                }
              }
              if (void 0 !== F[_].faceNormals) {
                L.faceNormals = [];
                for (let R = 0, N = F[_].faceNormals.length; R < N; R++)
                  L.faceNormals.push(F[_].faceNormals[R].clone());
              }
              this.morphNormals.push(L);
            }
            let U = _.skinWeights;
            for (let _ = 0, L = U.length; _ < L; _++)
              this.skinWeights.push(U[_].clone());
            let k = _.skinIndices;
            for (let _ = 0, L = k.length; _ < L; _++)
              this.skinIndices.push(k[_].clone());
            let Y = _.lineDistances;
            for (let _ = 0, L = Y.length; _ < L; _++)
              this.lineDistances.push(Y[_]);
            let X = _.boundingBox;
            null !== X && (this.boundingBox = X.clone());
            let Q = _.boundingSphere;
            return (
              null !== Q && (this.boundingSphere = Q.clone()),
              (this.elementsNeedUpdate = _.elementsNeedUpdate),
              (this.verticesNeedUpdate = _.verticesNeedUpdate),
              (this.uvsNeedUpdate = _.uvsNeedUpdate),
              (this.normalsNeedUpdate = _.normalsNeedUpdate),
              (this.colorsNeedUpdate = _.colorsNeedUpdate),
              (this.lineDistancesNeedUpdate = _.lineDistancesNeedUpdate),
              (this.groupsNeedUpdate = _.groupsNeedUpdate),
              this
            );
          }
          toBufferGeometry() {
            let _ = new ve().fromGeometry(this),
              L = new sP(),
              R = new Float32Array(3 * _.vertices.length);
            if (
              (L.setAttribute("position", hg.call(new sh(R, 3), _.vertices)),
              _.normals.length > 0)
            ) {
              let R = new Float32Array(3 * _.normals.length);
              L.setAttribute("normal", hg.call(new sh(R, 3), _.normals));
            }
            if (_.colors.length > 0) {
              let R = new Float32Array(3 * _.colors.length);
              L.setAttribute("color", zM.call(new sh(R, 3), _.colors));
            }
            if (_.uvs.length > 0) {
              let R = new Float32Array(2 * _.uvs.length);
              L.setAttribute("uv", VM.call(new sh(R, 2), _.uvs));
            }
            if (_.uvs2.length > 0) {
              let R = new Float32Array(2 * _.uvs2.length);
              L.setAttribute("uv2", VM.call(new sh(R, 2), _.uvs2));
            }
            for (let R in ((L.groups = _.groups), _.morphTargets)) {
              let N = [],
                z = _.morphTargets[R];
              for (let _ = 0, L = z.length; _ < L; _++) {
                let L = z[_],
                  R = new sv(3 * L.data.length, 3);
                (R.name = L.name), N.push(hg.call(R, L.data));
              }
              L.morphAttributes[R] = N;
            }
            if (_.skinIndices.length > 0) {
              let R = new sv(4 * _.skinIndices.length, 4);
              L.setAttribute("skinIndex", HM.call(R, _.skinIndices));
            }
            if (_.skinWeights.length > 0) {
              let R = new sv(4 * _.skinWeights.length, 4);
              L.setAttribute("skinWeight", HM.call(R, _.skinWeights));
            }
            return (
              null !== _.boundingSphere &&
                (L.boundingSphere = _.boundingSphere.clone()),
              null !== _.boundingBox && (L.boundingBox = _.boundingBox.clone()),
              L
            );
          }
          computeTangents() {
            console.error(
              "THREE.Geometry: .computeTangents() has been removed.",
            );
          }
          computeLineDistances() {
            console.error(
              "THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.",
            );
          }
          applyMatrix(_) {
            return (
              console.warn(
                "THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4().",
              ),
              this.applyMatrix4(_)
            );
          }
          dispose() {
            this.dispatchEvent({ type: "dispose" });
          }
          static createBufferGeometryFromObject(_) {
            let L = new sP(),
              R = _.geometry;
            if (_.isPoints || _.isLine) {
              let _ = new sv(3 * R.vertices.length, 3),
                N = new sv(3 * R.colors.length, 3);
              if (
                (L.setAttribute("position", hg.call(_, R.vertices)),
                L.setAttribute("color", zM.call(N, R.colors)),
                R.lineDistances && R.lineDistances.length === R.vertices.length)
              ) {
                let _ = new sv(R.lineDistances.length, 1);
                L.setAttribute("lineDistance", dH.call(_, R.lineDistances));
              }
              null !== R.boundingSphere &&
                (L.boundingSphere = R.boundingSphere.clone()),
                null !== R.boundingBox &&
                  (L.boundingBox = R.boundingBox.clone());
            } else _.isMesh && (L = R.toBufferGeometry());
            return L;
          }
        };
      g7.prototype.isGeometry = !0;
      var ve = class {
          constructor() {
            (this.vertices = []),
              (this.normals = []),
              (this.colors = []),
              (this.uvs = []),
              (this.uvs2 = []),
              (this.groups = []),
              (this.morphTargets = {}),
              (this.skinWeights = []),
              (this.skinIndices = []),
              (this.boundingBox = null),
              (this.boundingSphere = null),
              (this.verticesNeedUpdate = !1),
              (this.normalsNeedUpdate = !1),
              (this.colorsNeedUpdate = !1),
              (this.uvsNeedUpdate = !1),
              (this.groupsNeedUpdate = !1);
          }
          computeGroups(_) {
            let L = [],
              R,
              N,
              z,
              F = _.faces;
            for (N = 0; N < F.length; N++) {
              let _ = F[N];
              _.materialIndex !== z &&
                ((z = _.materialIndex),
                void 0 !== R && ((R.count = 3 * N - R.start), L.push(R)),
                (R = { start: 3 * N, materialIndex: z }));
            }
            void 0 !== R && ((R.count = 3 * N - R.start), L.push(R)),
              (this.groups = L);
          }
          fromGeometry(_) {
            let L = _.faces,
              R = _.vertices,
              N = _.faceVertexUvs,
              z = N[0] && N[0].length > 0,
              F = N[1] && N[1].length > 0,
              U = _.morphTargets,
              k = U.length,
              Y;
            if (k > 0) {
              Y = [];
              for (let _ = 0; _ < k; _++) Y[_] = { name: U[_].name, data: [] };
              this.morphTargets.position = Y;
            }
            let X = _.morphNormals,
              Q = X.length,
              K;
            if (Q > 0) {
              K = [];
              for (let _ = 0; _ < Q; _++) K[_] = { name: X[_].name, data: [] };
              this.morphTargets.normal = K;
            }
            let J = _.skinIndices,
              $ = _.skinWeights,
              ee = J.length === R.length,
              er = $.length === R.length;
            R.length > 0 &&
              0 === L.length &&
              console.error(
                "THREE.DirectGeometry: Faceless geometries are not supported.",
              );
            for (let _ = 0; _ < L.length; _++) {
              let en = L[_];
              this.vertices.push(R[en.a], R[en.b], R[en.c]);
              let ea = en.vertexNormals;
              if (3 === ea.length) this.normals.push(ea[0], ea[1], ea[2]);
              else {
                let _ = en.normal;
                this.normals.push(_, _, _);
              }
              let eo = en.vertexColors;
              if (3 === eo.length) this.colors.push(eo[0], eo[1], eo[2]);
              else {
                let _ = en.color;
                this.colors.push(_, _, _);
              }
              if (!0 === z) {
                let L = N[0][_];
                void 0 !== L
                  ? this.uvs.push(L[0], L[1], L[2])
                  : (console.warn(
                      "THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ",
                      _,
                    ),
                    this.uvs.push(new iT(), new iT(), new iT()));
              }
              if (!0 === F) {
                let L = N[1][_];
                void 0 !== L
                  ? this.uvs2.push(L[0], L[1], L[2])
                  : (console.warn(
                      "THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ",
                      _,
                    ),
                    this.uvs2.push(new iT(), new iT(), new iT()));
              }
              for (let _ = 0; _ < k; _++) {
                let L = U[_].vertices;
                Y[_].data.push(L[en.a], L[en.b], L[en.c]);
              }
              for (let L = 0; L < Q; L++) {
                let R = X[L].vertexNormals[_];
                K[L].data.push(R.a, R.b, R.c);
              }
              ee && this.skinIndices.push(J[en.a], J[en.b], J[en.c]),
                er && this.skinWeights.push($[en.a], $[en.b], $[en.c]);
            }
            return (
              this.computeGroups(_),
              (this.verticesNeedUpdate = _.verticesNeedUpdate),
              (this.normalsNeedUpdate = _.normalsNeedUpdate),
              (this.colorsNeedUpdate = _.colorsNeedUpdate),
              (this.uvsNeedUpdate = _.uvsNeedUpdate),
              (this.groupsNeedUpdate = _.groupsNeedUpdate),
              null !== _.boundingSphere &&
                (this.boundingSphere = _.boundingSphere.clone()),
              null !== _.boundingBox &&
                (this.boundingBox = _.boundingBox.clone()),
              this
            );
          }
        },
        vt = class {
          constructor(_, L, R, N, z, F = 0) {
            (this.a = _),
              (this.b = L),
              (this.c = R),
              (this.normal = N && N.isVector3 ? N : new iq()),
              (this.vertexNormals = Array.isArray(N) ? N : []),
              (this.color = z && z.isColor ? z : new iz()),
              (this.vertexColors = Array.isArray(z) ? z : []),
              (this.materialIndex = F);
          }
          clone() {
            return new this.constructor().copy(this);
          }
          copy(_) {
            (this.a = _.a),
              (this.b = _.b),
              (this.c = _.c),
              this.normal.copy(_.normal),
              this.color.copy(_.color),
              (this.materialIndex = _.materialIndex);
            for (let L = 0, R = _.vertexNormals.length; L < R; L++)
              this.vertexNormals[L] = _.vertexNormals[L].clone();
            for (let L = 0, R = _.vertexColors.length; L < R; L++)
              this.vertexColors[L] = _.vertexColors[L].clone();
            return this;
          }
        };
      function dH(_) {
        return this.array.set(_), this;
      }
      function zM(_) {
        let L = this.array,
          R = 0;
        for (let N = 0, z = _.length; N < z; N++) {
          let z = _[N];
          void 0 === z &&
            (console.warn(
              "THREE.BufferAttribute.copyColorsArray(): color is undefined",
              N,
            ),
            (z = new iz())),
            (L[R++] = z.r),
            (L[R++] = z.g),
            (L[R++] = z.b);
        }
        return this;
      }
      function VM(_) {
        let L = this.array,
          R = 0;
        for (let N = 0, z = _.length; N < z; N++) {
          let z = _[N];
          void 0 === z &&
            (console.warn(
              "THREE.BufferAttribute.copyVector2sArray(): vector is undefined",
              N,
            ),
            (z = new iT())),
            (L[R++] = z.x),
            (L[R++] = z.y);
        }
        return this;
      }
      function hg(_) {
        let L = this.array,
          R = 0;
        for (let N = 0, z = _.length; N < z; N++) {
          let z = _[N];
          void 0 === z &&
            (console.warn(
              "THREE.BufferAttribute.copyVector3sArray(): vector is undefined",
              N,
            ),
            (z = new iq())),
            (L[R++] = z.x),
            (L[R++] = z.y),
            (L[R++] = z.z);
        }
        return this;
      }
      function HM(_) {
        let L = this.array,
          R = 0;
        for (let N = 0, z = _.length; N < z; N++) {
          let z = _[N];
          void 0 === z &&
            (console.warn(
              "THREE.BufferAttribute.copyVector4sArray(): vector is undefined",
              N,
            ),
            (z = new iV())),
            (L[R++] = z.x),
            (L[R++] = z.y),
            (L[R++] = z.z),
            (L[R++] = z.w);
        }
        return this;
      }
      var vi = ["a", "b", "c"];
      function nb(_, L, R) {
        let N = Math.min(_, L),
          z = Math.max(_, L);
        return R.get(N + "_" + z);
      }
      function rb(_, L, R, N, z, F) {
        let U = Math.min(_, L),
          k = Math.max(_, L),
          Y = U + "_" + k,
          X;
        N.has(Y)
          ? (X = N.get(Y))
          : ((X = { a: R[U], b: R[k], newEdge: null, faces: [] }), N.set(Y, X)),
          X.faces.push(z),
          F[_].edges.push(X),
          F[L].edges.push(X);
      }
      function fg(_, L, R, N, z) {
        _.push(new vt(L, R, N, void 0, void 0, z));
      }
      function xu(_, L) {
        return Math.abs(L - _) / 2 + Math.min(_, L);
      }
      function pg(_, L, R, N) {
        _.push([L.clone(), R.clone(), N.clone()]);
      }
      var vr = class {
          constructor(_ = 1) {
            this.subdivisions = _;
          }
          modify(_) {
            (_ =
              _ instanceof sP
                ? new g7().fromBufferGeometry(_)
                : _.clone()).mergeVertices();
            let L = this.subdivisions;
            for (; L-- > 0; ) this._smooth(_);
            return _.computeFaceNormals(), _.computeVertexNormals(), _;
          }
          _smooth(_) {
            let L = new iq(),
              R,
              N,
              z,
              F,
              U,
              k = _.vertices,
              Y = _.faces,
              X = _.faceVertexUvs[0],
              Q = void 0 !== X && X.length > 0,
              K = [],
              J = new Map();
            !(function (_, L, R, N) {
              let z, F, U;
              for (z = 0, F = _.length; z < F; z++) R[z] = { edges: [] };
              for (z = 0, F = L.length; z < F; z++)
                rb((U = L[z]).a, U.b, _, N, U, R),
                  rb(U.b, U.c, _, N, U, R),
                  rb(U.c, U.a, _, N, U, R);
            })(k, Y, K, J);
            let $ = [],
              ee,
              er,
              en,
              ea,
              eo,
              el,
              ec;
            for (let _ of Array.from(J.keys())) {
              for (
                er = J.get(_),
                  en = new iq(),
                  eo = 3 / 8,
                  el = 1 / 8,
                  2 != (ec = er.faces.length) && ((eo = 0.5), (el = 0)),
                  en.addVectors(er.a, er.b).multiplyScalar(eo),
                  L.set(0, 0, 0),
                  F = 0;
                F < ec;
                F++
              ) {
                for (
                  ea = er.faces[F], U = 0;
                  U < 3 &&
                  !(
                    (ee =
                      k[
                        (function (_, L) {
                          switch (L) {
                            case "c":
                              return _.c;
                            case "b":
                              return _.b;
                            default:
                              return _.a;
                          }
                        })(ea, vi[U])
                      ]) !== er.a && ee !== er.b
                  );
                  U++
                );
                ee && L.add(ee);
              }
              L.multiplyScalar(el),
                en.add(L),
                (er.newEdge = $.length),
                $.push(en);
            }
            let ed,
              eu,
              ep,
              ef,
              ev,
              ex,
              eb,
              ew = [];
            for (N = 0, z = k.length; N < z; N++) {
              for (
                ex = k[N],
                  3 == (R = (ev = K[N].edges).length)
                    ? (ed = 3 / 16)
                    : R > 3 && (ed = 3 / (8 * R)),
                  eu = 1 - R * Number(ed),
                  ep = ed,
                  R <= 2 && 2 == R && ((eu = 3 / 4), (ep = 1 / 8)),
                  eb = ex.clone().multiplyScalar(eu),
                  L.set(0, 0, 0),
                  F = 0;
                F < R;
                F++
              )
                (ee = (ef = ev[F]).a !== ex ? ef.a : ef.b), L.add(ee);
              L.multiplyScalar(Number(ep)), eb.add(L), ew.push(eb);
            }
            let e_ = ew.concat($),
              eA = ew.length,
              eM,
              eE,
              eC,
              eP = [],
              eD = [],
              eO,
              eL,
              eR,
              eI,
              eB = new iT(),
              ez = new iT(),
              eF = new iT();
            for (N = 0, z = Y.length; N < z; N++)
              fg(
                eP,
                (eM = Number(nb((ea = Y[N]).a, ea.b, J).newEdge) + eA),
                (eE = Number(nb(ea.b, ea.c, J).newEdge) + eA),
                (eC = Number(nb(ea.c, ea.a, J).newEdge) + eA),
                ea.materialIndex,
              ),
                fg(eP, ea.a, eM, eC, ea.materialIndex),
                fg(eP, ea.b, eE, eM, ea.materialIndex),
                fg(eP, ea.c, eC, eE, ea.materialIndex),
                Q &&
                  ((eL = (eO = X[N])[0]),
                  (eR = eO[1]),
                  (eI = eO[2]),
                  eB.set(xu(eL.x, eR.x), xu(eL.y, eR.y)),
                  ez.set(xu(eR.x, eI.x), xu(eR.y, eI.y)),
                  eF.set(xu(eL.x, eI.x), xu(eL.y, eI.y)),
                  pg(eD, eB, ez, eF),
                  pg(eD, eL, eB, eF),
                  pg(eD, eR, ez, eB),
                  pg(eD, eI, eF, ez));
            (_.vertices = e_), (_.faces = eP), Q && (_.faceVertexUvs[0] = eD);
          }
        },
        vs = new iq(),
        vn = class {
          static create(_) {
            return this.build(this.normalizeInputs(_));
          }
          static normalizeInputs(_, L) {
            let R =
                _.geometry ??
                L?.geometry ??
                new sP().copy(new sW(100, 100, 100)),
              N;
            void 0 === L
              ? (R.computeBoundingBox(),
                R.boundingBox.getSize(vs),
                (N = {
                  width: vs.x,
                  height: vs.y,
                  depth: vs.z,
                  subdivisions: 0,
                }))
              : (N = L.parameters);
            let z = { ...N, ..._.parameters };
            return {
              parameters: {
                width: Math.abs(z.width),
                height: Math.abs(z.height),
                depth: Math.abs(z.depth),
                subdivisions: Math.abs(z.subdivisions),
              },
              geometry: R,
            };
          }
          static build(_) {
            let {
                width: L,
                height: R,
                depth: N,
                subdivisions: z,
              } = _.parameters,
              F = _.geometry ?? new sP().copy(new sW(100, 100, 100)),
              U = F.userData.parameters;
            void 0 === U
              ? (F.computeBoundingBox(), F.boundingBox.getSize(vs))
              : vs.set(U.width, U.height, U.depth),
              (L !== vs.x || R !== vs.y || N !== vs.z) &&
                F.scale(
                  0 === vs.x ? 1 : L / vs.x,
                  0 === vs.y ? 1 : R / vs.y,
                  0 === vs.z ? 1 : N / vs.z,
                );
            let k = F.originalGeometry;
            return (
              z > 0
                ? (void 0 === k || U?.subdivisions !== z) &&
                  (void 0 === k && (k = F),
                  (F = new vr(z).modify(k).toBufferGeometry()))
                : (void 0 !== k && (F = k),
                  (k = void 0),
                  void 0 === F.getAttribute("normal") &&
                    F.computeVertexNormals()),
              void 0 !== k && Object.assign(F, { originalGeometry: k }),
              delete _.geometry,
              Object.assign(F, {
                userData: { ..._, type: "NonParametricGeometry" },
              })
            );
          }
          static loadFromUrl(_, L, R) {
            new oM(R).load(_, (_) => {
              let R = this.normalizeInputs({ geometry: _ });
              _.boundingBox.getSize(vs);
              let N = 100 / vs.x;
              Object.assign(R.parameters, {
                width: 100,
                height: vs.y * N,
                depth: vs.z * N,
              }),
                L(this.build(R));
            });
          }
        },
        va = class {
          static create(_) {
            return this.build(this.normalizeInputs(_));
          }
          static normalizeInputs(_, L) {
            let R = Object.assign(
              {},
              L?.parameters ?? {
                width: 100,
                depth: 0,
                spikes: 5,
                cornerRadius: 0,
                extrudeBevelSize: 0,
                extrudeBevelSegments: 3,
              },
              _.parameters,
            );
            return {
              shape: _.shape && _.shape instanceof gL ? _.shape : new gL(),
              parameters: Object.assign(R, {
                width: Math.abs(R.width),
                height: Math.abs(R.height ?? R.width),
                depth: Math.abs(R.depth ?? 0),
              }),
            };
          }
          static build(_) {
            let {
                width: L,
                height: R,
                spikes: N,
                cornerRadius: z,
                depth: F,
                extrudeBevelSize: U,
                extrudeBevelSegments: k,
              } = _.parameters,
              Y = _.shape,
              X = 0.5 * L,
              Q = 0.5 * R,
              K = (2 * Math.PI) / N;
            for (let _ = 0; _ < N; _++) {
              let L = K * _,
                R = 0 + Math.sin(L) * X,
                N = 0 + Math.cos(L) * Q;
              Y.addPoint(Y.createPoint(R, N));
            }
            Y.isClosed = !0;
            for (let _ = 0, L = Y.points.length; _ < L; _++)
              Y.points[_].roundness = z;
            return (
              (Y.roundness = z),
              Y.update(),
              Object.assign(
                gq.create({
                  shape: Y,
                  parameters: {
                    roundness: z,
                    depth: F,
                    extrudeBevelSize: U,
                    extrudeBevelSegments: k,
                  },
                }),
                { userData: { ..._, type: "PolygonGeometry" } },
              )
            );
          }
        },
        vo = class {
          static create(_) {
            return this.build(this.normalizeInputs(_));
          }
          static normalizeInputs(_, L) {
            let R = Object.assign(
              {},
              L?.parameters ?? {
                width: 100,
                radialSegments: 4,
                heightSegments: 1,
                cornerRadius: 0,
                cornerSegments: 8,
                openEnded: !1,
              },
              _.parameters,
            );
            return {
              parameters: Object.assign(R, {
                width: Math.abs(R.width),
                height: Math.abs(R.height ?? R.width),
                depth: Math.abs(R.depth ?? R.width),
              }),
            };
          }
          static build(_) {
            let {
                width: L,
                height: R,
                depth: N,
                radialSegments: z,
                heightSegments: F,
                openEnded: U,
                cornerRadius: k,
                cornerSegments: Y,
              } = _.parameters,
              X = new vg(0.5 * L, R, z, F, U, k, Y);
            return (
              X.scale(1, 1, N / L),
              Object.assign(X, { userData: { ..._, type: "PyramidGeometry" } })
            );
          }
        };
      function Ph(_, L, R) {
        (R.x = _.x * L.x), (R.y = _.y), (R.z = _.x * L.y);
      }
      function ib(_, L, R, N, z, F) {
        let U = L.clone().sub(_),
          k = R.clone().sub(_),
          Y = U.angleTo(k);
        if ((U.normalize(), k.normalize(), N === z)) {
          let L = U.add(k).normalize();
          F.copy(_).addScaledVector(L, N / Math.sin(Y / 2));
        } else {
          let L = U.angleTo(k);
          F.copy(_),
            F.addScaledVector(U, z / Math.sin(L)),
            F.addScaledVector(k, N / Math.sin(L));
        }
      }
      var vl,
        vd,
        vu,
        vp,
        vf,
        vm,
        vg = class extends sP {
          constructor(_ = 0.5, L = 1, R = 4, N = 1, z = !1, F = 0, U = 4) {
            let k;
            super(),
              (R = Math.floor(Math.max(3, R))),
              (N = Math.floor(N)),
              (U = Math.floor(U));
            let Y = [],
              X = [],
              Q = [],
              K = [],
              J = 0,
              $ = L / 2,
              ee = Math.PI / R,
              er = _ * Math.cos(Math.PI / R),
              en = (2 * Math.PI) / R,
              ea = Math.PI - ((R - 2) * Math.PI) / R,
              eo = new iq(0, -$, 0),
              el = new iq(0, $, 0),
              ec = new iT(_, -$),
              ed = new iT(er, -$),
              eu = new iT(0, el.y).sub(ed),
              ep = new iT(0, el.y).sub(ec),
              ef = new iT(eu.y, -eu.x).normalize(),
              ev = new iT(ep.y, -ep.x).normalize();
            F = Math.min(
              F,
              _ * Math.cos(Math.PI / R) * Math.tan((Math.PI - eu.angle()) / 2) -
                1e-8,
            );
            {
              let _ = new iq(ef.x, ef.y, 0),
                L = new iq(Math.cos(en) * _.x, _.y, Math.sin(en) * _.x);
              k = _.angleTo(L);
            }
            let ex = F / Math.tan((Math.PI - eu.angle()) / 2),
              eb = F / Math.tan((Math.PI - k) / 2),
              ew = new iq();
            if (!z) {
              X.push(eo.x, eo.y, eo.z), Q.push(0, -1, 0), K.push(0, 0);
              let _ = J++,
                L = [],
                N = ec.clone(),
                z = ex / Math.cos(Math.PI / R);
              N.x -= z;
              for (let _ = 0; _ < R; _++) {
                let z = (_ / R) * Math.PI * 2 + ee;
                Ph(N, new iT(Math.sin(z), Math.cos(z)), ew),
                  X.push(ew.x, ew.y, ew.z),
                  Q.push(0, -1, 0),
                  K.push(0, 0),
                  L.push(J++);
              }
              for (let R = 0; R < L.length; R++)
                Y.push(L[R], _, L[(R + 1) % L.length]);
            }
            let e_ = [];
            {
              let _ = new iq(),
                L = new iq(),
                N = new iq(),
                z = new iq(),
                $ = new iq(),
                er = new iq();
              for (let en = 0; en < R; en++) {
                let ed = (en / R) * Math.PI * 2 + ee,
                  ew = ((en + 0.5) / R) * Math.PI * 2 + ee,
                  eA = ((en + 1) / R) * Math.PI * 2 + ee,
                  eM = new iT(Math.sin(ed), Math.cos(ed)),
                  eE = new iT(Math.sin(ew), Math.cos(ew)),
                  eC = new iT(Math.sin(eA), Math.cos(eA));
                Ph(ec, eM, L),
                  Ph(ec, eC, N),
                  Ph(ef, eE, _),
                  ib(el, L, N, eb, eb, z),
                  X.push(z.x, z.y, z.z),
                  ib(L, el, N, eb, ex, $),
                  X.push($.x, $.y, $.z),
                  ib(N, L, el, ex, eb, er),
                  X.push(er.x, er.y, er.z),
                  Q.push(_.x, _.y, _.z),
                  Q.push(_.x, _.y, _.z),
                  Q.push(_.x, _.y, _.z),
                  K.push(0, 0),
                  K.push(0, 0),
                  K.push(0, 0);
                let eP = J++,
                  eD = J++,
                  eO = J++;
                if ((Y.push(eP, eD, eO), F > 0)) {
                  let ee, en;
                  {
                    let _ = L.clone().add(N).multiplyScalar(0.5),
                      R = el.clone().sub(_).normalize(),
                      z = eo
                        .clone()
                        .sub(_)
                        .normalize()
                        .add(R)
                        .normalize()
                        .multiplyScalar(-1);
                    W(_, er.clone().sub($), z, eu.angle());
                  }
                  {
                    let _ = new iq();
                    Ph(ev, eC, _);
                    let L = er.clone().add(z).multiplyScalar(0.5);
                    L = (function (_, L, R) {
                      let N = _.clone().sub(L),
                        z = R.clone().sub(L);
                      return N.projectOnVector(z), N.add(L);
                    })(L, N, el);
                    let R = er.clone().sub(z);
                    [ee, en] = W(L, R, _, k, z.y);
                  }
                  {
                    let _ = ee,
                      L = _.clone().setY(0).normalize(),
                      R = new iq(0, -1, 0),
                      N = L.clone().cross(R);
                    !(function (_, L, R, N) {
                      let z = Math.PI / 2,
                        k = ep.angle() - z,
                        $ = [],
                        ee = new iq(),
                        er = new iq();
                      for (let Y = 0; Y <= U; Y++) {
                        let en = [],
                          eo = Y / U;
                        for (let U = 0; U <= Y; U++) {
                          let $ = ((Y ? U / Y : 0) - 0.5) * ea,
                            el = Math.cos($),
                            ec = Math.sin($),
                            ed = (z + Math.atan(Math.tan(k) * el)) * eo,
                            eu = Math.cos(ed),
                            ep = Math.sin(ed);
                          ee.set(0, 0, 0),
                            ee.addScaledVector(L, ep * el),
                            ee.addScaledVector(R, eu),
                            ee.addScaledVector(N, ep * ec),
                            er.copy(_).addScaledVector(ee, F),
                            X.push(er.x, er.y, er.z),
                            Q.push(ee.x, ee.y, ee.z),
                            K.push(0, 0),
                            en.push(J++);
                        }
                        $.push(en);
                      }
                      let en = $.length - 1;
                      for (let _ = 0; _ < en; _++) {
                        let L = $[_],
                          R = $[_ + 1],
                          N = L.length - 1;
                        Y.push(L[0], R[1], R[0]);
                        for (let _ = 1; _ <= N; _++)
                          Y.push(L[_ - 1], L[_], R[_]),
                            Y.push(L[_], R[_ + 1], R[_]);
                      }
                    })(_, L, R, N);
                  }
                  e_.concat(en);
                  {
                    let L = eu.angle(),
                      N = Math.PI - L,
                      z = el.clone();
                    z.y -= F / Math.sin(L - Math.PI / 2);
                    let k = new iq(),
                      $ = [];
                    for (let L = 0; L < U; L++) {
                      let Y = [],
                        ee = Math.PI / 2 - (N * L) / U,
                        er = Math.cos(ee),
                        en = Math.sin(ee),
                        ea = ew;
                      for (let N = 0; N <= L; N++) {
                        let N = Math.cos(ea),
                          U = Math.sin(ea);
                        (_.x = er * U),
                          (_.y = en),
                          (_.z = er * N),
                          k.copy(z).addScaledVector(_, F),
                          X.push(k.x, k.y, k.z),
                          Q.push(_.x, _.y, _.z),
                          K.push(0, 0),
                          Y.push(J++),
                          (ea += (2 * Math.PI) / L / R);
                      }
                      $.push(Y);
                    }
                    en.reverse(), $.push(en);
                    let ee = $.length - 1;
                    for (let _ = 0; _ < ee; _++) {
                      let L = $[_],
                        R = $[_ + 1],
                        N = L.length - 1;
                      Y.push(R[1], L[0], R[0]);
                      for (let _ = 1; _ <= N; _++)
                        Y.push(L[_], L[_ - 1], R[_]),
                          Y.push(R[_ + 1], L[_], R[_]);
                    }
                  }
                }
              }
            }
            function W(_, L, R, N, z) {
              let k = -N / 2,
                $ = (Math.PI - N) / 2,
                ee = L.clone().normalize().cross(R);
              _.addScaledVector(R, -F / Math.sin($));
              let er = new iq(),
                en = new iq(),
                ea = J,
                eo = [];
              for (let Y = 0; Y <= U; Y++) {
                let $ = k + (Y / U) * N;
                en.set(0, 0, 0),
                  en.addScaledVector(ee, Math.sin($)),
                  en.addScaledVector(R, Math.cos($));
                for (let R = 0; R <= 1; R++) {
                  let N = R / 1 - 0.5;
                  if (
                    (er.copy(_),
                    er.addScaledVector(L, N),
                    er.addScaledVector(en, F),
                    null != z)
                  ) {
                    let _ = Math.max(0, er.y - z);
                    er.addScaledVector(L, -_ / L.y);
                  }
                  X.push(er.x, er.y, er.z),
                    Q.push(en.x, en.y, en.z),
                    K.push(0, 0),
                    0 === R && eo.push(J),
                    J++;
                }
              }
              for (let _ = 0; _ < U; _++)
                for (let L = 0; L < 1; L++) {
                  let R = ea + L + 2 * _,
                    N = R + 2,
                    z = N + 1,
                    F = R + 1;
                  Y.push(R, N, F), Y.push(N, z, F);
                }
              return [_.clone().addScaledVector(L, 0.5), eo];
            }
            this.setIndex(Y),
              this.setAttribute("position", new sv(X, 3)),
              this.setAttribute("normal", new sv(Q, 3)),
              this.setAttribute("uv", new sv(K, 2));
          }
        },
        vv = class {
          static create(_) {
            return this.build(this.normalizeInputs(_));
          }
          static normalizeInputs(_, L) {
            let R = Object.assign(
                {},
                L?.parameters ?? {
                  width: 100,
                  depth: 0,
                  cornerRadius: [0, 0, 0, 0],
                  cornerType: 1,
                  extrudeBevelSize: 0,
                  extrudeBevelSegments: 1,
                },
                _.parameters,
              ),
              N = Object.assign(L?.ui ?? { enabledIndieCorners: !1 }, _.ui);
            return {
              shape: _.shape && _.shape instanceof gL ? _.shape : new gL(),
              parameters: Object.assign(R, {
                width: Math.abs(R.width),
                height: Math.abs(R.height ?? R.width),
                depth: Math.abs(R.depth ?? 0),
              }),
              ui: N,
            };
          }
          static build(_) {
            let L = _.shape,
              {
                width: R,
                height: N,
                cornerRadius: z,
                cornerType: F,
                depth: U,
                extrudeBevelSize: k,
                extrudeBevelSegments: Y,
              } = _.parameters,
              X = { x: 0.5 * R, y: 0.5 * N },
              Q = { x: -X.x, y: -X.y },
              K = { x: X.x, y: X.y };
            function h(_, L, z) {
              return L > R && z > N
                ? Math.min((_ * R) / L, (_ * N) / z)
                : L > R
                  ? (_ * R) / L
                  : z > N
                    ? (_ * N) / z
                    : _;
            }
            let J = [];
            (J[0] = 0 === z[0] ? 0 : h(z[0], z[0] + z[3], z[0] + z[1])),
              (J[1] = 0 === z[1] ? 0 : h(z[1], z[1] + z[2], z[1] + z[0])),
              (J[2] = 0 === z[2] ? 0 : h(z[2], z[2] + z[1], z[2] + z[3])),
              (J[3] = 0 === z[3] ? 0 : h(z[3], z[3] + z[0], z[3] + z[2]));
            let $ = Q.x,
              ee = K.x,
              er = K.y,
              en = Q.y;
            L.addPoint(L.createPoint($, er)),
              L.addPoint(L.createPoint(ee, er)),
              L.addPoint(L.createPoint(ee, en)),
              L.addPoint(L.createPoint($, en)),
              (L.isClosed = !0);
            let ea = !0;
            for (let _ = 0, R = L.points.length; _ < R; _++)
              (L.points[_].roundness = J[_]),
                _ > 0 && J[_] !== J[_ - 1] && (ea = !1);
            return (
              ea && (L.roundness = J[0]),
              (L.useCubicForRoundedCorners = 1 !== F),
              L.update(),
              Object.assign(
                gq.create({
                  shape: L,
                  parameters: {
                    depth: U,
                    extrudeBevelSize: k,
                    extrudeBevelSegments: Y,
                  },
                }),
                { userData: { ..._, type: "RectangleGeometry" } },
              )
            );
          }
        },
        vy = class {
          static create(_) {
            return this.build(this.normalizeInputs(_));
          }
          static normalizeInputs(_, L) {
            let R = Object.assign(
              {},
              L?.parameters ?? {
                width: 100,
                widthSegments: 64,
                heightSegments: 64,
                phiStart: 0,
                phiLength: 2 * Math.PI,
                thetaStart: 0,
                thetaLength: Math.PI,
              },
              _.parameters,
            );
            return {
              parameters: Object.assign(R, {
                width: Math.abs(R.width),
                height: Math.abs(R.height ?? R.width),
                depth: Math.abs(R.depth ?? R.width),
              }),
            };
          }
          static build(_) {
            let {
                width: L = 100,
                height: R = L,
                depth: N = L,
                widthSegments: z = 64,
                heightSegments: F = 64,
                phiStart: U,
                phiLength: k,
                thetaStart: Y,
                thetaLength: X,
              } = _.parameters,
              Q = new aY(0.5 * L, z, F, U, k, Y, X);
            return (
              Q.scale(1, R / L, N / L),
              Object.assign(Q, { userData: { ..._, type: "SphereGeometry" } })
            );
          }
        },
        vb = class {
          static create(_) {
            return this.build(this.normalizeInputs(_));
          }
          static normalizeInputs(_, L) {
            let R = Object.assign(
              {},
              L?.parameters ?? {
                width: 100,
                depth: 0,
                widthSegments: 8,
                heightSegments: 8,
              },
              _.parameters,
            );
            return {
              parameters: Object.assign(R, {
                width: Math.abs(R.width),
                height: Math.abs(R.height ?? R.width),
                depth: 0,
              }),
            };
          }
          static build(_) {
            let {
                width: L = 100,
                height: R = L,
                widthSegments: N = 8,
                heightSegments: z = 8,
              } = _.parameters,
              F = new ne(L, R, N, z);
            return (
              F.scale(1, 1, 1),
              Object.assign(F, { userData: { ..._, type: "PlaneGeometry" } })
            );
          }
        },
        vw = class {
          static create(_) {
            return this.build(this.normalizeInputs(_));
          }
          static normalizeInputs(_, L) {
            let R = Object.assign(
              {},
              L?.parameters ?? {
                width: 100,
                angle: 90,
                cornerRadius: 24,
                cornerSegments: 8,
              },
              _.parameters,
            );
            return {
              parameters: Object.assign(R, {
                width: Math.abs(R.width),
                height: Math.abs(R.height ?? R.width),
                depth: Math.abs(R.depth ?? R.width),
              }),
            };
          }
          static build(_) {
            let {
              width: L,
              height: R,
              depth: N,
              angle: z,
              cornerRadius: F,
              cornerSegments: U,
            } = _.parameters;
            return Object.assign(new v_(L, R, N, z, F, U), {
              userData: { ..._, type: "BackdropGeometry" },
            });
          }
        },
        v_ = class extends sP {
          constructor(_ = 1, L = 1, R = 1, N = 90, z = 10, F = 24) {
            super(), (this.type = "BackdropGeometry");
            let U = [],
              k = [],
              Y = [];
            0 == z && (F = 1),
              (F = Math.max(1, Math.floor(F))),
              (z = Math.min(z, 100)),
              (N = Math.min(179.999, N) * (Math.PI / 180));
            let X = [],
              Q = Math.PI / 2,
              f = (_ = 0, L = 0, R = 0) => new iq(_, L, R),
              K = f(),
              J = f(),
              [$, ee, er] = [L / 2, _ / 2, R / 2],
              en = -ee,
              ea = +ee,
              [eo, el, ec] = [f(en, -$, +er), f(en, -$, -er), f(en, +$, -er)],
              S = (_, L = !1) => Math.sin(_ - Math.PI / (1 + +L)),
              E = (_, L = !1) => Math.cos(_ - Math.PI / (1 + +L));
            ec.y = Math.sin(N) * L - $;
            let ed = Math.cos(N) * L - er,
              eu = eo.z - 0.001;
            N <= Q
              ? ((ec.z = Math.min(ed, eu)),
                ec.z == eu && (ec.y -= (ed - eu) / Math.tan(Q - N)))
              : (el.z = Math.min(el.z - ed - er, eo.z - 0.001)),
              K.subVectors(eo, el),
              J.subVectors(ec, el);
            let ep = (Math.min(K.length(), J.length()) * z) / 100,
              ef = ep * Math.tan(N / 2),
              ev = ep / Math.cos(N / 2),
              ex = K.clone()
                .normalize()
                .add(J.normalize())
                .setLength(ev)
                .add(el);
            K.set(0, S(N, !0), E(N, !0)), X.push([ec, K.clone()]);
            let eb = (Math.PI - N) / F;
            for (let _ = 0; _ <= F; _++) {
              let L = Q + N + _ * eb;
              K.set(0, Math.sin(L) * ef, Math.cos(L) * ef),
                K.add(ex),
                J.set(0, S(L), E(L)),
                X.push([K.clone(), J.clone()]);
            }
            X.push([eo, f(0, 1, 0)]);
            let ew = Math.sin(eb / 2) * ef * 2,
              e_ = X.length - 1,
              eA = X[0][0].distanceTo(X[1][0]),
              eM = eA + ew * F + X[e_ - 1][0].distanceTo(X[e_][0]);
            X[0].push(1);
            for (let _ = 0; _ <= F; _++) X[_ + 1].push(1 - (eA + _ * ew) / eM);
            X[e_].push(0);
            let [eE, eC, eP] = X[0],
              eD,
              eO,
              eL;
            for (let _ = 1; _ < X.length; _++)
              ([eD, eO, eL] = X[_]),
                U.push(
                  en,
                  eE.y,
                  eE.z,
                  en,
                  eD.y,
                  eD.z,
                  ea,
                  eE.y,
                  eE.z,
                  ea,
                  eE.y,
                  eE.z,
                  en,
                  eD.y,
                  eD.z,
                  ea,
                  eD.y,
                  eD.z,
                ),
                k.push(
                  0,
                  eC.y,
                  eC.z,
                  0,
                  eO.y,
                  eO.z,
                  0,
                  eC.y,
                  eC.z,
                  0,
                  eC.y,
                  eC.z,
                  0,
                  eO.y,
                  eO.z,
                  0,
                  eO.y,
                  eO.z,
                ),
                Y.push(0, eP, 0, eL, 1, eP, 1, eP, 0, eL, 1, eL),
                ([eE, eC, eP] = [eD, eO, eL]);
            this.setAttribute("position", new sv(U, 3)),
              this.setAttribute("normal", new sv(k, 3)),
              this.setAttribute("uv", new sv(Y, 2));
          }
        },
        vA = class {
          static create(_) {
            return this.build(this.normalizeInputs(_));
          }
          static normalizeInputs(_, L) {
            let R = Object.assign(
              {},
              L?.parameters ?? {
                width: 100,
                depth: 0,
                innerRadiusPercent: 38.19,
                spikes: 5,
                cornerRadius: 0,
                angle: 360,
                extrudeBevelSize: 0,
                extrudeBevelSegments: 1,
              },
              _.parameters,
            );
            return {
              shape: _.shape && _.shape instanceof gL ? _.shape : new gL(),
              parameters: Object.assign(R, {
                width: Math.abs(R.width),
                height: Math.abs(R.height ?? R.width),
                depth: Math.abs(R.depth ?? 0),
              }),
            };
          }
          static build(_) {
            let {
                width: L,
                height: R,
                innerRadiusPercent: N,
                spikes: z,
                cornerRadius: F,
                angle: U,
                depth: k,
                extrudeBevelSize: Y,
                extrudeBevelSegments: X,
              } = _.parameters,
              Q = _.shape,
              K = 0.5 * L,
              J = 0.5 * R,
              $ = (U * Math.PI) / 360 / z,
              ee = -((Math.PI / 2) * 3),
              er = (K * N) / 100,
              en = (J * N) / 100;
            if (3 === z && 50 === N) {
              $ = (2 * Math.PI) / z;
              for (let _ = 0; _ < z; _++) {
                let L = $ * _,
                  R = 0 + Math.sin(L) * K,
                  N = 0 + Math.cos(L) * J;
                Q.addPoint(Q.createPoint(R, N));
              }
            } else
              for (let _ = 0; _ < z; _++) {
                let _ = 0 + Math.cos(ee) * K,
                  L = 0 + Math.sin(ee) * J;
                Q.addPoint(Q.createPoint(_, L)),
                  (ee += $),
                  (_ = 0 + Math.cos(ee) * er),
                  (L = 0 + Math.sin(ee) * en),
                  Q.addPoint(Q.createPoint(_, L)),
                  (ee += $);
              }
            Q.isClosed = !0;
            for (let _ = 0, L = Q.points.length; _ < L; _++)
              Q.points[_].roundness = F;
            return (
              (Q.roundness = F),
              Q.update(),
              Object.assign(
                gq.create({
                  shape: Q,
                  parameters: {
                    roundness: F,
                    depth: k,
                    extrudeBevelSize: Y,
                    extrudeBevelSegments: X,
                  },
                }),
                { userData: { ..._, type: "StarGeometry" } },
              )
            );
          }
        },
        vM = class {
          static create(_) {
            return this.build(this.normalizeInputs(_));
          }
          static normalizeInputs(_, L) {
            let R = Object.assign(
              {},
              L?.parameters ?? { width: 100, depth: 0 },
              _.parameters,
            );
            return {
              parameters: Object.assign(R, {
                width: Math.abs(R.width),
                height: Math.abs(R.height ?? R.width),
                depth: Math.abs(R.depth ?? 0),
              }),
            };
          }
          static build(_) {
            let { width: L, height: R } = _.parameters;
            return Object.assign(new ne(L, R), {
              userData: { ..._, type: "TextFrameGeometry" },
            });
          }
        },
        vE = class {
          static create(_) {
            return this.build(this.normalizeInputs(_));
          }
          static normalizeInputs(_, L) {
            let R = Object.assign(
                {},
                L?.parameters ?? {
                  width: 100,
                  radialSegments: 32,
                  tubularSegments: 64,
                  arc: 2 * Math.PI,
                  cornerRadius: 30,
                  cornerSegments: 8,
                },
                _.parameters,
              ),
              N = Math.abs(R.width),
              z = Math.abs(R.height ?? R.width),
              F = Math.round(Math.abs(R.depth ?? 0.25 * R.width));
            return {
              parameters: Object.assign(R, { width: N, height: z, depth: F }),
            };
          }
          static build(_) {
            var L, R, N, z, F, U;
            let {
                width: k,
                height: Y,
                depth: X,
                radialSegments: Q,
                tubularSegments: K,
                arc: J,
                cornerRadius: $,
                cornerSegments: ee,
              } = _.parameters,
              er =
                ((L = Y),
                (R = X),
                (N = 0.5 * k),
                (z = J),
                (F = 0),
                (U = $),
                ([L, R] = [R, L]),
                (F = L / 2),
                1 == (z /= 2 * Math.PI) && (U = 0),
                new gJ(!0, k, L, R, N, z, K, F, 0, Q, U, ee));
            return (
              er.scale(1, Y / k, 1),
              Object.assign(er, { userData: { ..._, type: "TorusGeometry" } })
            );
          }
        },
        vC = class {
          static create(_) {
            return this.build(this.normalizeInputs(_));
          }
          static normalizeInputs(_, L) {
            let R = Object.assign(
              {},
              L?.parameters ?? {
                width: 100,
                tubularSegments: 64,
                radialSegments: 32,
                p: 2,
                q: 3,
              },
              _.parameters,
            );
            return {
              parameters: Object.assign(R, {
                width: Math.abs(R.width),
                height: Math.abs(R.height ?? R.width),
                depth: Math.abs(R.depth ?? R.width),
                tube: R.tube ?? 0.125 * R.width,
              }),
            };
          }
          static build(_) {
            let {
                width: L,
                tube: R,
                tubularSegments: N,
                radialSegments: z,
                p: F,
                q: U,
              } = _.parameters,
              k = 0.5 * L;
            return (
              k !== R && (k -= R),
              Object.assign(new aX(k, R, N, z, F, U), {
                userData: { ..._, type: "TorusKnotGeometry" },
              })
            );
          }
        },
        vP = class {
          static create(_) {
            return this.build(this.normalizeInputs(_));
          }
          static normalizeInputs(_, L) {
            let R = Object.assign(
              {},
              L?.parameters ?? {
                width: 100,
                depth: 0,
                spikes: 5,
                cornerRadius: 0,
                extrudeBevelSize: 0,
                extrudeBevelSegments: 1,
                isRect: !1,
              },
              _.parameters,
            );
            return {
              shape: _.shape && _.shape instanceof gL ? _.shape : new gL(),
              parameters: Object.assign(R, {
                width: Math.abs(R.width),
                height: Math.abs(
                  R.height ?? R.width * (R.isRect ? 1 : Math.sqrt(3) / 2),
                ),
                depth: Math.abs(R.depth ?? 0),
              }),
            };
          }
          static build(_) {
            let {
                width: L = 100,
                height: R,
                cornerRadius: N,
                depth: z,
                extrudeBevelSize: F,
                extrudeBevelSegments: U,
                isRect: k,
              } = _.parameters,
              Y = _.shape,
              X = 0.5 * L,
              Q = 0.5 * R;
            k
              ? Y.addPoint(Y.createPoint(-X, Q))
              : Y.addPoint(Y.createPoint(0, Q)),
              Y.addPoint(Y.createPoint(X, -Q)),
              Y.addPoint(Y.createPoint(-X, -Q)),
              (Y.isClosed = !0);
            for (let _ = 0, L = Y.points.length; _ < L; _++)
              Y.points[_].roundness = N;
            return (
              (Y.roundness = N),
              Y.update(),
              Object.assign(
                gq.create({
                  shape: Y,
                  parameters: {
                    roundness: N,
                    depth: z,
                    extrudeBevelSize: F,
                    extrudeBevelSegments: U,
                  },
                }),
                { userData: { ..._, type: "TriangleGeometry" } },
              )
            );
          }
        },
        vD = class {
          static create(_) {
            return this.build(this.normalizeInputs(_));
          }
          static normalizeInputs(_, L) {
            let R = Object.assign(
                {},
                L?.parameters ?? {
                  width: 100,
                  height: 100,
                  depth: 1,
                  subdivisions: 12,
                  roundness: 0,
                  extrudeBevelSize: 0,
                  extrudeBevelSegments: 3,
                },
                _.parameters,
              ),
              N = Math.abs(R.width),
              z = Math.abs(R.height ?? R.width),
              F = Math.abs(R.depth ?? 0),
              U = L?.shapeData ?? gZ.create({ parameters: pW }).userData.shape;
            return {
              path: _.path ?? fj.defaultData(),
              parameters: Object.assign(R, {
                width: N,
                height: z,
                depth: F,
                extrusion: { ...pY, ...R.extrusion },
              }),
              shapeData: U,
            };
          }
          static build(_) {
            return _.path.points.length >= 2
              ? Object.assign(new vO(_), {
                  userData: { ..._, type: "PathGeometry" },
                })
              : Object.assign(new sP(), {
                  userData: { ..._, type: "PathGeometry" },
                });
          }
        },
        vO = class extends sP {
          constructor(_) {
            super(),
              (this.type = "PathExtrusionGeometry"),
              (this.inputs = _),
              this.build();
          }
          _isGeometryClosed() {
            return (
              this.inputs.path.isClosed &&
              1 === this.inputs.parameters.extrusion.depth
            );
          }
          _isOpenEnded() {
            let _,
              L = this.inputs.parameters.extrusion;
            return (
              !(this.inputs.path.isClosed && 1 === L.depth) ||
              ((L.twist % (_ = 2 * Math.PI)) + _) % _ != ((0 % _) + _) % _ ||
              L.startScale !== L.endScale
            );
          }
          build() {
            let _ = this._extractPathPoints();
            if (_.length < 2) return;
            let L = this._computeBasisMatrices(_),
              { depth: R, offset: N } = this.inputs.parameters.extrusion,
              z = this.inputs.path.isClosed ? _.length : _.length - 1,
              F = Math.floor(N * z),
              U = Math.min(
                Math.max(
                  2,
                  (this.inputs.path.isClosed
                    ? Math.ceil((R + N) * z)
                    : Math.ceil(Math.min(1, R + N) * z)) -
                    F +
                    1,
                ),
                z + 2,
              ),
              k = [],
              Y = [];
            for (let R = 0; R < U; R++) {
              let N = this.inputs.path.isClosed
                ? (R + F) % _.length
                : Math.min(R + F, _.length - 1);
              k.push(_[N].clone()), Y.push(L[N].clone());
            }
            let h = (_, L, R) => {
                var N, z;
                let F, U;
                (k[_] = k[_].clone().lerp(k[L], R)),
                  (Y[_] =
                    ((N = Y[_]),
                    (z = Y[L]),
                    (F = [new iq(), new iq(), new iq()]),
                    (U = [new iq(), new iq(), new iq()]),
                    N.extractBasis(F[0], F[1], F[2]),
                    z.extractBasis(U[0], U[1], U[2]),
                    F.forEach((_, L) => {
                      let N = U[L],
                        z = iE.lerp(_.length(), N.length(), R);
                      _.lerp(N, R).setLength(z);
                    }),
                    new rw().makeBasis(F[0], F[1], F[2])));
              },
              X = 0,
              Q = (N * z) % 1;
            (!this.inputs.path.isClosed || R <= 1) &&
              (Q || 0 === N) &&
              h(0, 1, (X = Q));
            let K = 0,
              J = ((N + R) * z) % 1;
            if (
              (((this.inputs.path.isClosed && R <= 1) ||
                (!this.inputs.path.isClosed && N + R < 1)) &&
                J &&
                ((K = J), h(k.length - 1, k.length - 2, 1 - K)),
              0 === R)
            ) {
              let _ = k.length - 1;
              k[_].copy(k[0]), Y[_].copy(Y[0]);
            }
            this._applyPathModifiers(Y, X, K);
            let {
                regions: $,
                infos: ee,
                vertices: er,
              } = this._computeShapePoints(5),
              en = 0,
              ea = 0;
            ee.sort((_, L) => _.start - L.start),
              ee.forEach((_) => {
                (_.verticesStart = en),
                  (_.verticesCount = _.continuous.reduce(
                    (_, L, R) => _ + (0 !== R && L ? 1 : 2),
                    0,
                  )),
                  (ea += _.verticesCount),
                  (en = ea);
              });
            let eo = ea * U,
              el,
              ec = 0;
            if (this._isOpenEnded()) {
              try {
                el = Ui({
                  windingRule: vp.ODD,
                  elementType: vf.POLYGONS,
                  polySize: 3,
                  vertexSize: 2,
                  strict: !0,
                  contours: $,
                });
              } catch {
                el = gH;
              }
              ec = el.vertexCount;
            }
            let ed = eo + 2 * ec,
              eu = {
                positions: new Float32Array(3 * ed),
                normals: new Float32Array(3 * ed),
                uvs: new Float32Array(2 * ed),
              },
              ep = [];
            ee.forEach((_) => {
              this._extrudeRegion(
                _,
                er,
                Y,
                k,
                eu,
                ep,
                this._isGeometryClosed() && !this._isOpenEnded(),
              );
            }),
              el &&
                (this._closeEnd(el, eo, ep, eu, Y[0], k[0], !1),
                this._closeEnd(
                  el,
                  eo + ec,
                  ep,
                  eu,
                  Y[Y.length - 1],
                  k[k.length - 1],
                  !0,
                )),
              this.setAttribute("position", new sh(eu.positions, 3)),
              this.setAttribute("normal", new sh(eu.normals, 3)),
              this.setAttribute("uv", new sh(eu.uvs, 2)),
              this.setIndex(ep);
          }
          _extractPathPoints() {
            let _ = sg(this.inputs.path).getPoints(
              this.inputs.path.subdivisions,
            );
            if (_.length < 2) return [];
            let L = [_[0]];
            return (
              _.forEach((_) => {
                L[L.length - 1].distanceToSquared(_) > 0.001 && L.push(_);
              }),
              this.inputs.path.isClosed &&
                0.001 > L[L.length - 1].distanceTo(L[0]) &&
                L.pop(),
              L
            );
          }
          _computeBasisMatrices(_) {
            let L = [],
              R = _.length,
              N = this.inputs.path.isClosed,
              z = new iq(),
              F = new iq(),
              U = new iq(),
              k = new iq(),
              Y = new iq(0, 1, 0);
            for (let X = 0; X < R; X++) {
              let Q,
                K = _[X],
                J;
              (J =
                0 === X
                  ? N
                    ? _[_.length - 2]
                    : K.clone().multiplyScalar(2).sub(_[1])
                  : _[X - 1]),
                (Q =
                  X === R - 1
                    ? N
                      ? _[1]
                      : K.clone()
                          .multiplyScalar(2)
                          .sub(_[X - 1])
                    : _[X + 1]);
              let $ = K.clone().sub(J).normalize(),
                ee = Q.clone().sub(K).normalize(),
                er = $.clone().add(ee).normalize();
              U.copy(er),
                0 === X &&
                  (er.equals(Y) || er.clone().negate().equals(Y)) &&
                  Y.set(0, 0, 1);
              let en = Y.clone().cross(er).normalize(),
                ea = er.clone().cross(en).normalize();
              Y.copy(ea), k.copy(en), 0 === X && (z.copy(ea), F.copy(er));
              let eo = new rw().makeBasis(en, ea, er);
              L.push(eo);
            }
            let X = N ? F : U,
              Q = N ? z : new iq(0, 1, 0),
              K = X.clone().cross(k).normalize(),
              J = Math.acos(Q.dot(K));
            if (isNaN(J)) return L;
            let $ = Q.clone().cross(K);
            X.dot($) > 0 && (J *= -1);
            for (let _ = 1; _ < L.length; _++) {
              let R = new rw().makeRotationZ((J * _) / L.length);
              L[_].multiply(R);
            }
            return L;
          }
          _applyPathModifiers(_, L, R) {
            let N = _.length,
              {
                angle: z,
                twist: F,
                startScale: U,
                endScale: k,
              } = this.inputs.parameters.extrusion,
              Y = new rw(),
              X = new rw();
            return (
              _.forEach((_, Q) => {
                let K =
                  0 === Q
                    ? 0
                    : Q === N - 1
                      ? 1
                      : (Q - L) / (N - (0 === R ? 0 : 1) - (L + (1 - R)));
                Y.makeRotationZ(iE.lerp(z, z + F, K));
                let J = iE.lerp(U, k, K);
                X.makeScale(J, J, J), _.multiply(Y).multiply(X);
              }),
              _
            );
          }
          _computeShapePoints(_ = 12, L = vp.ODD) {
            let R,
              N = this.inputs.shapeData,
              z = N.extractShapePointsToFlatArray([], _),
              F = N.shapeHoles.map((L) => {
                let R = L.extractShapePointsToFlatArray([], _),
                  N = [];
                for (let _ = R.length - 1; _ >= 1; _ -= 2) {
                  let L = R[_ - 1],
                    z = R[_ - 0];
                  N.push(L, z);
                }
                return N;
              }),
              U;
            try {
              U = Ui({
                windingRule: L,
                elementType: vf.BOUNDARY_CONTOURS,
                vertexSize: 2,
                strict: !0,
                contours: [z],
              });
            } catch {
              U = gG;
            }
            try {
              R = Ui({
                windingRule: vp.ODD,
                elementType: vf.BOUNDARY_CONTOURS,
                vertexSize: 2,
                strict: !0,
                contours: [...F],
              });
            } catch {
              R = gV;
            }
            if (!U) throw Error("error generating geometry");
            let k = U.elementCount;
            if (R) {
              U.elementCount += R.elementCount;
              for (let _ = 0; _ < R.elements.length; _++) {
                let L = R.elements[_],
                  N = _ % 2 == 0 ? U.vertexCount : 0;
                U.elements.push(L + N);
              }
              for (let _ = 0; _ < R.vertexIndices.length; _++) {
                let L = R.vertexIndices[_],
                  N = U.vertexCount;
                U.vertexIndices.push(L + N);
              }
              for (let _ = 0; _ < R.vertices.length; _++) {
                let L = R.vertices[_];
                U.vertices.push(L);
              }
            }
            let Y = 1 / 0,
              X = -1 / 0,
              Q = 1 / 0,
              K = -1 / 0;
            for (let _ = 0, L = U.vertexCount; _ < L; _++) {
              let L = 2 * _,
                R = U.vertices[L + 0],
                N = U.vertices[L + 1];
              R < Y && (Y = R),
                R > X && (X = R),
                N < Q && (Q = N),
                N > K && (K = N);
            }
            let J = [];
            for (let _ = U.elementCount - 1; _ >= 0; _--) {
              let L = _ >= k,
                R = 2 * _,
                z = U.elements[R + 0],
                F = U.elements[R + 1],
                Y = z + F,
                X = {
                  start: z,
                  count: F,
                  normals: [],
                  isHole: L,
                  continuous: [],
                  verticesStart: 0,
                  verticesCount: 0,
                };
              J.push(X);
              let Q = z,
                K = Y - 1,
                $ = z + 1,
                ee = N.roundedCurves.length;
              do {
                let _ = Q - z,
                  R = U.vertices[2 * K + 0],
                  k = U.vertices[2 * K + 1],
                  J = U.vertices[2 * Q + 0],
                  er = U.vertices[2 * Q + 1],
                  en = U.vertices[2 * $ + 0],
                  ea = U.vertices[2 * $ + 1],
                  eo = J - R,
                  el = er - k,
                  ec = Math.sqrt(eo * eo + el * el);
                (eo /= ec), (el /= ec);
                let ed = J - en,
                  eu = er - ea,
                  ep = Math.sqrt(ed * ed + eu * eu);
                (ed /= ep),
                  (eu /= ep),
                  (X.normals[2 * _ + 0] = -eu),
                  (X.normals[2 * _ + 1] = ed);
                let ef = U.vertexIndices[Q];
                if (Array.isArray(ef)) X.continuous[_] = !1;
                else {
                  let [L, R] = N.getCurveIndexFromVertexId(ef - 1, !0);
                  if (R > 0 && R < 1) X.continuous[_] = !0;
                  else {
                    let z = 1 === R ? L + 1 : L - 1;
                    z = (z + ee) % ee;
                    let F = 1 === R ? 0 : 1,
                      U = N.roundedCurves[L].getTangent(R),
                      k = N.roundedCurves[z].getTangent(F);
                    X.continuous[_] = U.dot(k) > 0.95;
                  }
                }
                L &&
                  ((X.normals[2 * _ + 0] *= -1), (X.normals[2 * _ + 1] *= -1)),
                  ([K, Q, $] = [Q, $, $ + 1]),
                  $ >= Y && ($ -= F);
              } while ($ !== z + 1);
            }
            return { regions: [z, ...F], infos: J, vertices: U.vertices };
          }
          _insertVertex(_, L, R, N, z) {
            let F = 2 * L,
              U = 3 * L;
            (_.positions[U + 0] = R.x),
              (_.positions[U + 1] = R.y),
              (_.positions[U + 2] = R.z),
              (_.normals[U + 0] = N.x),
              (_.normals[U + 1] = N.y),
              (_.normals[U + 2] = N.z),
              (_.uvs[F + 0] = z.x),
              (_.uvs[F + 1] = z.y);
          }
          _extrudeRegion(_, L, R, N, z, F, U) {
            let k = new iq(),
              Y = new iq(),
              X = new iq(),
              Q = new iq(),
              K = new iT();
            R.forEach((F, U) => {
              let J = N[U],
                $ = _.verticesStart * R.length + _.verticesCount * U;
              for (let N = 0; N < _.count; N++) {
                let ee = (_.start + N) * 2;
                if (
                  (k.set(L[ee + 0], L[ee + 1], 0),
                  X.copy(k).applyMatrix4(F).add(J),
                  _.continuous[N])
                )
                  Q.set(_.normals[2 * N + 0], _.normals[2 * N + 1], 0);
                else {
                  let R = 0 == N ? (_.start + _.count - 1) * 2 : ee - 2;
                  Y.set(L[R + 0], L[R + 1], 0),
                    Q.copy(k).sub(Y),
                    Q.set(-Q.y, Q.x, 0),
                    _.isHole || Q.negate();
                }
                if (
                  (Q.applyMatrix4(F).normalize(),
                  K.set(0 === N ? 1 : N / _.count, U / (R.length - 1)),
                  this._insertVertex(z, $, X, Q, K),
                  $++,
                  !_.continuous[N] || 0 === N)
                ) {
                  if (0 === N)
                    Q.set(_.normals[2 * N + 0], _.normals[2 * N + 1], 0),
                      K.set(0, U / (R.length - 1));
                  else {
                    let R = N === _.count - 1 ? 2 * _.start : ee + 2;
                    Y.set(L[R + 0], L[R + 1], 0),
                      Q.copy(Y).sub(k),
                      Q.set(-Q.y, Q.x, 0),
                      _.isHole || Q.negate();
                  }
                  Q.applyMatrix4(F).normalize(),
                    this._insertVertex(z, $, X, Q, K),
                    $++;
                }
              }
            });
            let J = R.length - 1;
            for (let L = 0; L < J; L++) {
              let N = _.verticesStart * R.length + _.verticesCount * L,
                z = _.verticesStart * R.length + _.verticesCount * (L + 1),
                U = 0;
              for (let L = 0; L < _.count; L++) {
                (!_.continuous[L] || 0 === L) && U++;
                let R = L === _.count - 1 ? 0 : U + 1,
                  k = N + U,
                  Y = N + R,
                  X = z + R,
                  Q = z + U;
                _.isHole ? F.push(k, X, Y, k, Q, X) : F.push(k, Y, X, k, X, Q),
                  U++;
              }
            }
          }
          _closeEnd(_, L, R, N, z, F, U) {
            let k = _.vertexCount,
              Y = new iq(0, 0, U ? -1 : 1).applyMatrix4(z),
              X = new iq(),
              Q = new iT();
            for (let R = 0; R < k; R++) {
              let U = 2 * R;
              X.set(_.vertices[U + 0], _.vertices[U + 1], 0)
                .applyMatrix4(z)
                .add(F),
                this._insertVertex(N, L + R, X, Y, Q);
            }
            let K = _.elements;
            for (let N = 0; N < _.elementCount; N++) {
              let _ = 3 * N,
                z = K[_ + 0] + L,
                F = K[_ + (U ? 1 : 2)] + L,
                k = K[_ + (U ? 2 : 1)] + L;
              R.push(z, F, k);
            }
          }
        },
        vL = class extends sP {
          constructor(_, L) {
            super(),
              (this.charWidths = []),
              (this.charCoords = []),
              (this.wrappedText = []),
              (this.isLowResolution = !1),
              (this.vectorShapes = []),
              (this.userData = { parameters: _, type: "TextGeometry" });
            let R = L.getFont(_.font);
            R?.isLoaded
              ? ((this.font = R), this.update(_))
              : this.updateFont(_.font, L).then(() => {
                  this.update(_), L?.requestRender();
                });
          }
          async updateFont(_, L) {
            let R = L.getFont(_);
            R && ((this.font = R), await R.loadingPromise);
          }
          update(_) {
            let L,
              R = this.font;
            if (
              ((this.userData = { parameters: _, type: "TextGeometry" }),
              !R?.isLoaded)
            ) {
              console.warn("Cannot update text because its font is not loaded");
              return;
            }
            let {
                width: N,
                height: z,
                depth: F,
                extrudeBevelSize: U,
                extrudeBevelSegments: k,
                text: Y,
                textTransform: X,
              } = _,
              Q = (function (_, L, R) {
                R = R ?? _.text;
                let N = [""],
                  z = "";
                for (let F of R)
                  (z += F),
                    " " === F ||
                    F ===
                      `
`
                      ? ((N[N.length - 1] += z),
                        (z = ""),
                        F ===
                          `
` && N.push(""))
                      : L.getTextWidth(N[N.length - 1] + z, _) > _.width &&
                        (N[N.length - 1].length && N.push(""),
                        L.getTextWidth(N[N.length - 1] + z, _) > _.width &&
                          (1 === z.length
                            ? ((N[N.length - 1] += z), (z = ""))
                            : ((N[N.length - 1] += z.slice(0, -1)),
                              (z = z[z.length - 1]),
                              N.push(""))));
                return (N[N.length - 1] += z), N;
              })(
                _,
                R,
                2 === X ? Y.toUpperCase() : 3 === X ? Y.toLowerCase() : Y,
              ),
              {
                shapes: K,
                charWidths: J,
                charCoords: $,
              } = R.generateShapes(Q, _),
              ee = K.map((_) => new gL().fromShape(_));
            this.vectorShapes = ee;
            let er = ee.map((_) =>
                gq.create({
                  shape: _,
                  parameters: {
                    depth: F,
                    extrudeBevelSegments: k,
                    extrudeBevelSize: U,
                    windingRule: F <= 0 ? vp.NONZERO : vp.ODD,
                    subdivisions: this.isLowResolution && F > 0 ? 1 : 12,
                  },
                }),
              ),
              en = er.length
                ? no(er)
                : ((L = new sP()).setAttribute(
                    "position",
                    new sh(new Float32Array([]), 3),
                  ),
                  L.setIndex(new sh(new Uint16Array([]), 1)),
                  L);
            en.translate(-(0.5 * N), 0.5 * z, 0),
              this.dispose(),
              (this.wrappedText = Q),
              (this.charCoords = $),
              (this.charWidths = J),
              this.deleteAttribute("extrudeNormal"),
              Object.entries(en.attributes).forEach(([_, L]) => {
                this.setAttribute(_, L);
              }),
              this.setIndex(en.index),
              this.computeBoundingSphere();
          }
          clone() {
            let _ = Ri(new sP(), vL.prototype);
            return _.copy(this), console.log("CloneGeometry", this, _), _;
          }
          copy(_) {
            return (
              Object.entries(_.attributes).forEach(([_, L]) => {
                this.setAttribute(_, L);
              }),
              this.setIndex(_.index),
              (this.userData = {
                parameters: { ..._.userData.parameters },
                type: "TextGeometry",
              }),
              this
            );
          }
          async setText(_) {
            this.font && (await this.font.loadingPromise),
              await this.update({ ...this.userData.parameters, text: _ });
          }
          get text() {
            return this.userData.parameters.text ?? "";
          }
        },
        vR = new Promise((_) => {
          vm = _;
        }),
        vI = !1;
      async function rC() {
        if (vI) return;
        let [_, L] = await Promise.all([
            R.e(6256).then(R.bind(R, 86256)),
            fetch(
              "https://unpkg.com/@splinetool/modelling-wasm@0.9.291/build/process.wasm",
            ).then((_) => _.arrayBuffer()),
          ]),
          N = _.default,
          z = await N({ wasmBinary: L });
        vm(z), (vI = !0);
      }
      function il(_, L, R) {
        let N,
          z = { parameters: _, type: _.type };
        if ("PathGeometry" === _.type) z.path = _.path;
        else if ("VectorGeometry" === _.type) {
          let L = gL.createFromState(_.shape, _.width, _.height);
          z.shape = L;
        } else if ("NonParametricGeometry" === _.type)
          _.data.groups &&
            _.data.groups.forEach(
              (_) => (_.materialIndex = Math.max(_.materialIndex ?? 0, 0)),
            ),
            (z.geometry = new oM().parse(_));
        else {
          if ("SubdivGeometry" === _.type) return new vG(_, R);
          if ("TextGeometry" === _.type) return new vL(_, L);
        }
        try {
          N = lb(z);
        } catch (_) {
          console.error(_);
        }
        if (!N) {
          let _ = gL.createFromState(fk.defaultData(), 100, 100);
          (z.shape = _), (N = lb(z));
        }
        return N;
      }
      var vB = new rw();
      function Ih(_, L, R, N) {
        let z = _.position.array,
          F = _.normal.array,
          U = vB.makeScale(L, R, N).invert().elements,
          k,
          Y,
          X;
        for (var Q = 0, K = z.length; Q < K; Q += 3)
          (z[Q] *= L),
            (z[Q + 1] *= R),
            (z[Q + 2] *= N),
            (k = F[Q]),
            (Y = F[Q + 1]),
            (X = F[Q + 2]),
            (F[Q] = U[0] * k + U[4] * Y + U[8] * X),
            (F[Q + 1] = U[1] * k + U[5] * Y + U[9] * X),
            (F[Q + 2] = U[2] * k + U[6] * Y + U[10] * X);
        (_.position.needsUpdate = !0), (_.normal.needsUpdate = !0);
      }
      var vN,
        vz = new iK(),
        vF = new iq();
      vR.then((_) => {
        vN = _;
      });
      var vU = new Float32Array([
          10, 10, 0, -10, 10, 0, -10, -10, 0, 10, -10, 0,
        ]),
        vk = new Uint32Array([0, 1, 2, 3]),
        vj = new Uint8Array([4]),
        vG = class extends sP {
          constructor(_, L) {
            super(),
              (this.data = _),
              (this.flatShading = L),
              (this.subdivPointer = 0),
              this.rebuild(),
              this.freeSubdivPointer();
          }
          mutateDirectlyScaleBaked(_, L) {
            this.freeSubdivPointer();
            let R = this.data.scaleBaked,
              N = pf.div(L, R);
            this.subdividedGeometry &&
              Ih(this.subdividedGeometry.attributes, ...N),
              this.originalGeometry &&
                Ih(this.originalGeometry.attributes, ...N),
              (this.data = _);
            let z = this.userData.parameters;
            (this.userData.parameters = {
              width: z.width * N[0],
              height: z.height * N[1],
              depth: z.depth * N[2],
            }),
              this.originalGeometry.boundingSphere.center.multiply(
                vF.fromArray(N),
              );
            let F = vF.set(z.width, z.height, z.depth).length();
            this.originalGeometry.boundingSphere.radius = F / 2;
          }
          ensureSubdivPointer() {
            return (
              0 === this.subdivPointer && this.rebuild(), this.subdivPointer
            );
          }
          rebuild() {
            let _, L, R;
            try {
              ({
                originalGeometry: _,
                subdividedGeometry: L,
                subdivPointer: R,
              } = vG.build(this.data, void 0, !this.flatShading, void 0));
            } catch {
              (_ = new sW(100, 100, 100)), (R = 0);
            }
            (this.subdivPointer = R),
              (this.originalGeometry = _),
              (this.subdividedGeometry = L ?? void 0),
              Object.assign(
                this,
                this.subdividedGeometry ?? this.originalGeometry,
              ),
              this.calcBoundingBox();
          }
          freeSubdivPointer() {
            this.subdivPointer &&
              (vG.freeSubdivPointer(this.subdivPointer),
              (this.subdivPointer = 0));
          }
          dispose() {
            super.dispose(), this.freeSubdivPointer();
          }
          calcBoundingBox() {
            let _ = this.originalGeometry;
            null === _.boundingSphere &&
              ((_.boundingSphere = new ro()),
              this.subdividedGeometry &&
                (this.subdividedGeometry.boundingSphere = _.boundingSphere));
            let L = _.attributes.position,
              R = _.boundingSphere.center;
            vz.setFromBufferAttribute(L),
              vz.getCenter(R),
              (_.boundingSphere.radius = R.distanceTo(vz.max)),
              isNaN(_.boundingSphere.radius) &&
                console.error(
                  'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
                  this,
                ),
              vz.getSize(vF);
            let N = { width: vF.x, height: vF.y, depth: vF.z };
            return (this.userData.parameters = N), N;
          }
          static build(_, L, R, N) {
            let z,
              F,
              U,
              k = _?.phongAngle ?? 35;
            !1 === R && (k = -1),
              L && (vN.free_bvh(L), vN.free_subdivision_surface(L));
            try {
              z = vG.allocate(_, N);
            } catch (L) {
              console.error(L, _),
                (z = vG.allocate(
                  { positionWASM: vU, indexWASM: vk, verticesPerFaceWASM: vj },
                  N,
                ));
            }
            if (
              (vN.set_destination_refinement_level(z, 0),
              (F = vG.buildLevel(z, !0, k)),
              _.subdivisions > 0)
            )
              try {
                vN.set_destination_refinement_level(z, _.subdivisions),
                  (U = vG.buildLevel(z, !1, k));
              } catch {
                try {
                  vN.set_destination_refinement_level(z, _.subdivisions - 1),
                    (U = vG.buildLevel(z, !1, k));
                } catch {
                  U = null;
                }
              }
            else U = null;
            return {
              subdivPointer: z,
              originalGeometry: F,
              subdividedGeometry: U,
            };
          }
          static primitiveToQuads(_, L, R) {
            let N, z, F, U, k, Y;
            if (
              (_.widthSegments > 16 && (_.widthSegments = 16),
              _.heightSegments > 16 && (_.heightSegments = 16),
              _.depthSegments > 16 && (_.depthSegments = 16),
              _.radialSegments > 16 && (_.radialSegments = 16),
              "DodecahedronGeometry" === _.type && (_.detail = 0),
              "TorusGeometry" === _.type && _.arc === 2 * Math.PI)
            ) {
              let {
                width: L,
                height: R,
                depth: z,
                arc: F,
                tubularSegments: U,
                radialSegments: k,
              } = _;
              N = new gJ(
                !0,
                L,
                z,
                R,
                0.5 * L,
                F / (2 * Math.PI),
                U,
                z / 2,
                0,
                k,
                0,
                0,
                !0,
              );
            } else N = void 0 !== _.shape ? L.geometry : il(_, R, !1);
            if (
              (({ positions: z, triIndices: k } = Dh(
                N.getAttribute("position"),
                N.getIndex(),
              )),
              "CylinderGeometry" === _.type &&
                0 === _.cornerRadius &&
                0 === _.hollow &&
                !1 === _.openEnded)
            ) {
              let L = _.radialSegments * _.heightSegments * 6,
                R = L + 3 * _.radialSegments;
              Y = [L, R];
            }
            return (
              ({ indices: F, verticesPerFace: U } = hb(z, k, N, Y)),
              { positions: z, indices: F, verticesPerFace: U }
            );
          }
          static allocate(_, L) {
            let R,
              N,
              z,
              F,
              U = [],
              k = [];
            _.positionWASM && _.positionWASM.length > 0
              ? ((N = _.positionWASM),
                (z = _.indexWASM),
                (F = _.verticesPerFaceWASM))
              : ((N = vU), (z = vk), (F = vj));
            let Y = N.length,
              X = z.length,
              Q = F.length,
              K = N.length + U.length + k.length,
              J = z.length + F.length,
              $ =
                K * Float32Array.BYTES_PER_ELEMENT +
                J * Uint32Array.BYTES_PER_ELEMENT,
              ee = K * Float32Array.BYTES_PER_ELEMENT,
              er = (Uint32Array.BYTES_PER_ELEMENT, vN._malloc($)),
              en = new Float32Array(vN.HEAPF32.buffer, er, K),
              ea = new Uint32Array(vN.HEAPU32.buffer, er + ee, J);
            en.set(N, 0),
              en.set(U, N.length),
              en.set(k, N.length + U.length),
              ea.set(z, 0),
              ea.set(F, z.length),
              _?.scaleBaked?.some((_) => 1 !== _) &&
                (R = new rw().makeScale(..._.scaleBaked)),
              L && (R ? R.premultiply(L) : (R = L));
            let eo = R
              ? vN.alloc_subdivision_surface2(
                  er,
                  Y,
                  er + ee,
                  X,
                  er + ee + z.length * Uint32Array.BYTES_PER_ELEMENT,
                  Q,
                  R.elements,
                )
              : vN.alloc_subdivision_surface(
                  er,
                  Y,
                  er + ee,
                  X,
                  er + ee + z.length * Uint32Array.BYTES_PER_ELEMENT,
                  Q,
                );
            return vN._free(er), eo;
          }
          static buildLevel(_, L, R, N, z) {
            let F = z
                ? vN.get_mesh_data2(
                    _,
                    L ? vN.Level.CONTROL : vN.Level.REFINED,
                    R,
                    z.elements,
                  )
                : vN.get_mesh_data(
                    _,
                    L ? vN.Level.CONTROL : vN.Level.REFINED,
                    R,
                  ),
              U = vN.HEAPU32.subarray(F >> 2, (F >> 2) + 8),
              k = U.subarray(4, 8),
              Y = 0,
              X = vN.HEAPU32[U[Y] >> 2],
              Q = vN.HEAPF32.subarray(X >> 2, (X >> 2) + k[Y]);
            Y++;
            let K = vN.HEAPU32[U[Y] >> 2],
              J = vN.HEAPF32.subarray(K >> 2, (K >> 2) + k[Y]);
            Y++;
            let $ = vN.HEAPU32[U[Y] >> 2],
              ee = vN.HEAPU32.subarray($ >> 2, ($ >> 2) + k[Y]);
            Y++;
            let er = vN.HEAPU32[U[Y] >> 2],
              en = vN.HEAPU32.subarray(er >> 2, (er >> 2) + k[Y]);
            if ((Y++, void 0 === N)) {
              let _ = new sP();
              if (
                (_.setIndex(new sp(en, 1)),
                _.setAttribute("position", new sv(Q, 3)),
                _.setAttribute("normal", new sv(J, 3)),
                L)
              ) {
                _.setAttribute("faceMap", new sp(ee, 1));
                let L = new Float32Array((J.length / 3) * 4).fill(0);
                _.setAttribute("color", new sh(L, 4));
              }
              return (
                vN.free_mesh_data(F), (_.userData.type = "SubdivGeometry"), _
              );
            }
            N.getAttribute("position").copyArray(Q),
              N.getAttribute("normal").copyArray(J),
              (N.attributes.position.needsUpdate = !0),
              (N.attributes.normal.needsUpdate = !0),
              vN.free_mesh_data(F);
          }
          static freeSubdivPointer(_) {
            vN.free_bvh(_), vN.free_subdivision_surface(_);
          }
          static buildControlCageWireframe(_, L, R) {
            let N = vN.get_wireframe_data_for_base_level(_),
              z = vN.HEAPU32.subarray(N >> 2, (N >> 2) + 4),
              F = z.subarray(2, 4),
              U = 0,
              k = vN.HEAPU32[z[U] >> 2],
              Y = vN.HEAPF32.subarray(k >> 2, (k >> 2) + F[U]);
            U++;
            let X = vN.HEAPU32[z[U] >> 2],
              Q = vN.HEAPU32.subarray(X >> 2, (X >> 2) + F[U]);
            if (void 0 === L) {
              let _ = new sP();
              _.setAttribute("position", new sv(Y, 3));
              let L = new Float32Array(Y.length);
              for (let _ = 0, N = Y.length; _ < N; )
                (L[_++] = R.r), (L[_++] = R.g), (L[_++] = R.b);
              return (
                _.setAttribute("color", new sh(L, 3)),
                _.setIndex(new sp(Q, 1)),
                vN.free_wireframe_data_for_base_level(N),
                _
              );
            }
            L.getAttribute("position").copyArray(Y),
              (L.attributes.position.needsUpdate = !0),
              vN.free_wireframe_data_for_base_level(N);
          }
          static updateCollabMesh(_, L, R) {
            let N = 0 === L;
            N || vN.set_destination_refinement_level(_, L);
            let z = R
                ? vN.get_topological_data2(
                    _,
                    N ? vN.Level.CONTROL : vN.Level.REFINED,
                    R.elements,
                  )
                : vN.get_topological_data(
                    _,
                    N ? vN.Level.CONTROL : vN.Level.REFINED,
                  ),
              F = vN.HEAPU32.subarray(z >> 2, (z >> 2) + 6),
              U = F.subarray(3, 6),
              k = 0,
              Y = vN.HEAPU32[F[k] >> 2],
              X = new Float32Array(
                vN.HEAPF32.subarray(Y >> 2, (Y >> 2) + U[k]),
              );
            k++;
            let Q = vN.HEAPU32[F[k] >> 2],
              K = new Uint32Array(vN.HEAPU32.subarray(Q >> 2, (Q >> 2) + U[k]));
            k++;
            let J = vN.HEAPU32[F[k] >> 2],
              $ = new Uint8Array(vN.HEAPU32.subarray(J >> 2, (J >> 2) + U[k]));
            return (
              vN.free_topological_data(z),
              { positions: X, indices: K, verticesPerFace: $ }
            );
          }
        },
        vV = ["getX", "getY", "getZ"];
      function Dh(_, L) {
        let R = {},
          N = L ? L.count : _.count,
          z = 0,
          F = [],
          U = [];
        for (let k = 0; k < N; k++) {
          let N = L ? L.getX(k) : k,
            Y = "";
          for (let L = 0; L < 3; L++) Y += `${~~(1e4 * _[vV[L]](N))},`;
          if (Y in R) F.push(R[Y]);
          else {
            for (let L = 0; L < 3; L++) U.push(_[vV[L]](N));
            (R[Y] = z), F.push(z), z++;
          }
        }
        let k = [];
        for (let _ = 0; _ < F.length; _ += 3)
          F[_] === F[_ + 1] ||
            F[_] === F[_ + 2] ||
            F[_ + 1] === F[_ + 2] ||
            k.push(F[_], F[_ + 1], F[_ + 2]);
        return { positions: U, triIndices: k };
      }
      var vH = new iq(),
        vW = new iq(),
        vY = new iq(),
        vX = new iq();
      function hb(_, L, R, N) {
        let z = [],
          F = [];
        if (
          void 0 !== R.userData.shape &&
          0 === R.userData.parameters.depth &&
          0 === R.userData.shape.shapeHoles.length
        ) {
          let L = R.userData.shape.extractShapePointsToFlatArray([]),
            N = R.userData.parameters.spikes;
          if (
            "EllipseGeometry" === R.userData.type &&
            N <= 24 &&
            N % 4 == 0 &&
            R.userData.parameters.angle >= 360
          ) {
            let _ = L.length / 2 / N;
            L = L.filter((L, R) => Math.floor(R / 2) % _ == 0);
          }
          let U = 0;
          for (let _ = 0; _ < L.length; _ += 2)
            U +=
              (L[_] - L[(0 === _ ? L.length : _) - 2]) *
              (L[_ + 1] + L[(0 === _ ? L.length : _) - 1]);
          _.length = 0;
          let k = 0;
          if (U < 0)
            for (let R = 0; R < L.length; R += 2)
              _.push(L[R], L[R + 1], 0), z.push(k++);
          else
            for (let R = L.length - 2; R >= 0; R -= 2)
              _.push(L[R], L[R + 1], 0), z.push(k++);
          return F.push(k), { indices: z, verticesPerFace: F };
        }
        for (let U = 0, k = R.capStartIndex ?? L.length; U < k; )
          (L[U + 1] === L[U + 3] && L[U + 2] === L[U + 5]) ||
          (L[U + 0] === L[U + 3] && L[U + 2] === L[U + 4])
            ? (vH.set(_[3 * L[U]], _[3 * L[U] + 1], _[3 * L[U] + 2]),
              vW.set(_[3 * L[U + 1]], _[3 * L[U + 1] + 1], _[3 * L[U + 1] + 2]),
              vY.set(_[3 * L[U + 4]], _[3 * L[U + 4] + 1], _[3 * L[U + 4] + 2]),
              vX.set(_[3 * L[U + 5]], _[3 * L[U + 5] + 1], _[3 * L[U + 5] + 2]),
              vW.sub(vH).normalize(),
              vY.sub(vH).normalize(),
              vX.sub(vH).normalize(),
              Math.abs(vW.cross(vY).dot(vX)) > 0.005 ||
              (N && N.some((_, L) => L % 2 != 1 && U >= N[L] && U < N[L + 1]))
                ? (z.push(L[U], L[U + 1], L[U + 2]), F.push(3), (U += 3))
                : (z.push(L[U], L[U + 1], L[U + 4], L[U + 5]),
                  F.push(4),
                  (U += 6)))
            : (z.push(L[U], L[U + 1], L[U + 2]), F.push(3), (U += 3));
        if (void 0 !== R.capStartIndex) {
          let L = [],
            N = [],
            U = 0,
            k = new Float32Array([R.userData.parameters.depth])[0];
          for (let R = 0, z = 0; R < _.length; R += 3, z++)
            0 === _[R + 2] && (L.push(z), U++), _[R + 2] === k && N.push(z);
          if (0 === R.userData.parameters.extrudeBevelSize) {
            let _ = N[0];
            (N[0] = N[1]), (N[1] = _);
          }
          L.reverse(), z.push(...L, ...N), F.push(U, U);
        }
        return { indices: z, verticesPerFace: F };
      }
      var vq = {};
      ((_, L) => {
        for (var R in L) t6(_, R, { get: L[R], enumerable: !0 });
      })(vq, {
        calcBoolean: () => TH,
        calcBooleanTopological: () => _H,
        freeMeshSet: () => CH,
        getMeshSet: () => EH,
        transformMeshSet: () => MH,
      });
      var vQ,
        vZ = new Promise((_) => {
          vQ = _;
        }),
        vK = !1;
      async function dC() {
        if (vK) return;
        let [_, L] = await Promise.all([
            R.e(6669).then(R.bind(R, 76669)),
            fetch(
              "https://unpkg.com/@splinetool/boolean-wasm@0.9.291/build/boolean.wasm",
            ).then((_) => _.arrayBuffer()),
          ]),
          N = _.default,
          z = await N({ wasmBinary: L });
        vQ(z), (vK = !0);
      }
      function hC(_) {
        let L = _.length,
          R = L * Uint32Array.BYTES_PER_ELEMENT,
          N = L * Float32Array.BYTES_PER_ELEMENT,
          z = Number.isInteger(_[0]) ? R : N,
          F = xt._malloc(z);
        return (
          (Number.isInteger(_[0])
            ? new Uint32Array(xt.HEAPU32.buffer, F, L)
            : new Float32Array(xt.HEAPF32.buffer, F, L)
          ).set(_, 0),
          F
        );
      }
      function fC(_) {
        switch (_) {
          case 0:
            return xt.OP.UNION;
          case 1:
            return xt.OP.INTERSECTION;
          case 2:
            return xt.OP.A_MINUS_B;
          case 3:
            return xt.OP.B_MINUS_A;
          case 4:
            return xt.OP.SYMMETRIC_DIFFERENCE;
          case 5:
            return xt.OP.ALL;
          default:
            throw Error("Unknown boolean operation " + _);
        }
      }
      function _H(_, L) {
        void 0 === xi && (xi = xt.init_csg());
        let R = hC(_),
          N = xt.csg_calc_topological(xi, R, _.length, fC(L));
        xt._free(R);
        let z = xt.HEAPU32.subarray(N >> 2, (N >> 2) + 6),
          F = z.subarray(3, 6),
          U = 0,
          k = xt.HEAPU32[z[U] >> 2],
          Y = new Float32Array(xt.HEAPF32.subarray(k >> 2, (k >> 2) + F[U]));
        U++;
        let X = xt.HEAPU32[z[U] >> 2],
          Q = new Uint32Array(xt.HEAPU32.subarray(X >> 2, (X >> 2) + F[U]));
        U++;
        let K = xt.HEAPU32[z[U] >> 2],
          J = new Uint8Array(xt.HEAPU32.subarray(K >> 2, (K >> 2) + F[U]));
        return (
          xt.free_mesh_data(N), { positions: Y, indices: Q, verticesPerFace: J }
        );
      }
      function TH(_, L, R, N) {
        void 0 === xi && (xi = xt.init_csg());
        let z = hC(_),
          F = xt.csg_calc(xi, z, _.length, N, fC(L));
        xt._free(z);
        let U = xt.HEAPU32.subarray(F >> 2, (F >> 2) + 5),
          k = U.subarray(2, 5),
          Y = 0,
          X = xt.HEAPU32[U[Y] >> 2],
          Q = xt.HEAPF32.subarray(X >> 2, (X >> 2) + k[Y]);
        Y++;
        let K = xt.HEAPU32[U[Y] >> 2],
          J = xt.HEAPF32.subarray(K >> 2, (K >> 2) + k[Y]),
          $ = k[++Y];
        R.setAttribute("position", new sv(Q, 3)),
          R.setAttribute("normal", new sv(J, 3));
        let ee = xt.HEAPF32.subarray((F >> 2) + 5, (F >> 2) + 5 + 6);
        return (
          null === R.boundingSphere && (R.boundingSphere = new ro()),
          R.boundingSphere.center.set(ee[0], ee[1], ee[2]),
          (R.boundingSphere.radius =
            (ee[3] ** 2 + ee[4] ** 2 + ee[5] ** 2) ** 0.5),
          (R.userData.parameters = {
            width: 2 * ee[3],
            height: 2 * ee[4],
            depth: 2 * ee[5],
          }),
          xt.free_mesh_data(F),
          $
        );
      }
      function EH(_, L, R) {
        let N, z, F;
        if (void 0 === xt) return -1;
        if (L && void 0 !== _.userData.positions) {
          let L = _.userData;
          (F = L.verticesPerFace.length),
            (N = L.positions),
            (z = Array(L.verticesPerFace.reduce((_, L) => _ + L, 0) + F));
          for (let _ = 0, R = 0, N = 0; _ < L.verticesPerFace.length; _++) {
            z[N++] = L.verticesPerFace[_];
            for (let F = 0; F < L.verticesPerFace[_]; F++)
              z[N++] = L.indices[R++];
          }
        } else
          ({
            positions: N,
            faceIndices: z,
            nFaces: F,
          } = (function (_, L, R) {
            let N,
              { positions: z, triIndices: F } = Dh(
                _.getAttribute("position"),
                _.getIndex(),
              ),
              U;
            if (L && R) {
              let { indices: L, verticesPerFace: R } = hb(z, F, _);
              (U = R.length), (N = []);
              for (let _ = 0, z = 0; _ < U; _++) {
                N.push(R[_]);
                for (let F = 0; F < R[_]; F++) N.push(L[z++]);
              }
            } else {
              let _ = F.length;
              (N = Array(_ + _ / 3)), (U = 0);
              for (let _ = 0, L = 0; L < N.length; )
                (N[L++] = 3),
                  U++,
                  (N[L++] = F[_++]),
                  (N[L++] = F[_++]),
                  (N[L++] = F[_++]);
            }
            return { positions: z, faceIndices: N, nFaces: U };
          })(_, L, R));
        let U = N.length,
          k = z.length,
          Y = N.length,
          X = z.length,
          Q =
            Y * Float32Array.BYTES_PER_ELEMENT +
            X * Uint32Array.BYTES_PER_ELEMENT,
          K = Y * Float32Array.BYTES_PER_ELEMENT,
          J = (Uint32Array.BYTES_PER_ELEMENT, xt._malloc(Q)),
          $ = new Float32Array(xt.HEAPF32.buffer, J, Y),
          ee = new Uint32Array(xt.HEAPU32.buffer, J + K, X);
        return $.set(N, 0), ee.set(z, 0), xt.get_csg_mesh(J, U, J + K, k, F);
      }
      function MH(_, L) {
        xt.transform_csg_mesh(_, L.elements);
      }
      function CH(_) {
        xt.free_csg_mesh(_);
      }
      vZ.then((_) => (xt = _));
      var vJ = {
          ConeGeometry: gr,
          CubeGeometry: gs,
          CylinderGeometry: gt,
          DodecahedronGeometry: gl,
          EllipseGeometry: gZ,
          HelixGeometry: gK,
          IcosahedronGeometry: g$,
          LatheGeometry: g5,
          NonParametricGeometry: vn,
          PolygonGeometry: va,
          PyramidGeometry: vo,
          RectangleGeometry: vv,
          SphereGeometry: vy,
          PlaneGeometry: vb,
          BackdropGeometry: vw,
          StarGeometry: vA,
          TextFrameGeometry: vM,
          TorusGeometry: vE,
          TorusKnotGeometry: vC,
          TriangleGeometry: vP,
          PathGeometry: vD,
          VectorGeometry: gq,
        },
        lb = (_) => vJ[_.type].create(_);
      function Oh(_) {
        return null !== _ && "booleanOp" in _;
      }
      var v$ = class extends og(sH) {
          constructor() {
            super(...arguments),
              (this.booleanMeshSetAddress = -1),
              (this.booleanWasTransformed = !1),
              (this.booleanMatrixInvOld = new rw());
          }
          updateVisible() {
            super.updateVisible(),
              (this.visible = !Oh(this.parent) && this.visible),
              Oh(this.parent) && this.parent.invalidateDownstreamBooleanData();
          }
          freeBooleanPointer() {
            -1 !== this.booleanMeshSetAddress &&
              (vq.freeMeshSet(this.booleanMeshSetAddress),
              (this.booleanMeshSetAddress = -1));
          }
          invalidateDownstreamBooleanData(_ = !1) {
            return (
              _ ? (this.booleanWasTransformed = !0) : this.freeBooleanPointer(),
              Oh(this.parent)
                ? this.parent.invalidateDownstreamBooleanData()
                : this
            );
          }
          invalidateUpstreamBooleanData() {
            for (let _ of (this.freeBooleanPointer(), this.children))
              _ instanceof v$ &&
                (_.freeBooleanPointer(),
                Oh(_) && _.invalidateUpstreamBooleanData());
          }
          updateTransformState(_) {
            let L = super.updateTransformState(_);
            return (
              L && Oh(this.parent) && this.invalidateDownstreamBooleanData(!0),
              L
            );
          }
        },
        v2 = new iK();
      function Lh(_, L = 0, R = _.count, N, z) {
        let F = 1 / 0,
          U = 1 / 0,
          k = 1 / 0,
          Y = -1 / 0,
          X = -1 / 0,
          Q = -1 / 0;
        for (let N = L; N < R; N++) {
          let L = _.getX(N),
            R = _.getY(N),
            z = _.getZ(N);
          L < F && (F = L),
            R < U && (U = R),
            z < k && (k = z),
            L > Y && (Y = L),
            R > X && (X = R),
            z > Q && (Q = z);
        }
        v2.min.set(F, U, k),
          v2.max.set(Y, X, Q),
          v2.getCenter(N),
          v2.getSize(z).multiplyScalar(0.5);
      }
      var v4 = new sP(),
        v5 = new ss(),
        v6 = class extends v$ {
          constructor(_, L) {
            super(v4, v5), this.super_Entity(_, L);
          }
          updateState(_, L) {
            this.updateState_Entity(_, L);
          }
          updateEntityBoxSize(_, L) {
            let R = this.geometry.getAttribute("position");
            void 0 !== R
              ? Lh(
                  R,
                  this.geometry.drawRange.start,
                  this.geometry.drawRange.count < 1 / 0
                    ? this.geometry.drawRange.count
                    : R.count,
                  _,
                  L,
                )
              : super.updateEntityBoxSize(_, L);
          }
        },
        v8 = class {
          constructor(_) {
            (_ = _ ?? {}),
              (this.name = _.name),
              (this.type = _.type),
              (this.node = _.node),
              (this.size = _.size),
              (this.needsUpdate = _.needsUpdate);
          }
          get value() {
            return this.node.value;
          }
          set value(_) {
            this.node.value = _;
          }
        },
        v9 = class {
          constructor(_) {
            (this.hashProperties = void 0),
              (this.isNode = !0),
              (this.shortcuts = {}),
              (this.uuid = iE.generateUUID()),
              (this.type = _),
              (this.name = "");
          }
          analyze(_, L) {
            (L = L ?? {}),
              (_.analyzing = !0),
              this.build(_.addFlow(L.slot, L.cache, L.context), "v4"),
              _.clearVertexNodeCode(),
              _.clearFragmentNodeCode(),
              _.removeFlow(),
              (_.analyzing = !1);
          }
          analyzeAndFlow(_, L, R) {
            return (R = R ?? {}), this.analyze(_, R), this.flow(_, L, R);
          }
          flow(_, L, R) {
            (R = R ?? {}), _.addFlow(R.slot, R.cache, R.context);
            let N = {
              result: this.build(_, L),
              code: _.clearNodeCode(),
              extra: _.context.extra,
            };
            return _.removeFlow(), N;
          }
          build(_, L, R) {
            L = L ?? this.getType(_, L);
            let N = _.getNodeData(R ?? this);
            return (
              _.analyzing && this.appendDepsNode(_, N, L),
              -1 === _.nodes.indexOf(this) && _.nodes.push(this),
              void 0 !== this.updateFrame &&
                -1 === _.updaters.indexOf(this) &&
                _.updaters.push(this),
              this.generate(_, L, R)
            );
          }
          updateFrame(_) {}
          generateReadonly(_, L, R, N, z, F) {
            return "";
          }
          generate(_, L, R, N, z) {
            return "";
          }
          parse(_, L, R, N) {}
          appendDepsNode(_, L, R) {
            L.deps = (L.deps || 0) + 1;
            let N = _.getTypeLength(R);
            (N > (L.outputMax || 0) || this.getType(_, R)) &&
              ((L.outputMax = N), (L.output = R));
          }
          setName(_) {
            this.name = _;
          }
          getName() {
            return this.name;
          }
          getType(_, L) {
            return "sampler2D" === L || "samplerCube" === L ? L : this.type;
          }
          getHash() {
            let _ = "{",
              L,
              R;
            for (L in this)
              (R = this[L]) instanceof v9 &&
                (_ += '"' + L + '":' + R.getHash() + ",");
            if (this.hashProperties)
              for (let N = 0; N < this.hashProperties.length; N++)
                (R = this[(L = this.hashProperties[N])]),
                  (_ += '"' + L + '":"' + String(R) + '",');
            return _ + '"id":"' + this.uuid + '"}';
          }
        },
        v7 = new (class {
          constructor() {
            (this.nodes = {}), (this.keywords = {});
          }
          add(_) {
            this.nodes[_.name] = _;
          }
          addKeyword(_, L, R) {
            (R = void 0 === R || R),
              (this.keywords[_] = { callback: L, cache: R });
          }
          remove(_) {
            delete this.nodes[_.name];
          }
          removeKeyword(_) {
            delete this.keywords[_];
          }
          get(_) {
            return this.nodes[_];
          }
          getKeyword(_, L) {
            return this.keywords[_].callback(L);
          }
          getKeywordData(_) {
            return this.keywords[_];
          }
          contains(_) {
            return void 0 !== this.nodes[_];
          }
          containsKeyword(_) {
            return void 0 !== this.keywords[_];
          }
        })(),
        ye = class extends v9 {
          constructor(_, L) {
            super(_),
              (this.scope = ""),
              (L = L ?? {}),
              (this.shared = void 0 === L.shared || L.shared),
              (this.unique = void 0 !== L.unique && L.unique);
          }
          build(_, L, R, N) {
            if (((L = L ?? this.getType(_)), this.getShared(_, L))) {
              let z = this.getUnique(_, L);
              z && void 0 === this.uuid && (this.uuid = iE.generateUUID()),
                (R = _.getUUID(R ?? this.getUUID(), !z));
              let F = _.getNodeData(R),
                U = F.output || this.getType(_);
              if (_.analyzing)
                return (F.deps || 0) > 0 || this.getLabel()
                  ? (this.appendDepsNode(_, F, L), this.generate(_, L, R))
                  : super.build(_, L, R);
              if (z) return (F.name = F.name || super.build(_, L, R)), F.name;
              if (
                !this.getLabel() &&
                (!this.getShared(_, U) || _.context.ignoreCache || 1 === F.deps)
              )
                return super.build(_, L, R);
              R = this.getUUID(!1);
              let k = this.getTemp(_, R);
              if (k) return _.format(k, U, L);
              {
                k = super.generate(_, L, R, F.output, N);
                let z = this.generate(_, U, R);
                return _.addNodeCode(k + " = " + z + ";"), _.format(k, U, L);
              }
            }
            return super.build(_, L, R);
          }
          getShared(_, L) {
            return "sampler2D" !== L && "samplerCube" !== L && this.shared;
          }
          getUnique(_, L) {
            return this.unique;
          }
          setLabel(_) {
            return (this.label = _), this;
          }
          getLabel() {
            return this.label;
          }
          getUUID(_) {
            let L = this.uuid;
            return (
              "string" == typeof this.scope && (L = this.scope + "-" + L), L
            );
          }
          getTemp(_, L) {
            L = L || this.uuid;
            let R = _.getVars()[L];
            return R ? R.name : void 0;
          }
          generate(_, L, R, N, z) {
            return (
              this.getShared(_, L) || console.error("TempNode is not shared"),
              (R = R ?? this.uuid),
              _.getTempVar(R, N ?? this.getType(_), z, this.getLabel()).name
            );
          }
        },
        yt = class extends ye {
          constructor(_, L) {
            ((L = L ?? {}).shared = void 0 !== L.shared && L.shared),
              super(_, L),
              (this.readonly = !1);
          }
          setReadonly(_) {
            return (
              (this.readonly = _),
              (this.hashProperties = this.readonly ? ["value"] : void 0),
              this
            );
          }
          getReadonly() {
            return this.readonly;
          }
          generate(_, L, R, N, z, F) {
            (R = _.getUUID(R ?? this.getUUID())), (N = N ?? this.getType(_));
            let U = _.getNodeData(R);
            return this.getReadonly() && void 0 !== this.generateReadonly
              ? this.generateReadonly(_, L, R, N, z, F)
              : _.isShader("vertex")
                ? (U.vertex ||
                    (U.vertex = _.createVertexUniform(
                      N,
                      this,
                      z,
                      F,
                      this.getLabel(),
                    )),
                  _.format(U.vertex.name, N, L))
                : (U.fragment ||
                    (U.fragment = _.createFragmentUniform(
                      N,
                      this,
                      z,
                      F,
                      this.getLabel(),
                    )),
                  _.format(U.fragment.name, N, L));
          }
        },
        yi = class extends yt {
          constructor(_ = 0, L) {
            super("v2"),
              (this.nodeType = "Vector2"),
              (this.value = _ instanceof iT ? _ : new iT(_, L));
          }
          get x() {
            return this.value.x;
          }
          set x(_) {
            this.value.x = _;
          }
          get y() {
            return this.value.y;
          }
          set y(_) {
            this.value.y = _;
          }
          generateReadonly(_, L, R, N, z, F) {
            return _.format(
              "vec2(" + this.value.x + ", " + this.value.y + ")",
              N,
              L,
            );
          }
        },
        yr = class extends yt {
          constructor(_ = 0, L, R) {
            super("v3"),
              (this.nodeType = "Vector3"),
              (this.value = _ instanceof iq ? _ : new iq(_, L, R));
          }
          get x() {
            return this.value.x;
          }
          set x(_) {
            this.value.x = _;
          }
          get y() {
            return this.value.y;
          }
          set y(_) {
            this.value.y = _;
          }
          get z() {
            return this.value.z;
          }
          set z(_) {
            this.value.z = _;
          }
          generateReadonly(_, L, R, N, z, F) {
            return _.format(
              "vec3(" +
                this.value.x +
                ", " +
                this.value.y +
                ", " +
                this.value.z +
                ")",
              N,
              L,
            );
          }
        },
        ys = class extends iz {
          constructor(_, L, R, N) {
            super(_, L, R), (this.isColorA = !0), (this.a = N);
          }
          setRGBA(_, L, R, N) {
            super.setRGB(_, L, R), (this.a = N);
          }
          copy(_) {
            return super.copy(_), (this.a = "a" in _ ? _.a : 1), this;
          }
          clone() {
            return new this.constructor(this.r, this.g, this.b, this.a);
          }
          setStyle(_, L = "srgb") {
            let R;
            if ("transparent" === _) return this.setRGBA(0, 0, 0, 0), this;
            if ((R = /^((?:rgb|hsl)a?)\(([^)]*)\)/.exec(_))) {
              let N,
                z = R[1],
                F = R[2];
              switch (z) {
                case "rgb":
                case "rgba":
                  if (
                    (N =
                      /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                        F,
                      ))
                  )
                    return (
                      (this.a = "rgba" === z ? parseFloat(N[4]) : 1),
                      super.setStyle(_, L)
                    );
                  break;
                case "hsl":
                case "hsla":
                  if (
                    (N =
                      /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)%\s*,\s*(\d*\.?\d+)%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                        F,
                      ))
                  )
                    return (
                      (this.a = "hsla" === z ? parseFloat(N[4]) : 1),
                      super.setStyle(_, L)
                    );
              }
            }
            return super.setStyle(_, L);
          }
          get x() {
            return this.r;
          }
          get y() {
            return this.g;
          }
          get z() {
            return this.b;
          }
          get w() {
            return this.a;
          }
          set x(_) {
            this.r = _;
          }
          set y(_) {
            this.g = _;
          }
          set z(_) {
            this.b = _;
          }
          set w(_) {
            this.a = _;
          }
        },
        yn = class extends yt {
          constructor(_) {
            super("v4"),
              (this.nodeType = "Vector4"),
              (this.value = _ instanceof ys ? _ : new ys(_.r, _.g, _.b, _.a));
          }
          generateReadonly(_, L, R, N, z, F) {
            return _.format(
              "vec4(" +
                this.value.r +
                ", " +
                this.value.g +
                ", " +
                this.value.b +
                ", " +
                this.value.a +
                ")",
              N,
              L,
            );
          }
        },
        ya = /^\s*([a-z_0-9]+)\s([a-z_0-9]+)\s*\((.*?)\)/i,
        yo = /[a-z_0-9]+/gi,
        yl = class extends ye {
          constructor(_, L, R, N, z) {
            super(z),
              (this.src = ""),
              (this.nodeType = "Function"),
              (this.useKeywords = !0),
              (this.includes = []),
              (this.extensions = {}),
              (this.keywords = {}),
              (this.isMethod = void 0 === z),
              (this.isInterface = !1),
              this.parse(_, L, R, N);
          }
          getShared(_, L) {
            return !this.isMethod;
          }
          getType(_) {
            return _.getTypeByFormat(this.type);
          }
          getInputByName(_) {
            if (this.inputs) {
              let L = this.inputs.length;
              for (; L--; )
                if (this.inputs[L].name === _) return this.inputs[L];
            }
          }
          getIncludeByName(_) {
            if (this.includes) {
              let L = this.includes.length;
              for (; L--; )
                if (this.includes[L].name === _) return this.includes[L];
            }
          }
          generate(_, L, R, N, z) {
            let F,
              U = 0,
              k = this.src;
            if (this.includes)
              for (let L = 0; L < this.includes.length; L++)
                _.include(this.includes[L], this);
            for (let L in this.extensions) _.extensions[L] = !0;
            let Y = [];
            for (; (F = yo.exec(this.src)); ) Y.push(F);
            for (let L = 0; L < Y.length; L++) {
              let R = Y[L],
                N = R[0],
                z = !this.isMethod || !this.getInputByName(N),
                F = N;
              if (
                this.keywords[N] ||
                (this.useKeywords && z && v7.containsKeyword(N))
              ) {
                let L = this.keywords[N];
                if (!L) {
                  let R = v7.getKeywordData(N);
                  R.cache && (L = _.keywords[N]),
                    (L = L || v7.getKeyword(N, _)),
                    R.cache && (_.keywords[N] = L);
                }
                F = L.build(_);
              }
              N !== F &&
                "." !== k[R.index + U - 1] &&
                ((k =
                  k.substring(0, R.index + U) +
                  F +
                  k.substring(R.index + N.length + U)),
                (U += F.length - N.length)),
                void 0 === this.getIncludeByName(F) &&
                  v7.contains(F) &&
                  _.include(v7.get(F));
            }
            return "source" === L
              ? k
              : this.isMethod
                ? (this.isInterface || _.include(this, void 0, k), this.name)
                : _.format("( " + k + " )", this.getType(_), L);
          }
          parse(_, L, R, N) {
            if (
              ((this.src = _ || ""),
              (this.includes = L ?? []),
              (this.extensions = R ?? {}),
              (this.keywords = N ?? {}),
              this.isMethod)
            ) {
              let _ = ya.exec(this.src);
              if (((this.inputs = []), _ && 4 == _.length)) {
                (this.type = _[1]), (this.name = _[2]);
                let L = _[3].match(yo);
                if (L) {
                  let _ = 0;
                  for (; _ < L.length; ) {
                    let R = L[_++],
                      N;
                    "in" === R || "out" === R || "inout" === R
                      ? (N = L[_++])
                      : ((N = R), (R = ""));
                    let z = L[_++];
                    this.inputs.push({ name: z, type: N, qualifier: R });
                  }
                }
                this.isInterface = -1 === this.src.indexOf("{");
              } else (this.type = ""), (this.name = "");
            }
          }
        },
        yh = /^([a-z_0-9]+)\s([a-z_0-9]+)\s?\=?\s?(.*?)(\;|$)/i,
        yd = class extends ye {
          constructor(_ = "", L) {
            super(),
              (this.src = ""),
              (this.useDefine = !1),
              (this.nodeType = "Const"),
              this.parse(_ || yd.PI, void 0, void 0, void 0, L);
          }
          getType(_) {
            return _.getTypeByFormat(this.type);
          }
          parse(_, L, R, N, z) {
            this.src = _ || "";
            let F,
              U,
              k = "",
              Y = yh.exec(_);
            (this.useDefine = z ?? "#" === this.src.charAt(0)),
              Y && Y.length > 1
                ? ((U = Y[1]), (F = Y[2]), (k = Y[3]))
                : ((F = this.src), (U = "f")),
              (this.name = F),
              (this.type = U),
              (this.value = k);
          }
          build(_, L) {
            if ("source" === L) {
              if (this.value)
                return this.useDefine
                  ? "#define " + this.name + " " + this.value
                  : "const " +
                      this.type +
                      " " +
                      this.name +
                      " = " +
                      this.value +
                      ";";
              if (this.useDefine) return this.src;
            }
            return _.include(this), _.format(this.name, this.getType(_), L);
          }
          generate(_, L, R, N, z) {
            return _.format(this.name, this.getType(_), L);
          }
        };
      (yd.PI = "PI"),
        (yd.PI2 = "PI2"),
        (yd.RECIPROCAL_PI = "RECIPROCAL_PI"),
        (yd.RECIPROCAL_PI2 = "RECIPROCAL_PI2"),
        (yd.LOG2 = "LOG2"),
        (yd.EPSILON = "EPSILON");
      var yu = RegExp(
          `^structs*([a-z_0-9]+)s*{s*((.|
)*?)}`,
          "gim",
        ),
        yp = RegExp("s*(w*?)s*(w*?)(=|;)", "gim"),
        yf = class extends ye {
          constructor(_ = "") {
            super(),
              (this.inputs = []),
              (this.src = ""),
              (this.nodeType = "Struct"),
              this.parse(_);
          }
          getType(_) {
            return _.getTypeByFormat(this.name);
          }
          getInputByName(_) {
            let L = this.inputs.length;
            for (; L--; ) if (this.inputs[L].name === _) return this.inputs[L];
          }
          generate(_, L, R, N, z) {
            return "source" === L
              ? this.src + ";"
              : _.format("( " + this.src + " )", this.getType(_), L);
          }
          parse(_ = "") {
            (this.src = _), (this.inputs = []);
            let L = yu.exec(_);
            if (L) {
              let _ = L[2],
                R;
              for (; (R = yp.exec(_)); )
                this.inputs.push({ type: R[1], name: R[2] });
              this.name = L[1];
            } else this.name = "";
            this.type = this.name;
          }
        },
        ym = class extends ye {
          constructor(_) {
            super("v2", { shared: !1 }),
              (this.nodeType = "UV"),
              (this.index = _ ?? 0);
          }
          generate(_, L) {
            _.requires.uv[this.index] = !0;
            let R = this.index > 0 ? this.index + 1 : "",
              N = _.isShader("vertex") ? "uv" + R : "vUv" + R;
            return _.format(N, this.getType(_), L);
          }
        };
      v7.addKeyword("uv", function () {
        return new ym();
      }),
        v7.addKeyword("uv2", function () {
          return new ym(1);
        });
      var yg = class extends ye {
        constructor(_, L) {
          super("v4"),
            (this.nodeType = "ColorSpace"),
            (this.input = _),
            (this.method = L ?? yg.LINEAR_TO_LINEAR),
            (this.hashProperties = ["method"]);
        }
        static getEncodingComponents(_) {
          switch (_) {
            case 3e3:
              return ["Linear"];
            case 3001:
              return ["sRGB"];
            default:
              return [];
          }
        }
        generate(_, L) {
          let R = this.input.build(_, "v4"),
            N = this.getType(_),
            z = yg.Nodes[this.method],
            F = _.include(z);
          if (F === yg.LINEAR_TO_LINEAR) return _.format(R, N, L);
          if (z.inputs?.length !== 2)
            return _.format(F + "( " + R + " )", N, L);
          {
            let z = this.factor.build(_, "f");
            return _.format(F + "( " + R + ", " + z + " )", N, L);
          }
        }
        fromEncoding(_) {
          let L = yg.getEncodingComponents(_);
          (this.method = "LinearTo" + L[0]), (this.factor = L[1]);
        }
        fromDecoding(_) {
          let L = yg.getEncodingComponents(_);
          (this.method = L[0] + "ToLinear"), (this.factor = L[1]);
        }
      };
      (yg.Nodes = {
        LinearToLinear: new yl(
          ["vec4 LinearToLinear( in vec4 value ) {", "	return value;", "}"]
            .join(`
`),
        ),
        sRGBToLinear: new yl(
          [
            "vec4 sRGBToLinear( in vec4 value ) {",
            "	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );",
            "}",
          ].join(`
`),
        ),
        LinearTosRGB: new yl(
          [
            "vec4 LinearTosRGB( in vec4 value ) {",
            "	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );",
            "}",
          ].join(`
`),
        ),
      }),
        (yg.LINEAR_TO_LINEAR = "LinearToLinear"),
        (yg.SRGB_TO_LINEAR = "sRGBToLinear"),
        (yg.LINEAR_TO_SRGB = "LinearTosRGB");
      var yv = class extends yl {
          constructor(_ = "", L, R, N, z) {
            super(_, z, N, R, L), (this.nodeType = "Expression");
          }
        },
        yy = class extends yt {
          constructor(_ = new iG(), L, R, N) {
            super("v4", { shared: !0 }),
              (this.nodeType = "Texture"),
              (this.value = _),
              (this.uv = L ?? new ym()),
              (this.bias = R),
              (this.project = void 0 !== N && N);
          }
          getTexture(_, L) {
            return super.generate(_, L, this.value.uuid, "t");
          }
          generate(_, L) {
            let R, N;
            if ("sampler2D" === L) return this.getTexture(_, L);
            let z = this.getTexture(_, L),
              F = this.uv.build(_, this.project ? "v4" : "v2"),
              U = this.bias ? this.bias.build(_, "f") : void 0;
            void 0 === U &&
              _.context.bias &&
              (U = _.context.bias.setTexture(this).build(_, "f")),
              (R = this.project ? "texture2DProj" : U ? "tex2DBias" : "tex2D"),
              (N = U
                ? R + "( " + z + ", " + F + ", " + U + " )"
                : R + "( " + z + ", " + F + " )");
            let k = { include: _.isShader("vertex"), ignoreCache: !0 },
              Y = this.getType(_);
            return (
              _.addContext(k),
              (this.colorSpace = this.colorSpace ?? new yg(new yv("", Y))),
              this.colorSpace.fromDecoding(
                _.getTextureEncodingFromMap(this.value),
              ),
              this.colorSpace.input.parse(N),
              (N = this.colorSpace.build(_, Y)),
              _.removeContext(),
              _.format(N, Y, L)
            );
          }
        },
        yx = class extends yt {
          constructor(_) {
            super("f"), (this.nodeType = "Float"), (this.value = _ ?? 0);
          }
          generateReadonly(_, L, R, N, z, F) {
            return _.format(this.value + (this.value % 1 ? "" : ".0"), N, L);
          }
        },
        yb = class extends ye {
          constructor(_, L) {
            super(),
              (this.inputs = []),
              (this.nodeType = "FunctionCall"),
              (this.value = _),
              (this.inputs = L ?? []);
          }
          getFunction() {
            return this.value;
          }
          getType(_) {
            return this.value.getType(_);
          }
          generate(_, L, R, N, z) {
            N = this.getType(_);
            let F = this.value,
              U = F.build(_, L) + "( ",
              k = [];
            if (F.inputs) {
              for (let L = 0; L < F.inputs.length; L++) {
                let R = F.inputs[L],
                  N = this.inputs[L] || this.inputs[R.name];
                k.push(N.build(_, _.getTypeByFormat(R.type)));
              }
              U += k.join(", ") + " )";
            }
            return _.format(U, N, L);
          }
        },
        yw = class extends ye {
          constructor(_, L, R = yw.ADD) {
            super(),
              (this.nodeType = "Operator"),
              (this.type = _.type),
              (this.a = _),
              (this.b = L),
              (this.op = R);
          }
          getType(_) {
            let L = this.a.getType(_),
              R = this.b.getType(_);
            return _.isTypeMatrix(L)
              ? "v4"
              : _.getTypeLength(R) > _.getTypeLength(L)
                ? R
                : L;
          }
          generate(_, L) {
            let R = this.getType(_);
            this.type = R;
            let N = this.a.build(_, R),
              z = this.b.build(_, R);
            return _.format("( " + N + " " + this.op + " " + z + " )", R, L);
          }
        };
      (yw.ADD = "+"), (yw.SUB = "-"), (yw.MUL = "*"), (yw.DIV = "/");
      var y_ = class extends ye {
        constructor(_, L = y_.ABS, R, N) {
          super(),
            (this.nodeType = "Math"),
            (this.a = _),
            "string" != typeof L ? (this.b = L) : (N = L),
            "string" != typeof R ? (this.c = R) : (N = R),
            (this.method = N),
            (this.hashProperties = ["method"]);
        }
        getNumInputs(_) {
          switch (this.method) {
            case y_.MIX:
            case y_.CLAMP:
            case y_.REFRACT:
            case y_.SMOOTHSTEP:
            case y_.FACEFORWARD:
              return 3;
            case y_.MIN:
            case y_.MAX:
            case y_.MOD:
            case y_.STEP:
            case y_.REFLECT:
            case y_.DISTANCE:
            case y_.DOT:
            case y_.CROSS:
            case y_.POW:
              return 2;
            default:
              return 1;
          }
        }
        getInputType(_) {
          let L = _.getTypeLength(this.a.getType(_)),
            R = this.b ? _.getTypeLength(this.b.getType(_)) : 0,
            N = this.c ? _.getTypeLength(this.c.getType(_)) : 0;
          return L > R && L > N
            ? this.a.getType(_)
            : R > N
              ? this.b.getType(_)
              : this.c.getType(_);
        }
        getType(_) {
          switch (this.method) {
            case y_.LENGTH:
            case y_.DISTANCE:
            case y_.DOT:
              return "f";
            case y_.CROSS:
              return "v3";
          }
          return this.getInputType(_);
        }
        generate(_, L) {
          let R,
            N,
            z,
            F = this.a ? _.getTypeLength(this.a.getType(_)) : 0,
            U = this.b ? _.getTypeLength(this.b.getType(_)) : 0,
            k = this.c ? _.getTypeLength(this.c.getType(_)) : 0,
            Y = this.getInputType(_),
            X = this.getType(_);
          switch (((this.type = X), this.method)) {
            case y_.NEGATE:
              return _.format("( -" + this.a.build(_, Y) + " )", Y, L);
            case y_.INVERT:
              return _.format("( 1.0 - " + this.a.build(_, Y) + " )", Y, L);
            case y_.CROSS:
              (R = this.a.build(_, "v3")), (N = this.b.build(_, "v3"));
              break;
            case y_.STEP:
              (R = this.a.build(_, 1 === F ? "f" : Y)),
                (N = this.b.build(_, Y));
              break;
            case y_.MIN:
            case y_.MAX:
            case y_.MOD:
              (R = this.a.build(_, Y)),
                (N = this.b.build(_, 1 === U ? "f" : Y));
              break;
            case y_.REFRACT:
              (R = this.a.build(_, Y)),
                (N = this.b.build(_, Y)),
                (z = this.c.build(_, "f"));
              break;
            case y_.MIX:
              (R = this.a.build(_, Y)),
                (N = this.b.build(_, Y)),
                (z = this.c.build(_, 1 === k ? "f" : Y));
              break;
            default:
              (R = this.a.build(_, Y)),
                this.b && (N = this.b.build(_, Y)),
                this.c && (z = this.c.build(_, Y));
          }
          let Q = [];
          Q.push(R), N && Q.push(N), z && Q.push(z);
          let K = this.getNumInputs(_);
          if (Q.length !== K)
            throw Error(
              `Arguments not match used in "${this.method}". Require ${K}, currently ${Q.length}.`,
            );
          return _.format(this.method + "( " + Q.join(", ") + " )", X, L);
        }
      };
      (y_.RAD = "radians"),
        (y_.DEG = "degrees"),
        (y_.EXP = "exp"),
        (y_.EXP2 = "exp2"),
        (y_.LOG = "log"),
        (y_.LOG2 = "log2"),
        (y_.SQRT = "sqrt"),
        (y_.INV_SQRT = "inversesqrt"),
        (y_.FLOOR = "floor"),
        (y_.CEIL = "ceil"),
        (y_.NORMALIZE = "normalize"),
        (y_.FRACT = "fract"),
        (y_.SATURATE = "saturate"),
        (y_.SIN = "sin"),
        (y_.COS = "cos"),
        (y_.TAN = "tan"),
        (y_.ASIN = "asin"),
        (y_.ACOS = "acos"),
        (y_.ARCTAN = "atan"),
        (y_.ABS = "abs"),
        (y_.SIGN = "sign"),
        (y_.LENGTH = "length"),
        (y_.NEGATE = "negate"),
        (y_.INVERT = "invert"),
        (y_.MIN = "min"),
        (y_.MAX = "max"),
        (y_.MOD = "mod"),
        (y_.STEP = "step"),
        (y_.REFLECT = "reflect"),
        (y_.DISTANCE = "distance"),
        (y_.DOT = "dot"),
        (y_.CROSS = "cross"),
        (y_.POW = "pow"),
        (y_.MIX = "mix"),
        (y_.CLAMP = "clamp"),
        (y_.REFRACT = "refract"),
        (y_.SMOOTHSTEP = "smoothstep"),
        (y_.FACEFORWARD = "faceforward");
      var yS = class extends ye {
        constructor(_, L, R) {
          super("v4"),
            (this.nodeType = "TextureCubeUV"),
            (this.value = _),
            (this.uv = L),
            (this.bias = R);
        }
        bilinearCubeUV(_, L, R, N) {
          let z = new yb(yS.Nodes.bilinearCubeUV, [L, R, N]);
          (this.colorSpaceTL = this.colorSpaceTL ?? new yg(new yv("", "v4"))),
            this.colorSpaceTL.fromDecoding(
              _.getTextureEncodingFromMap(this.value.value),
            ),
            this.colorSpaceTL.input.parse(z.build(_) + ".tl"),
            (this.colorSpaceTR = this.colorSpaceTR ?? new yg(new yv("", "v4"))),
            this.colorSpaceTR.fromDecoding(
              _.getTextureEncodingFromMap(this.value.value),
            ),
            this.colorSpaceTR.input.parse(z.build(_) + ".tr"),
            (this.colorSpaceBL = this.colorSpaceBL ?? new yg(new yv("", "v4"))),
            this.colorSpaceBL.fromDecoding(
              _.getTextureEncodingFromMap(this.value.value),
            ),
            this.colorSpaceBL.input.parse(z.build(_) + ".bl"),
            (this.colorSpaceBR = this.colorSpaceBR ?? new yg(new yv("", "v4"))),
            this.colorSpaceBR.fromDecoding(
              _.getTextureEncodingFromMap(this.value.value),
            ),
            this.colorSpaceBR.input.parse(z.build(_) + ".br");
          let F = { include: _.isShader("vertex"), ignoreCache: !0 };
          _.addContext(F),
            (this.colorSpaceTLExp = new yv(
              this.colorSpaceTL.build(_, "v4"),
              "v4",
            )),
            (this.colorSpaceTRExp = new yv(
              this.colorSpaceTR.build(_, "v4"),
              "v4",
            )),
            (this.colorSpaceBLExp = new yv(
              this.colorSpaceBL.build(_, "v4"),
              "v4",
            )),
            (this.colorSpaceBRExp = new yv(
              this.colorSpaceBR.build(_, "v4"),
              "v4",
            )),
            _.removeContext();
          let U = new yv(
            "mix( mix( cubeUV_TL, cubeUV_TR, cubeUV.f.x ), mix( cubeUV_BL, cubeUV_BR, cubeUV.f.x ), cubeUV.f.y )",
            "v4",
          );
          return (
            (U.keywords.cubeUV_TL = this.colorSpaceTLExp),
            (U.keywords.cubeUV_TR = this.colorSpaceTRExp),
            (U.keywords.cubeUV_BL = this.colorSpaceBLExp),
            (U.keywords.cubeUV_BR = this.colorSpaceBRExp),
            (U.keywords.cubeUV = z),
            U
          );
        }
        generate(_, L) {
          if (!_.isShader("fragment"))
            return (
              console.warn(
                "TextureCubeUVNode is not compatible with " +
                  _.shader +
                  " shader.",
              ),
              _.format("vec4( 0.0 )", this.getType(_), L)
            );
          {
            let R = this.uv,
              N = this.bias || _.context.roughness,
              z = new yb(yS.Nodes.roughnessToMip, [N]),
              F = new y_(z, yS.Nodes.m0, yS.Nodes.cubeUV_maxMipLevel, y_.CLAMP),
              U = new y_(F, y_.FLOOR),
              k = new y_(F, y_.FRACT),
              Y = this.bilinearCubeUV(_, this.value, R, U),
              X = this.bilinearCubeUV(
                _,
                this.value,
                R,
                new yw(U, new yx(1).setReadonly(!0), yw.ADD),
              ),
              Q = new y_(Y, X, k, y_.MIX);
            return _.format(Q.build(_), "v4", L);
          }
        }
      };
      yS.Nodes =
        ((e0 = new yf(`struct TextureCubeUVData {
			vec4 tl;
			vec4 tr;
			vec4 br;
			vec4 bl;
			vec2 f;
		}`)),
        (e2 = new yd("float cubeUV_maxMipLevel 8.0", !0)),
        (e4 = new yd("float cubeUV_minMipLevel 4.0", !0)),
        (e6 = new yd("float cubeUV_maxTileSize 256.0", !0)),
        (e8 = new yd("float cubeUV_minTileSize 16.0", !0)),
        ((e9 = new yl(`float getFace(vec3 direction) {
				vec3 absDirection = abs(direction);
				float face = -1.0;
				if (absDirection.x > absDirection.z) {
					if (absDirection.x > absDirection.y)
						face = direction.x > 0.0 ? 0.0 : 3.0;
					else
						face = direction.y > 0.0 ? 1.0 : 4.0;
				} else {
					if (absDirection.z > absDirection.y)
						face = direction.z > 0.0 ? 2.0 : 5.0;
					else
						face = direction.y > 0.0 ? 1.0 : 4.0;
				}
				return face;
		}`)).useKeywords = !1),
        ((e7 = new yl(`vec2 getUV(vec3 direction, float face) {
				vec2 uv;
				if (face == 0.0) {
					uv = vec2(direction.z, direction.y) / abs(direction.x); // pos x
				} else if (face == 1.0) {
					uv = vec2(-direction.x, -direction.z) / abs(direction.y); // pos y
				} else if (face == 2.0) {
					uv = vec2(-direction.x, direction.y) / abs(direction.z); // pos z
				} else if (face == 3.0) {
					uv = vec2(-direction.z, direction.y) / abs(direction.x); // neg x
				} else if (face == 4.0) {
					uv = vec2(-direction.x, direction.z) / abs(direction.y); // neg y
				} else {
					uv = vec2(direction.x, direction.y) / abs(direction.z); // neg z
				}
				return 0.5 * (uv + 1.0);
		}`)).useKeywords = !1),
        ((te = new yl(
          `TextureCubeUVData bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {
			float face = getFace(direction);
			float filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);
			mipInt = max(mipInt, cubeUV_minMipLevel);
			float faceSize = exp2(mipInt);
			float texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);
			vec2 uv = getUV(direction, face) * (faceSize - 1.0);
			vec2 f = fract(uv);
			uv += 0.5 - f;
			if (face > 2.0) {
				uv.y += faceSize;
				face -= 3.0;
			}
			uv.x += face * faceSize;
			if(mipInt < cubeUV_maxMipLevel){
				uv.y += 2.0 * cubeUV_maxTileSize;
			}
			uv.y += filterInt * 2.0 * cubeUV_minTileSize;
			uv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);
			uv *= texelSize;
			vec4 tl = texture2D(envMap, uv);
			uv.x += texelSize;
			vec4 tr = texture2D(envMap, uv);
			uv.y += texelSize;
			vec4 br = texture2D(envMap, uv);
			uv.x -= texelSize;
			vec4 bl = texture2D(envMap, uv);
			return TextureCubeUVData( tl, tr, br, bl, f );
		}`,
          [e0, e9, e7, e2, e4, e6, e8],
        )).useKeywords = !1),
        (tt = new yd("float r0 1.0", !0)),
        (ti = new yd("float v0 0.339", !0)),
        (tr = new yd("float m0 -2.0", !0)),
        (tn = new yd("float r1 0.8", !0)),
        (ta = new yd("float v1 0.276", !0)),
        (to = new yd("float m1 -1.0", !0)),
        (tl = new yd("float r4 0.4", !0)),
        (th = new yd("float v4 0.046", !0)),
        (td = new yd("float m4 2.0", !0)),
        (tu = new yd("float r5 0.305", !0)),
        (tp = new yd("float v5 0.016", !0)),
        (tg = new yd("float m5 3.0", !0)),
        (tv = new yd("float r6 0.21", !0)),
        (tx = new yd("float v6 0.0038", !0)),
        (tb = new yd("float m6 4.0", !0)),
        {
          bilinearCubeUV: te,
          roughnessToMip: new yl(
            `float roughnessToMip(float roughness) {
			float mip = 0.0;
			if (roughness >= r1) {
				mip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;
			} else if (roughness >= r4) {
				mip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;
			} else if (roughness >= r5) {
				mip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;
			} else if (roughness >= r6) {
				mip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;
			} else {
				mip = -2.0 * log2(1.16 * roughness);// 1.16 = 1.79^0.25
			}
			return mip;
		}`,
            [tt, ti, tr, tn, ta, to, tl, th, td, tu, tp, tg, tv, tx, tb],
          ),
          m0: tr,
          cubeUV_maxMipLevel: e2,
        });
      var yA = class extends ye {
        constructor(_) {
          super("v3"), (this.nodeType = "Normal"), (this.scope = _ ?? yA.VIEW);
        }
        getShared() {
          return this.scope === yA.WORLD;
        }
        build(_, L, R, N) {
          let z = _.context[this.scope + "Normal"];
          return z ? z.build(_, L, R, N) : super.build(_, L, R);
        }
        generate(_, L, R, N, z) {
          let F;
          switch (this.scope) {
            case yA.VIEW:
              F = _.isShader("vertex") ? "transformedNormal" : "geometryNormal";
              break;
            case yA.LOCAL:
              _.isShader("vertex")
                ? (F = "objectNormal")
                : ((_.requires.normal = !0), (F = "vObjectNormal"));
              break;
            case yA.WORLD:
              _.isShader("vertex")
                ? (F =
                    "inverseTransformDirection( transformedNormal, viewMatrix ).xyz")
                : ((_.requires.worldNormal = !0), (F = "vWNormal"));
          }
          return _.format(F, this.getType(_), L);
        }
      };
      (yA.LOCAL = "local"),
        (yA.WORLD = "world"),
        (yA.VIEW = "view"),
        (yA.NORMAL = "normal"),
        v7.addKeyword("viewNormal", function () {
          return new yA(yA.VIEW);
        }),
        v7.addKeyword("localNormal", function () {
          return new yA(yA.NORMAL);
        }),
        v7.addKeyword("worldNormal", function () {
          return new yA(yA.WORLD);
        });
      var yM = class extends ye {
        constructor(_) {
          super("v3"),
            (this.nodeType = "Position"),
            (this.scope = _ ?? yM.LOCAL);
        }
        getType() {
          return this.scope === yM.PROJECTION ? "v4" : this.type;
        }
        getShader() {
          switch (this.scope) {
            case yM.LOCAL:
            case yM.WORLD:
              return !1;
          }
          return !0;
        }
        generate(_, L, R, N, z) {
          let F;
          switch (this.scope) {
            case yM.LOCAL:
              _.isShader("vertex")
                ? (F = "transformed")
                : ((_.requires.position = !0), (F = "vPosition"));
              break;
            case yM.WORLD:
              if (_.isShader("vertex"))
                return "( modelMatrix * vec4( transformed, 1.0 ) ).xyz";
              (_.requires.worldPosition = !0), (F = "vWPosition");
              break;
            case yM.VIEW:
              F = _.isShader("vertex") ? "-mvPosition.xyz" : "vViewPosition";
              break;
            case yM.PROJECTION:
              F = _.isShader("vertex")
                ? "( projectionMatrix * modelViewMatrix * vec4( position, 1.0 ) )"
                : "vec4( 0.0 )";
          }
          return _.format(F, this.getType(), L);
        }
      };
      (yM.LOCAL = "local"),
        (yM.WORLD = "world"),
        (yM.VIEW = "view"),
        (yM.PROJECTION = "projection"),
        v7.addKeyword("position", function () {
          return new yM();
        }),
        v7.addKeyword("worldPosition", function () {
          return new yM(yM.WORLD);
        }),
        v7.addKeyword("viewPosition", function () {
          return new yM(yM.VIEW);
        });
      var yE = class extends ye {
        constructor(_) {
          super("v3"), (this.nodeType = "Reflect"), (this.scope = _ ?? yE.CUBE);
        }
        getUnique(_) {
          return !_.context.viewNormal;
        }
        getType() {
          return this.scope === yE.SPHERE ? "v2" : this.type;
        }
        generate(_, L) {
          let R = this.getUnique(_);
          if (!_.isShader("fragment"))
            return (
              console.warn(
                "ReflectNode is not compatible with " + _.shader + " shader.",
              ),
              _.format("vec3( 0.0 )", this.type, L)
            );
          {
            let N;
            switch (this.scope) {
              case yE.VECTOR: {
                let L = new yA(yA.VIEW),
                  z = _.context.roughness,
                  F = L.build(_, "v3"),
                  U = new yM(yM.VIEW).build(_, "v3"),
                  k = z ? z.build(_, "f") : void 0,
                  Y = `reflect( -normalize( ${U} ), ${F} )`;
                k && (Y = `normalize( mix( ${Y}, ${F}, ${k} * ${k} ) )`);
                let X = `inverseTransformDirection( ${Y}, viewMatrix )`;
                R
                  ? (_.addNodeCode(`vec3 reflectVec = ${X};`),
                    (N = "reflectVec"))
                  : (N = X);
                break;
              }
              case yE.CUBE: {
                let L = new yE(yE.VECTOR).build(_, "v3"),
                  z = "vec3( -" + L + ".x, " + L + ".yz )";
                R
                  ? (_.addNodeCode(`vec3 reflectCubeVec = ${z};`),
                    (N = "reflectCubeVec"))
                  : (N = z);
                break;
              }
              case yE.SPHERE: {
                let L =
                  "normalize( ( viewMatrix * vec4( " +
                  new yE(yE.VECTOR).build(_, "v3") +
                  ", 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) ).xy * 0.5 + 0.5";
                R
                  ? (_.addNodeCode(`vec2 reflectSphereVec = ${L};`),
                    (N = "reflectSphereVec"))
                  : (N = L);
              }
            }
            return _.format(N, this.getType(), L);
          }
        }
      };
      (yE.CUBE = "cube"), (yE.SPHERE = "sphere"), (yE.VECTOR = "vector");
      var yT = class extends ye {
          constructor(_ = new yy(), L, R) {
            super("v4"),
              (this.nodeType = "TextureCube"),
              (this.value = _),
              (this.radianceNode = new yS(
                this.value,
                L ?? new yE(yE.VECTOR),
                R,
              )),
              (this.irradianceNode = new yS(
                this.value,
                new yA(yA.WORLD),
                new yx(1).setReadonly(!0),
              ));
          }
          generate(_, L) {
            return _.isShader("fragment")
              ? (_.require("irradiance"),
                _.context.bias && _.context.bias.setTexture(this.value),
                ("irradiance" === _.slot
                  ? this.irradianceNode
                  : this.radianceNode
                ).build(_, L))
              : (console.warn(
                  "TextureCubeNode is not compatible with " +
                    _.shader +
                    " shader.",
                ),
                _.format("vec4( 0.0 )", this.getType(_), L));
          }
        },
        yC = class extends yt {
          constructor(_ = new s$(), L, R) {
            super("v4", { shared: !0 }),
              (this.nodeType = "CubeTexture"),
              (this.value = _),
              (this.uv = L ?? new yE()),
              (this.bias = R);
          }
          getTexture(_, L) {
            return super.generate(_, L, this.value.uuid, "tc");
          }
          generate(_, L) {
            let R;
            if ("samplerCube" === L) return this.getTexture(_, L);
            let N = this.getTexture(_, L),
              z = this.uv?.build(_, "v3"),
              F = this.bias ? this.bias.build(_, "f") : void 0;
            void 0 === F &&
              _.context.bias &&
              (F = _.context.bias.setTexture(this).build(_, "f")),
              (R = F
                ? "texCubeBias( " + N + ", " + z + ", " + F + " )"
                : "texCube( " + N + ", " + z + " )");
            let U = { include: _.isShader("vertex"), ignoreCache: !0 },
              k = this.getType(_);
            return (
              _.addContext(U),
              (this.colorSpace = this.colorSpace ?? new yg(new yv("", k))),
              this.colorSpace.fromDecoding(
                _.getTextureEncodingFromMap(this.value),
              ),
              this.colorSpace.input.parse(R),
              (R = this.colorSpace.build(_, k)),
              _.removeContext(),
              _.format(R, k, L)
            );
          }
        },
        yP = ["x", "y", "z", "w"],
        yD = ["float", "vec2", "vec3", "vec4"],
        yO = {
          float: "f",
          vec2: "v2",
          vec3: "v3",
          vec4: "v4",
          mat4: "v4",
          int: "i",
          bool: "b",
          "float[]": "f[]",
          "vec4[]": "v4[]",
        },
        yL = {
          t: "sampler2D",
          tc: "samplerCube",
          b: "bool",
          i: "int",
          f: "float",
          c: "vec3",
          v2: "vec2",
          v3: "vec3",
          v4: "vec4",
          m3: "mat3",
          m4: "mat4",
          "f[]": "float[]",
          "v4[]": "vec4[]",
        },
        yR = class {
          constructor() {
            (this.includes = { consts: {}, functions: {}, structs: {} }),
              (this.cache = ""),
              (this.slot = ""),
              (this.shader = ""),
              (this.context = {}),
              (this.getIncludesCode = (function () {
                function t(_, L) {
                  return _.deps.length - L.deps.length;
                }
                return function (_, L) {
                  let R = this.getIncludes(_, L);
                  if (!R) return "";
                  let N = "";
                  R = R.sort(t);
                  for (let _ = 0; _ < R.length; _++)
                    R[_].src &&
                      (N +=
                        R[_].src +
                        `
`);
                  return N;
                };
              })()),
              (this.slots = []),
              (this.caches = []),
              (this.contexts = []),
              (this.keywords = {}),
              (this.nodeData = {}),
              (this.fragmentVariables = {}),
              (this.fragmentParsVariables = {}),
              (this.vertexParsVariables = {}),
              (this.requires = {
                uv: [],
                color: [],
                transparent: !1,
                irradiance: !1,
                position: !1,
                worldPosition: !1,
                normal: !1,
                worldNormal: !1,
                vWorldViewDir: !1,
                modelMatrix: !1,
                viewMatrix: !1,
                projectionMatrix: !1,
              }),
              (this.includes = { consts: [], functions: [], structs: [] }),
              (this.attributes = {}),
              (this.prefixCode = [
                "#ifdef TEXTURE_LOD_EXT",
                "	#define texCube(a, b) textureCube(a, b)",
                "	#define texCubeBias(a, b, c) textureCubeLodEXT(a, b, c)",
                "	#define tex2D(a, b) texture2D(a, b)",
                "	#define tex2DBias(a, b, c) texture2DLodEXT(a, b, c)",
                "#else",
                "	#define texCube(a, b) textureCube(a, b)",
                "	#define texCubeBias(a, b, c) textureCube(a, b, c)",
                "	#define tex2D(a, b) texture2D(a, b)",
                "	#define tex2DBias(a, b, c) texture2D(a, b, c)",
                "#endif",
                `
			// NOTE: Include Spline's blending modes. This could be part of BlendNode
			#define SPE_BLENDING_NORMAL 0
			#define SPE_BLENDING_MULTIPLY 1
			#define SPE_BLENDING_SCREEN 2
			#define SPE_BLENDING_OVERLAY 3

			vec3 spe_normalBlend( vec3 a, vec3 b, float alpha ) {
				return mix( a, b, alpha );
			}

			vec3 spe_multiplyBlend( vec3 a, vec3 b, float alpha ) {
				return mix( a, a * b, alpha );
			}

			vec3 spe_screenBlend( vec3 a, vec3 b, float alpha ) {
				vec3 tmp = 1.0 - ( 1.0 - a ) * ( 1.0 - b );
				return mix( a, tmp, alpha );
			}

			vec3 spe_overlayBlend( vec3 a, vec3 b, float alpha ) {
				vec3 tmp = mix( 1. - 2. * (1. - a) * (1. - b), 2. * a * b, step( a, vec3(.5) ) );
				return clamp( mix( a, tmp, alpha ), 0.0, 1.0 );
			}

			vec3 spe_blend( vec3 a, vec3 b, float alpha, int mode ) {
				if ( mode == SPE_BLENDING_NORMAL ) return spe_normalBlend( a, b, alpha );
				else if ( mode == SPE_BLENDING_MULTIPLY ) return spe_multiplyBlend( a, b, alpha );
				else if ( mode == SPE_BLENDING_SCREEN ) return spe_screenBlend( a, b, alpha );
				else if ( mode == SPE_BLENDING_OVERLAY ) return spe_overlayBlend( a, b, alpha );
				return vec3( 1.0 );
			}
			`,
                "#include <packing>",
                "#include <common>",
              ].join(`
`)),
              (this.parsCode = {
                vertex: ["float neighbor_offset = 0.0001;", ""].join(`
`),
                fragment: [
                  "float accumAlpha = 0.0;",
                  `void accumulateAlpha(float alpha) {
					accumAlpha += (1.0 - accumAlpha) * alpha;
				}`,
                  "",
                ].join(`
`),
              }),
              (this.code = { vertex: "", fragment: "" }),
              (this.nodeCode = { vertex: "", fragment: "" }),
              (this.resultCode = { vertex: "", fragment: "" }),
              (this.finalCode = { vertex: "", fragment: "" }),
              (this.inputs = {
                uniforms: { list: [], vertex: [], fragment: [] },
                arrayUniforms: { list: [], vertex: [], fragment: [] },
                vars: { varying: [], vertex: [], fragment: [] },
              }),
              (this.defines = {}),
              (this.uniforms = {}),
              (this.extensions = {
                derivatives: !1,
                fragDepth: !1,
                drawBuffers: !1,
                shaderTextureLOD: !1,
              }),
              (this.updaters = []),
              (this.nodes = []),
              (this.analyzing = !1);
          }
          build(_, L) {
            this.buildShader("vertex", _), this.buildShader("fragment", L);
            for (let _ = 0; _ < this.requires.uv.length; _++)
              if (this.requires.uv[_]) {
                let L = _ > 0 ? _ + 1 : "";
                this.addVaryCode("varying vec2 vUv" + L + ";"),
                  _ > 0 &&
                    this.addVertexParsCode("attribute vec2 uv" + L + ";"),
                  this.addVertexFinalCode("vUv" + L + " = uv" + L + ";");
              }
            return (
              this.requires.color[0] &&
                (this.addVaryCode("varying vec4 vColor;"),
                this.addVertexParsCode("attribute vec4 color;"),
                this.addVertexFinalCode("vColor = color;")),
              this.requires.color[1] &&
                (this.addVaryCode("varying vec4 vColor2;"),
                this.addVertexParsCode("attribute vec4 color2;"),
                this.addVertexFinalCode("vColor2 = color2;")),
              this.requires.position &&
                (this.addVaryCode("varying vec3 vPosition;"),
                this.addVertexFinalCode("vPosition = transformed;")),
              this.requires.worldPosition,
              this.requires.normal &&
                (this.addVaryCode("varying vec3 vObjectNormal;"),
                this.addVertexFinalCode("vObjectNormal = normal;")),
              this.requires.modelMatrix &&
                this.addFragmentParsCode("uniform mat4 modelMatrix;"),
              this.requires.viewMatrix &&
                this.addFragmentParsCode("uniform mat4 viewMatrix;"),
              this.requires.projectionMatrix &&
                this.addFragmentParsCode("uniform mat4 projectionMatrix;"),
              this.requires.worldNormal &&
                (this.addVaryCode("varying vec3 vWNormal;"),
                this.addVertexFinalCode(
                  "vWNormal = inverseTransformDirection( transformedNormal, viewMatrix ).xyz;",
                )),
              this.requires.vWorldViewDir &&
                (this.addVaryCode("varying vec3 vWorldViewDir;"),
                this.addVertexFinalCode(
                  "vWorldViewDir = isPerspectiveMatrix( projectionMatrix ) ?  ( (modelMatrix * vec4(position, 1.0)).xyz - cameraPosition ) : vec3( -viewMatrix[0][2], -viewMatrix[1][2], -viewMatrix[2][2] );",
                )),
              this
            );
          }
          buildShader(_, L) {
            this.resultCode[_] = L.build(this.setShader(_), "v4");
          }
          setMaterial(_, L) {
            return (this.defines = {}), this;
          }
          addFlow(_, L, R) {
            return this.addSlot(_).addCache(L).addContext(R);
          }
          removeFlow() {
            return this.removeSlot().removeCache().removeContext();
          }
          addCache(_) {
            return (this.cache = _ ?? ""), this.caches.push(this.cache), this;
          }
          removeCache() {
            return (
              this.caches.pop(),
              (this.cache = this.caches[this.caches.length - 1] || ""),
              this
            );
          }
          addContext(_) {
            return (
              (this.context = Object.assign({}, this.context, _)),
              (this.context.extra = this.context.extra || {}),
              this.contexts.push(this.context),
              this
            );
          }
          removeContext() {
            return (
              this.contexts.pop(),
              (this.context = this.contexts[this.contexts.length - 1] || {}),
              this
            );
          }
          addSlot(_) {
            return (this.slot = _ || ""), this.slots.push(this.slot), this;
          }
          removeSlot() {
            return (
              this.slots.pop(),
              (this.slot = this.slots[this.slots.length - 1] || ""),
              this
            );
          }
          addFragmentVariable(_, L) {
            void 0 === this.fragmentVariables[_] &&
              (this.addFragmentCode(`${L} ${_};`),
              (this.fragmentVariables[_] = ""));
          }
          addFragmentParsVariable(_, L) {
            void 0 === this.fragmentParsVariables[_] &&
              (this.addFragmentParsCode(`${L} ${_};`),
              (this.fragmentParsVariables[_] = ""));
          }
          addVertexParsVariable(_, L) {
            void 0 === this.vertexParsVariables[_] &&
              (this.addVertexParsCode(`${L} ${_};`),
              (this.vertexParsVariables[_] = ""));
          }
          addVertexCode(_) {
            this.addCode(_, "vertex");
          }
          addFragmentCode(_) {
            this.addCode(_, "fragment");
          }
          addCode(_, L) {
            this.code[L ?? this.shader] +=
              _ +
              `
`;
          }
          addVertexNodeCode(_) {
            this.addNodeCode(_, "vertex");
          }
          addFragmentNodeCode(_) {
            this.addNodeCode(_, "fragment");
          }
          addNodeCode(_, L) {
            this.nodeCode[L ?? this.shader] +=
              _ +
              `
`;
          }
          clearNodeCode(_) {
            _ = _ ?? this.shader;
            let L = this.nodeCode[_];
            return (this.nodeCode[_] = ""), L;
          }
          clearVertexNodeCode() {
            return this.clearNodeCode("vertex");
          }
          clearFragmentNodeCode() {
            return this.clearNodeCode("fragment");
          }
          addVertexFinalCode(_) {
            this.addFinalCode(_, "vertex");
          }
          addFragmentFinalCode(_) {
            this.addFinalCode(_, "fragment");
          }
          addFinalCode(_, L) {
            this.finalCode[L ?? this.shader] +=
              _ +
              `
`;
          }
          addVertexParsCode(_) {
            this.addParsCode(_, "vertex");
          }
          addFragmentParsCode(_) {
            this.addParsCode(_, "fragment");
          }
          addParsCode(_, L) {
            this.parsCode[L ?? this.shader] +=
              _ +
              `
`;
          }
          addVaryCode(_) {
            this.addVertexParsCode(_), this.addFragmentParsCode(_);
          }
          isCache(_) {
            return -1 !== this.caches.indexOf(_);
          }
          isSlot(_) {
            return -1 !== this.slots.indexOf(_);
          }
          define(_, L) {
            this.defines[_] = void 0 === L ? 1 : L;
          }
          require(_) {
            this.requires[_] = !0;
          }
          isDefined(_) {
            return void 0 !== this.defines[_];
          }
          getVar(_, L, R, N = "varying", z = "V", F = "") {
            let U = this.getVars(N),
              k = U[_];
            if (!k) {
              let N = U.length;
              (k = { name: R || "node" + z + N + (F ? "_" + F : ""), type: L }),
                U.push(k),
                (U[_] = k);
            }
            return k;
          }
          getTempVar(_, L, R, N) {
            return this.getVar(_, L, R, this.shader, "T", N);
          }
          getAttribute(_, L) {
            if (!this.attributes[_]) {
              let R = this.getVar(_, L);
              this.addVertexParsCode("attribute " + L + " " + _ + ";"),
                this.addVertexFinalCode(R.name + " = " + _ + ";"),
                (this.attributes[_] = { varying: R, name: _, type: L });
            }
            return this.attributes[_];
          }
          getCode(_) {
            return [
              this.prefixCode,
              this.parsCode[_],
              this.getVarListCode(this.getVars("varying"), "varying"),
              this.getVarListCode(this.inputs.uniforms[_], "uniform"),
              this.getVarListCode(this.inputs.arrayUniforms[_], "uniform"),
              this.getIncludesCode("consts", _),
              this.getIncludesCode("structs", _),
              this.getIncludesCode("functions", _),
              "void main() {",
              this.getVarListCode(this.getVars(_)),
              this.code[_],
              this.resultCode[_],
              this.finalCode[_],
              "}",
            ].join(`
`);
          }
          getVarListCode(_, L) {
            L = L ?? "";
            let R = "";
            for (let N = 0, z = _.length; N < z; ++N) {
              let z = _[N],
                F = z.type,
                U = z.name,
                k = z.size,
                Y = this.getFormatByType(F);
              if (void 0 === Y) throw Error("Node pars " + Y + " not found.");
              Y.includes("[]")
                ? (R +=
                    L +
                    " " +
                    Y.substring(0, Y.length - 2) +
                    " " +
                    U +
                    `[${k}];
`)
                : (R +=
                    L +
                    " " +
                    Y +
                    " " +
                    U +
                    `;
`);
            }
            return R;
          }
          getVars(_) {
            return this.inputs.vars[_ ?? this.shader];
          }
          getNodeData(_) {
            let L = _ instanceof v9 ? _.uuid : _;
            return (this.nodeData[L] = this.nodeData[L] || {});
          }
          createUniform(_, L, R, N, z, F) {
            if (L.includes("[]")) {
              let U = this.inputs.arrayUniforms,
                k = U.list.length,
                Y = new v8({
                  type: L,
                  size: R.size,
                  name: N || "nodeUA" + k + (F ? "_" + F : ""),
                  node: R,
                  needsUpdate: z,
                });
              return (
                U.list.push(Y),
                U[_].push(Y),
                (U[_][Y.name] = Y),
                (this.uniforms[Y.name] = Y),
                Y
              );
            }
            {
              let U = this.inputs.uniforms,
                k = U.list.length,
                Y = new v8({
                  type: L,
                  name: N || "nodeU" + k + (F ? "_" + F : ""),
                  node: R,
                  needsUpdate: z,
                });
              return (
                U.list.push(Y),
                U[_].push(Y),
                (U[_][Y.name] = Y),
                (this.uniforms[Y.name] = Y),
                Y
              );
            }
          }
          createVertexUniform(_, L, R, N, z) {
            return this.createUniform("vertex", _, L, R, N, z);
          }
          createFragmentUniform(_, L, R, N, z) {
            return this.createUniform("fragment", _, L, R, N, z);
          }
          include(_, L, R) {
            let N;
            if (
              ((_ = "string" == typeof _ ? v7.get(_) : _),
              !1 === this.context.include)
            )
              return _.name;
            _ instanceof yl
              ? (N = this.includes.functions)
              : _ instanceof yd
                ? (N = this.includes.consts)
                : _ instanceof yf && (N = this.includes.structs);
            let z = (N[this.shader] = N[this.shader] || []);
            if (_) {
              let N = z[_.name];
              if (
                (N ||
                  ((N = z[_.name] = { node: _, deps: [] }),
                  z.push(N),
                  (N.src = _.build(this, "source"))),
                _ instanceof yl &&
                  L &&
                  z[L.name] &&
                  -1 === z[L.name].deps.indexOf(_) &&
                  (z[L.name].deps.push(_), _.includes?.length))
              ) {
                let R = 0;
                do this.include(_.includes[R++], L);
                while (R < _.includes.length);
              }
              return R && (N.src = R), _.name;
            }
            throw Error("Include not found.");
          }
          colorToVectorProperties(_) {
            return _.replace("r", "x")
              .replace("g", "y")
              .replace("b", "z")
              .replace("a", "w");
          }
          colorToVector(_) {
            return _.replace(/c/g, "v3");
          }
          getIncludes(_, L) {
            return this.includes[_][L || this.shader];
          }
          getConstructorFromLength(_) {
            return yD[_ - 1];
          }
          isTypeMatrix(_) {
            return /^m/.test(_);
          }
          getTypeLength(_) {
            return "f" === _ ? 1 : parseInt(this.colorToVector(_).substr(1));
          }
          getTypeFromLength(_) {
            return 1 === _ ? "f" : "v" + _;
          }
          findNode(..._) {
            for (let L = 0; L < arguments.length; L++) {
              let R = _[L];
              if (R?.isNode) return R;
            }
          }
          resolve(..._) {
            for (let L = 0; L < arguments.length; L++) {
              let R = _[L];
              if (void 0 !== R) {
                if (R.isNode) return R;
                if (R.isTexture)
                  switch (R.mapping) {
                    case 301:
                    case 302:
                      return new yC(R);
                    case 306:
                      return new yT(new yy(R));
                    default:
                      return new yy(R);
                  }
                else {
                  if (R.isVector2) return new yi(R);
                  if (R.isVector3) return new yr(R);
                  if (R.isVector4) return new yn(R);
                }
              }
            }
          }
          format(_, L, R) {
            switch (this.colorToVector(R + " <- " + L)) {
              case "f <- v2":
              case "f <- v3":
              case "f <- v4":
                return _ + ".x";
              case "f <- i":
              case "f <- b":
                return "float( " + _ + " )";
              case "v2 <- f":
                return "vec2( " + _ + " )";
              case "v2 <- v3":
              case "v2 <- v4":
                return _ + ".xy";
              case "v2 <- i":
              case "v2 <- b":
              case "v3 <- i":
              case "v3 <- b":
                return "vec2( float( " + _ + " ) )";
              case "v3 <- f":
                return "vec3( " + _ + " )";
              case "v3 <- v2":
                return "vec3( " + _ + ", 0.0 )";
              case "v3 <- v4":
                return _ + ".xyz";
              case "v4 <- f":
                return "vec4( " + _ + " )";
              case "v4 <- v2":
                return "vec4( " + _ + ", 0.0, 1.0 )";
              case "v4 <- v3":
                return "vec4( " + _ + ", 1.0 )";
              case "v4 <- i":
              case "v4 <- b":
                return "vec4( float( " + _ + " ) )";
              case "i <- f":
              case "i <- b":
                return "int( " + _ + " )";
              case "i <- v2":
              case "i <- v3":
              case "i <- v4":
                return "int( " + _ + ".x )";
              case "b <- f":
                return "( " + _ + " != 0.0 )";
              case "b <- v2":
                return "( " + _ + " != vec2( 0.0 ) )";
              case "b <- v3":
                return "( " + _ + " != vec3( 0.0 ) )";
              case "b <- v4":
                return "( " + _ + " != vec4( 0.0 ) )";
              case "b <- i":
                return "( " + _ + " != 0 )";
            }
            return _;
          }
          getTypeByFormat(_) {
            return yO[_] || _;
          }
          getFormatByType(_) {
            return yL[_] || _;
          }
          getUUID(_, L) {
            return (
              (L = void 0 === L || L) &&
                this.cache &&
                (_ = this.cache + "-" + _),
              _
            );
          }
          getElementByIndex(_) {
            return yP[_];
          }
          getIndexByElement(_) {
            return yP.indexOf(_);
          }
          isShader(_) {
            return this.shader === _;
          }
          setShader(_) {
            return (this.shader = _), this;
          }
          mergeDefines(_) {
            for (let L in _) this.defines[L] = _[L];
            return this.defines;
          }
          mergeUniform(_) {
            for (let L in _) this.uniforms[L] = _[L];
            return this.uniforms;
          }
          getTextureEncodingFromMap(_) {
            let L;
            return (
              _ ? _.isTexture && (L = _.encoding) : (L = 3e3),
              3e3 === L && this.context.gamma && (L = 3001),
              L
            );
          }
        },
        yI = class extends yt {
          constructor(_ = 0, L, R, N) {
            super("c"),
              (this.nodeType = "Color"),
              (this.value = _ instanceof ys ? _ : new ys(_ || 0, L, R, N));
          }
          setRGBA(_) {
            this.value.setRGBA(_.r, _.g, _.b, _.a);
          }
          generate(_, L, R, N, z, F) {
            (R = _.getUUID(R ?? this.getUUID())), (N = N ?? this.getType(_));
            let U = _.getNodeData(R),
              k = this.getReadonly() && void 0 !== this.generateReadonly;
            if (this.alpha) {
              let L = this.alpha.build(_, "f");
              _.addFragmentNodeCode(
                `accumAlpha += ( 1.0 - accumAlpha ) * ${L};`,
              );
            }
            return k
              ? this.generateReadonly(_, L, R, N, z, F)
              : _.isShader("vertex")
                ? (U.vertex ||
                    (U.vertex = _.createVertexUniform(
                      N,
                      this,
                      z,
                      F,
                      this.getLabel(),
                    )),
                  _.format(U.vertex.name, N, L))
                : (U.fragment ||
                    (U.fragment = _.createFragmentUniform(
                      N,
                      this,
                      z,
                      F,
                      this.getLabel(),
                    )),
                  _.format(U.fragment.name, N, L));
          }
          generateReadonly(_, L, R, N, z, F) {
            return _.format(
              "vec3(" +
                this.value.r +
                ", " +
                this.value.g +
                ", " +
                this.value.b +
                ")",
              N,
              L,
            );
          }
        },
        yB = class extends yt {
          constructor(_) {
            super("i"),
              (this.nodeType = "Int"),
              (this.value = Math.floor(_ ?? 0));
          }
          generateReadonly(_, L, R, N, z, F) {
            return _.format(this.value.toString(), N, L);
          }
        },
        yN = class extends v9 {
          constructor() {
            super("basic"),
              (this.nodeType = "Basic"),
              (this.color = new yI(5526619)),
              (this.shadingAlpha = new yx(1)),
              (this.shadingBlend = new yB(0));
          }
          get category() {
            return "phong";
          }
          generate(_) {
            let L;
            if (_.isShader("vertex")) {
              let R = this.position
                ? this.position.analyzeAndFlow(_, "v3", { cache: "position" })
                : void 0;
              _.mergeUniform(sY.merge([ni.fog])),
                _.addParsCode(
                  [
                    "varying vec3 vViewPosition;",
                    "varying vec3 vWPosition;",
                    "#include <fog_pars_vertex>",
                    "#include <normal_pars_vertex>",
                  ].join(`
`),
                );
              let N = [
                "#include <beginnormal_vertex>",
                `
				#if !defined( USE_LAYER_DISPLACE )
					#include <defaultnormal_vertex>
				#endif

				vec3 displaced_position = position;
				vec3 displaced_normal = normal;

				#if defined( USE_LAYER_DISPLACE )
					vec3 transformed;
					vec3 transformedNormal;
				#endif
				`,
                "#include <normal_vertex>",
                `
				#if !defined( USE_LAYER_DISPLACE )
					#include <begin_vertex>
				#endif /* !USE_LAYER_DISPLACE */
				`,
              ];
              R &&
                N.push(
                  R.code,
                  R.result ? "displaced_position = " + R.result + ";" : "",
                ),
                N.push(
                  "transformed = displaced_position;",
                  "transformedNormal = normalMatrix * displaced_normal;",
                  "#ifndef FLAT_SHADED",
                  "	vNormal = transformedNormal;",
                  "#endif",
                ),
                N.push(
                  "#include <project_vertex>",
                  "#include <fog_vertex>",
                  "#include <clipping_planes_vertex>",
                  "	vViewPosition = - mvPosition.xyz;",
                  "#include <worldpos_vertex>",
                ),
                N.push(
                  "vWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;",
                ),
                (L = N.join(`
`));
            } else {
              void 0 === this.color && (this.color = new yI(5526619)),
                this.color.analyze(_, { slot: "color" }),
                this.alpha && this.alpha.analyze(_),
                this.afterColor &&
                  this.afterColor.analyze(_, { slot: "afterColor" });
              let R = this.color.flow(_, "c", { slot: "color" }),
                N = this.alpha ? this.alpha.flow(_, "f") : void 0,
                z = this.afterColor
                  ? this.afterColor.flow(_, "c", { slot: "afterColor" })
                  : void 0;
              (_.requires.transparent = void 0 !== N),
                _.addParsCode(
                  [
                    "varying vec3 vWPosition;",
                    "#include <fog_pars_fragment>",
                    "#include <dithering_pars_fragment>",
                    "varying vec3 vViewPosition;",
                    "#include <normal_pars_fragment>",
                  ].join(`
`),
                );
              let F = ["#include <normal_fragment_begin>", R.code];
              N &&
                F.push(
                  N.code,
                  "#ifdef ALPHATEST",
                  " if ( " + N.result + " <= ALPHATEST ) discard;",
                  "#endif",
                ),
                z
                  ? F.push(
                      z.code,
                      `vec3 outgoingLight = ${R.result};`,
                      `vec3 finalColor = spe_blend(outgoingLight, ${z.result}, 1.0, SPE_BLENDING_NORMAL);`,
                    )
                  : F.push(`vec3 finalColor = ${R.result};`),
                N
                  ? F.push(
                      `gl_FragColor = vec4( finalColor, accumAlpha * ${N.result} );`,
                    )
                  : F.push("gl_FragColor = vec4(" + R.result + ", 1.0 );"),
                F.push(
                  "#include <fog_fragment>",
                  "#include <dithering_fragment>",
                ),
                (L = F.join(`
`));
            }
            return L;
          }
        },
        yz = class extends yt {
          constructor(_ = 1, L) {
            super("f[]"),
              (this.nodeType = "FloatArray"),
              (this.size = _),
              (this.value = Array.isArray(L)
                ? L
                : "number" == typeof L
                  ? Array(_).fill(L)
                  : Array(_).fill(0));
          }
        },
        yF = {
          normalRenderTarget: new yy(),
          normalRenderTargetDepth: new yy(),
          transmissionRenderTarget: new yy(),
          transmissionSize: new yi(2048, 2048),
          transmissionRenderTargetDepth: new yy(),
          pixelRatioNode: new yx(1),
          resolution: new yi(),
          penumbraSize: new yz(5, 0.5),
        };
      for (let _ of Object.values(yF)) _.isRenderGlobal = !0;
      var yU = class extends v9 {
          constructor() {
            super("lambert"),
              (this.nodeType = "Lambert"),
              (this.color = new yI(5526619)),
              (this.emissive = new yI(0)),
              (this.emissiveIntensity = new yx(1)),
              (this.shadingAlpha = new yx(1)),
              (this.shadingBlend = new yB(0));
          }
          get category() {
            return "lambert";
          }
          build(_) {
            let L;
            if (
              (_.define("LAMBERT"),
              (_.requires.lights = !0),
              (_.extensions.derivatives = !0),
              _.isShader("vertex"))
            ) {
              let R = this.position
                ? this.position.analyzeAndFlow(_, "v3", { cache: "position" })
                : void 0;
              _.mergeUniform(sY.merge([ni.fog, ni.lights])),
                _.addParsCode(
                  [
                    "varying vec3 vViewPosition;",
                    "varying vec3 vWPosition;",
                    "varying vec3 vLightFront;",
                    "varying vec3 vIndirectFront;",
                    "#ifndef DOUBLE_SIDED",
                    "   #define DOUBLE_SIDED",
                    "#endif",
                    "#ifdef DOUBLE_SIDED",
                    "	varying vec3 vLightBack;",
                    "	varying vec3 vIndirectBack;",
                    "#endif",
                    "#include <bsdfs>",
                    "#include <lights_pars_begin>",
                    "#include <color_pars_vertex>",
                    "#include <fog_pars_vertex>",
                    "#include <normal_pars_vertex>",
                    "#include <shadowmap_pars_vertex>",
                    "#include <clipping_planes_pars_vertex>",
                  ].join(`
`),
                );
              let N = [
                "#include <beginnormal_vertex>",
                `
				#ifndef USE_LAYER_DISPLACE
					#include <defaultnormal_vertex>
				#endif

				vec3 displaced_position = position;
				vec3 displaced_normal = normal;

				#ifdef USE_LAYER_DISPLACE
					vec3 transformed;
					vec3 transformedNormal;
				#endif
				`,
                "#include <normal_vertex>",
                `
				#ifndef USE_LAYER_DISPLACE
					#include <begin_vertex>
				#endif
				`,
              ];
              R &&
                N.push(
                  R.code,
                  R.result ? "displaced_position = " + R.result + ";" : "",
                ),
                N.push(
                  "transformed = displaced_position;",
                  "transformedNormal = normalMatrix * displaced_normal;",
                  "#ifndef FLAT_SHADED",
                  "    vNormal = transformedNormal;",
                  "#endif",
                ),
                N.push(
                  "	#include <project_vertex>",
                  "	#include <clipping_planes_vertex>",
                  "	vViewPosition = - mvPosition.xyz;",
                  "	#include <worldpos_vertex>",
                  `
					vec3 diffuse = vec3( 1.0 );
					GeometricContext geometry;
					geometry.position = mvPosition.xyz;
					geometry.normal = normalize( transformedNormal );
					geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
					GeometricContext backGeometry;
					backGeometry.position = geometry.position;
					backGeometry.normal = -geometry.normal;
					backGeometry.viewDir = geometry.viewDir;
					vLightFront = vec3( 0.0 );
					vIndirectFront = vec3( 0.0 );
					#ifdef DOUBLE_SIDED
						vLightBack = vec3( 0.0 );
						vIndirectBack = vec3( 0.0 );
					#endif
					IncidentLight directLight;
					float dotNL;
					vec3 directLightColor_Diffuse;
					vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
					vIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );
					#ifdef DOUBLE_SIDED
						vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
						vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );
					#endif
					#if NUM_POINT_LIGHTS > 0
						#pragma unroll_loop_start
						for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
							getPointLightInfo( pointLights[ i ], geometry, directLight );
							dotNL = dot( geometry.normal, directLight.direction );
							directLightColor_Diffuse = directLight.color;
							vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
							#ifdef DOUBLE_SIDED
								vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
							#endif
						}
						#pragma unroll_loop_end
					#endif
					#if NUM_SPOT_LIGHTS > 0
						#pragma unroll_loop_start
						for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
							getSpotLightInfo( spotLights[ i ], geometry, directLight );
							dotNL = dot( geometry.normal, directLight.direction );
							directLightColor_Diffuse = directLight.color;
							vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
							#ifdef DOUBLE_SIDED
								vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
							#endif
						}
						#pragma unroll_loop_end
					#endif
					#if NUM_DIR_LIGHTS > 0
						#pragma unroll_loop_start
						for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
							getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );
							dotNL = dot( geometry.normal, directLight.direction );
							directLightColor_Diffuse = directLight.color;
							vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
							#ifdef DOUBLE_SIDED
								vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
							#endif
						}
						#pragma unroll_loop_end
					#endif
					#if NUM_HEMI_LIGHTS > 0
						#pragma unroll_loop_start
						for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
							vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
							#ifdef DOUBLE_SIDED
								vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );
							#endif
						}
						#pragma unroll_loop_end
					#endif
				`,
                  "	#include <shadowmap_vertex>",
                  "	#include <fog_vertex>",
                ),
                N.push(
                  "vWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;",
                ),
                (L = N.join(`
`));
            } else {
              _.mergeUniform({ penumbraSize: yF.penumbraSize }),
                void 0 === this.color && (this.color = new yI(5526619)),
                this.color.analyze(_, { slot: "color" }),
                this.shadingAlpha.analyze(_),
                this.shadingBlend.analyze(_),
                this.afterColor &&
                  this.afterColor.analyze(_, { slot: "afterColor" }),
                this.alpha && this.alpha.analyze(_);
              let R = this.color.flow(_, "c", { slot: "color" }),
                N = this.emissive.flow(_, "c", { slot: "emissive" }),
                z = this.emissiveIntensity.flow(_, "f", { slot: "emissive" }),
                F = this.shadingAlpha.flow(_, "f"),
                U = this.shadingBlend.flow(_, "i"),
                k = this.afterColor
                  ? this.afterColor.flow(_, "c", { slot: "afterColor" })
                  : void 0,
                Y = this.alpha ? this.alpha.flow(_, "f") : void 0;
              (_.requires.transparent = void 0 !== Y),
                _.addParsCode(
                  [
                    "uniform float penumbraSize[5];",
                    "varying vec3 vViewPosition;",
                    "varying vec3 vWPosition;",
                    "varying vec3 vLightFront;",
                    "varying vec3 vIndirectFront;",
                    "#ifndef DOUBLE_SIDED",
                    "   #define DOUBLE_SIDED",
                    "#endif",
                    "#include <normal_pars_fragment>",
                    "#ifdef DOUBLE_SIDED",
                    "	varying vec3 vLightBack;",
                    "	varying vec3 vIndirectBack;",
                    "#endif",
                    "#include <bsdfs>",
                    "#include <lights_pars_begin>",
                    "#include <fog_pars_fragment>",
                    "#include <shadowmap_pars_fragment>",
                    "#include <shadowmask_pars_fragment>",
                    "#include <clipping_planes_pars_fragment>",
                    "#include <dithering_pars_fragment>",
                  ].join(`
`),
                );
              let X = [
                "#include <normal_fragment_begin>",
                `
				// NOTE: gl_FrontFacing alternative using face normal estimation.
				vec3 viewdx = dFdx(vViewPosition);
				vec3 viewdy = dFdy(vViewPosition);
				vec3 faceNormal = normalize(cross(viewdx, viewdy));
				bool isFrontFacing = (dot(normal, faceNormal) >= 0.0);
				`,
                "#include <clipping_planes_fragment>",
              ];
              X.push(
                R.code,
                "vec3 diffuseColor = " + R.result + ";",
                "ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );",
              ),
                Y &&
                  X.push(
                    Y.code,
                    "#ifdef ALPHATEST",
                    "if ( " + Y.result + " <= ALPHATEST ) discard;",
                    "#endif",
                  ),
                X.push(
                  "#ifdef DOUBLE_SIDED",
                  "	reflectedLight.indirectDiffuse += ( isFrontFacing ) ? vIndirectFront : vIndirectBack;",
                  "#else",
                  "	reflectedLight.indirectDiffuse += vIndirectFront;",
                  "#endif",
                  "#include <lightmap_fragment>",
                  "reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );",
                  "#ifdef DOUBLE_SIDED",
                  "	reflectedLight.directDiffuse = ( isFrontFacing ) ? vLightFront : vLightBack;",
                  "#else",
                  "	reflectedLight.directDiffuse = vLightFront;",
                  "#endif",
                  "reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();",
                ),
                N &&
                  X.push(
                    N.code,
                    "reflectedLight.directDiffuse += " +
                      N.result +
                      " * " +
                      z.result +
                      ";",
                  ),
                X.push(
                  "vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;",
                ),
                X.push(`
				if (outgoingLight != diffuseColor) {
					float lightAccu = clamp( length( reflectedLight.directSpecular + reflectedLight.indirectSpecular ), 0.0, 1.0 );
					accumAlpha += ( 1.0 - accumAlpha ) * ${F.result} * lightAccu;
					outgoingLight = spe_blend( diffuseColor, outgoingLight, ${F.result}, ${U.result} );
				}
				`),
                k &&
                  X.push(
                    k.code,
                    `outgoingLight = spe_blend(outgoingLight, ${k.result}, 1.0, SPE_BLENDING_NORMAL);`,
                  ),
                Y
                  ? X.push(
                      `gl_FragColor = vec4( outgoingLight, accumAlpha * ${Y.result} );`,
                    )
                  : X.push("gl_FragColor = vec4( outgoingLight, 1.0 );"),
                X.push(
                  "#include <encodings_fragment>",
                  "#include <fog_fragment>",
                  "#include <dithering_fragment>",
                ),
                (L = X.join(`
`));
            }
            return L;
          }
        },
        yk = class extends v9 {
          constructor() {
            super("phong"),
              (this.nodeType = "Phong"),
              (this.color = new yI(5526619)),
              (this.specular = new yI(1118481)),
              (this.shininess = new yx(30)),
              (this.shadingAlpha = new yx(1)),
              (this.shadingBlend = new yB(0));
          }
          get category() {
            return "phong";
          }
          build(_) {
            let L;
            if (
              (_.define("PHONG"),
              (_.requires.lights = !0),
              (_.extensions.derivatives = !0),
              _.isShader("vertex"))
            ) {
              let R = this.position
                ? this.position.analyzeAndFlow(_, "v3", { cache: "position" })
                : void 0;
              _.mergeUniform(sY.merge([ni.fog, ni.lights])),
                _.addParsCode(
                  [
                    "varying vec3 vViewPosition;",
                    "varying vec3 vWPosition;",
                    "#include <fog_pars_vertex>",
                    "#include <normal_pars_vertex>",
                    "#include <shadowmap_pars_vertex>",
                    "#include <clipping_planes_pars_vertex>",
                  ].join(`
`),
                );
              let N = [
                "#include <beginnormal_vertex>",
                `
				#ifndef USE_LAYER_DISPLACE
					#include <defaultnormal_vertex>
				#endif


				vec3 displaced_position = position;
				vec3 displaced_normal = normal;

				#ifdef USE_LAYER_DISPLACE
					vec3 transformed;
					vec3 transformedNormal;
				#endif
				`,
                "#include <normal_vertex>",
                `
				#ifndef USE_LAYER_DISPLACE
					#include <begin_vertex>
				#endif
				`,
              ];
              R &&
                N.push(
                  R.code,
                  R.result ? "displaced_position = " + R.result + ";" : "",
                ),
                N.push(
                  "transformed = displaced_position;",
                  "transformedNormal = normalMatrix * displaced_normal;",
                  "#ifndef FLAT_SHADED",
                  "    vNormal = transformedNormal;",
                  "#endif",
                ),
                N.push(
                  "	#include <project_vertex>",
                  "	#include <clipping_planes_vertex>",
                  "	vViewPosition = - mvPosition.xyz;",
                  "	#include <worldpos_vertex>",
                  "	#include <shadowmap_vertex>",
                  "	#include <fog_vertex>",
                ),
                N.push(
                  "vWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;",
                ),
                (L = N.join(`
`));
            } else {
              _.mergeUniform({ penumbraSize: yF.penumbraSize }),
                void 0 === this.color && (this.color = new yI(5526619)),
                this.color.analyze(_, { slot: "color" }),
                this.specular.analyze(_),
                this.shininess.analyze(_),
                this.shadingAlpha.analyze(_),
                this.shadingBlend.analyze(_),
                this.afterColor &&
                  this.afterColor.analyze(_, { slot: "afterColor" }),
                this.alpha && this.alpha.analyze(_);
              let R = this.color.flow(_, "c", { slot: "color" }),
                N = this.specular.flow(_, "c"),
                z = this.shininess.flow(_, "f"),
                F = this.shadingAlpha.flow(_, "f"),
                U = this.shadingBlend.flow(_, "i"),
                k = this.afterColor
                  ? this.afterColor.flow(_, "c", { slot: "afterColor" })
                  : void 0,
                Y = this.alpha ? this.alpha.flow(_, "f") : void 0;
              (_.requires.transparent = void 0 !== Y),
                _.addParsCode(
                  [
                    "varying vec3 vWPosition;",
                    "uniform vec3 emissive;",
                    "uniform float penumbraSize[5];",
                    "#include <normal_pars_fragment>",
                    "#include <fog_pars_fragment>",
                    "#include <bsdfs>",
                    "#include <lights_pars_begin>",
                    "#include <lights_phong_pars_fragment>",
                    "#include <shadowmap_pars_fragment>",
                    "#include <dithering_pars_fragment>",
                  ].join(`
`),
                );
              let X = [
                "#include <normal_fragment_begin>",
                `
				// NOTE: gl_FrontFacing alternative using face normal estimation.
				vec3 viewdx = dFdx(vViewPosition);
				vec3 viewdy = dFdy(vViewPosition);
				vec3 faceNormal = normalize(cross(viewdx,viewdy));
				if (dot(normal, faceNormal) < 0.0) {
					normal *= -1.0;
				}
				`,
                "	BlinnPhongMaterial material;",
              ];
              X.push(
                R.code,
                "	vec3 diffuseColor = " + R.result + ";",
                "	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );",
                "	vec3 totalEmissiveRadiance = emissive;",
                N.code,
                "	vec3 specular = " + N.result + ";",
                z.code,
                "	float shininess = max( 0.0001, " + z.result + " );",
                "	float specularStrength = 1.0;",
              ),
                Y &&
                  X.push(
                    Y.code,
                    "#ifdef ALPHATEST",
                    "if ( " + Y.result + " <= ALPHATEST ) discard;",
                    "#endif",
                  ),
                X.push("material.diffuseColor = diffuseColor;"),
                X.push(
                  "material.specularColor = specular;",
                  "material.specularShininess = shininess;",
                  "material.specularStrength = specularStrength;",
                  "#include <lights_fragment_begin>",
                  "#include <lights_fragment_end>",
                ),
                X.push(
                  "vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;",
                ),
                X.push(`
				if (outgoingLight != diffuseColor) {
					float lightAccu = clamp( length( reflectedLight.directSpecular + reflectedLight.indirectSpecular ), 0.0, 1.0 );
					accumAlpha += ( 1.0 - accumAlpha ) * ${F.result} * lightAccu;
					outgoingLight = spe_blend( diffuseColor, outgoingLight, ${F.result}, ${U.result} );
				}
				`),
                k &&
                  X.push(
                    k.code,
                    `outgoingLight = spe_blend(outgoingLight, ${k.result}, 1.0, SPE_BLENDING_NORMAL);`,
                  ),
                Y
                  ? X.push(
                      `gl_FragColor = vec4( outgoingLight, accumAlpha * ${Y.result} );`,
                    )
                  : X.push("gl_FragColor = vec4( outgoingLight, 1.0 );"),
                X.push(
                  "#include <encodings_fragment>",
                  "#include <fog_fragment>",
                  "#include <dithering_fragment>",
                ),
                (L = X.join(`
`));
            }
            return L;
          }
        },
        yj = class extends v9 {
          constructor() {
            super("standard"),
              (this.nodeType = "Standard"),
              (this.color = new yI(5526619)),
              (this.roughness = new yx(0.3)),
              (this.metalness = new yx(0)),
              (this.reflectivity = new yx(0.5)),
              (this.shadingAlpha = new yx(1)),
              (this.shadingBlend = new yB(0));
          }
          get category() {
            return "physical";
          }
          build(_) {
            let L;
            if (
              (_.define("STANDARD"),
              (_.requires.lights = !0),
              (_.extensions.derivatives = !0),
              (_.extensions.shaderTextureLOD = !0),
              _.isShader("vertex"))
            ) {
              let R = this.position
                ? this.position.analyzeAndFlow(_, "v3", { cache: "position" })
                : void 0;
              _.mergeUniform(sY.merge([ni.fog, ni.lights])),
                ni.LTC_1 &&
                  ((_.uniforms.ltc_1 = { value: void 0 }),
                  (_.uniforms.ltc_2 = { value: void 0 })),
                _.addParsCode(
                  [
                    "varying vec3 vViewPosition;",
                    "varying vec3 vWPosition;",
                    "#include <fog_pars_vertex>",
                    "#include <normal_pars_vertex>",
                    "#include <shadowmap_pars_vertex>",
                    "#include <clipping_planes_pars_vertex>",
                  ].join(`
`),
                );
              let N = [
                "#include <beginnormal_vertex>",
                `
				#if !defined( USE_LAYER_DISPLACE )
					#include <defaultnormal_vertex>
				#endif

				vec3 displaced_position = position;
				vec3 displaced_normal = normal;

				#if defined( USE_LAYER_DISPLACE )
					vec3 transformed;
					vec3 transformedNormal;
				#endif
				`,
                "#include <normal_vertex>",
                `
				#if !defined( USE_LAYER_DISPLACE )
					#include <begin_vertex>
				#endif /* !USE_LAYER_DISPLACE */
				`,
              ];
              R &&
                N.push(
                  R.code,
                  R.result ? "displaced_position = " + R.result + ";" : "",
                ),
                N.push(
                  "transformed = displaced_position;",
                  "transformedNormal = normalMatrix * displaced_normal;",
                  "#ifndef FLAT_SHADED",
                  "    vNormal = transformedNormal;",
                  "#endif",
                ),
                N.push(
                  "#include <project_vertex>",
                  "#include <fog_vertex>",
                  "#include <clipping_planes_vertex>",
                  "	vViewPosition = - mvPosition.xyz;",
                  "#include <worldpos_vertex>",
                  "#include <shadowmap_vertex>",
                ),
                N.push(
                  "vWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;",
                ),
                (L = N.join(`
`));
            } else {
              _.mergeUniform({ penumbraSize: yF.penumbraSize });
              let R = { gamma: !0 };
              void 0 === this.color && (this.color = new yI(5526619)),
                this.color.analyze(_, { slot: "color", context: R }),
                this.roughness.analyze(_),
                this.metalness.analyze(_),
                this.shadingAlpha.analyze(_),
                this.shadingBlend.analyze(_),
                this.afterColor &&
                  this.afterColor.analyze(_, { slot: "afterColor" }),
                this.alpha && this.alpha.analyze(_),
                this.reflectivity && this.reflectivity.analyze(_);
              let N = this.color.flow(_, "c", { slot: "color", context: R }),
                z = this.roughness.flow(_, "f"),
                F = this.metalness.flow(_, "f"),
                U = this.shadingAlpha.flow(_, "f"),
                k = this.shadingBlend.flow(_, "i"),
                Y = this.afterColor
                  ? this.afterColor.flow(_, "c", { slot: "afterColor" })
                  : void 0,
                X = this.alpha ? this.alpha.flow(_, "f") : void 0,
                Q = this.reflectivity ? this.reflectivity.flow(_, "f") : void 0;
              (_.requires.transparent = void 0 !== X),
                _.addParsCode(
                  [
                    "varying vec3 vViewPosition;",
                    "varying vec3 vWPosition;",
                    "uniform float penumbraSize[5];",
                    "#include <normal_pars_fragment>",
                    "#include <dithering_pars_fragment>",
                    "#include <fog_pars_fragment>",
                    "#include <bsdfs>",
                    "#include <lights_pars_begin>",
                    "#include <lights_physical_pars_fragment>",
                    "#include <shadowmap_pars_fragment>",
                  ].join(`
`),
                );
              let K = [
                "#include <clipping_planes_fragment>",
                "	#include <normal_fragment_begin>",
                `
				// NOTE: gl_FrontFacing alternative using face normal estimation.
				vec3 viewdx = dFdx(vViewPosition);
				vec3 viewdy = dFdy(vViewPosition);
				vec3 faceNormal = normalize(cross(viewdx,viewdy));
				if (dot(normal, faceNormal) < 0.0) {
					normal *= -1.0;
				}
				`,
                "	PhysicalMaterial material;",
                "	material.diffuseColor = vec3( 1.0 );",
              ];
              K.push(
                N.code,
                "	vec3 diffuseColor = " + N.result + ";",
                "	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );",
                z.code,
                "	float roughnessFactor = " + z.result + ";",
                F.code,
                "	float metalnessFactor = " + F.result + ";",
              ),
                X &&
                  K.push(
                    X.code,
                    "#ifdef ALPHATEST",
                    "	if ( " + X.result + " <= ALPHATEST ) discard;",
                    "#endif",
                  ),
                K.push(
                  "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );",
                  "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );",
                ),
                K.push(
                  "material.diffuseColor = diffuseColor * ( 1.0 - metalnessFactor );",
                  "material.roughness = max( roughnessFactor, 0.0525 );",
                  "material.roughness += geometryRoughness;",
                  "material.roughness = min( material.roughness, 1.0 );",
                  "material.roughness = clamp( roughnessFactor, 0.04, 1.0 );",
                ),
                Q
                  ? K.push(
                      Q.code,
                      "material.specularColor = mix( vec3( 0.16 * pow2( " +
                        Q.result +
                        " ) ), diffuseColor, metalnessFactor );",
                    )
                  : K.push(
                      "material.specularColor = mix( vec3( 0.04 ), diffuseColor, metalnessFactor );",
                    ),
                K.push("#include <lights_fragment_begin>"),
                K.push("#include <lights_fragment_end>"),
                K.push(
                  "vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular;",
                ),
                K.push(`
				if (outgoingLight != diffuseColor) {
					float lightAccu = clamp( length( reflectedLight.directSpecular + reflectedLight.indirectSpecular ), 0.0, 1.0 );
					accumAlpha += ( 1.0 - accumAlpha ) * ${U.result} * lightAccu;
					outgoingLight = spe_blend( diffuseColor, outgoingLight, ${U.result}, ${k.result} );
				}
				`),
                Y &&
                  K.push(
                    Y.code,
                    `outgoingLight = spe_blend(outgoingLight, ${Y.result}, 1.0, SPE_BLENDING_NORMAL);`,
                  ),
                X
                  ? K.push(
                      `gl_FragColor = vec4( outgoingLight, accumAlpha * ${X.result} );`,
                    )
                  : K.push("gl_FragColor = vec4( outgoingLight, 1.0 );"),
                K.push(
                  "#include <encodings_fragment>",
                  "#include <fog_fragment>",
                  "#include <dithering_fragment>",
                ),
                (L = K.join(`
`));
            }
            return L;
          }
        },
        yG = class extends v9 {
          constructor() {
            super("toon"),
              (this.nodeType = "Toon"),
              (this.color = new yI(5526619)),
              (this.specular = new yI(1118481)),
              (this.shininess = new yx(30)),
              (this.shadingAlpha = new yx(1)),
              (this.shadingBlend = new yB(0));
          }
          get category() {
            return "toon";
          }
          build(_) {
            let L;
            if (
              (_.define("TOON"),
              (_.requires.lights = !0),
              (_.extensions.derivatives = !0),
              _.isShader("vertex"))
            ) {
              let R = this.position
                ? this.position.analyzeAndFlow(_, "v3", { cache: "position" })
                : void 0;
              _.mergeUniform(sY.merge([ni.fog, ni.lights])),
                _.addParsCode(
                  [
                    "varying vec3 vViewPosition;",
                    "varying vec3 vWPosition;",
                    "#include <fog_pars_vertex>",
                    "#include <normal_pars_vertex>",
                    "#include <shadowmap_pars_vertex>",
                    "#include <clipping_planes_pars_vertex>",
                  ].join(`
`),
                );
              let N = [
                "#include <beginnormal_vertex>",
                `
				#ifndef USE_LAYER_DISPLACE
					#include <defaultnormal_vertex>
				#endif

				vec3 displaced_position = position;
				vec3 displaced_normal = normal;

				#ifdef USE_LAYER_DISPLACE
					vec3 transformed;
					vec3 transformedNormal;
				#endif
				`,
                "#include <normal_vertex>",
                `
				#ifndef USE_LAYER_DISPLACE
					#include <begin_vertex>
				#endif
				`,
              ];
              R &&
                N.push(
                  R.code,
                  R.result ? "displaced_position = " + R.result + ";" : "",
                ),
                N.push(
                  "transformed = displaced_position;",
                  "transformedNormal = normalMatrix * displaced_normal;",
                  "#ifndef FLAT_SHADED",
                  "    vNormal = transformedNormal;",
                  "#endif",
                ),
                N.push(
                  "	#include <project_vertex>",
                  "	#include <fog_vertex>",
                  "	#include <clipping_planes_vertex>",
                  "	vViewPosition = - mvPosition.xyz;",
                  "	#include <worldpos_vertex>",
                  "	#include <shadowmap_vertex>",
                  "	#include <fog_vertex>",
                ),
                N.push(
                  "vWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;",
                ),
                (L = N.join(`
`));
            } else {
              _.mergeUniform({ penumbraSize: yF.penumbraSize }),
                void 0 === this.color && (this.color = new yI(5526619)),
                this.color.analyze(_, { slot: "color" }),
                this.specular.analyze(_),
                this.shininess.analyze(_),
                this.shadingAlpha.analyze(_),
                this.shadingBlend.analyze(_),
                this.afterColor &&
                  this.afterColor.analyze(_, { slot: "afterColor" }),
                this.alpha && this.alpha.analyze(_);
              let R = this.color.flow(_, "c", { slot: "color" }),
                N = this.specular.flow(_, "c"),
                z = this.shininess.flow(_, "f"),
                F = this.shadingAlpha.flow(_, "f"),
                U = this.shadingBlend.flow(_, "i"),
                k = this.afterColor
                  ? this.afterColor.flow(_, "c", { slot: "afterColor" })
                  : void 0,
                Y = this.alpha ? this.alpha.flow(_, "f") : void 0;
              (_.requires.transparent = void 0 !== Y),
                _.addParsCode(
                  [
                    "uniform float penumbraSize[5];",
                    "varying vec3 vWPosition;",
                    "#include <normal_pars_fragment>",
                    "#include <gradientmap_pars_fragment>",
                    "#include <fog_pars_fragment>",
                    "#include <bsdfs>",
                    "#include <lights_pars_begin>",
                    "#include <dithering_pars_fragment>",
                    `
					varying vec3 vViewPosition;
					struct ToonMaterial {
						vec3	diffuseColor;
						vec3	specularColor;
						float	specularShininess;
						float	specularStrength;
					};
					void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
						vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
			
						reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
						reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
					}
					void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
						reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
					}
					#define RE_Direct				RE_Direct_Toon
					#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
					#define Material_LightProbeLOD( material )	(0)
					`,
                    "#include <shadowmap_pars_fragment>",
                    "#include <bumpmap_pars_fragment>",
                    "#include <normalmap_pars_fragment>",
                  ].join(`
`),
                );
              let X = [
                "#include <normal_fragment_begin>",
                `
				// NOTE: gl_FrontFacing alternative using face normal estimation.
				vec3 viewdx = dFdx(vViewPosition);
				vec3 viewdy = dFdy(vViewPosition);
				vec3 faceNormal = normalize(cross(viewdx,viewdy));
				if (dot(normal, faceNormal) < 0.0) {
					normal *= -1.0;
				}
				`,
                "	ToonMaterial material;",
              ];
              X.push(
                R.code,
                "	vec3 diffuseColor = " + R.result + ";",
                "	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );",
                N.code,
                "	vec3 specular = " + N.result + ";",
                z.code,
                "	float shininess = max( 0.0001, " + z.result + " );",
                "	float specularStrength = 1.0;",
              ),
                Y &&
                  X.push(
                    Y.code,
                    "#ifdef ALPHATEST",
                    "if ( " + Y.result + " <= ALPHATEST ) discard;",
                    "#endif",
                  ),
                X.push("material.diffuseColor = diffuseColor;"),
                X.push(
                  "material.specularColor = specular;",
                  "material.specularShininess = shininess;",
                  "material.specularStrength = specularStrength;",
                  "#include <lights_fragment_begin>",
                  "#include <lights_fragment_end>",
                ),
                X.push(
                  "vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular;",
                ),
                X.push(`
				if (outgoingLight != diffuseColor) {
					float lightAccu = clamp( length( reflectedLight.directSpecular + reflectedLight.indirectSpecular ), 0.0, 1.0 );
					accumAlpha += ( 1.0 - accumAlpha ) * ${F.result} * lightAccu;
					outgoingLight = spe_blend( diffuseColor, outgoingLight, ${F.result}, ${U.result} );
				}
				`),
                k &&
                  X.push(
                    k.code,
                    `outgoingLight = spe_blend(outgoingLight, ${k.result}, 1.0, SPE_BLENDING_NORMAL);`,
                  ),
                Y
                  ? X.push(
                      `gl_FragColor = vec4( outgoingLight, accumAlpha * ${Y.result} );`,
                    )
                  : X.push("gl_FragColor = vec4( outgoingLight, 1.0 );"),
                X.push(
                  "#include <encodings_fragment>",
                  "#include <fog_fragment>",
                  "#include <dithering_fragment>",
                ),
                (L = X.join(`
`));
            }
            return L;
          }
        },
        yV = class extends yt {
          constructor(_) {
            super("b"), (this.nodeType = "Bool"), (this.value = _ ?? !1);
          }
          generateReadonly(_, L, R, N) {
            return _.format(this.value ? "true" : "false", N, L);
          }
        },
        yH = class extends yt {
          constructor(_) {
            super("m3"),
              (this.nodeType = "Matrix3"),
              (this.value = _ ?? new iC());
          }
          generateReadonly(_, L, R, N, z, F) {
            return _.format(
              "mat3(" + this.value.elements.join(", ") + ")",
              N,
              L,
            );
          }
          get elements() {
            return this.value.elements;
          }
          set elements(_) {
            this.value.fromArray(_);
          }
        },
        yW = class extends yt {
          constructor(_ = 1, L) {
            super("v4[]"),
              (this.nodeType = "Vector4Array"),
              (this.size = _),
              (this.value = Array.isArray(L)
                ? L
                : L instanceof iV
                  ? Array(_).fill(L)
                  : Array(_).fill(new iV(0)));
          }
        },
        yY =
          (((y7 = yY || {}).SIMPLEX = "simplex3d"),
          (y7.SIMPLEX_FRACTAL = "simplex3dFractal"),
          (y7.ASHIMA = "simplexAshima"),
          (y7.FBM = "fbm"),
          (y7.PERLIN = "perlin"),
          y7),
        yX =
          ((tw = new yl(`vec3 random3(vec3 c) {
			float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));
			vec3 r;
			r.z = fract(512.0*j);
			j *= .125;
			r.x = fract(512.0*j);
			j *= .125;
			r.y = fract(512.0*j);
			return r-0.5;
		}`)),
          ((t_ = new yl(
            `float simplex3d(vec3 p) {
			 vec3 s = floor(p + dot(p, vec3(F3)));
			 vec3 x = p - s + dot(s, vec3(G3));
			 
			 vec3 e = step(vec3(0.0), x - x.yzx);
			 vec3 i1 = e*(1.0 - e.zxy);
			 vec3 i2 = 1.0 - e.zxy*(1.0 - e);
				
			 vec3 x1 = x - i1 + G3;
			 vec3 x2 = x - i2 + 2.0*G3;
			 vec3 x3 = x - 1.0 + 3.0*G3;
			 
			 vec4 w, d;
			 
			 w.x = dot(x, x);
			 w.y = dot(x1, x1);
			 w.z = dot(x2, x2);
			 w.w = dot(x3, x3);
			 
			 w = max(0.6 - w, 0.0);
			 
			 d.x = dot(random3(s), x);
			 d.y = dot(random3(s + i1), x1);
			 d.z = dot(random3(s + i2), x2);
			 d.w = dot(random3(s + 1.0), x3);
			 
			 w *= w;
			 w *= w;
			 d *= w;
			 
			 return dot(d, vec4(52.0));
		}`,
            [tw],
          )).keywords.F3 = new yd("float F3 0.3333333")),
          (t_.keywords.G3 = new yd("float G3 0.1666667")),
          (tS = new yl(
            `float simplex3dFractal(vec3 m) {
			mat3 rot1 = mat3(-0.37, 0.36, 0.85,-0.14,-0.93, 0.34,0.92, 0.01,0.4);
			mat3 rot2 = mat3(-0.55,-0.39, 0.74, 0.33,-0.91,-0.24,0.77, 0.12,0.63);
			mat3 rot3 = mat3(-0.71, 0.52,-0.47,-0.08,-0.72,-0.68,-0.7,-0.45,0.56);
			return 0.5333333 * simplex3d(m * rot1)
				 + 0.2666667 * simplex3d(2.0 * m * rot2)
				 + 0.1333333 * simplex3d(4.0 * m * rot3)
				 + 0.0666667 * simplex3d(8.0 * m);
		}`,
            [t_],
          )),
          (tA = new yl(
            "vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}",
          )),
          (tM = new yl(
            "vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}",
          )),
          (tE = new yl(
            `float simplexAshima(vec3 v) {
		  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
		  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
		  vec3 i  = floor(v + dot(v, C.yyy) );
		  vec3 x0 =   v - i + dot(i, C.xxx) ;
		  vec3 g = step(x0.yzx, x0.xyz);
		  vec3 l = 1.0 - g;
		  vec3 i1 = min( g.xyz, l.zxy );
		  vec3 i2 = max( g.xyz, l.zxy );
		  vec3 x1 = x0 - i1 + 1.0 * C.xxx;
		  vec3 x2 = x0 - i2 + 2.0 * C.xxx;
		  vec3 x3 = x0 - 1. + 3.0 * C.xxx;
		  i = mod(i, 289.0 ); 
		  vec4 p = permute( permute( permute( 
					 i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
				   + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
				   + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
		  float n_ = 1.0/7.0; // N=7
		  vec3  ns = n_ * D.wyz - D.xzx;
		  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)
		  vec4 x_ = floor(j * ns.z);
		  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)
		  vec4 x = x_ *ns.x + ns.yyyy;
		  vec4 y = y_ *ns.x + ns.yyyy;
		  vec4 h = 1.0 - abs(x) - abs(y);
		  vec4 b0 = vec4( x.xy, y.xy );
		  vec4 b1 = vec4( x.zw, y.zw );
		  vec4 s0 = floor(b0)*2.0 + 1.0;
		  vec4 s1 = floor(b1)*2.0 + 1.0;
		  vec4 sh = -step(h, vec4(0.0));
		  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
		  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
		  vec3 p0 = vec3(a0.xy,h.x);
		  vec3 p1 = vec3(a0.zw,h.y);
		  vec3 p2 = vec3(a1.xy,h.z);
		  vec3 p3 = vec3(a1.zw,h.w);
		  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
		  p0 *= norm.x;
		  p1 *= norm.y;
		  p2 *= norm.z;
		  p3 *= norm.w;
		  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
		  m = m * m;
		  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), 
										dot(p2,x2), dot(p3,x3) ) );
		}`,
            [tA, tM],
          )),
          (tT = new yl(
            "vec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}",
          )),
          (tC = new yl(
            "vec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}",
            [tT],
          )),
          (tD = new yl(
            `float noise(vec3 p){
			vec3 a = floor(p);
			vec3 d = p - a;
			d = d * d * (3.0 - 2.0 * d);
			vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);
			vec4 k1 = perm(b.xyxy);
			vec4 k2 = perm(k1.xyxy + b.zzww);
			vec4 c = k2 + a.zzzz;
			vec4 k3 = perm(c);
			vec4 k4 = perm(c + 1.0);
			vec4 o1 = fract(k3 * (1.0 / 41.0));
			vec4 o2 = fract(k4 * (1.0 / 41.0));
			vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);
			vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);
			return o4.y * d.y + o4.x * (1.0 - d.y);
		}`,
            [tC],
          )),
          ((tO = new yl(
            `float fbm(vec3 x) {
			float v = 0.0;
			float a = 0.5;
			vec3 shift = vec3(100);
			for (int i = 0; i < NUM_OCTAVES; ++i) {
				v += a * noise(x);
				x = x * 2.0 + shift;
				a *= 0.5;
			}
			return v;
		}`,
            [tD],
          )).keywords.NUM_OCTAVES = new yd("int NUM_OCTAVES 5")),
          (tL = new yl(
            "vec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}",
          )),
          {
            simplex: t_,
            simplexFractal: tS,
            simplexAshima: tE,
            fbm: tO,
            perlin: new yl(
              `float perlin(vec3 P){
		  vec3 Pi0 = floor(P);
		  vec3 Pi1 = Pi0 + vec3(1.0);
		  Pi0 = mod(Pi0, 289.0);
		  Pi1 = mod(Pi1, 289.0);
		  vec3 Pf0 = fract(P);
		  vec3 Pf1 = Pf0 - vec3(1.0);
		  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
		  vec4 iy = vec4(Pi0.yy, Pi1.yy);
		  vec4 iz0 = Pi0.zzzz;
		  vec4 iz1 = Pi1.zzzz;
		  vec4 ixy = permute(permute(ix) + iy);
		  vec4 ixy0 = permute(ixy + iz0);
		  vec4 ixy1 = permute(ixy + iz1);
		  vec4 gx0 = ixy0 / 7.0;
		  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;
		  gx0 = fract(gx0);
		  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
		  vec4 sz0 = step(gz0, vec4(0.0));
		  gx0 -= sz0 * (step(0.0, gx0) - 0.5);
		  gy0 -= sz0 * (step(0.0, gy0) - 0.5);
		  vec4 gx1 = ixy1 / 7.0;
		  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;
		  gx1 = fract(gx1);
		  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
		  vec4 sz1 = step(gz1, vec4(0.0));
		  gx1 -= sz1 * (step(0.0, gx1) - 0.5);
		  gy1 -= sz1 * (step(0.0, gy1) - 0.5);
		  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
		  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
		  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
		  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
		  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
		  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
		  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
		  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);
		  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
		  g000 *= norm0.x;
		  g010 *= norm0.y;
		  g100 *= norm0.z;
		  g110 *= norm0.w;
		  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
		  g001 *= norm1.x;
		  g011 *= norm1.y;
		  g101 *= norm1.z;
		  g111 *= norm1.w;
		  float n000 = dot(g000, Pf0);
		  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
		  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
		  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
		  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
		  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
		  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
		  float n111 = dot(g111, Pf1);
		  vec3 fade_xyz = fade(Pf0);
		  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
		  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
		  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); 
		  return 2.2 * n_xyz;
		}`,
              [tA, tM, tL],
            ),
          }),
        yq = class extends ye {
          constructor(_, L, R, N, z, F, U, k, Y, X, Q, K) {
            super("v3"),
              (this.nodeType = "Noise"),
              (this.scale = _),
              (this.size = L),
              (this.move = R),
              (this.fA = N),
              (this.fB = z),
              (this.distortion = F),
              (this.colorA = U),
              (this.colorB = k),
              (this.colorC = Y),
              (this.colorD = X),
              (this.alpha = Q),
              (this.noiseType = K),
              (this.calpha = `g${this.uuid
                .toString()
                .replace(/-/g, "")}_calpha`);
          }
          generate(_, L, R, N, z) {
            _.require("uv"),
              (_.requires.uv = [!0]),
              _.addFragmentVariable(this.calpha, "float");
            let F = Object.values(yY)[this.noiseType.value],
              U = new yl(
                `vec3 ${F}customNoise(float scale, vec3 size, float move, vec2 fA, vec2 fB, vec2 distortion, vec4 colorA, vec4 colorB, vec4 colorC, vec4 colorD, float alpha, out float calpha) {
                vec3 st = position / size;
				st /= scale;
				vec3 q = vec3(${F}(st),
							  ${F}(st + vec3(1.0)),
							  ${F}(st + vec3(1.0)));
				vec3 r = vec3(${F}(st + vec3(distortion, 1.0) * q + vec3(fA, 1.0) + move),
							  ${F}(st + vec3(distortion, 1.0) * q + vec3(fB, 1.0) + move), 
							  ${F}(st * q));
				float f = ${F}(st + r);
				vec4 color;
				color = mix(colorA, colorB, clamp((f * f) * 4.0, 0.0, 1.0));
				color = mix(color, colorC, clamp(length(q), 0.0, 1.0));
				color = mix(color, colorD, clamp(length(r.x), 0.0, 1.0));

                float lalpha = alpha * color.a;
                calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );

			    accumAlpha += ( 1.0 - accumAlpha ) * lalpha;
				return clamp(color, 0.0, 1.0).rgb;
			}`,
                [
                  yX.simplex,
                  yX.simplexFractal,
                  yX.simplexAshima,
                  yX.fbm,
                  yX.perlin,
                ],
              ),
              k = _.include(U),
              Y = [];
            return (
              Y.push(this.scale.build(_, "f")),
              Y.push(this.size.build(_, "v3")),
              Y.push(this.move.build(_, "f")),
              Y.push(this.fA.build(_, "v2")),
              Y.push(this.fB.build(_, "v2")),
              Y.push(this.distortion.build(_, "v2")),
              Y.push(this.colorA.build(_, "v4")),
              Y.push(this.colorB.build(_, "v4")),
              Y.push(this.colorC.build(_, "v4")),
              Y.push(this.colorD.build(_, "v4")),
              Y.push(this.alpha.build(_, "f")),
              Y.push(this.calpha),
              _.format(k + "(" + Y.join(",") + ")", this.getType(_), L)
            );
          }
        };
      yq.numOctaves = 5;
      var yQ = class extends ye {
        constructor(_, L, R, N, z, F, U) {
          super("v3"),
            (this.nodeType = "Fresnel"),
            (this.color = _),
            (this.bias = L),
            (this.scale = R),
            (this.intensity = N),
            (this.factor = z),
            (this.alpha = F),
            (this.mode = U),
            (this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`);
        }
        generate(_, L) {
          if (
            (_.require("vWorldViewDir"),
            _.require("worldNormal"),
            !_.isShader("fragment"))
          )
            return (
              console.warn(
                "FresnelNode is not compatible with " + _.shader + " shader.",
              ),
              _.format("vec3( 0.0 )", this.getType(_), L)
            );
          {
            _.addFragmentVariable(this.calpha, "float");
            let R = _.include(yQ.Nodes.fresnel),
              N = [];
            return (
              N.push(this.color.build(_, "c")),
              N.push(this.bias.build(_, "f")),
              N.push(this.scale.build(_, "f")),
              N.push(this.intensity.build(_, "f")),
              N.push(this.factor.build(_, "f")),
              N.push(this.alpha.build(_, "f")),
              N.push(this.mode.build(_, "i")),
              N.push(this.calpha),
              _.format(R + "(" + N.join(",") + ")", this.getType(_), L)
            );
          }
        }
      };
      yQ.Nodes = {
        fresnel:
          new yl(`vec3 fresnel(vec3 color, float bias, float scale, float intensity, float factor, float alpha, int mode, out float calpha) {
				float fresnel = bias + scale * pow( abs( factor + dot( normalize( vWorldViewDir ), normalize( vWNormal ) ) ), intensity );

				float lalpha = clamp( fresnel, 0.0, 1.0 ) * alpha;
				calpha = lalpha / clamp(lalpha + accumAlpha, 0.001, 1.0);
				accumAlpha += (1.0 - accumAlpha) * lalpha;
				return color;
			}`),
      };
      var yZ = class extends ye {
        constructor(_, L, R, N, z, F, U) {
          super("v3"),
            (this.nodeType = "Rainbow"),
            (this.filmThickness = _),
            (this.movement = L),
            (this.wavelengths = R),
            (this.noiseStrength = N),
            (this.noiseScale = z),
            (this.offset = F),
            (this.alpha = U),
            (this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`);
        }
        generate(_, L) {
          if (
            (_.require("vWorldViewDir"),
            _.require("worldNormal"),
            !_.isShader("fragment"))
          )
            return (
              console.warn(
                "RainbowNode is not compatible with " + _.shader + " shader.",
              ),
              _.format("vec3( 0.0 )", this.getType(_), L)
            );
          {
            _.require("uv"),
              (_.requires.uv = [!0]),
              _.addFragmentVariable(this.calpha, "float");
            let R = _.include(yZ.Nodes.rainbow),
              N = [];
            return (
              N.push(this.filmThickness.build(_, "f")),
              N.push(this.movement.build(_, "f")),
              N.push(this.wavelengths.build(_, "v3")),
              N.push(this.noiseStrength.build(_, "f")),
              N.push(this.noiseScale.build(_, "f")),
              N.push(this.offset.build(_, "v3")),
              N.push(this.alpha.build(_, "f")),
              N.push(this.calpha),
              _.format(R + "(" + N.join(",") + ")", this.getType(_), L)
            );
          }
        }
      };
      yZ.Nodes =
        ((tR = new yl(
          `vec3 attenuation(vec3 wavelengths, float filmThickness, float movement, float noiseStrength, float noiseScale, vec3 offset) {
                 vec3 st = position / noiseScale;
				 vec3 q = vec3(simplex3d(st),
							  simplex3d(st + vec3(1.0)),
							  simplex3d(st + vec3(1.0)));

				 vec3 r = vec3(simplex3d(st + vec3(1.4, 1.3, 1.0) * q + vec3(1.7, 9.2, 1.0)),
							  simplex3d(st + vec3(2.0, 1.2, 1.0) * q + vec3(8.3, 2.8, 1.0)),
							  simplex3d(st * q));

                 float noise = simplex3d(st + r);

                 return .5 + .5 * cos((((filmThickness + (noise * noiseStrength)) / (vec3(wavelengths.r * 1.0, wavelengths.g * 0.8, wavelengths.b * 0.6) + 1.0)) * dot(normalize(vWorldViewDir + (offset * -0.001)), normalize(vWNormal))) + movement);
             }`,
          [yX.simplex],
        )),
        {
          rainbow: new yl(
            `vec3 rainbow(float filmThickness, float movement, vec3 wavelengths, float noiseStrength, float noiseScale, vec3 offset, float alpha, out float calpha) {
                 vec3 res = clamp(attenuation(wavelengths, filmThickness, movement, noiseStrength, noiseScale, offset), 0.0, 2.0);

                 float rainbowContribution = clamp(res.r + res.g + res.b, 0.0, 1.0);
                 float lalpha = alpha * rainbowContribution;
                 calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
                 accumAlpha += ( 1.0 - accumAlpha ) * lalpha;

                 return res;
             }`,
            [tR],
          ),
        });
      var yK = class extends ye {
        constructor(_, L, R, N, z, F, U, k, Y, X, Q, K, J, $, ee, er) {
          super("v3"),
            (this.nodeType = "Outline"),
            (this.firstTime = !0),
            (this.outlineColor = _),
            (this.contourColor = L),
            (this.outlineWidth = R),
            (this.contourWidth = N),
            (this.contourThreshold = z),
            (this.outlineThreshold = F),
            (this.contourFrequency = U),
            (this.outlineSmoothing = k),
            (this.contourDirection = Y),
            (this.positionalLines = X),
            (this.compensation = Q),
            (this.resolution = K),
            (this.normalMap = J),
            (this.depthMap = $),
            (this.pixelRatio = ee),
            (this.alpha = er),
            (this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`);
        }
        generate(_, L) {
          if (
            (_.require("vWorldViewDir"),
            _.require("worldNormal"),
            (_.extensions.derivatives = !0),
            this.firstTime)
          ) {
            let L = this.outlineWidth.build(_, "f"),
              R = this.resolution.build(_, "v2"),
              N = this.compensation.build(_, "b"),
              z = this.pixelRatio.build(_, "f");
            _.addVertexParsVariable("randomColor", "attribute vec3"),
              _.addVertexParsVariable("extrudeNormal", "attribute vec3"),
              _.addVertexParsVariable(L, "uniform float"),
              _.addVertexParsVariable(R, "uniform vec2"),
              _.addVertexParsVariable(N, "uniform bool"),
              _.addVertexParsVariable(z, "uniform float"),
              _.addVertexParsVariable("vID", "flat out float"),
              _.addFragmentParsVariable("vID", "flat in float");
            let F = `g${this.uuid.toString().replace(/-/g, "")}`;
            _.addVertexFinalCode(`
                vID = randomColor.r;
                if (${N}) {
                    vec4 ${F}_clipPosition = projectionMatrix * (modelViewMatrix * vec4(position, 1.0));
                    // NOTE: For certain shapes, like spheres, we get incorrect extrusion when the
                    // normals face the camera directly. So we hackily fix this by offsetting the normal
                    // by a tiny amount.
                    vec3 ${F}_clipNormal = mat3(projectionMatrix) * (mat3(modelViewMatrix) * extrudeNormal) + 0.0000001;
                    vec2 ${F}_offset = normalize(${F}_clipNormal.xy) / ${R} * (${L} / 2.0) * ${F}_clipPosition.w * 2.0 * ${z};
                    ${F}_clipPosition.xy += ${F}_offset;
                    // TODO(MAX): To handle multiple outline layers, we only want to extrude
                    // if this offset is the biggest of all the potential offsets
                    gl_Position = ${F}_clipPosition;
                }
            `);
          }
          if (!_.isShader("fragment"))
            return (
              console.warn(
                "OutlineNode is not compatible with " + _.shader + " shader.",
              ),
              ""
            );
          {
            _.require("uv"),
              (_.requires.uv = [!0]),
              _.addFragmentVariable(this.calpha, "float");
            let R = _.include(yK.Nodes.outline),
              N = [];
            return (
              N.push(this.outlineColor.build(_, "c")),
              N.push(this.contourColor.build(_, "c")),
              N.push(this.outlineWidth.build(_, "f")),
              N.push(this.contourWidth.build(_, "f")),
              N.push(this.contourThreshold.build(_, "f")),
              N.push(this.outlineThreshold.build(_, "f")),
              N.push(this.contourFrequency.build(_, "f")),
              N.push(this.outlineSmoothing.build(_, "f")),
              N.push(this.contourDirection.build(_, "v3")),
              N.push(this.positionalLines.build(_, "b")),
              N.push(this.resolution.build(_, "v2")),
              N.push(this.normalMap.getTexture(_, "t")),
              N.push(this.depthMap.getTexture(_, "t")),
              N.push(this.pixelRatio.build(_, "f")),
              N.push(this.compensation.build(_, "b")),
              N.push(this.alpha.build(_, "f")),
              N.push(this.calpha),
              (this.firstTime = !this.firstTime),
              _.format(R + "(" + N.join(",") + ")", this.getType(_), L)
            );
          }
        }
      };
      yK.Nodes =
        ((tI = new yl(`
float sobelSample(sampler2D t, sampler2D d, vec2 uv, vec2 resolution, float outlineWidth, float pixelRatio)
{
    vec2 texelSize = (vec2(1.0) / resolution) * outlineWidth * pixelRatio;

    vec2 uvSamples[9];
    vec4 normalSamples[9];

	uvSamples[0] = uv + vec2( -texelSize.x, -texelSize.y);
	uvSamples[1] = uv + vec2(0.0, -texelSize.y);
	uvSamples[2] = uv + vec2(  texelSize.x, -texelSize.y);
	uvSamples[3] = uv + vec2( -texelSize.x, 0.0);
	uvSamples[4] = uv;
	uvSamples[5] = uv + vec2(  texelSize.x, 0.0);
	uvSamples[6] = uv + vec2( -texelSize.x, texelSize.y);
	uvSamples[7] = uv + vec2(0.0, texelSize.y);
	uvSamples[8] = uv + vec2(  texelSize.x, texelSize.y);


    normalSamples[0] = texture2D(t, uvSamples[0]);
    normalSamples[1] = texture2D(t, uvSamples[1]);
    normalSamples[2] = texture2D(t, uvSamples[2]);
    normalSamples[3] = texture2D(t, uvSamples[3]);
    normalSamples[4] = texture2D(t, uvSamples[4]);
    normalSamples[5] = texture2D(t, uvSamples[5]);
    normalSamples[6] = texture2D(t, uvSamples[6]);
    normalSamples[7] = texture2D(t, uvSamples[7]);
    normalSamples[8] = texture2D(t, uvSamples[8]);

    float depthBias = 0.0001;
    // TODO(MAX): Can we somehow reduce the number of conditionals here with MATH?!
    if (normalSamples[0].a != vID && normalSamples[0].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[0]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[1].a != vID && normalSamples[1].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[1]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[2].a != vID && normalSamples[2].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[2]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[3].a != vID && normalSamples[3].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[3]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }


    if (normalSamples[4].a != vID && normalSamples[4].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[4]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[5].a != vID && normalSamples[5].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[5]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[6].a != vID && normalSamples[6].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[6]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[7].a != vID && normalSamples[7].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[7]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[8].a != vID && normalSamples[8].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[8]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    vec4 sobel_edge_h = normalSamples[2] + (2.0*normalSamples[5]) + normalSamples[8] - (normalSamples[0] + (2.0*normalSamples[3]) + normalSamples[6]);
  	vec4 sobel_edge_v = normalSamples[0] + (2.0*normalSamples[1]) + normalSamples[2] - (normalSamples[6] + (2.0*normalSamples[7]) + normalSamples[8]);

    float edgeNormal = sqrt(dot(sobel_edge_h, sobel_edge_h) + dot(sobel_edge_v, sobel_edge_v));
    return edgeNormal;
}
`)),
        {
          outline: new yl(
            `vec3 outline(vec3 outlineColor, vec3 contourColor, float outlineWidth, float contourWidth, float outlineThreshold, float contourThreshold, float outlineSmoothing, float contourFrequency, vec3 contourDirection, bool positionalLines, vec2 resolution, sampler2D normalMap, sampler2D depthMap, float pixelRatio, bool compensation, float alpha, out float calpha) {
                vec3 result = outlineColor;
                float resultAlpha = 0.0;

                vec3 N = normalize(vWNormal);
                vec2 nuv = (gl_FragCoord.xy / resolution);
                float sobelSample = compensation ? sobelSample(normalMap, depthMap, nuv, resolution, outlineWidth / 2., pixelRatio) : sobelSample(normalMap, depthMap, nuv, resolution, outlineWidth, pixelRatio);
                resultAlpha = smoothstep(outlineThreshold - outlineSmoothing, outlineThreshold + outlineSmoothing, sobelSample);

                float t = 1.0 - contourThreshold;
                if(positionalLines) {
                    vec3 NDir = position * contourDirection;
                    float NT = NDir.x + NDir.y + NDir.z;
                    float f  = fract(NT * contourFrequency * 0.01);
                    float df = fwidth(NT * contourFrequency);

                    float g = smoothstep(df * (contourWidth * 0.01), df * (contourWidth * 0.01 * 2.0), f);
                    if (g < 1.0 && resultAlpha == 0.0) {
                        result = contourColor;
                        resultAlpha = 1.0;
                    }
                 }
                 else {
                    vec3 NDir = N * contourDirection;
                    float NT = NDir.x + NDir.y + NDir.z;
                    float df = fwidth(NT * contourThreshold);
                    float f = sin(NT * 1.0 * contourFrequency);
                    float g = smoothstep(0.0, df * contourWidth, 1.0 - f);

                    if (df > (t * 0.5) && g < 1.0 && resultAlpha == 0.0) {
                        result = contourColor;
                        resultAlpha = 1.0 - g;
                    }
                 }

                 float lalpha = alpha * resultAlpha;
                 calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
                 accumAlpha += ( 1.0 - accumAlpha ) * lalpha;
                 return result;
             }`,
            [tI],
          ),
        });
      var yJ = class extends ye {
        constructor(_, L, R, N, z, F, U, k) {
          super("v3"),
            (this.nodeType = "Transmission"),
            (this.thickness = _),
            (this.ior = L),
            (this.roughness = R),
            (this.transmissionSamplerSize = N),
            (this.transmissionSamplerMap = z),
            (this.transmissionDepthMap = F),
            (this.aspectRatio = U),
            (this.alpha = k),
            (this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`);
        }
        generate(_, L) {
          if (
            ((_.extensions.shaderTextureLOD = !0),
            (_.extensions.derivatives = !0),
            !_.isShader("fragment"))
          )
            return (
              console.warn(
                "TransmissionNode is not compatible with " +
                  _.shader +
                  " shader.",
              ),
              _.format("vec3( 0.0 )", this.getType(_), L)
            );
          {
            _.define("NUM_SAMPLES", 30),
              _.require("worldPosition"),
              (_.requires.worldNormal = !0),
              (_.requires.modelMatrix = !0),
              (_.requires.projectionMatrix = !0),
              _.addFragmentVariable(this.calpha, "float");
            let R = _.include(yJ.Nodes.transmission),
              N = [];
            return (
              N.push(this.thickness.build(_, "f")),
              N.push(this.ior.build(_, "f")),
              N.push(this.roughness.build(_, "f")),
              N.push(this.transmissionSamplerSize.build(_, "v2")),
              N.push(this.transmissionSamplerMap.getTexture(_, "t")),
              N.push(this.transmissionDepthMap.getTexture(_, "t")),
              N.push(this.aspectRatio.build(_, "v2")),
              N.push("normal"),
              N.push(this.alpha.build(_, "f")),
              N.push(this.calpha),
              _.format(R + "(" + N.join(",") + ")", this.getType(_), L)
            );
          }
        }
      };
      yJ.Nodes =
        ((tB = new yl(`
            float gaussian(vec2 i) {
                const float sigma = float(NUM_SAMPLES) * .25;
                return exp( -.5* dot(i/=sigma,i) ) / ( 6.28 * sigma*sigma );
            }`)),
        (tz = new yl(
          `
            vec3 blur(sampler2D sp, vec2 U, vec2 scale, float lod, sampler2D dm, vec2 unrefractedU, vec2 aspectRatio) {
                // Slightly modified version of this:
                // https://www.shadertoy.com/view/ltScRG

                const int LOD = 2;
                const int sLOD = 4; // tile size = 2^LOD

                vec3 O = vec3(0);
                float a = 0.0;
                const int s = NUM_SAMPLES/sLOD;
                for ( int i = 0; i < s*s; i++ ) {
                    int modulo = (i)-((i)/(s))*(s);
                    vec2 d = vec2(float(modulo), float(i/s))*float(sLOD) - float(NUM_SAMPLES)/2.;
                    vec2 uv = U + (scale * aspectRatio) * d;
                    // What is the depth of the opaque object we're trying to sample
                    float opaqueDepth = unpackRGBAToDepth(texture2D(dm, uv));
                    if (opaqueDepth != 0.0 && opaqueDepth < gl_FragCoord.z) {
                        uv = unrefractedU + ((scale * min(lod / 2., 1.)) * aspectRatio) * d;
                        lod = lod > 4.0 ? lod : lod / 2.0;
                    }
                    float gaussian = gaussian(d);
		            #ifdef TEXTURE_LOD_EXT
                    O += gaussian * texture2DLodEXT( sp, uv, lod).rgb;
                    #else
                    O += gaussian * textureLod( sp, uv, lod).rgb;
                    #endif
                    a += gaussian;
                }
                return O / a;
            }`,
          [tB],
        )),
        (tF = new yl(`
            vec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {
		        // Direction of refracted light.
		        vec3 refractionVector = refract( -v,  n, 1.0 / ior );
		        // Compute rotation-independant scaling of the model matrix.
		        vec3 modelScale;
		        modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		        modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		        modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		        // The thickness is specified in local space.
		        return normalize( refractionVector ) * thickness * modelScale;
	        }`)),
        (tU = new yl(`
float applyIorToRoughness( float roughness, float ior ) {
		// Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and
		// an IOR of 1.5 results in the default amount of microfacet refraction.
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	} `)),
        (tk = new yl(
          `
vec3 getTransmissionSample( vec2 fragCoord, float roughness, float ior, vec2 transmissionSamplerSize, sampler2D transmissionSamplerMap, sampler2D transmissionDepthMap, vec2 unrefractedCoords, vec2 aspectRatio) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
        float lod = applyIorToRoughness(roughness, ior);

        return blur(transmissionSamplerMap, fragCoord, vec2(lod / (transmissionSamplerSize.x / 2.)), min(framebufferLod / 5.5, 8.5), transmissionDepthMap, unrefractedCoords, aspectRatio);
	}`,
          [tU, tz],
        )),
        (tj = new yl(
          `
vec3 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness, vec2 transmissionSamplerSize, sampler2D transmissionSamplerMap, sampler2D transmissionDepthMap, vec2 aspectRatio ) {
        vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
        vec3 refractedRayExit = position + transmissionRay;

        // Project refracted vector on the framebuffer, while mapping to normalized device coordinates.
        vec4 ndcPos = projMatrix * viewMatrix *  vec4( refractedRayExit, 1.0 );
        vec2 refractionCoords = ndcPos.xy / ndcPos.w;
        refractionCoords += 1.0;
        refractionCoords /= 2.0;

        vec4 ndcPosUnrefracted = projMatrix * viewMatrix * vec4(position, 1.0 );
        vec2 unrefractedCoords = ndcPosUnrefracted.xy / ndcPosUnrefracted.w;
        unrefractedCoords += 1.0;
        unrefractedCoords /= 2.0;

        // Sample framebuffer to get pixel the refracted ray hits.
        return getTransmissionSample( refractionCoords, roughness, ior, transmissionSamplerSize, transmissionSamplerMap, transmissionDepthMap, unrefractedCoords, aspectRatio );
    }`,
          [tk, tF],
        )),
        {
          transmission: new yl(
            `
            vec3 transmission(float thickness, float ior, float roughness, vec2 transmissionSamplerSize, sampler2D transmissionSamplerMap, sampler2D transmissionDepthMap, vec2 aspectRatio, vec3 normal, float alpha, out float calpha) {
                vec3 v = vec3(0.);
                if (isOrthographic) {
                    v = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
                } else {
                    v = normalize(vWPosition - cameraPosition);
                }
                vec3 transmission = getIBLVolumeRefraction(vWNormal, -v, roughness,  vWPosition, modelMatrix, viewMatrix, projectionMatrix, ior, thickness, transmissionSamplerSize, transmissionSamplerMap, transmissionDepthMap, aspectRatio );
                float lalpha = alpha;

                 calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
                 accumAlpha += ( 1.0 - accumAlpha ) * lalpha;
                 return transmission;
            }`,
            [tj],
          ),
        });
      var y$ = class extends ye {
        constructor(_, L, R, N, z, F, U, k, Y, X, Q) {
          super("v3"),
            (this.nodeType = "Depth"),
            (this.gradientType = _),
            (this.smooth = L),
            (this.near = R),
            (this.far = N),
            (this.isVector = z),
            (this.isWorldSpace = F),
            (this.origin = U),
            (this.direction = k),
            (this.colors = Y),
            (this.steps = X),
            (this.alpha = Q),
            (this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`);
        }
        generate(_, L) {
          let R = `g${this.uuid.toString().replace(/-/g, "")}`,
            N = new yl(
              `vec3 ${R}_sdepth(float near, float far, vec3 origin, vec3 direction, vec4 colors[${R}_MAX_COLORS], float steps[${R}_MAX_COLORS], float alpha, out float calpha) {
               vec4 color = colors[0];
               #ifdef ${R}_IS_VECTOR
                   #ifdef ${R}_LINEAR
                       #ifdef ${R}_WORLDSPACE
                       float depth = vectorLinearWorldSpaceDepth(direction, origin, near, far);
                       #else
                       float depth = vectorLinearObjectSpaceDepth(direction, origin, near, far);
                       #endif
                   #else
                       #ifdef ${R}_WORLDSPACE
                           float depth = vectorSphericalWorldSpaceDepth(origin, near, far);
                       #else
                           float depth = vectorSphericalObjectSpaceDepth(origin, near, far);
                       #endif
                   #endif
               #else
                   float dist = length(vWPosition - cameraPosition);
			       float depth = ( dist - near ) / ( far - near );
               #endif


              float p;
              #ifdef ${R}_SMOOTH
				for ( int i = 1; i < ${R}_MAX_COLORS; i++ ) {
						p = clamp( ( depth - steps[i-1] ) / ( steps[i] - steps[i-1] ), 0.0, 1.0 );
						color = mix(color, colors[i], smoothstep(0.0, 1.0, p));
					}
              #else
                for ( int i = 1; i < ${R}_MAX_COLORS; i++ ) {
                   p = clamp(( depth - steps[i - 1] ) / ( steps[i] - steps[i - 1] ), 0.0, 1.0);
                   color = mix(color, colors[i], p);
                 }
              #endif

               float lalpha = alpha * color.a;
               calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );

			   accumAlpha += ( 1.0 - accumAlpha ) * lalpha;
               return color.rgb;
			}`,
              [
                y$.Nodes.vectorLinearWorldSpaceDepth,
                y$.Nodes.vectorLinearObjectSpaceDepth,
                y$.Nodes.vectorSphericalObjectSpaceDepth,
                y$.Nodes.vectorSphericalWorldSpaceDepth,
              ],
            );
          if (!_.isShader("fragment"))
            return (
              console.warn(
                "DepthNode is not compatible with " + _.shader + " shader.",
              ),
              _.format("vec3( 0.0 )", this.getType(_), L)
            );
          {
            _.define(`${R}_MAX_COLORS`, this.colors.value.length),
              this.smooth.value && _.define(`${R}_SMOOTH`),
              this.isVector.value > 0.5 && _.define(`${R}_IS_VECTOR`),
              0 === this.gradientType.value && _.define(`${R}_LINEAR`),
              this.isWorldSpace.value > 0.5 && _.define(`${R}_WORLDSPACE`),
              _.require("worldPosition"),
              _.addFragmentVariable(this.calpha, "float");
            let z = _.include(N),
              F = [];
            return (
              F.push(this.near.build(_, "f")),
              F.push(this.far.build(_, "f")),
              F.push(this.origin.build(_, "v3")),
              F.push(this.direction.build(_, "v3")),
              F.push(this.colors.build(_, "v4[]")),
              F.push(this.steps.build(_, "f[]")),
              F.push(this.alpha.build(_, "f")),
              F.push(this.calpha),
              _.format(z + "(" + F.join(",") + ")", this.getType(_), L)
            );
          }
        }
      };
      y$.Nodes = {
        vectorLinearWorldSpaceDepth:
          new yl(`float vectorLinearWorldSpaceDepth(vec3 direction, vec3 origin, float near, float far) {
               vec3 n = normalize(direction);
               float dist = (n.x*(vWPosition.x - origin.x) + n.y*(vWPosition.y - origin.y) + n.z*(vWPosition.z - origin.z));
               return ( dist - near ) / ( far - near );
            }`),
        vectorLinearObjectSpaceDepth:
          new yl(`float vectorLinearObjectSpaceDepth(vec3 direction, vec3 origin, float near, float far) {
               vec3 n = normalize(direction);
               float dist = (n.x*(position.x - origin.x) + n.y*(position.y - origin.y) + n.z*(position.z - origin.z));
               return ( dist - near ) / ( far - near );
            }`),
        vectorSphericalWorldSpaceDepth:
          new yl(`float vectorSphericalWorldSpaceDepth(vec3 origin, float near, float far) {
               float dist = length(vWPosition - origin);
               return ( dist - near ) / ( far - near );
            }`),
        vectorSphericalObjectSpaceDepth:
          new yl(`float vectorSphericalObjectSpaceDepth(vec3 origin, float near, float far) {
               float dist = length(position - origin);
               return ( dist - near ) / ( far - near );
            }`),
      };
      var y2 = class extends ye {
          constructor(_, L, R, N) {
            super("v3"),
              (this.nodeType = "Blend"),
              (this.a = _),
              (this.b = L),
              (this.alpha = R),
              (this.mode = N);
          }
          generate(_, L) {
            if (!_.isShader("fragment"))
              return (
                console.warn(
                  "BlendNode is not compatible with " + _.shader + " shader.",
                ),
                _.format("vec3( 0.0 )", this.getType(_), L)
              );
            {
              let R = [];
              return (
                R.push(this.a.build(_, "c")),
                R.push(this.b.build(_, "c")),
                R.push(this.alpha.build(_, "f")),
                R.push(this.mode.build(_, "i")),
                _.format("spe_blend(" + R.join(",") + ")", this.getType(_), L)
              );
            }
          }
        },
        y4 = (((xe = y4 || {}).NOISE = "noise"), (xe.MAP = "map"), xe),
        y5 = class extends ye {
          constructor(_, L, R, N, z) {
            super("v3"),
              (this.displacementTypeIndex = new yB(0)),
              (this.nodeType = "VertexDisplacement"),
              (this.intensity = _),
              (this.movementOrTexture = L),
              "map" === Object.values(y4)[this.displacementTypeIndex.value] &&
                (this.mat = new yH(this.movementOrTexture.value.matrix)),
              (this.cropOrOffset = R),
              (this.scale = N),
              (this.noiseFunctionIndex = z);
          }
          generate(_, L) {
            if (!_.isShader("vertex"))
              return (
                console.warn(
                  "VertexDisplacementNode is not compatible with " +
                    _.shader +
                    " shader.",
                ),
                _.format("vec3( 0.0 )", this.getType(_), L)
              );
            {
              _.define("USE_LAYER_DISPLACE");
              let R,
                N = [];
              switch (
                (N.push("displaced_position"),
                N.push("displaced_normal"),
                Object.values(y4)[this.displacementTypeIndex.value])
              ) {
                case "map":
                  (R = _.include(y5.Nodes.map)),
                    N.push(this.movementOrTexture.getTexture(_, "t")),
                    N.push("uv"),
                    N.push(this.cropOrOffset.build(_, "f")),
                    this.mat && N.push(this.mat.build(_, "mat3"));
                  break;
                case "noise": {
                  let L = Object.values(yY)[this.noiseFunctionIndex.value],
                    z = new yl(`vec3 orthogonal(vec3 v) {
							return normalize(abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0) : vec3(0.0, -v.z, v.y));
						}`),
                    F = new yl(
                      `vec3 distorted(vec3 p, vec3 n, float scale, float intensity, vec3 offset, float neighbour_offset, float movement) {
							return p + n * ${L}((p + offset) * scale * 0.001 + neighbour_offset + (movement * 0.1)) * intensity;
						}`,
                      [
                        yX.simplex,
                        yX.simplexFractal,
                        yX.simplexAshima,
                        yX.fbm,
                        yX.perlin,
                      ],
                    ),
                    U = new yl(
                      `vec3 vertexDisplacementNoise(vec3 position, vec3 normal, float scale, vec3 offset, float movement, float intensity, out vec3 displaced_normal) {
							vec3 displaced_position = distorted(position, normal, scale, intensity, offset, neighbor_offset, movement);
							vec3 tangent1 = orthogonal(normal);
							vec3 tangent2 = normalize(cross(normal, tangent1));

                            // TODO(Max): The distance to the neighbors was originally scaled by 0.1.
                            // This caused some small oval/circular visual artifacts in the lighting.
                            // For now, simply using neighbors further away betters the problem,
                            // but we should figure out the underlying cause when we have some time.
                            // Maybe its related to how we calculate the tangent and bitangent?
							vec3 nearby1 = position + tangent1;
							vec3 nearby2 = position + tangent2;
							vec3 distorted1 = distorted(nearby1, normal, scale, intensity, offset, neighbor_offset, movement);
							vec3 distorted2 = distorted(nearby2, normal, scale, intensity, offset, neighbor_offset, movement);
							displaced_normal = normalize(cross(distorted1 - displaced_position, distorted2 - displaced_position));
							return displaced_position;
						}`,
                      [F, z],
                    );
                  (R = _.include(U)),
                    N.push(this.scale.build(_, "f")),
                    N.push(this.cropOrOffset.build(_, "v3")),
                    N.push(this.movementOrTexture.build(_, "f"));
                }
              }
              return (
                N.push(this.intensity.build(_, "f")),
                N.push("displaced_normal"),
                _.format(R + "(" + N.join(",") + ")", this.getType(_), L)
              );
            }
          }
        };
      y5.Nodes =
        ((tG = new yl(`vec3 orthogonal(vec3 v) {
				return normalize(abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0) : vec3(0.0, -v.z, v.y));
			}`)),
        (tV =
          new yl(`float displacementMapTexture(sampler2D tex, float crop, vec2 uv, mat3 mat, vec2 offset) {
				vec2 uvs = (mat * vec3(uv * 2.0 - 1.0, 1.0) / 2.0 + 0.5).xy + offset;
				vec4 tmp = texture2D(tex, uvs);
				vec3 col = tmp.rgb;
				if (crop > 0.5) {
					if ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {
						return 0.0;
					}
				}
				return col.r;
			}`)),
        {
          map: new yl(
            `vec3 vertexDisplacementMap(vec3 position, vec3 normal, sampler2D tex, vec2 uv, float crop, mat3 mat, float intensity, out vec3 displaced_normal) {
				vec3 displaced_position = position + normal * displacementMapTexture(tex, crop, uv, mat, vec2(0.0)) * intensity;
				vec3 tangent1 = normalize(orthogonal(normal));
				vec3 tangent2 = normalize(cross(normal, tangent1));
				vec3 nearby1 = position + tangent1 * 0.1;
				vec3 nearby2 = position + tangent2 * 0.1;
				vec3 distorted1 = nearby1 + normal * displacementMapTexture(tex, crop, uv, mat, vec2(neighbor_offset)) * intensity;
				vec3 distorted2 = nearby2 + normal * displacementMapTexture(tex, crop, uv, mat, vec2(neighbor_offset)) * intensity;
				displaced_normal = normalize(cross(distorted1 - displaced_position, distorted2 - displaced_position));
				return displaced_position;
			}`,
            [tG, tV],
          ),
        });
      var y6 = class extends ye {
        constructor(_, L, R, N, z, F, U, k) {
          super("v3"),
            (this.nodeType = "Gradient"),
            (this.gradientType = _),
            (this.smooth = L),
            (this.colors = R),
            (this.steps = N),
            (this.offset = z),
            (this.morph = F),
            (this.angle = U),
            (this.alpha = k),
            (this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`);
        }
        generate(_, L) {
          if (!_.isShader("fragment"))
            return (
              console.warn(
                "GradientNode is not compatible with " + _.shader + " shader.",
              ),
              _.format("vec3( 0.0 )", this.getType(_), L)
            );
          {
            _.define("GRAD_MAX", 10),
              _.require("uv"),
              (_.requires.uv = [!0]),
              _.addFragmentVariable(this.calpha, "float");
            let R = _.include(y6.Nodes.gradient),
              N = [];
            return (
              N.push(this.gradientType.build(_, "i")),
              N.push(this.smooth.build(_, "b")),
              N.push(this.colors.build(_, "v4[]")),
              N.push(this.steps.build(_, "f[]")),
              N.push(this.offset.build(_, "v2")),
              N.push(this.morph.build(_, "v2")),
              N.push(this.angle.build(_, "f")),
              N.push(this.alpha.build(_, "f")),
              N.push(this.calpha),
              _.format(R + "(" + N.join(",") + ")", this.getType(_), L)
            );
          }
        }
      };
      y6.Nodes = {
        gradient:
          new yl(`vec3 gradient(int gradientType, bool smoothed, vec4 colors[GRAD_MAX], float steps[GRAD_MAX], vec2 offset, vec2 morph, float angle, float alpha, out float calpha) {
				vec4 color = colors[0];
				vec2 m = morph / vUv.xy;
				vec2 rot = vec2( 0.5 + m.x, m.y );
				vec2 dt = vec2(
					cos( angle ) * rot.x - sin( angle ) * rot.y,
					sin( angle ) * rot.x + cos( angle ) * rot.y
				);
				vec2 pt = ( vUv - 0.5 + offset ) / 2.0 + dt / 2.0;
				float t = dot( pt, dt ) / dot( dt, dt );
				if ( gradientType == 1 ) {
					t = distance (
						( vUv + morph ) * 3.0,
						( vUv + offset ) + 1.0
					) + angle;
				} else if ( gradientType == 2 ) {
					float polar = atan(
						vUv.x + morph.x - 0.5 + offset.x,
						vUv.y + morph.y - 0.5 + offset.y
					) * -1.0;
					t = fract( ( angle / PI / -2.0 ) + 0.5 * ( polar / PI ) );
				}

				float p;
				if (smoothed) {
					for ( int i = 1; i < GRAD_MAX; i++ ) {
						p = clamp( ( t - steps[i-1] ) / ( steps[i] - steps[i-1] ), 0.0, 1.0 );
						color = mix(color, colors[i], smoothstep(0.0, 1.0, p));
					}

				} else {
					for ( int i = 1; i < GRAD_MAX; i++ ) {
						p = clamp( ( t - steps[i-1] ) / ( steps[i] - steps[i-1] ), 0.0, 1.0 );
						color = mix(color, colors[i], p);
					}
				}

				float lalpha = alpha * color.a;
				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += ( 1.0 - accumAlpha ) * lalpha;

				return color.xyz;
			}`),
      };
      var y8 = class extends ye {
        constructor(_, L, R, N, z, F, U, k, Y, X) {
          super("v3"),
            (this.nodeType = "CustomTexture"),
            (this.firstTime = !0),
            (this.texture = _),
            (this.textureSize = L),
            (this.crop = R),
            (this.projection = N),
            (this.axis = z),
            (this.side = F),
            (this.size = U),
            (this.mat = k),
            (this.alpha = Y),
            (this.mode = X),
            (this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`);
        }
        generate(_, L) {
          _.require("position"),
            _.require("normal"),
            _.require("uv"),
            (_.requires.uv = [!0]),
            (_.extensions.shaderTextureLOD = !0),
            (_.extensions.derivatives = !0);
          let R = `g${this.uuid.toString().replace(/-/g, "")}`,
            N;
          switch (this.projection.value) {
            case 3:
              N = _.include(y8.Nodes.cylindrical);
              break;
            case 2:
              N = _.include(y8.Nodes.spherical);
              break;
            case 1:
              let z = [
                  "vec3(1.0, 0.0, 0.0)",
                  "vec3(0.0, 1.0, 0.0)",
                  "vec3(0.0, 0.0, 1.0)",
                ][this.axis.value],
                F = new yl(`
		vec3 ${R}_planarTexture(sampler2D tex, vec2 textureSize, float crop, mat3 mat, vec2 size, float alpha, int mode, out float calpha) {

				vec2 uvs = ( mat * vec3( (${R}_vCustomUv * 2. - 1.) / (size * .5), 1. ) / 2. + 0.5 ).xy;

				vec4 tmp = texture2D( tex, uvs );

				vec3 col = tmp.rgb;
				float lalpha = alpha * tmp.a;
				${
          2 === this.side.value
            ? ""
            : `lalpha *= step(0.0, ${
                1 === this.side.value ? "-1.0 * " : ""
              }dot(vObjectNormal, mat * ${z}));`
        }

				if ( crop > 0.5 ) {
					if ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {
						lalpha = 0.0;
					}
				}
				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += ( 1.0 - accumAlpha ) * lalpha;
				return col;
			}`);
              N = _.include(F);
              break;
            default:
              N = _.include(y8.Nodes.uv);
          }
          if (1 === this.projection.value && this.firstTime) {
            _.addVertexParsCode(`varying vec2 ${R}_vCustomUv;`),
              _.addFragmentParsCode(`varying vec2 ${R}_vCustomUv;`);
            let L = ["zy", "xz", "xy"][this.axis.value];
            _.addVertexFinalCode(
              `${R}_vCustomUv = (1. + (transformed.${L})) / 2.;`,
            );
          }
          _.addFragmentVariable(this.calpha, "float");
          let U = [];
          return (
            U.push(this.texture.generate(_, "t")),
            U.push(this.textureSize.build(_, "v2")),
            U.push(this.crop.build(_, "f")),
            U.push(this.mat.build(_, "mat3")),
            U.push(this.size.build(_, "v2")),
            U.push(this.alpha.build(_, "f")),
            U.push(this.mode.build(_, "i")),
            U.push(this.calpha),
            (this.firstTime = !this.firstTime),
            _.format(N + "(" + U.join(",") + ")", this.getType(_), L)
          );
        }
      };
      y8.Nodes = {
        cylindrical: new yl(`
vec3 cylindricalTexture(sampler2D tex, vec2 textureSize, float crop, mat3 mat, vec2 size, float alpha, int mode, out float calpha) {
                vec3 posN = normalize(position);
                float u = 0.5 + atan(posN.z, posN.x) / (2.*3.1415);
                float scaledHeight = position.y / (size.y * 0.5);
                float v =  (scaledHeight / 2.) + .5;

                vec2 calculatedUv = vec2(u,v);
				vec2 uvs = ( mat * vec3( calculatedUv * 2. - 1., 1. ) / 2. + 0.5 ).xy;

                vec2 df = fwidth(uvs);
               	if(df.x > 0.5) df.x = 0.;

				#ifdef GL_EXT_shader_texture_lod
                vec4 tmp = texture2DLodEXT(tex, uvs, log2(max(df.x, df.y)*min(textureSize.x, textureSize.y)));
				#else
                vec4 tmp = textureLod(tex, uvs, log2(max(df.x, df.y)*min(textureSize.x, textureSize.y)));
				#endif

				vec3 col = tmp.rgb;
				float lalpha = alpha * tmp.a;
				if ( crop > 0.5 ) {
					if ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {
						lalpha = 0.0;
					}
				}
				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += ( 1.0 - accumAlpha ) * lalpha;
				return col;
			}
`),
        spherical: new yl(`
vec3 sphericalTexture(sampler2D tex, vec2 textureSize, float crop, mat3 mat, vec2 size, float alpha, int mode, out float calpha) {
                vec3 posN = normalize(vPosition);
                float u = 0.5 + atan(posN.z, posN.x) / (2.*3.1415);
                float v = 0.5 + asin(posN.y) / 3.1415;

                vec2 calculatedUv = vec2(u,v);
				vec2 uvs = ( mat * vec3( calculatedUv * 2. - 1., 1. ) / 2. + 0.5 ).xy;

                vec2 df = fwidth(uvs);
               	if(df.x > 0.5) df.x = 0.;
				#ifdef GL_EXT_shader_texture_lod
                vec4 tmp = texture2DLodEXT(tex, uvs, log2(max(df.x, df.y)*min(textureSize.x, textureSize.y)));
				#else
                vec4 tmp = textureLod(tex, uvs, log2(max(df.x, df.y)*min(textureSize.x, textureSize.y)));
				#endif

				vec3 col = tmp.rgb;
				float lalpha = alpha * tmp.a;
				if ( crop > 0.5 ) {
					if ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {
						lalpha = 0.0;
					}
				}
				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += ( 1.0 - accumAlpha ) * lalpha;
				return col;
			}
`),
        uv: new yl(`vec3 uvTexture(sampler2D tex, vec2 textureSize, float crop, mat3 mat, vec2 size, float alpha, int mode, out float calpha) {

				vec2 uvs = ( mat * vec3( vUv * 2. - 1., 1. ) / 2. + 0.5 ).xy;
				vec4 tmp = texture2D( tex, uvs );

				vec3 col = tmp.rgb;

				float lalpha = alpha * tmp.a;
				if ( crop > 0.5 ) {
					if ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {
						lalpha = 0.0;
					}
				}
				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += ( 1.0 - accumAlpha ) * lalpha;
				return col;
			}`),
      };
      var y9 = class extends ye {
        constructor(_, L) {
          super("v3"),
            (this.nodeType = "CustomNormal"),
            (this.cnormal = _),
            (this.alpha = L);
        }
        generate(_, L) {
          if (!_.isShader("fragment"))
            return (
              console.warn(
                "CustomNormalNode is not compatible with " +
                  _.shader +
                  " shader.",
              ),
              _.format("vec3( 0.0 )", this.getType(_), L)
            );
          {
            let R = _.include(y9.Nodes.customNormal),
              N = [];
            return (
              N.push(this.cnormal.build(_, "v3")),
              N.push("normal"),
              N.push(this.alpha.build(_, "f")),
              _.format(R + "(" + N.join(",") + ")", this.getType(_), L)
            );
          }
        }
      };
      function Sr(_, L) {
        return L.color(_);
      }
      function ps(_) {
        let { alpha: L, mode: R } = _;
        return { type: _.type, alpha: L, mode: R };
      }
      y9.Nodes = {
        customNormal:
          new yl(`vec3 customNormal(vec3 cnormal, vec3 norm, float alpha) {
				vec3 normal = packNormalToRGB( norm ).rgb;
				normal *= step( vec3(0.5), cnormal );

				accumAlpha += ( 1.0 - accumAlpha ) * alpha;

				return normal;
			}`),
      };
      var y7,
        xe,
        xt,
        xi,
        xr,
        xn = class extends ys {},
        xa = class {
          constructor(_ = 1e4) {
            (this.timeout = _),
              (this.cache = new Map()),
              (this.head = {
                data: null,
                time: 0,
                src: null,
                next: null,
                prev: null,
              }),
              (this.tail = {
                data: null,
                time: 1 / 0,
                src: null,
                next: null,
                prev: null,
              }),
              (this.hasClean = !1),
              (this.head.next = this.tail),
              (this.tail.prev = this.head);
          }
          log(..._) {}
          remove(_) {
            let L = this.cache.get(_);
            L &&
              (this.dispose(_, L.data),
              this.cache.delete(_),
              (L.prev.next = L.next),
              (L.next.prev = L.prev));
          }
          scheduleCleanup() {
            this.hasClean ||
              (this.log("scheduled cleanup"),
              (this.hasClean = !0),
              setTimeout(() => {
                (this.hasClean = !1), this.log("cleaning");
                let _ = Date.now(),
                  L = this.head.next;
                for (; L.time < _ - this.timeout; )
                  this.dispose(L.src, L.data),
                    this.cache.delete(L.src),
                    ((L = L.next).prev = this.head),
                    (this.head.next = L);
                this.head.next !== this.tail
                  ? this.scheduleCleanup()
                  : this.log("no more cleanup");
              }, this.timeout + 1e3));
          }
          has(_) {
            return this.cache.get(_)?.data;
          }
          load(_) {
            let L = Date.now(),
              R = this.cache.get(_);
            return (
              void 0 === R
                ? ((R = {
                    data: this.create(_),
                    src: _,
                    time: L,
                    next: null,
                    prev: null,
                  }),
                  this.cache.set(_, R))
                : ((R.time = L),
                  (R.prev.next = R.next),
                  (R.next.prev = R.prev)),
              (R.prev = this.tail.prev),
              (R.next = this.tail),
              (this.tail.prev.next = R),
              (this.tail.prev = R),
              this.scheduleCleanup(),
              R.data
            );
          }
        },
        xo = class extends xa {
          create(_) {
            return URL.createObjectURL(new Blob([_]));
          }
          dispose(_, L) {
            URL.revokeObjectURL(L);
          }
        },
        xl = class {
          constructor(_, L) {
            (this.data = _), (this.cache = L), (this.refCount = 0);
          }
          deref() {
            this.refCount,
              (this.refCount -= 1),
              0 === this.refCount && (this.cache.remove(this), this.dispose());
          }
          dispose() {
            this.refCount;
          }
        },
        xh = class {
          constructor() {
            this.cache = new Map();
          }
          remove(_) {
            this.cache.delete(_.data);
          }
          load(_) {
            let L = this.cache.get(_);
            return (
              void 0 === L && ((L = this.create(_)), this.cache.set(_, L)),
              (L.refCount += 1),
              L
            );
          }
        },
        xd = class extends xl {
          constructor(_, L) {
            super(_, L.imageHolderCache),
              (this.data = _),
              (this.shared = L),
              (this.loaded = !1),
              (this.isVideo = !1),
              (this.isVideo = "video" == _.type),
              this.updateSrc(_.data);
          }
          async updateSrc(_) {
            if (typeof document > "u") return;
            this.disposeTextures(), (this.loaded = !1);
            let n = () => {
              for (let _ of ((this.loaded = !0), [1e3, 1001, 1002])) {
                let L = this[_];
                L && ((L.image = this.img), (L.needsUpdate = !0));
              }
              this.shared.requestRender();
            };
            if (this.isVideo) {
              if (
                ((this.img = document.createElement("video")),
                (this.img.preload = "auto"),
                (this.img.playsInline = !0),
                (this.img.currentTime = 0.01),
                "string" != typeof _)
              ) {
                let R;
                var L = new FileReader();
                L.readAsDataURL(new Blob([_], { type: "video/mp4" })),
                  await new Promise((_) => {
                    L.onloadend = (L) => {
                      (R = L.target?.result), _(null);
                    };
                  }),
                  (this.img.src = R);
              } else this.img.src = _;
              this.img.onloadeddata = () => {
                n();
              };
            } else
              (this.img = new Image()),
                (this.img.src =
                  "string" == typeof _
                    ? _
                    : (xr || (xr = new xo()), xr.load(_))),
                (this.img.onload = n);
          }
          getTexture(_) {
            let L = this[_];
            if (L) return L;
            {
              let L;
              return (
                (L = this.isVideo
                  ? new ac(this.img, void 0, _, _)
                  : new iG(this.img, void 0, _, _)),
                this.loaded && (L.needsUpdate = !0),
                (this[_] = L),
                L
              );
            }
          }
          disposeTextures() {
            this[1e3]?.dispose(),
              (this[1e3] = void 0),
              this[1001]?.dispose(),
              (this[1001] = void 0),
              this[1002]?.dispose(),
              (this[1002] = void 0);
          }
          dispose() {
            super.dispose(), this.disposeTextures();
          }
        },
        xp = class extends xd {},
        xm = class extends yt {},
        xg = {
          noise: ["noiseType"],
          texture: ["projection", "axis", "side"],
          video: ["projection", "axis", "side"],
          displace: ["noiseType"],
          depth: ["smooth", "isWorldSpace", "gradientType", "isVector"],
        },
        xv = { depth: ["colors"] };
      function Cb(_, L, R) {
        let N = R.uniforms[`f${R.id}_texture`];
        if (!N) return !1;
        if ("image" in _) {
          let R = _.image,
            z = L.image(R);
          N.image instanceof xp || N.image.deref(), (N.image = z);
        }
        if ("video" in _) {
          let R = _.video,
            z = L.video(R);
          N.image instanceof xp || N.image.deref(), (N.image = z);
        }
        if (
          ("wrapping" in _ && (N.wrap = _.wrapping),
          "repeat" in _ || "offset" in _)
        ) {
          let L = R.uniforms[`f${R.id}_mat`];
          "repeat" in _ && (L.repeat = _.repeat),
            "offset" in _ && (L.offset = _.offset),
            L.updateMatrix();
        }
        return !1;
      }
      var xy = class extends ye {
        constructor(_, L, R) {
          super("v3"),
            (this.nodeType = "Matcap"),
            (this.texture = _),
            (this.alpha = L),
            (this.mode = R),
            (this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`);
        }
        generate(_, L) {
          if (!_.isShader("fragment"))
            return (
              console.warn(
                "MatcapNode is not compatible with " + _.shader + " shader.",
              ),
              _.format("vec3( 0.0 )", this.getType(_), L)
            );
          {
            _.addFragmentVariable(this.calpha, "float");
            let R = _.include(xy.Nodes.matcap);
            _.require("normal"), (_.requires.normal = !0);
            let N = [];
            return (
              N.push(this.texture.generate(_, "t")),
              N.push("normal"),
              N.push(this.alpha.build(_, "f")),
              N.push(this.mode.build(_, "i")),
              N.push(this.calpha),
              _.format(R + "(" + N.join(",") + ")", this.getType(_), L)
            );
          }
        }
      };
      xy.Nodes = {
        matcap:
          new yl(`vec3 matcap(sampler2D matcapTex, vec3 normal, float alpha, int mode, out float calpha) {
                vec3 viewDir = normalize( vViewPosition );
                vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
                vec3 y = cross( viewDir, x );
                vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5; // 0.495 to remove artifacts caused by undersized matcap disks
                vec4 matcapColor = texture2D( matcapTex, uv );

                calpha =  alpha / clamp( alpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += ( 1.0 - accumAlpha ) * alpha;
                
                return matcapColor.rgb;
            }
            `),
      };
      var xb = class extends xm {
          constructor(_, L) {
            super("t"), (this.image = _), (this.wrap = L);
          }
          get value() {
            return this.image.getTexture(this.wrap);
          }
        },
        xw = class extends xm {
          constructor(_) {
            super("v3"), (this.image = _), (this._value = new iq());
          }
          get value() {
            return (
              (this._value.x = this.image.isVideo
                ? this.image.img.videoWidth ?? 0
                : this.image.img.width),
              (this._value.y = this.image.isVideo
                ? this.image.img.videoHeight ?? 0
                : this.image.img.height),
              this._value
            );
          }
        },
        x_ = class extends ye {
          constructor(_, L, R, N, z, F, U, k, Y, X) {
            super("v3"),
              (this.nodeType = "Toon"),
              (this.positioning = _),
              (this.colors = L),
              (this.steps = R),
              (this.source = N),
              (this.isWorldSpace = z),
              (this.noiseStrength = F),
              (this.noiseScale = U),
              (this.shadowColor = k),
              (this.offset = Y),
              (this.alpha = X),
              (this.calpha = `g${this.uuid
                .toString()
                .replace(/-/g, "")}_calpha`);
          }
          generate(_, L) {
            if (
              (_.require("worldNormal"),
              _.require("worldPosition"),
              !_.isShader("fragment"))
            )
              return (
                console.warn(
                  "ToonNode is not compatible with " + _.shader + " shader.",
                ),
                _.format("vec3( 0.0 )", this.getType(_), L)
              );
            {
              _.define("COLORS_MAX", 10),
                _.addFragmentVariable(this.calpha, "float");
              let R = _.include(x_.Nodes.toon),
                N = [];
              return (
                N.push(this.positioning.build(_, "i")),
                N.push(this.colors.build(_, "v4[]")),
                N.push(this.steps.build(_, "f[]")),
                N.push(this.source.build(_, "v3")),
                N.push(this.isWorldSpace.build(_, "b")),
                N.push(this.noiseStrength.build(_, "f")),
                N.push(this.noiseScale.build(_, "f")),
                N.push(this.shadowColor.build(_, "v4")),
                N.push(this.offset.build(_, "v3")),
                N.push(this.alpha.build(_, "f")),
                N.push(this.calpha),
                _.format(R + "(" + N.join(",") + ")", this.getType(_), L)
              );
            }
          }
        };
      function xC(_, L, R) {
        _.setUvTransform(R[0], R[1], L[0], L[1], 0, 0, 0);
      }
      x_.Nodes =
        ((tH = new yl(`float rand(float n) {
				return fract(sin(n) * 43758.5453123);
			}`)),
        (tW = new yl(`float hash1(float p) { 
				p = fract(p * 0.011); 
				p *= p + 7.5; 
				p *= p + p; 
				return fract(p); 
			}`)),
        (tY = new yl(
          `float valueNoise(vec3 x) {
				const vec3 step = vec3(110, 241, 171);
			
				vec3 i = floor(x);
				vec3 f = fract(x);
			 
				// For performance, compute the base input to a 1D hash from the integer part of the argument and the 
				// incremental change to the 1D based on the 3D -> 1D wrapping
				float n = dot(i, step);
			
				vec3 u = f * f * (3.0 - 2.0 * f);
				return mix(mix(mix( hash1(n + dot(step, vec3(0, 0, 0))), hash1(n + dot(step, vec3(1, 0, 0))), u.x),
							   mix( hash1(n + dot(step, vec3(0, 1, 0))), hash1(n + dot(step, vec3(1, 1, 0))), u.x), u.y),
						   mix(mix( hash1(n + dot(step, vec3(0, 0, 1))), hash1(n + dot(step, vec3(1, 0, 1))), u.x),
							   mix( hash1(n + dot(step, vec3(0, 1, 1))), hash1(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);
			}`,
          [tW],
        )),
        (tX = new yl(`vec3 hash3(vec3 x) {
				x = vec3(dot(x,vec3(127.1, 311.7, 74.7)),
						 dot(x,vec3(269.5, 183.3, 246.1)),
						 dot(x,vec3(113.5, 271.9, 124.6)));
			
				return fract(sin(x)*43758.5453123);
			}`)),
        (tq = new yl(
          `vec3 voronoiNoise(in vec3 x)
			{
				vec3 p = floor(x);
				vec3 f = fract(x);

				float id = 0.0;
				vec2 res = vec2(100.0);

				for(int k=-1; k<=1; k++)
				for(int j=-1; j<=1; j++)
				for(int i=-1; i<=1; i++)
				{
					vec3 b = vec3(float(i), float(j), float(k));

					// Comment out the "+ hash(p + b);" part below to get "square" cells
					vec3 r = vec3(b) - f + hash3(p + b);
					float d = dot(r, r);

					if (d < res.x)
					{
						id = dot(p + b, vec3(1.0, 57.0, 113.0));
						res = vec2(d, res.x);			
					}
					else if (d < res.y)
					{
						res.y = d;
					}
				}

				return vec3(sqrt(res), abs(id));
			}
			`,
          [tX],
        )),
        {
          toon: new yl(
            `vec3 toon(int positioning, vec4 colors[COLORS_MAX], float steps[COLORS_MAX], vec3 source, bool isWorldSpace, float noiseStrength, float noiseScale, vec4 shadowColor, vec3 offset, float alpha, out float calpha) {
				float t = 0.0;
				float shadow = 1.0;

				if (positioning == 0) {

					// Can't do this mode if lighting is "none"
					#if (defined(PHONG) || defined(LAMBERT) || defined(STANDARD))

						// Algorithm from Chapter 10 of Graphics Shaders
						const vec3 weights = vec3(0.2125, 0.7154, 0.0721);
						vec3 lpos;
						vec3 l;
						float dproduct;

						#if (NUM_POINT_LIGHTS > 0)

							#if defined(USE_SHADOWMAP) && (NUM_POINT_LIGHT_SHADOWS > 0)
								PointLightShadow pointLightShadow;
							#endif 

							#pragma unroll_loop_start
							for (int i = 0; i < NUM_POINT_LIGHTS; i++) {
								// Light positions are in view-space for some reason?
								lpos = (inverse(viewMatrix) * vec4(pointLights[UNROLLED_LOOP_INDEX].position, 1.0)).xyz;
								l = normalize(lpos - worldPosition);
								
								dproduct = dot(l, normalize(worldNormal)) * 0.5 + 0.5;
								
								// TODO: we want to use "intensity" but it isn't available in the shader code
								//dproduct += dot(pointLights[UNROLLED_LOOP_INDEX].color, weights);

								t = max(t, dproduct);

								// Accumulate shadow contribution
								#if defined(USE_SHADOWMAP) && (UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS)
									pointLightShadow = pointLightShadows[UNROLLED_LOOP_INDEX];
									shadow *= getPointShadow( 
											pointShadowMap[UNROLLED_LOOP_INDEX], 
											pointLightShadow.shadowMapSize, 
											pointLightShadow.shadowBias, 
											pointLightShadow.shadowRadius,
											vPointShadowCoord[UNROLLED_LOOP_INDEX], 
											pointLightShadow.shadowCameraNear, 
											pointLightShadow.shadowCameraFar);
								#endif
							}
							#pragma unroll_loop_end

						#endif

						#if NUM_DIR_LIGHTS > 0 
							
							#if defined(USE_SHADOWMAP) && (NUM_DIR_LIGHT_SHADOWS > 0)
								DirectionalLightShadow directionalLightShadow;
							#endif 

							#pragma unroll_loop_start
							for (int i = 0; i < NUM_DIR_LIGHTS; i++) {
								// Use the direction vector for directional lights instead
								l = (inverse(viewMatrix) * vec4(directionalLights[UNROLLED_LOOP_INDEX].direction, 0.0)).xyz;
		
								dproduct = dot(l, normalize(worldNormal)) * 0.5 + 0.5;
								t = max(t, dproduct);

								// Accumulate shadow contribution
								#if defined(USE_SHADOWMAP) && (UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS)
									directionalLightShadow = directionalLightShadows[UNROLLED_LOOP_INDEX];
									shadow *= getShadow( 
										UNROLLED_LOOP_INDEX,
										directionalShadowMap[UNROLLED_LOOP_INDEX], 
										directionalLightShadow.shadowMapSize, 
										directionalLightShadow.shadowBias, 
										directionalLightShadow.shadowRadius, 
										vDirectionalShadowCoord[UNROLLED_LOOP_INDEX]);
								#endif
							}
							#pragma unroll_loop_end

						#endif

						#if NUM_SPOT_LIGHTS > 0 
							
							#if defined(USE_SHADOWMAP) && (NUM_SPOT_LIGHT_SHADOWS > 0)
								SpotLightShadow spotLightShadow;
							#endif 

							#pragma unroll_loop_start
							for (int i = 0; i < NUM_SPOT_LIGHTS; i++) {
								lpos = (inverse(viewMatrix) * vec4(spotLights[UNROLLED_LOOP_INDEX].position, 1.0)).xyz;
								l = normalize(lpos - worldPosition);
								
								dproduct = dot(l, normalize(worldNormal)) * 0.5 + 0.5;
								t = max(t, dproduct);

								// Accumulate shadow contribution
								#if defined(USE_SHADOWMAP) && (UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS)
									spotLightShadow = spotLightShadows[UNROLLED_LOOP_INDEX];
									shadow *= getShadow(
										UNROLLED_LOOP_INDEX,
										spotShadowMap[UNROLLED_LOOP_INDEX], 
										spotLightShadow.shadowMapSize, 
										spotLightShadow.shadowBias, 
										spotLightShadow.shadowRadius, 
										vSpotLightCoord[UNROLLED_LOOP_INDEX]);
								#endif
							}
							#pragma unroll_loop_end

						#endif

						t = clamp(t, 0.0, 1.0);
				
					#endif

				} else if (positioning == 1) {
					
					vec3 origin = mix(position, worldPosition, float(isWorldSpace));
					vec3 direction = normalize(source - origin);
					t = dot(direction, normalize(worldNormal)) * 0.5 + 0.5;	

				} else {

					vec3 origin = worldPosition;
					vec3 source = cameraPosition - offset;
					vec3 direction = normalize(source - origin);
					t = dot(direction, normalize(worldNormal)) * 0.5 + 0.5;	
					
				}

				if (noiseStrength > 0.0) {
					// Distort with noise
					vec3 st = position / noiseScale;
					
					// Voronoi "smooth" noise
					float noise = 1.0 - voronoiNoise(st).x;

					// Voronoi cellular noise
					//float noise = 1.0 - rand(voronoiNoise(st).z);

					// Position warp noise
					// vec3 offset = vec3(
					// 	simplex3d(st),
					// 	simplex3d(st + vec3(111.1, 143.89, 217.19)),
					// 	simplex3d(st + vec3(171.1, 247.89, 117.23))
					// );
					// st += offset;
					// float noise = valueNoise(st);

					t += noise * noiseStrength;
				}

				t = clamp(t, 0.0, 1.0);

				// Compute ramp color
				float p;
				vec4 color = colors[0];
				for (int i = 1; i < COLORS_MAX; i++) {
					p = clamp((t - steps[i-1]) / (steps[i] - steps[i-1]), 0.0, 1.0);
					color = mix(color, colors[i], smoothstep(0.0, 1.0, p));
				}

				// Incorporate custom shadow color
				if (positioning == 0) {

					vec3 blendedShadow = mix(color.rgb, shadowColor.rgb, shadowColor.a);
					color.rgb = mix(blendedShadow, color.rgb, shadow);
				
				}

				// Accumulate alpha as usual
				float lalpha = alpha * color.a;
				calpha =  lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0);
				accumAlpha += (1.0 - accumAlpha) * lalpha;

				return color.xyz;

            }`,
            [yX.simplex, tH, tY, tq],
          ),
        });
      var xS = class extends yH {
          constructor(_, L) {
            super(new iC()),
              (this.repeat = _),
              (this.offset = L),
              xC(this.value, _, L);
          }
          updateMatrix() {
            xC(this.value, this.repeat, this.offset);
          }
        },
        xA = class {
          constructor(_, L, R, N) {
            for (let z in ((this.id = _),
            (this.uuid = L),
            (this.data = R),
            (this.uniforms = {}),
            N))
              this.uniforms[`f${this.id}_${z}`] = N[z];
            for (let _ in R) Pb(_, this, R);
          }
          get type() {
            return this.data.type;
          }
          static create(_, L, R, N) {
            if ("light" === R.type) return xD.createLigherLayer(_, L, R, N);
            if ("texture" === R.type || "video" === R.type) {
              let z =
                  "texture" === R.type
                    ? N.image(R.texture.image)
                    : N.video(R.texture.video),
                F = new xb(z, R.texture.wrapping),
                U = new xw(z),
                k = new xS(R.texture.repeat, R.texture.offset),
                Y = new yx(R.crop ? 1 : 0),
                X = new yB(R.projection ?? 0),
                Q = new yB(["x", "y", "z"].indexOf(R.axis) ?? 0),
                K = new yB(R.side ?? 0),
                J = new yi(
                  R.size ? new iT(R.size[0], R.size[1]) : new iT(100, 100),
                ),
                $ = new yx(R.alpha ?? 1),
                ee = new yB(R.mode ?? 0),
                er = new y8(F, U, Y, X, Q, K, J, k, $, ee),
                en = new yv(er.calpha, "f");
              return new xM(
                _,
                L,
                R,
                {
                  texture: F,
                  textureSize: U,
                  crop: Y,
                  projection: X,
                  axis: Q,
                  side: K,
                  size: J,
                  mat: k,
                  alpha: $,
                  mode: ee,
                },
                er,
                ee,
                en,
              );
            }
            if ("matcap" === R.type) {
              let z = N.image(R.texture.image),
                F = new xb(z, R.texture.wrapping),
                U = new yx(R.alpha ?? 1),
                k = new yB(R.mode ?? 0),
                Y = new xy(F, U, k),
                X = new yv(Y.calpha, "f");
              return new xM(
                _,
                L,
                R,
                { texture: F, alpha: U, mode: k },
                Y,
                k,
                X,
              );
            }
            if ("displace" !== R.type) {
              let z;
              return (
                (z = (function (_, L) {
                  switch (_.type) {
                    case "fresnel":
                      return (function (_, L) {
                        let {
                          bias: R,
                          scale: N,
                          intensity: z,
                          factor: F,
                          color: U,
                        } = _;
                        return {
                          ...ps(_),
                          color: Sr(U, L),
                          bias: R,
                          scale: N,
                          intensity: z,
                          factor: F,
                        };
                      })(_, L);
                    case "gradient":
                      return (function (_) {
                        let {
                          gradientType: L,
                          smooth: R,
                          colors: N,
                          steps: z,
                          angle: F,
                          offset: U,
                          morph: k,
                        } = _;
                        return {
                          ...ps(_),
                          gradientType: L,
                          smooth: R,
                          colors: N.map((_) => new iV(_[0], _[1], _[2], _[3])),
                          num: N.length,
                          steps: z,
                          offset: new iT(...U),
                          morph: new iT(...k),
                          angle: F,
                        };
                      })(_);
                    case "depth":
                      return (function (_) {
                        let {
                          gradientType: L,
                          near: R,
                          far: N,
                          isVector: z,
                          isWorldSpace: F,
                          origin: U,
                          direction: k,
                          colors: Y,
                          steps: X,
                          smooth: Q,
                        } = _;
                        return {
                          ...ps(_),
                          gradientType: L,
                          near: R,
                          far: N,
                          isVector: z,
                          isWorldSpace: F,
                          origin: new iq(...U),
                          direction: k ? new iq(...k) : new iq(1, 0, 0),
                          colors: Y.map((_) =>
                            void 0 !== _
                              ? new iV(_[0], _[1], _[2], _[3])
                              : new iV(0, 0, 0, 0),
                          ),
                          steps: X.slice(0, Y.length),
                          smooth: Q,
                        };
                      })(_);
                    case "normal":
                      return (function (_) {
                        let { cnormal: L } = _;
                        return { ...ps(_), cnormal: new iq(L[0], L[1], L[2]) };
                      })(_);
                    case "noise":
                      return {
                        ...ps(_),
                        scale: _.scale,
                        move: _.move,
                        fA: new iT(..._.fA),
                        fB: new iT(..._.fB),
                        size: new iq(..._.size),
                        distortion: new iT(..._.distortion),
                        colorA: Sr(_.colorA, L),
                        colorB: Sr(_.colorB, L),
                        colorC: Sr(_.colorC, L),
                        colorD: Sr(_.colorD, L),
                        noiseType: _.noiseType,
                      };
                    case "rainbow":
                      return {
                        ...ps(_),
                        filmThickness: _.filmThickness,
                        movement: _.movement,
                        wavelengths: new iq(..._.wavelengths),
                        noiseStrength: _.noiseStrength,
                        noiseScale: _.noiseScale,
                        offset: new iq(..._.offset),
                      };
                    case "toon":
                      return {
                        ...ps(_),
                        positioning: _.positioning,
                        colors: _.colors.map(
                          (_) => new iV(_[0], _[1], _[2], _[3]),
                        ),
                        num: _.colors.length,
                        steps: _.steps,
                        source: new iq(..._.source),
                        isWorldSpace: _.isWorldSpace,
                        noiseStrength: _.noiseStrength,
                        noiseScale: _.noiseScale,
                        shadowColor: Sr(_.shadowColor, L),
                        offset: new iq(..._.offset),
                      };
                    case "outline":
                      return {
                        ...ps(_),
                        outlineColor: Sr(_.outlineColor, L),
                        contourColor: Sr(_.contourColor, L),
                        outlineWidth: _.outlineWidth,
                        contourWidth: _.contourWidth,
                        outlineThreshold: _.outlineThreshold,
                        contourThreshold: _.contourThreshold,
                        outlineSmoothing: _.outlineSmoothing,
                        contourFrequency: _.contourFrequency,
                        contourDirection: new iq(..._.contourDirection),
                        positionalLines: _.positionalLines,
                        compensation: _.compensation,
                      };
                    case "transmission":
                      return {
                        ...ps(_),
                        thickness: _.thickness,
                        ior: _.ior,
                        roughness: _.roughness,
                      };
                    case "color":
                      return { ...ps(_), color: Sr(_.color, L) };
                  }
                })(R, N)),
                (function (_, L, R, N) {
                  switch (_.type) {
                    case "color": {
                      let z = new yI(N.color ?? 5526619),
                        F = new yx(N.alpha ?? 1),
                        U = new yv(
                          "alpha / clamp(alpha + accumAlpha, 0.00001, 1.0 )",
                          "f",
                        );
                      U.keywords.alpha = F;
                      let k = new yB(N.mode ?? 0);
                      return (
                        (z.alpha = F),
                        new xM(
                          L,
                          R,
                          _,
                          { color: z, alpha: F, mode: k },
                          z,
                          k,
                          U,
                        )
                      );
                    }
                    case "fresnel": {
                      let z = new yI(N.color ?? 16777215),
                        F = new yx(N.bias ?? 0.1),
                        U = new yx(N.scale ?? 1),
                        k = new yx(N.intensity ?? 2),
                        Y = new yx(N.factor ?? 1),
                        X = new yx(N.alpha ?? 1),
                        Q = new yB(N.mode ?? 0),
                        K = new yQ(z, F, U, k, Y, X, Q),
                        J = new yv(K.calpha, "f");
                      return new xM(
                        L,
                        R,
                        _,
                        {
                          color: z,
                          bias: F,
                          scale: U,
                          intensity: k,
                          factor: Y,
                          alpha: X,
                          mode: Q,
                        },
                        K,
                        Q,
                        J,
                      );
                    }
                    case "rainbow": {
                      let z = new yx(N.filmThickness ?? 30),
                        F = new yx(N.movement ?? 0),
                        U = new yr(N.wavelengths ?? new iq(0, 0, 0)),
                        k = new yx(N.noiseStrength ?? 0),
                        Y = new yx(N.noiseScale ?? 1),
                        X = new yr(N.offset ?? new iq(0, 0, 0)),
                        Q = new yx(N.alpha ?? 1),
                        K = new yZ(z, F, U, k, Y, X, Q),
                        J = new yv(K.calpha, "f"),
                        $ = new yB(N.mode ?? 0);
                      return new xM(
                        L,
                        R,
                        _,
                        {
                          filmThickness: z,
                          movement: F,
                          wavelengths: U,
                          noiseStrength: k,
                          noiseScale: Y,
                          offset: X,
                          alpha: Q,
                          mode: $,
                        },
                        K,
                        $,
                        J,
                      );
                    }
                    case "transmission": {
                      let z = new yx(N.thickness ?? 10),
                        F = new yx(N.ior ?? 1.5),
                        U = new yx(N.roughness ?? 0.5),
                        k = yF.transmissionSize,
                        Y = yF.transmissionRenderTarget,
                        X = yF.transmissionRenderTargetDepth,
                        Q = window.innerWidth,
                        K = window.innerHeight,
                        J = Q >= K ? new yi(K / Q, 1) : new yi(1, Q / K),
                        $ = new yx(N.alpha ?? 1),
                        ee = new yJ(z, F, U, k, Y, X, J, $),
                        er = new yv(ee.calpha, "f"),
                        en = new yB(N.mode ?? 0);
                      return new xM(
                        L,
                        R,
                        _,
                        {
                          thickness: z,
                          ior: F,
                          roughness: U,
                          aspectRatio: J,
                          alpha: $,
                          mode: en,
                        },
                        ee,
                        en,
                        er,
                      );
                    }
                    case "toon": {
                      let z,
                        F = new yB(N.positioning ?? 0),
                        U;
                      N.colors
                        ? (U = new yW(N.colors.length, N.colors))
                        : ((U = new yW(10, new iV(0, 0, 0, 1))).value[1] =
                            new iV(1, 1, 1, 1)),
                        N.steps
                          ? (z = new yz(N.steps.length, N.steps))
                          : ((z = new yz(10, 1)).value[0] = 0);
                      let k = new yr(N.source ?? new iq(0, 0, 0)),
                        Y = new yV(N.isWorldSpace ?? !0),
                        X = new yx(N.noiseStrength ?? 0),
                        Q = new yx(N.noiseScale ?? 1),
                        K = new yn(N.shadowColor),
                        J = new yr(N.offset ?? new iq(0, 0, 0)),
                        $ = new yx(N.alpha ?? 1),
                        ee = new x_(F, U, z, k, Y, X, Q, K, J, $),
                        er = new yv(ee.calpha, "f"),
                        en = new yB(N.mode ?? 0);
                      return new xM(
                        L,
                        R,
                        _,
                        {
                          positioning: F,
                          colors: U,
                          steps: z,
                          source: k,
                          isWorldSpace: Y,
                          noiseStrength: X,
                          noiseScale: Q,
                          shadowColor: K,
                          offset: J,
                          alpha: $,
                          mode: en,
                        },
                        ee,
                        en,
                        er,
                      );
                    }
                    case "outline": {
                      let z = new yI(N.outlineColor ?? 16777215),
                        F = new yI(N.contourColor ?? 16777215),
                        U = new yx(N.outlineWidth ?? 0.1),
                        k = new yx(N.contourWidth ?? 0.1),
                        Y = new yx(N.outlineThreshold ?? 0.1),
                        X = new yx(N.contourThreshold ?? 0.1),
                        Q = new yx(N.outlineSmoothing ?? 0.1),
                        K = new yx(N.contourFrequency ?? 0.1),
                        J = new yr(N.contourDirection ?? new iq(0, 1, 0)),
                        $ = new yV(N.positionalLines ?? !1),
                        ee = new yV(N.compensation ?? !0),
                        er = yF.normalRenderTarget,
                        en = yF.normalRenderTargetDepth,
                        ea = yF.pixelRatioNode,
                        eo = yF.resolution,
                        el = new yx(N.alpha ?? 1),
                        ec = new yK(
                          z,
                          F,
                          U,
                          k,
                          Y,
                          X,
                          Q,
                          K,
                          J,
                          $,
                          ee,
                          eo,
                          er,
                          en,
                          ea,
                          el,
                        ),
                        ed = new yv(ec.calpha, "f"),
                        eu = new yB(N.mode ?? 0);
                      return new xM(
                        L,
                        R,
                        _,
                        {
                          outlineColor: z,
                          contourColor: F,
                          outlineWidth: U,
                          contourWidth: k,
                          outlineThreshold: Y,
                          contourThreshold: X,
                          outlineSmoothing: Q,
                          contourFrequency: K,
                          contourDirection: J,
                          positionalLines: $,
                          compensation: ee,
                          alpha: el,
                          mode: eu,
                        },
                        ec,
                        eu,
                        ed,
                      );
                    }
                    case "depth": {
                      let z,
                        F = new yB(N.gradientType ?? 0),
                        U = new yV(N.smooth ?? !1),
                        k = new yx(N.near ?? 50),
                        Y = new yx(N.far ?? 200),
                        X = new yx(N.isVector ?? 1),
                        Q = new yx(N.isWorldSpace ?? 0),
                        K = new yr(N.origin ?? new iq()),
                        J = new yr(N.direction ?? new iq()),
                        $;
                      N.colors
                        ? ($ = new yW(N.colors.length, N.colors))
                        : (($ = new yW(2, new iV(0, 0, 0, 1))).value[1] =
                            new iV(1, 1, 1, 1)),
                        N.steps
                          ? (z = new yz(N.steps.length, N.steps))
                          : ((z = new yz(2, 1)).value[0] = 0);
                      let ee = new yx(N.alpha ?? 1),
                        er = new yB(N.mode ?? 0),
                        en = new y$(F, U, k, Y, X, Q, K, J, $, z, ee),
                        ea = new yv(en.calpha, "f");
                      return new xM(
                        L,
                        R,
                        _,
                        {
                          gradientType: F,
                          smooth: U,
                          near: k,
                          far: Y,
                          isVector: X,
                          isWorldSpace: Q,
                          origin: K,
                          direction: J,
                          colors: $,
                          steps: z,
                          alpha: ee,
                          mode: er,
                        },
                        en,
                        er,
                        ea,
                      );
                    }
                    case "noise": {
                      let z = new yx(N.scale ?? 1),
                        F = new yr(N.size ?? new iq(100, 100, 100)),
                        U = new yx(N.move ?? 1),
                        k = new yi(N.fA ?? new iT(1.7, 9.2)),
                        Y = new yi(N.fB ?? new iT(8.3, 2.8)),
                        X = new yi(N.distortion ?? new iT(1, 1)),
                        Q = new yn(N.colorA),
                        K = new yn(N.colorB),
                        J = new yn(N.colorC),
                        $ = new yn(N.colorD),
                        ee = new yx(N.alpha ?? 1),
                        er = new yB(N.mode ?? 0),
                        en = new yB(N.noiseType ?? 0),
                        ea = new yq(z, F, U, k, Y, X, Q, K, J, $, ee, en),
                        eo = new yv(ea.calpha, "f");
                      return new xM(
                        L,
                        R,
                        _,
                        {
                          scale: z,
                          size: F,
                          move: U,
                          fA: k,
                          fB: Y,
                          distortion: X,
                          colorA: Q,
                          colorB: K,
                          colorC: J,
                          colorD: $,
                          alpha: ee,
                          mode: er,
                          noiseType: en,
                        },
                        ea,
                        er,
                        eo,
                      );
                    }
                    case "normal": {
                      let z = new yr(N.cnormal ?? new iq(1, 1, 1)),
                        F = new yx(N.alpha ?? 1),
                        U = new yB(N.mode ?? 0),
                        k = new y9(z, F),
                        Y = new yv(
                          "alpha / clamp(alpha + accumAlpha, 0.00001, 1.0 )",
                          "f",
                        );
                      return (
                        (Y.keywords.alpha = F),
                        new xM(
                          L,
                          R,
                          _,
                          { cnormal: z, alpha: F, mode: U },
                          k,
                          U,
                          Y,
                        )
                      );
                    }
                    case "gradient": {
                      let z,
                        F = new yB(N.gradientType ?? 0),
                        U = new yV(N.smooth ?? !1),
                        k;
                      N.colors
                        ? (k = new yW(N.colors.length, N.colors))
                        : ((k = new yW(10, new iV(0, 0, 0, 1))).value[1] =
                            new iV(1, 1, 1, 1)),
                        N.steps
                          ? (z = new yz(N.steps.length, N.steps))
                          : ((z = new yz(10, 1)).value[0] = 0);
                      let Y = new yi(N.offset ?? new iT(0, 0)),
                        X = new yi(N.morph ?? new iT(0, 0)),
                        Q = new yx(N.angle ?? 0),
                        K = new yx(N.alpha ?? 1),
                        J = new yB(N.mode ?? 0),
                        $ = new y6(F, U, k, z, Y, X, Q, K),
                        ee = new yv($.calpha, "f");
                      return new xM(
                        L,
                        R,
                        _,
                        {
                          gradientType: F,
                          smooth: U,
                          colors: k,
                          steps: z,
                          offset: Y,
                          morph: X,
                          angle: Q,
                          alpha: K,
                          mode: J,
                        },
                        $,
                        J,
                        ee,
                      );
                    }
                    default: {
                      let N = new yI(1, 0, 0, 1),
                        z = new yx(1),
                        F = new yv(
                          "alpha / clamp(alpha + accumAlpha, 0.00001, 1.0 )",
                          "f",
                        );
                      F.keywords.alpha = z;
                      let U = new yB(0);
                      return (
                        (N.alpha = z),
                        new xM(
                          L,
                          R,
                          _,
                          { color: N, alpha: z, mode: U },
                          N,
                          U,
                          F,
                        )
                      );
                    }
                  }
                })(R, _, L, z)
              );
            }
            if ("noise" === R.displacementType) {
              let N = new yr(new iq(...R.offset)),
                z = new yx(R.scale ?? 10),
                F = new yx(R.intensity ?? 8),
                U = new yx(R.movement ?? 1),
                k = new yB(R.noiseType ?? 0),
                Y = new y5(F, U, N, z, k);
              return new xP(
                _,
                L,
                R,
                {
                  offset: N,
                  scale: z,
                  intensity: F,
                  movement: U,
                  noiseType: k,
                },
                Y,
              );
            }
            throw Error();
          }
          updateByOp(_, L, R) {
            if (void 0 === _.path[0]) {
              if (0 === _.type)
                return "type" in _.props ||
                  "category" in _.props ||
                  "visible" in _.props
                  ? (R.scene?.markNeedsUpdateRendererDirty(), !0)
                  : (function (_, L, R, N) {
                      let z = !1;
                      for (let [F, U] of Object.entries(_)) {
                        if (!F || void 0 === U) continue;
                        if (Pb(F, R, N)) {
                          "visible" === F && "light" === R.type && (z = !0);
                          continue;
                        }
                        R.visible = N.visible;
                        let _ = R.uniforms[`f${R.id}_${F}`];
                        if (_ && !(_ instanceof xm))
                          switch (
                            ((z =
                              z ||
                              (function (_, L, R) {
                                let N = xg[_.type],
                                  z = xv[_.type];
                                if (void 0 !== z) {
                                  let N = _.color;
                                  if (z.includes(L)) {
                                    let _ = N[L]?.value?.length;
                                    if (void 0 !== _ && _ !== R.length)
                                      return !0;
                                  }
                                }
                                return void 0 !== N && N.includes(L);
                              })(R, F, U)),
                            _.constructor)
                          ) {
                            case yI:
                              if ("string" == typeof U) {
                                let R = L.getColor(U);
                                R && (_.value = R);
                                break;
                              }
                              _.value instanceof xn
                                ? (_.value = new ys(U.r, U.g, U.b, U.a))
                                : _.setRGBA(U);
                              break;
                            case yn:
                              if ("string" == typeof U) {
                                let R = L.getColor(U);
                                R && (_.value = R);
                                break;
                              }
                              _.value instanceof xn
                                ? (_.value = new ys(U.r, U.g, U.b, U.a))
                                : _.value.setRGBA(U.r, U.g, U.b, U.a);
                              break;
                            case yi:
                              _.value.setX(U[0]), _.value.setY(U[1]);
                              break;
                            case yr:
                              _.value.setX(U[0]),
                                _.value.setY(U[1]),
                                _.value.setZ(U[2]);
                              break;
                            case yy:
                              Cb(U, L, R);
                              break;
                            case yW:
                              _.value = U.map((_) => new iV(..._));
                              break;
                            default:
                              _.value = U;
                          }
                      }
                      return z;
                    })(_.props, R.shared, this, L);
            } else if ("texture" === _.path[0])
              return (
                (!("texture" in L) && !("video" in L)) ||
                Cb(_.props, R.shared, this)
              );
            return !1;
          }
          dispose() {
            let _;
            if (
              "texture" === (_ = this instanceof xA ? this.type : this) ||
              "video" === _ ||
              "displace_map" === _ ||
              "matcap" === _
            ) {
              let _ = this.uniforms[`f${this.id}_texture`];
              if (!_) return !1;
              _.image instanceof xp || _.image.deref();
            }
          }
          hasValueByKey(_) {
            return void 0 !== this.uniforms[_];
          }
          hasValue(_) {
            return this.hasValueByKey(`f${this.id}_${_}`);
          }
          setValue(_, L) {
            let R = `f${this.id}_${_}`;
            this.hasValueByKey(R) &&
              void 0 !== L &&
              (this.uniforms[R].value = L);
          }
          getNode(_) {
            let L = `f${this.id}_${_}`;
            if (this.hasValueByKey(L)) return this.uniforms[L];
          }
          getValue(_) {
            let L = `f${this.id}_${_}`;
            if (this.hasValueByKey(L)) return this.uniforms[L].value;
          }
          getName(_) {
            let L = /f\d+_(.*)/.exec(_);
            if (L && L.length > 1) return L[1];
            console.log(`Layer.getName: error ${_}`);
          }
          getNames() {
            let _ = [];
            for (let L in this.uniforms) {
              let R = this.getName(L);
              R && _.push(R);
            }
            return _;
          }
        },
        xM = class extends xA {
          constructor(_, L, R, N, z, F, U) {
            super(_, L, R, N),
              (this.params = N),
              (this.color = z),
              (this.mode = F),
              (this.alpha = U);
          }
        },
        xP = class extends xA {
          constructor(_, L, R, N, z) {
            super(_, L, R, N), (this.position = z);
          }
        },
        xD = class extends xA {
          constructor(_, L, R, N, z) {
            super(_, L, R, z), (this.node = N);
          }
          static createLigherLayer(_, L, R, N) {
            let z,
              F = new yx(R.alpha),
              U = new yB(R.mode),
              k;
            if (R.visible) {
              if ("lambert" === R.category) {
                z = new yU();
                let _ = new yI(N.color(R.emissive) ?? 0);
                (k = { emissive: _ }), (z.emissive = _);
              } else if ("toon" === R.category) {
                z = new yG();
                let _ = new yx(R.shininess ?? 30),
                  L = new yI(N.color(R.specular) ?? 1118481);
                (k = { shininess: _, specular: L }),
                  (z.shininess = _),
                  (z.specular = L);
              } else if ("physical" === R.category) {
                z = new yj();
                let _ = new yx(R.roughness ?? 0.3),
                  L = new yx(R.metalness ?? 0),
                  N = new yx(R.reflectivity ?? 0.5);
                (k = { roughness: _, metalness: L, reflectivity: N }),
                  (z.roughness = _),
                  (z.metalness = L),
                  (z.reflectivity = N);
              } else {
                z = new yk();
                let _ = new yx(R.shininess ?? 30),
                  L = new yI(
                    void 0 !== R.specular
                      ? N.color(R.specular) ?? 1118481
                      : 1118481,
                  );
                (k = { shininess: _, specular: L }),
                  (z.shininess = _),
                  (z.specular = L);
              }
            } else (z = new yN()), (k = {});
            return (
              (z.alpha = new yx(1)),
              (z.shadingAlpha = F),
              (z.shadingBlend = U),
              (k.alpha = z.shadingAlpha),
              (k.mode = z.shadingBlend),
              new xD(_, L, R, z, k)
            );
          }
          get category() {
            return this.node.category;
          }
        };
      function Pb(_, L, R) {
        if ("displace" === R.type && ("intensity" === _ || "visible" === _)) {
          let _ = L.uniforms[`f${L.id}_intensity`];
          return _
            ? ((_.value = R.intensity * (R.visible ? 1 : 0)), _)
            : void 0;
        }
        if ("displace" !== R.type && ("alpha" === _ || "visible" === _)) {
          let N = L.uniforms[`f${L.id}_alpha`];
          if (!N) return;
          if (
            ((N.value = R.alpha * (R.visible ? 1 : 0)),
            "outline" === R.type && "visible" === _)
          ) {
            let _ = L.uniforms[`f${L.id}_compensation`];
            _ && (_.value = R.compensation && R.visible);
          }
          return N;
        }
      }
      function tf(_, L) {
        let R = 0;
        for (let N of _.layers)
          if (
            "displace" !== N.data.type &&
            "alpha" in N.data &&
            "light" !== N.data.type &&
            "fresnel" !== N.data.type &&
            "texture" !== N.data.type &&
            "matcap" !== N.data.type &&
            "rainbow" !== N.data.type &&
            "outline" !== N.data.type
          ) {
            let _ = N.data.visible ? N.data.alpha : 0;
            if (
              (1 === _ && "depth" === N.data.type) ||
              "gradient" === N.data.type
            ) {
              for (let L of N.data.colors)
                if (L[3] < 1) {
                  _ = L[3];
                  break;
                }
            } else if (1 === _ && "noise" === N.data.type) {
              let R = Math.min(
                L.color(N.data.colorA).a,
                Math.min(
                  L.color(N.data.colorB).a,
                  Math.min(L.color(N.data.colorC).a, L.color(N.data.colorD).a),
                ),
              );
              R < 1 && (_ = R);
            }
            R += (1 - R) * _;
          }
        return R < 1;
      }
      var xO = class extends sQ {
          constructor() {
            super(void 0),
              (this.flatShading = !1),
              (this.cacheKey = ""),
              (this.fog = !0),
              (this.dithering = !0),
              (this.vertexColors = !0),
              (this.transparent = !0);
          }
          customProgramCacheKey() {
            return this.cacheKey;
          }
        },
        xL = class extends xO {
          constructor(_, L, R, N) {
            super(),
              (this.flatShading = _),
              (this.side = L),
              (this.wireframe = R),
              (this.root = N);
          }
          updateAfterBuild() {
            let _ = this.root;
            (this.lights = _.lights),
              (this.vertexShader = _.vertexShader),
              (this.fragmentShader = _.fragmentShader),
              (this.defines = _.defines),
              (this.uniforms = _.uniforms),
              (this.extensions = _.extensions),
              (this.transparent = _.transparent),
              (this.cacheKey =
                _.customProgramCacheKey() +
                "flat" +
                this.flatShading +
                this.side);
          }
          onBeforeCompile(_, L) {
            this.root.onBeforeCompile(_);
          }
          get data() {
            return this.root.data;
          }
          get category() {
            return this.root.category;
          }
          getFlavor(_, L, R) {
            return this.root.getFlavor(_, L, R);
          }
          get layers() {
            return this.root.layers;
          }
          get fragment() {
            return this.root.fragment;
          }
          getLayersOfType(_) {
            return this.root.getLayersOfType(_);
          }
          getLayerByUuid(_) {
            return this.root.getLayerByUuid(_);
          }
          updateByOp(_, L, R) {
            this.root.updateByOp(_, L, R);
          }
          nodeMaterialDispose() {
            this.root.nodeMaterialDispose();
          }
        },
        xR = class extends xO {
          constructor(_, L) {
            super(),
              (this.data = _),
              (this.layerIdGen = 0),
              (this.flavors = []),
              (this.type = "NodeMaterial"),
              (this.updaters = []),
              this.reset0(_, L);
          }
          get nodeMaterial() {
            return this;
          }
          getFlavor(_, L, R) {
            let N = R ? 6 : (_ ? 3 : 0) + L;
            if (0 === N) return this;
            void 0 === this.flavors && (this.flavors = []), (N -= 1);
            let z = this.flavors[N];
            return (
              void 0 === z &&
                ((z = new xL(_, L, R, this)),
                (this.flavors[N] = z),
                (z.flatShading = _),
                (z.side = L),
                z.updateAfterBuild()),
              z
            );
          }
          get fragment() {
            return this.lightLayer.node;
          }
          get category() {
            return this.lightLayer.category;
          }
          reset(_, L) {
            this.data !== _ && this.reset0(_, L);
          }
          reset0(_, L) {
            this.data = _;
            let R = _.layers ?? fU.defaultTwoLayerData("phong").layers;
            (this.layers = R.map((_) =>
              xA.create(this.layerIdGen++, _.id, _.data, L.shared),
            )),
              this.layers.reverse(),
              (this.name = _.name ?? "Untitled Material"),
              this.onUpdate(),
              (this.transparent = tf(_, L.shared));
          }
          getLayersOfType(_) {
            return this.layers.filter((L) => L.type === _);
          }
          getLayerByUuid(_) {
            return this.layers.find((L) => L.uuid === _);
          }
          onUpdate() {
            for (let _ of ((this.cacheKey = this.computeCacheKey()),
            (this.lightLayer = this.layers.find((_) => _ instanceof xD)),
            void 0 === this.lightLayer &&
              (this.lightLayer = new xD(
                0,
                "",
                { ...pG.defaultData("light", "phong"), visible: !1 },
                new yN(),
                {},
              )),
            this.dispose(),
            this.flavors))
              _ && _.dispose();
            this.blendColors(), this.blendAfterColors(), this.blendPositions();
          }
          updateByOp(_, L, R) {
            if (
              (void 0 !== L ? (this.data = L) : (L = this.data),
              (this.transparent = tf(L, R.shared)),
              "layers" === _.path[0])
            ) {
              this.data = L;
              let N = R.shared,
                z = _.path[1];
              if (void 0 === z) {
                if ((this.layers.reverse(), 4 === _.type)) {
                  let L = xA.create(this.layerIdGen++, _.id, _.data, R.shared);
                  this.layers.splice(_.localIndex, 0, L),
                    R.scene?.markNeedsUpdateRendererDirty();
                } else if (5 === _.type)
                  this.layers.splice(_.localIndex, 1)[0].dispose(),
                    R.scene?.markNeedsUpdateRendererDirty();
                else if (6 === _.type) {
                  let L = this.layers.findIndex((L) => L.uuid === _.id),
                    N = this.layers[L];
                  this.layers.splice(L, 1),
                    this.layers.splice(_.localIndex, 0, N),
                    R.scene?.markNeedsUpdateRendererDirty();
                }
                this.layers.reverse(), this.onUpdate();
              } else {
                let F = this.layers.find((_) => _.uuid === z);
                if (F) {
                  let U = L.layers.data(z);
                  if (F.updateByOp({ ..._, path: _.path.slice(2) }, U, R)) {
                    let _ = xA.create(this.layerIdGen++, z, U, N);
                    this.layers.splice(
                      this.layers.findIndex((_) => _.uuid === z),
                      1,
                      _,
                    ),
                      this.onUpdate();
                  }
                }
              }
            } else this.reset(L, R);
          }
          blendColors() {
            let _ = this.layers.findIndex((_) => _ instanceof xM),
              L = this.layers.findIndex((_) => _ instanceof xD);
            if (-1 !== _ && _ < L) {
              let R = this.layers[_].color;
              for (let N = _ + 1; N < L; ++N) {
                let _ = this.layers[N];
                _ instanceof xM && (R = new y2(R, _.color, _.alpha, _.mode));
              }
              this.fragment.color = R;
            } else this.fragment.color = void 0;
          }
          blendAfterColors() {
            let _ = new yv("outgoingLight", "f"),
              L = this.layers.findIndex((_) => _ instanceof xD);
            if (this.layers.length > L + 1) {
              for (let R = L + 1; R < this.layers.length; ++R) {
                let L = this.layers[R];
                L instanceof xM && (_ = new y2(_, L.color, L.alpha, L.mode));
              }
              this.fragment.afterColor = _;
            } else this.fragment.afterColor = void 0;
          }
          blendPositions() {
            let _ = this.layers.filter((_) => _ instanceof xP);
            if (_.length > 0) {
              let L = _[0].position;
              for (let R = 1; R < _.length; ++R)
                _[R] &&
                  ((L = new yw(L, _[R].position, yw.ADD)),
                  (L = new yw(L, new yx(0.5).setReadonly(!0), yw.MUL)));
              this.fragment.position = L;
            } else this.fragment.position = void 0;
          }
          getDefines() {
            return this.defines;
          }
          getUniforms() {
            return this.uniforms;
          }
          getVertexShader() {
            return this.vertexShader;
          }
          getFragmentShader() {
            return this.fragmentShader;
          }
          onBeforeCompile(_) {
            this.build(),
              (_.defines = this.defines),
              (_.uniforms = this.uniforms),
              (_.vertexShader = this.vertexShader),
              (_.fragmentShader = this.fragmentShader),
              (_.extensionDerivatives = !0 === this.extensions.derivatives),
              (_.extensionFragDepth = !0 === this.extensions.fragDepth),
              (_.extensionDrawBuffers = !0 === this.extensions.drawBuffers),
              (_.extensionShaderTextureLOD =
                !0 === this.extensions.shaderTextureLOD);
          }
          clampUniformsForPreview(_, L) {
            let i = (_, L, R) => Math.min(Math.max(_, L), R);
            for (let R of this.layers)
              if ("displace" === R.type) {
                let N = i(R.uniforms[`f${R.id}_intensity`].value, _, L);
                R.uniforms[`f${R.id}_intensity`].value = N;
              }
          }
          computeCacheKey() {
            let _ = "[";
            for (let { data: L } of this.data.layers)
              if ("light" === L.type)
                _ += `"${L.visible ? L.category.toUpperCase() : "Basic"}"`;
              else {
                let R = [
                  ...(xg[L.type] ?? []).map((_) => L[_]),
                  ...(xv[L.type] ?? []).map((_) => L[_]?.length ?? 0),
                ];
                R.length
                  ? (_ += `["${L.type}", "${R.join('","')}"],`)
                  : (_ += `"${L.type}",`);
              }
            return _.slice(0, -1) + "]";
          }
          updateFrame(_) {
            for (let L = 0; L < this.updaters.length; ++L)
              _.updateNode(this.updaters[L]);
          }
          build() {
            let _ = new yR();
            for (let L of ((this.lights = this.lightLayer.data.visible),
            _.build(this.fragment, this.fragment),
            (this.vertexShader = _.getCode("vertex")),
            (this.fragmentShader = _.getCode("fragment")),
            (this.defines = _.defines),
            (this.uniforms = _.uniforms),
            (this.extensions = _.extensions),
            (this.updaters = _.updaters),
            this.flavors))
              L && L.updateAfterBuild();
            return this;
          }
          nodeMaterialDispose() {
            for (let _ of (this.layers.forEach((_) => _.dispose()),
            super.dispose(),
            this.flavors))
              _ && _.dispose();
          }
          assetsLoaded() {
            for (let _ of this.layers)
              if (_ instanceof xM) {
                let L = _.params.texture;
                if (L instanceof xb && !L.image.loaded) return !1;
              }
            return !0;
          }
          getHash() {
            return '{"fragment":' + this.fragment.getHash() + "}";
          }
        };
      Object.defineProperties(xO.prototype, {
        properties: {
          get: function () {
            return this.fragment.properties;
          },
        },
      });
      var xI,
        xB = class extends xR {},
        xN = dd(ir()),
        xz = new Map(),
        xF = class {
          constructor({ src: _, volume: L, delay: R, loop: N }) {
            let z;
            (this._volume = 1),
              (this.delay = 0),
              (this._loop = 1),
              (this.loopsRemaining = 0),
              (this._status = "stopped"),
              (this.onEnd = () => {
                this.loopsRemaining === 1 / 0
                  ? this.replay()
                  : this.loopsRemaining > 1
                    ? (this.replay(), this.loopsRemaining--)
                    : ((this._status = "stopped"),
                      (this.loopsRemaining = this._loop));
              }),
              (z =
                "string" == typeof _
                  ? { src: _ }
                  : {
                      src: (function (_) {
                        if ("string" == typeof _) return _;
                        let L = xz.get(_);
                        return (
                          L ||
                            ((L = { url: URL.createObjectURL(new Blob([_])) }),
                            xz.set(_, L)),
                          L.url
                        );
                      })(_),
                      format: "wav",
                    }),
              (this.sound = new xN.Howl(z)),
              this.sound.on("end", this.onEnd),
              (this.src = _),
              void 0 !== L && (this.volume = L),
              void 0 !== R && (this.delay = R),
              void 0 !== N && (this.loop = N);
          }
          get status() {
            return this._status;
          }
          get volume() {
            return this._volume;
          }
          set volume(_) {
            (this._volume = _), this.sound.volume(_);
          }
          get loop() {
            return this._loop;
          }
          set loop(_) {
            (this._loop = _), (this.loopsRemaining = _);
          }
          replay() {
            this.clearDelay(),
              (this.delayTimerId = window.setTimeout(() => {
                this.sound.play(), this.clearDelay();
              }, this.delay));
          }
          fade(_, L = 1e3) {
            _
              ? (this.sound.volume(this._volume),
                this.clearFade(),
                (this.fadeTimerId = window.setTimeout(() => {
                  this.sound.fade(this._volume, 0, L), this.clearFade();
                }, _)))
              : this.sound.fade(this._volume, 0, L);
          }
          on(_, L, R) {
            this.sound.on(_, L, R);
          }
          off(_, L, R) {
            this.sound.off(_, L, R);
          }
          play() {
            "playing" === this._status ||
              this.sound.playing() ||
              ("paused" === this._status
                ? (0 === this.sound.seek() ? this.replay() : this.sound.play(),
                  (this._status = "playing"))
                : "stopped" === this._status &&
                  (this.replay(), (this._status = "playing")));
          }
          pause() {
            "playing" === this._status &&
              (this.sound.pause(),
              this.clearFade(),
              this.clearDelay(),
              (this._status = "paused"));
          }
          stop() {
            this.sound.stop(),
              (this.loopsRemaining = this._loop),
              this.clearFade(),
              this.clearDelay(),
              (this._status = "stopped");
          }
          clearFade() {
            this.fadeTimerId &&
              (clearTimeout(this.fadeTimerId), delete this.fadeTimerId);
          }
          clearDelay() {
            this.delayTimerId &&
              (clearTimeout(this.delayTimerId), delete this.delayTimerId);
          }
          dispose(_ = !1) {
            this.off(), this.stop(), this.clearFade(), this.clearDelay();
          }
        },
        xU = class {
          constructor() {
            (this.type = "ShapePath"),
              (this.color = new iz()),
              (this.subPaths = []),
              (this.currentPath = null);
          }
          moveTo(_, L) {
            return (
              (this.currentPath = new aB()),
              this.subPaths.push(this.currentPath),
              this.currentPath.moveTo(_, L),
              this
            );
          }
          lineTo(_, L) {
            return this.currentPath?.lineTo(_, L), this;
          }
          quadraticCurveTo(_, L, R, N) {
            return this.currentPath?.quadraticCurveTo(_, L, R, N), this;
          }
          bezierCurveTo(_, L, R, N, z, F) {
            return this.currentPath?.bezierCurveTo(_, L, R, N, z, F), this;
          }
          splineThru(_) {
            return this.currentPath?.splineThru(_), this;
          }
          toShapes() {
            let _ = {
                ORIGIN: 0,
                DESTINATION: 1,
                BETWEEN: 2,
                LEFT: 3,
                RIGHT: 4,
                BEHIND: 5,
                BEYOND: 6,
              },
              L = { loc: _.ORIGIN, t: 0 };
            function s(R, N, z) {
              let F = z.x - N.x,
                U = z.y - N.y,
                k = R.x - N.x,
                Y = R.y - N.y,
                X = F * Y - k * U;
              if (R.x === N.x && R.y === N.y) {
                (L.loc = _.ORIGIN), (L.t = 0);
                return;
              }
              if (R.x === z.x && R.y === z.y) {
                (L.loc = _.DESTINATION), (L.t = 1);
                return;
              }
              if (X < -Number.EPSILON) {
                L.loc = _.LEFT;
                return;
              }
              if (X > Number.EPSILON) {
                L.loc = _.RIGHT;
                return;
              }
              if (F * k < 0 || U * Y < 0) {
                L.loc = _.BEHIND;
                return;
              }
              if (Math.sqrt(F * F + U * U) < Math.sqrt(k * k + Y * Y)) {
                L.loc = _.BEYOND;
                return;
              }
              (L.loc = _.BETWEEN), (L.t = 0 !== F ? k / F : Y / U);
            }
            let R = 0,
              N = 999999999,
              z = -999999999,
              F = [];
            this.subPaths.forEach((_) => {
              let L = _.getPoints(),
                U = -999999999,
                k = 999999999,
                Y = -999999999,
                X = 999999999;
              for (let _ = 0; _ < L.length; _++) {
                let R = L[_];
                R.y > U && (U = R.y),
                  R.y < k && (k = R.y),
                  R.x > Y && (Y = R.x),
                  R.x < X && (X = R.x);
              }
              z <= Y && (z = Y + 1),
                N >= X && (N = X - 1),
                L.length &&
                  F.push({
                    curves: _.curves,
                    points: L,
                    isCW: aH.isClockWise(L),
                    identifier: R++,
                    boundingBox: new oj(new iT(X, k), new iT(Y, U)),
                  });
            });
            let U = F.map((R) =>
                (function (R, N, z, F, U) {
                  (null == U || "" === U) && (U = "nonzero");
                  let k = new iT();
                  R.boundingBox.getCenter(k);
                  let Y = (function (R, N, z) {
                    let F = new iT();
                    N.getCenter(F);
                    let U = [];
                    return (
                      z.forEach((N) => {
                        N.boundingBox.containsPoint(F) &&
                          (function (R, N) {
                            let z = [],
                              F = [];
                            for (let U = 1; U < R.length; U++) {
                              let k = R[U - 1],
                                Y = R[U];
                              for (let R = 1; R < N.length; R++) {
                                let U = (function (R, N, z, F) {
                                  let U = R.x,
                                    k = N.x,
                                    Y = z.x,
                                    X = F.x,
                                    Q = R.y,
                                    K = N.y,
                                    J = z.y,
                                    $ = F.y,
                                    ee = (X - Y) * (Q - J) - ($ - J) * (U - Y),
                                    er = ($ - J) * (k - U) - (X - Y) * (K - Q),
                                    en = ee / er,
                                    ea =
                                      ((k - U) * (Q - J) - (K - Q) * (U - Y)) /
                                      er;
                                  if (
                                    (0 === er && 0 !== ee) ||
                                    en <= 0 ||
                                    en >= 1 ||
                                    ea < 0 ||
                                    ea > 1
                                  )
                                    return null;
                                  if (0 === ee && 0 === er) {
                                    for (let Y = 0; Y < 2; Y++)
                                      if (
                                        (s(0 === Y ? z : F, R, N),
                                        L.loc === _.ORIGIN)
                                      ) {
                                        let _ = 0 === Y ? z : F;
                                        return { x: _.x, y: _.y, t: L.t };
                                      } else if (L.loc === _.BETWEEN)
                                        return {
                                          x: +(U + L.t * (k - U)).toPrecision(
                                            10,
                                          ),
                                          y: +(Q + L.t * (K - Q)).toPrecision(
                                            10,
                                          ),
                                          t: L.t,
                                        };
                                    return null;
                                  }
                                  for (let U = 0; U < 2; U++)
                                    if (
                                      (s(0 === U ? z : F, R, N),
                                      L.loc === _.ORIGIN)
                                    ) {
                                      let _ = 0 === U ? z : F;
                                      return { x: _.x, y: _.y, t: L.t };
                                    }
                                  return {
                                    x: +(U + en * (k - U)).toPrecision(10),
                                    y: +(Q + en * (K - Q)).toPrecision(10),
                                    t: en,
                                  };
                                })(k, Y, N[R - 1], N[R]);
                                null !== U &&
                                  void 0 ===
                                    z.find(
                                      (_) =>
                                        _.t <= U.t + Number.EPSILON &&
                                        _.t >= U.t - Number.EPSILON,
                                    ) &&
                                  (z.push(U), F.push(new iT(U.x, U.y)));
                              }
                            }
                            return F;
                          })(R, N.points).forEach((_) => {
                            U.push({
                              identifier: N.identifier,
                              isCW: N.isCW,
                              point: _,
                            });
                          });
                      }),
                      U.sort((_, L) => _.point.x - L.point.x),
                      U
                    );
                  })([new iT(z, k.y), new iT(F, k.y)], R.boundingBox, N);
                  Y.sort((_, L) => _.point.x - L.point.x);
                  let X = [],
                    Q = [];
                  Y.forEach((_) => {
                    _.identifier === R.identifier ? X.push(_) : Q.push(_);
                  });
                  let K = X[0].point.x,
                    J = [],
                    $ = 0;
                  for (; $ < Q.length && Q[$].point.x < K; )
                    J.length > 0 && J[J.length - 1] === Q[$].identifier
                      ? J.pop()
                      : J.push(Q[$].identifier),
                      $++;
                  if ((J.push(R.identifier), "evenodd" === U)) {
                    let _ = J.length % 2 == 0,
                      L = J[J.length - 2];
                    return { identifier: R.identifier, isHole: _, for: L };
                  }
                  if ("nonzero" === U) {
                    let _ = !0,
                      L = null,
                      z = null;
                    for (let R = 0; R < J.length; R++) {
                      let F = J[R];
                      N[F] &&
                        (_
                          ? ((z = N[F].isCW), (_ = !1), (L = F))
                          : z !== N[F].isCW && ((z = N[F].isCW), (_ = !0)));
                    }
                    return { identifier: R.identifier, isHole: _, for: L };
                  }
                  console.warn(
                    'fill-rule: "' + U + '" is currently not implemented.',
                  );
                })(R, F, N, z, this.userData?.style.fillRule),
              ),
              k = [];
            return (
              F.forEach((_) => {
                let L = U[_.identifier];
                if (L && !L.isHole) {
                  let L = new aG();
                  (L.curves = _.curves),
                    U.filter(
                      (L) => L?.isHole && L.for === _.identifier,
                    ).forEach((_) => {
                      if (_) {
                        let R = F[_.identifier],
                          N = new aB();
                        (N.curves = R.curves), L.holes.push(N);
                      }
                    }),
                    k.push(L);
                }
              }),
              k
            );
          }
        },
        xk = new Promise((_) => {
          xI = _;
        }),
        xj = !1;
      async function EC() {
        if (xj) return;
        let _ = await R.e(7934).then(R.bind(R, 856));
        xI(_), (xj = !0);
      }
      async function e5(_) {
        return await (await fetch(_)).arrayBuffer();
      }
      var xG = new (class {
        async load(_, L, R = () => {}) {
          let { load: N } = await xk;
          N(_, (_, N) => {
            _ || !N ? R(_ ?? "Something went wrong") : L(N);
          });
        }
        async parse(_) {
          let { parse: L, Bidi: R } = await xk;
          try {
            let N = L(_),
              z = new R();
            return (
              z.registerModifier("glyphIndex", null, (_) =>
                N.charToGlyphIndex(_.char),
              ),
              z.applyFeatures(N, N.defaultRenderOptions.features),
              { font: N, bidi: z }
            );
          } catch (_) {
            console.error(_);
          }
        }
      })();
      async function Rb(_) {
        let L,
          R,
          N = !1;
        if (
          (_.url
            ? ((L = await e5(_.url)), (R = _.url), (N = _.url.startsWith("/")))
            : _.data && (L = _.data.buffer),
          L)
        ) {
          let _ = await xG.parse(L);
          if (_)
            return {
              font: _.font,
              url: R,
              intercepted: N,
              arr: L,
              bidi: _.bidi,
            };
        }
      }
      var xV = class {
          constructor(_) {
            (this._arrayBuffer = new ArrayBuffer(1)),
              (this._isLoaded = !1),
              (this._intercepted = !1),
              (this._isUserFont = _.isUserFont ?? !1),
              (this._loadingPromise = Rb(_).then((_) => {
                _ &&
                  ((this._arrayBuffer = _.arr),
                  (this._url = _.url),
                  (this.font = _.font),
                  (this._intercepted = _.intercepted),
                  (this._isLoaded = !0),
                  (this._bidi = _.bidi));
              }));
          }
          update(_) {
            (this._isLoaded = !1),
              (this._isUserFont = _.isUserFont ?? !1),
              (this._loadingPromise = Rb(_).then((_) => {
                _ &&
                  ((this._arrayBuffer = _.arr),
                  (this._url = _.url),
                  (this.font = _.font),
                  (this._intercepted = _.intercepted),
                  (this._isLoaded = !0),
                  (this._bidi = _.bidi));
              }));
          }
          get url() {
            return this._url;
          }
          get intercepted() {
            return this._intercepted;
          }
          get isLoaded() {
            return this._isLoaded;
          }
          get loadingPromise() {
            return this._loadingPromise;
          }
          reverseLigaturesTable(_, L, R) {
            if (!this._bidi) return [];
            let N = this._bidi;
            N.getTextGlyphs(L);
            let z = N.tokenizer.tokens,
              F = [],
              U = 0,
              k = R.length === z.length;
            for (let N = 0; N < R.length; N++) {
              let Y = R[N].index,
                X = String.fromCharCode(R[N].unicode),
                Q = z[U];
              if (
                Q.state.glyphIndex === Y ||
                Q.state.fina === Y ||
                Q.state.medi === Y ||
                Q.state.init === Y ||
                k
              )
                F.push({
                  char: X,
                  index: Y,
                  replacements: [Q.state.glyphIndex],
                  replacementChars: [Q.char],
                }),
                  U++;
              else {
                let R = Q.char,
                  N = "",
                  z = [Q.state.glyphIndex],
                  k = [],
                  K = !1;
                for (; !K; )
                  U++,
                    (R += N = L.charAt(U)),
                    z.push(_.charToGlyphIndex(N)),
                    1 === (k = _.stringToGlyphs(R)).length &&
                      k[0].index === Y &&
                      (K = !0),
                    U > L.length && (K = !0);
                F.push({
                  char: X,
                  index: Y,
                  replacements: z,
                  replacementChars: Array.from(R),
                }),
                  U++;
              }
            }
            return F;
          }
          generateShapes(_, L) {
            if (!this._isLoaded) return;
            let R = this.font,
              N = L.fontSize / this.unitsPerEm,
              z = L.fontSize * L.lineHeight,
              F = _.map((_) => this.getTextWidth(_, L)),
              U = L.width,
              k = this.getCharWidth(
                `
`,
                L,
              ),
              Y = 1 === L.horizontalAlign ? k : 0,
              X = this.computeSpaceWidthForLine(_, 0, L),
              Q = this.getLineInitialOffsetX(
                F[0],
                U,
                L.horizontalAlign,
                _[0],
                k,
              ),
              K = this.getLineInitialOffsetY(
                z,
                _.length,
                L.height,
                N,
                L.verticalAlign,
              ),
              J = [],
              $ = _.map((_) => []),
              ee = _.map((_) => []),
              er;
            for (let en = 0; en < _.length; en++) {
              let ea = _[en],
                eo = { features: { liga: !0 } },
                el = [];
              try {
                el = R.stringToGlyphs(ea, eo);
              } catch (_) {
                console.warn(_);
              }
              Q = this.getLineInitialOffsetX(
                F[en],
                U,
                L.horizontalAlign,
                ea,
                k,
              );
              let ec = [];
              try {
                ec = this.reverseLigaturesTable(R, ea, el);
              } catch (_) {
                console.warn(_);
              }
              X = this.computeSpaceWidthForLine(_, en, L);
              for (let _ = 0; _ < el.length; _++) {
                let z = el[_],
                  F =
                    0 === z.index
                      ? `
`
                      : z.unicode
                        ? String.fromCharCode(z.unicode)
                        : void 0,
                  U = ec[_],
                  k = 0,
                  ea = 0;
                0 === _ &&
                  2 === L.horizontalAlign &&
                  void 0 !== z.leftSideBearing &&
                  (ea = -z.leftSideBearing * N),
                  er && (k = R.getKerningValue(z, er) * N),
                  (Q += ea + k);
                let eo = 0;
                if (
                  F ===
                  `
`
                )
                  eo = Y;
                else if (" " === F) eo = X;
                else {
                  let _ = this.createPath(z, N, Q, K, L);
                  _ && ((eo = _.offsetX - (k + ea)), J.push(_.path));
                }
                if (1 === U.replacements.length)
                  ee[en].push([Q, K]), $[en].push(eo);
                else {
                  let _ = U.replacements.map(
                      (_) => (R.glyphs.get(_).advanceWidth ?? 0) * N,
                    ),
                    L = _.reduce((_, L) => (_ += L), 0),
                    z = _.map((_) => _ / L),
                    F = Q;
                  for (let _ = 0; _ < z.length; _++) {
                    let L = eo * z[_];
                    ee[en].push([F, K]), $[en].push(L), (F += L);
                  }
                }
                (Q += eo), (er = z);
              }
              K -= z;
            }
            let en = [];
            for (let _ = 0, L = J.length; _ < L; _++)
              en.push(...J[_].toShapes());
            return { shapes: en, charWidths: $, lineWidths: F, charCoords: ee };
          }
          get isUserFont() {
            return this._isUserFont;
          }
          get arrayBuffer() {
            return this._arrayBuffer;
          }
          get ascender() {
            return this.font?.ascender ?? 0;
          }
          get descender() {
            return this.font?.descender ?? 0;
          }
          get familyName() {
            return this.font?.names.fontFamily ?? "";
          }
          get subfamilyName() {
            return this.font?.names.fontSubfamily ?? "";
          }
          get unitsPerEm() {
            return this.font?.unitsPerEm ?? 1;
          }
          getLineInitialOffsetX(_, L, R, N, z) {
            return (
              (3 === R || 2 === R) &&
                N.indexOf(`
`) >= 0 &&
                (_ -= z),
              3 === R ? 0.5 * L - 0.5 * _ : 2 === R ? L - _ : 0
            );
          }
          getLineInitialOffsetY(_, L, R, N, z) {
            let F = L * _,
              U = Math.abs(this.ascender - this.descender) * N,
              k = -this.ascender * N - (_ - U) / 2;
            return 3 === z
              ? -(R - F - k)
              : 2 === z
                ? -(0.5 * R - 0.5 * F - k)
                : k;
          }
          createPath(_, L, R, N, z) {
            let F = _.getPath(R, -N, z.fontSize, {
              kerning: !1,
              letterSpacing: z.letterSpacing,
            });
            if (!F) {
              console.error(
                'THREE.Font: character "' +
                  _ +
                  '" does not exists in font family ' +
                  this.familyName +
                  ".",
              );
              return;
            }
            let U = new xU(),
              k = (_.advanceWidth ?? 1) * L;
            if (_)
              for (let _ of F.commands) {
                let L = U.currentPath?.currentPoint;
                if (!(L && "Z" !== _.type && L.x === _.x && -L.y === _.y))
                  switch (_.type) {
                    case "M":
                      U.moveTo(_.x, -_.y);
                      break;
                    case "L":
                      U.lineTo(_.x, -_.y);
                      break;
                    case "Q":
                      U.quadraticCurveTo(_.x1, -_.y1, _.x, -_.y);
                      break;
                    case "C":
                      U.bezierCurveTo(_.x1, -_.y1, _.x2, -_.y2, _.x, -_.y);
                  }
              }
            return (
              U.subPaths.forEach((_) => {
                let L = (function (_) {
                  if (_.length) {
                    let L = _[0];
                    if (L instanceof aT) return L.v1;
                    if (L instanceof aA || L instanceof aD) return L.v0;
                  }
                })(_.curves);
                void 0 !== L &&
                  _.currentPoint.distanceTo(L) > 0 &&
                  _.lineTo(L.x, L.y);
              }),
              { offsetX: k + z.fontSize * z.letterSpacing, path: U }
            );
          }
          getCharWidth(_, L) {
            return (
              this.font?.getAdvanceWidth(_, L.fontSize, {
                kerning: !0,
                letterSpacing: L.letterSpacing,
              }) ?? 0
            );
          }
          getTextWidth(_, L) {
            return (
              this.font?.getAdvanceWidth(_, L.fontSize, {
                kerning: !0,
                letterSpacing: L.letterSpacing,
              }) ?? 0
            );
          }
          computeSpaceWidthForLine(_, L, R) {
            let N = this.getCharWidth(" ", R),
              z = _[L];
            if (z) {
              let F = this.countSpaces(z.trimEnd());
              if (4 === R.horizontalAlign && L < _.length - 1 && F)
                return (R.width - (this.getTextWidth(z, R) - F * N)) / F;
            }
            return N;
          }
          countSpaces(_) {
            return (_.match(/ /g) || []).length;
          }
        },
        xH = class {
          constructor() {
            (this.objects = new Map()), (this.unreachable = new Set());
          }
          getCached(_) {
            return this.objects.get(_);
          }
          get size() {
            return this.objects.size;
          }
          get(_, L) {
            let R = this.objects.get(_);
            return (
              void 0 === R
                ? ((R = this.createObject(_, L)), this.objects.set(_, R))
                : (R.isShared = !0),
              R
            );
          }
          mutateIfUnique(_, L) {
            let R = this.objects.get(_);
            if (R && !0 !== R.isShared)
              return this.objects.delete(_), this.objects.set(L, R), R;
          }
          startGc() {
            this.unreachable = new Set(this.objects.keys());
          }
          markAsReachable(_, L) {
            L === this.objects.get(_) && this.unreachable.delete(_);
          }
          endGc() {
            this.unreachable.forEach((_) => {
              this.disposeObject(this.objects.get(_)), this.objects.delete(_);
            }),
              this.unreachable.clear();
          }
          dispose() {
            this.objects.forEach((_) => {
              this.disposeObject(_);
            }),
              this.objects.clear();
          }
        },
        xW = class extends xH {
          constructor(_) {
            super(), (this.flatShading = _);
          }
          disposeObject(_) {
            _.dispose();
          }
          createObject(_, L) {
            let R = il(_, L, this.flatShading);
            return R.computeBoundingSphere(), R;
          }
        },
        xY = {
          find(_) {},
          markNeedsUpdateRendererDirty: function () {},
          markGeometryCacheDirty: function () {},
          addPendingExpandCloner: function (_) {},
          addPendingUpdateCloner(_) {},
          addPendingCommand(_) {},
        },
        xX = class extends xh {
          constructor(_) {
            super(), (this.shared = _);
          }
          create(_) {
            return new xd(_, this.shared);
          }
        },
        xq = class {
          constructor(_, L = {}) {
            if (
              ((this.geometryCache = new xW(!0)),
              (this.geometryCache2 = new xW(!1)),
              (this.imageHolderCache = new xX(this)),
              (this.thisContext = { scene: xY, shared: this }),
              (this.deletedMaterial = new xB(
                fU.defaultTwoLayerData("phong"),
                this.thisContext,
              )),
              (this.deletedImage = new xp(mr.emptyImage, this)),
              (this.deletedVideo = new xp(pU.defaultVideo, this)),
              (this.materials = {}),
              (this.images = {}),
              (this.videos = {}),
              (this.colors = {}),
              (this.audios = {}),
              (this.fonts = {}),
              (this.penumbraSize = []),
              (this.requestRender = () => {
                this._requestRender && this._requestRender();
              }),
              L.images)
            )
              for (let [_, R] of Object.entries(L.images)) this.addImage(_, R);
            if (L.videos)
              for (let [_, R] of Object.entries(L.videos)) this.addVideo(_, R);
            if (L.audios)
              for (let [_, R] of Object.entries(L.audios))
                this.addAudio(_, R.data);
            this.reset(_);
          }
          setRequestRender(_) {
            this._requestRender = _;
          }
          reset(_) {
            for (let [L, R] of Object.entries(_.images)) this.addImage(L, R);
            for (let [L, R] of Object.entries(_.videos)) this.addVideo(L, R);
            for (let [L, R] of Object.entries(_.colors)) this.addColor(L, R);
            for (let [L, R] of Object.entries(_.materials))
              this.addMaterial(L, new xB(R, this.thisContext));
            for (let [L, R] of Object.entries(_.audios))
              this.addAudio(L, R.data);
            for (let [L, R] of Object.entries(_.fonts)) this.addFont(L, R);
            this.penumbraSize = _.penumbraSize;
          }
          addMaterial(_, L) {
            (L.uuid = _), (this.materials[_] = L);
          }
          deleteMaterial(_) {
            this.materials[_] &&
              (this.materials[_].nodeMaterialDispose(),
              delete this.materials[_]);
          }
          getMaterial(_) {
            return this.materials[_];
          }
          getMaterialOrDeletedPlaceholder(_) {
            return this.materials[_] ?? this.deletedMaterial;
          }
          material(_) {
            return "string" == typeof _
              ? this.getMaterialOrDeletedPlaceholder(_)
              : new xR(_, this.thisContext);
          }
          getMaterials() {
            return this.materials;
          }
          addImage(_, L) {
            return this.images[_]
              ? (this.onColorOrImageUpdate && this.onColorOrImageUpdate(),
                this.images[_].updateSrc(L.data),
                !0)
              : ((this.images[_] = new xp(L, this)), !1);
          }
          deleteImage(_) {
            let L = this.images[_];
            L && (L.dispose(), delete this.images[_]);
          }
          getDefaultImage() {
            return this.images.image_0;
          }
          getImage(_) {
            return this.images[_] ?? this.deletedImage;
          }
          image(_) {
            return "string" == typeof _
              ? this.getImage(_)
              : this.imageHolderCache.load(_);
          }
          addVideo(_, L) {
            return this.videos[_]
              ? (this.videos[_].updateSrc(L.data), !0)
              : ((this.videos[_] = new xp(L, this)), !1);
          }
          deleteVideo(_) {
            let L = this.videos[_];
            L && (L.dispose(), delete this.videos[_]);
          }
          getVideo(_) {
            return this.videos[_] ?? this.deletedVideo;
          }
          video(_) {
            return "string" == typeof _
              ? this.getVideo(_)
              : this.imageHolderCache.load(_);
          }
          addColor(_, L) {
            return this.colors[_]
              ? (this.onColorOrImageUpdate && this.onColorOrImageUpdate(),
                "a" in L
                  ? this.colors[_].setRGBA(L.r, L.g, L.b, L.a)
                  : this.colors[_].setRGBA(L.r, L.g, L.b, 1),
                !0)
              : ("a" in L
                  ? (this.colors[_] = new xn(L.r, L.g, L.b, L.a))
                  : (this.colors[_] = new xn(L.r, L.g, L.b, 1)),
                !1);
          }
          updateColor(_, L) {
            if (this.colors[_]) {
              this.onColorOrImageUpdate && this.onColorOrImageUpdate();
              let R = this.colors[_];
              return (
                (this.colors[_].r = L.r ?? R.r),
                (this.colors[_].g = L.g ?? R.g),
                (this.colors[_].b = L.b ?? R.b),
                (this.colors[_].a = L.a ?? R.a),
                !0
              );
            }
            return !1;
          }
          deleteColor(_) {
            this.colors[_] && delete this.colors[_];
          }
          getColor(_) {
            return this.colors[_];
          }
          color(_) {
            let L;
            if ("string" != typeof _)
              return "a" in _
                ? new ys(_.r, _.g, _.b, _.a)
                : new ys(_.r, _.g, _.b, 1);
            {
              let R = this.getColor(_);
              R
                ? (L = R)
                : (console.warn(
                    "Tried to create color layer params with a color key that does not exist in the assets manager",
                  ),
                  (L = new ys(0, 0, 0, 0)));
            }
            return L;
          }
          addAudio(_, L) {
            this.audios[_] = L;
          }
          getAudio(_) {
            let L = this.audios[_];
            if (L instanceof xF) return L;
            {
              let R = new xF({ src: L });
              return (this.audios[_] = R), R;
            }
          }
          deleteAudio(_) {
            let L = this.audios[_];
            L && (L instanceof xF && L.dispose(), delete this.audios[_]);
          }
          addFont(_, L) {
            (this.fonts[_] = new xV(L)),
              this.fonts[_].loadingPromise.then(() => this.requestRender());
          }
          getFont(_) {
            return this.fonts[_];
          }
          deleteFont(_) {
            this.fonts[_] && delete this.fonts[_];
          }
          dispose() {
            Object.keys(this.materials).forEach((_) => this.deleteMaterial(_)),
              (this._requestRender = void 0),
              Object.values(this.audios).forEach((_) => {
                _ instanceof xF && _.dispose();
              }),
              (this.audios = {}),
              this.geometryCache.dispose(),
              this.geometryCache2.dispose();
          }
        };
      new xq(ms.emptyData());
      var xQ = class extends v6 {
          updateByPatchedOp(_, L, R) {
            if (
              (super.updateByPatchedOp(_, L, R),
              null !==
                (function (_, L) {
                  let R = [];
                  if (L.length !== _.length) return null;
                  for (var N = 0; N < _.length; ) {
                    if ("*" === L[N]) R.push(_[N]);
                    else if (_[N] !== L[N]) return null;
                    N += 1;
                  }
                  return R;
                })(_.path, ["materials"]) &&
                0 === _.type &&
                Array.isArray(this.material))
            )
              for (let [L, N] of Object.entries(_.props)) {
                let _ = R.shared.material(N);
                this.material[Number(L)] = _;
              }
            else if (Di(_.path, ["material"]) && this.material instanceof xO)
              "material" in L &&
                "string" != typeof L.material &&
                this.material.updateByOp(dg.drop(_, 1), L.material, R);
            else if (
              Di(_.path, ["materials", "*"]) &&
              Array.isArray(this.material)
            ) {
              let N = _.path[1];
              if ("materials" in L && N < this.material.length) {
                let z = L.materials[N];
                "string" != typeof z &&
                  this.material[N].updateByOp(dg.drop(_, 2), z, R);
              }
            }
          }
          updateState(_, L) {
            super.updateState(_, L),
              void 0 !== _.castShadow && (this.castShadow = _.castShadow),
              void 0 !== _.receiveShadow &&
                (this.receiveShadow = _.receiveShadow);
            let R = this.dataPatched;
            if (
              (_.geometry?.type !== "NonParametricGeometry" &&
                "material" in _ &&
                void 0 !== _.material &&
                (this.disposeMaterial(),
                (this.material = L.shared
                  .material(_.material)
                  .getFlavor(R.flatShading, R.side, R.wireframe)),
                L.scene?.markNeedsUpdateRendererDirty()),
              _.geometry?.type === "NonParametricGeometry" &&
                ("materials" in _ && void 0 !== _.materials
                  ? (this.disposeMaterial(),
                    (this.material = _.materials.map((_) =>
                      L.shared
                        .material(_)
                        .getFlavor(R.flatShading, R.side, R.wireframe),
                    )),
                    L.scene?.markNeedsUpdateRendererDirty())
                  : "material" in _ &&
                    void 0 !== _.material &&
                    (this.disposeMaterial(),
                    (this.material = [
                      L.shared
                        .material(_.material)
                        .getFlavor(R.flatShading, R.side, R.wireframe),
                    ]),
                    L.scene?.markNeedsUpdateRendererDirty())),
              void 0 !== _.flatShading ||
                void 0 !== _.wireframe ||
                void 0 !== _.side)
            ) {
              if (Array.isArray(this.material))
                for (let _ = 0; _ < this.material.length; _++)
                  this.material[_] = this.material[_].getFlavor(
                    R.flatShading,
                    R.side,
                    R.wireframe,
                  );
              else
                this.material = this.material.getFlavor(
                  R.flatShading,
                  R.side,
                  R.wireframe,
                );
            }
          }
          disposeMaterial() {
            this.material &&
              Bm(this.material).forEach((_) => {
                _ instanceof xO && (_ instanceof xB || _.nodeMaterialDispose());
              });
          }
          dispose() {
            this.disposeMaterial(), super.dispose();
          }
        },
        xZ = class extends xQ {
          constructor(_, L, R) {
            super(_, L), (this.data = L), (this.localGeometry = void 0);
          }
          chooseGeoemtryCache(_) {
            return _.geometryCache;
          }
          markGeometryAsReachable(_) {
            this.geometryCreateDeleyed instanceof sP &&
              this.chooseGeoemtryCache(_).markAsReachable(
                this.dataPatched.geometry,
                this.geometryCreateDeleyed,
              );
          }
          get geometry() {
            if (void 0 !== this.localGeometry) return this.localGeometry;
            if (this.geometryCreateDeleyed instanceof xq) {
              let _ = this.geometryCreateDeleyed,
                L = this.chooseGeoemtryCache(_);
              this.geometryCreateDeleyed = L.get(this.dataPatched.geometry, _);
            }
            return this.geometryCreateDeleyed;
          }
          set geometry(_) {
            this.localGeometry = _;
          }
          get is2DAndNoDepth() {
            let _ = this.dataPatched.geometry;
            return fV.is2DParametricMesh(_.type) && 0 === _.depth;
          }
          get is2DType() {
            return fV.is2DParametricMesh(this.geometry.userData.type);
          }
          get isNonParametric() {
            return "NonParametricGeometry" === this.geometry.userData.type;
          }
          updateByPatchedOp(_, L, R) {
            super.updateByPatchedOp(_, L, R),
              Di(_.path, ["geometry"]) &&
                this.updateByPatchedOpGeometry(dg.drop(_, 1), L.geometry, R);
          }
          removeInteractionGeometry() {
            this.localGeometry?.dispose(), (this.localGeometry = void 0);
          }
          updateGeometryInteractions(_, L) {
            this.invalidateDownstreamBooleanData();
            let R = this.data.geometry.type;
            if ("NonParametricGeometry" === R || "SubdivGeometry" === R) {
              let R, N, z;
              if (void 0 === this.localGeometry) {
                let R = { ...this.data.geometry, ..._ };
                this.localGeometry = il(R, L, this.data.flatShading);
              }
              _.scaleBaked
                ? ([R, N, z] = _.scaleBaked)
                : ({ width: R, height: N, depth: z } = _);
              let F = this.localGeometry.userData;
              void 0 !== F.sxPrev &&
                Ih(
                  this.localGeometry.attributes,
                  R / F.sxPrev,
                  N / F.syPrev,
                  z / F.szPrev,
                ),
                (F.sxPrev = R),
                (F.syPrev = N),
                (F.szPrev = z);
            } else {
              let R = { ...this.data.geometry, ..._ };
              this.localGeometry?.dispose(),
                (this.localGeometry = il(R, L, this.data.flatShading));
            }
          }
          refreshAttachedCloners(_) {
            for (let L of this.attachedSurfaceCloners)
              _.scene.addPendingUpdateCloner(L.object);
          }
          refreshAttachedPaths(_) {
            for (let L of this.attachedPaths)
              _.scene.addPendingCommand(() => L.updateShape());
          }
          createGeometryDelayed(_) {
            (this.geometryCreateDeleyed = _.shared),
              this.refreshAttachedCloners(_),
              this.refreshAttachedPaths(_);
          }
          updateByPatchedOpGeometry(_, L, R) {
            let N = !1;
            0 === _.type &&
              0 === _.path.length &&
              Ha(["scaleBaked"], Object.keys(_.props)) &&
              this.geometryCreateDeleyed instanceof vG &&
              this.chooseGeoemtryCache(R.shared).mutateIfUnique(
                this.geometryCreateDeleyed.data,
                L,
              ) === this.geometryCreateDeleyed &&
              ((N = !0),
              this.geometryCreateDeleyed.mutateDirectlyScaleBaked(
                L,
                _.props.scaleBaked,
              ),
              this.refreshAttachedCloners(R),
              this.refreshAttachedPaths(R)),
              N ||
                (R.scene?.markGeometryCacheDirty(),
                this.createGeometryDelayed(R)),
              this.resetBBoxNeedsUpdate(),
              this.invalidateDownstreamBooleanData();
          }
          updateGeometryOnStateUpdate(_, L) {
            this.createGeometryDelayed(L);
          }
          updateState(_, L) {
            void 0 !== _.geometry &&
              this.updateGeometryOnStateUpdate(_.geometry, L),
              super.updateState(_, L);
          }
          updateGeometryGroupsIfNeeded() {
            Array.isArray(this.material) &&
              0 === this.geometry.groups.length &&
              this.geometry.addGroup(
                0,
                Math.max(
                  this.geometry.getIndex()?.count ?? 0,
                  this.geometry.getAttribute("position").count,
                ),
                0,
              );
          }
          updateEntityBoxSize(_, L) {
            let R = this.geometry.userData.parameters;
            this.is2DType
              ? _.set(0, 0, 0.5 * R.depth)
              : this.isNonParametric
                ? (_.setScalar(0),
                  this.geometry.boundingSphere &&
                    _.copy(this.geometry.boundingSphere.center),
                  L.set(R.width, R.height, R.depth ?? 0).multiplyScalar(0.5))
                : _.setScalar(0),
              L.set(R.width, R.height, R.depth ?? 0).multiplyScalar(0.5);
          }
        };
      function Lu(_) {
        if (Array.isArray(_.material)) {
          for (let L of _.material)
            if (0 === L.getLayersOfType("outline").length) return;
        } else if (
          !(_.material instanceof xO) ||
          0 === _.material.getLayersOfType("outline").length
        )
          return;
        _ instanceof xZ && _.is2DAndNoDepth
          ? (function (_) {
              if (
                _.geometry.attributes.extrudeNormals ||
                !_.geometry.attributes.position
              )
                return;
              let L = _.geometry.attributes.position.array,
                R = new Float32Array(L.length),
                N = new iq();
              for (let _ = 0; _ < L.length; _ += 3)
                N.set(L[_], L[_ + 1], L[_ + 2]).normalize(),
                  (R[_] = N.x),
                  (R[_ + 1] = N.y),
                  (R[_ + 2] = N.z);
              _.geometry.setAttribute("extrudeNormal", new sv(R, 3));
            })(_)
          : (function (_) {
              if (
                _.geometry.attributes.extrudeNormal ||
                !_.geometry.attributes.position ||
                !_.geometry.attributes.normal
              )
                return;
              let L = new Map(),
                R = _.geometry.attributes,
                N = R.position.array,
                z = R.normal.array,
                F = new Float32Array(N.length);
              for (let _ = 0; _ < N.length; _ += 3) {
                let R = `${N[_]}_${N[_ + 1]}_${N[_ + 2]}`,
                  F = new iq(z[_], z[_ + 1], z[_ + 2]);
                L.has(R)
                  ? L.get(R)?.normals.push(F)
                  : L.set(R, { normals: [F], result: new iq() });
              }
              L.forEach((_, L) => {
                for (let L of _.normals) _.result.add(L);
                _.result.divideScalar(_.normals.length);
              });
              for (let _ = 0; _ < N.length; _ += 3) {
                let R = `${N[_]}_${N[_ + 1]}_${N[_ + 2]}`,
                  z = L.get(R)?.result;
                z && ((F[_] = z.x), (F[_ + 1] = z.y), (F[_ + 2] = z.z));
              }
              _.geometry.setAttribute("extrudeNormal", new sv(F, 3));
            })(_);
      }
      function Ru(_) {
        if (!_.geometry.attributes.position) return;
        let L = _.geometry.attributes.position.array,
          R = new Float32Array(L.length),
          N = parseInt(_.uuid.replace(/\D/g, "")),
          z = [
            iE.seededRandom(N),
            iE.seededRandom(N + 1e4),
            iE.seededRandom(N + 2e4),
          ];
        for (let _ = 0; _ < L.length; _++) R[_] = z[_ % 3];
        _.geometry.setAttribute("randomColor", new sh(R, 3));
      }
      vR.then((_) => {});
      var xK = new iK(),
        xJ = new iq(),
        x$ = class extends xZ {
          constructor(_, L, R) {
            super(_, L, R),
              (this.data = L),
              (this.hiddenMatrixOld = new rw()),
              (this.smoothShading = !0),
              (this.skipReactionUpdate = !1);
          }
          chooseGeoemtryCache(_) {
            return this.dataPatched.flatShading
              ? _.geometryCache
              : _.geometryCache2;
          }
          get subdivPointerNew() {
            return void 0 !== this.localGeometry
              ? this.subdivPointer
              : this.geometry.ensureSubdivPointer();
          }
          get originalGeometryNew() {
            return void 0 !== this.localGeometry
              ? this.originalGeometry
              : this.geometry.originalGeometry;
          }
          get phongAngle() {
            return this.data.geometry.phongAngle ?? 45;
          }
          updateEntityBoxSize(_, L) {
            let R = this.geometry.userData.parameters;
            _.copy(this.originalGeometryNew.boundingSphere.center),
              L.set(R.width, R.height, R.depth ?? 0).multiplyScalar(0.5);
          }
          createGeometryByControls(_) {
            if (!0 === this.skipReactionUpdate) return;
            let L = this.localGeometry?.uuid,
              {
                originalGeometry: R,
                subdividedGeometry: N,
                subdivPointer: z,
              } = vG.build(
                _,
                this.subdivPointer,
                this.smoothShading,
                this.hasNonUniformScale ? this.shearScale : void 0,
              );
            (this.subdivPointer = z),
              void 0 !== R &&
                (this.originalGeometry?.dispose(), (this.originalGeometry = R)),
              void 0 !== N &&
                (this.subdividedGeometry?.dispose(),
                (this.subdividedGeometry = N ?? void 0)),
              (this.localGeometry =
                this.subdividedGeometry ?? this.originalGeometry),
              Lu(this),
              Ru(this),
              this.calcBoundingBox(),
              L && (this.localGeometry.uuid = L);
          }
          updateState(_, L) {
            if ((super.updateState(_, L), void 0 !== _.flatShading)) {
              let R = this.material;
              (this.material = R.getFlavor(!1, R.side, R.wireframe)),
                (this.smoothShading = !_.flatShading),
                this.createGeometryDelayed(L);
            }
          }
          updateMesh(_ = !1) {
            vG.buildLevel(
              this.subdivPointer,
              !0,
              this.smoothShading ? this.phongAngle : -1,
              this.originalGeometry,
              _ && this.hasNonUniformScale ? this.shearScaleInv : void 0,
            ),
              this.subdividedGeometry &&
                vG.buildLevel(
                  this.subdivPointer,
                  !1,
                  this.smoothShading ? this.phongAngle : -1,
                  this.subdividedGeometry,
                  _ && this.hasNonUniformScale ? this.shearScaleInv : void 0,
                );
          }
          updateTopology() {
            this.originalGeometry.dispose(),
              (this.originalGeometry = vG.buildLevel(
                this.subdivPointer,
                !0,
                this.smoothShading ? this.phongAngle : -1,
              )),
              this.subdividedGeometry &&
                (this.subdividedGeometry.dispose(),
                (this.subdividedGeometry = vG.buildLevel(
                  this.subdivPointer,
                  !1,
                  this.smoothShading ? this.phongAngle : -1,
                ))),
              (this.localGeometry =
                this.subdividedGeometry ?? this.originalGeometry);
          }
          raycast(_, L) {
            let R = this.localGeometry;
            (this.localGeometry = this.originalGeometryNew),
              v6.prototype.raycast.call(this, _, L),
              (this.localGeometry = R);
          }
          activateSVDCompensation() {
            this.hasNonUniformScale &&
              (this.matrix.copy(this.matrixWorldRigid),
              this.hiddenMatrixOld.copy(this.hiddenMatrix),
              this.hiddenMatrix.copy(this.parent.matrixWorld).invert());
          }
          deactivateSVDCompensation() {
            this.hasNonUniformScale &&
              (this.updateMatrix(),
              (this.hasNonUniformScale = void 0),
              this.hiddenMatrix.copy(this.hiddenMatrixOld));
          }
          calcBoundingBox() {
            let _ = this.originalGeometry;
            null === _.boundingSphere &&
              ((_.boundingSphere = new ro()),
              this.subdividedGeometry &&
                (this.subdividedGeometry.boundingSphere = _.boundingSphere));
            let L = _.attributes.position,
              R = _.boundingSphere.center;
            xK.setFromBufferAttribute(L),
              xK.getCenter(R),
              (_.boundingSphere.radius = R.distanceTo(xK.max)),
              isNaN(_.boundingSphere.radius) &&
                console.error(
                  'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
                  this,
                ),
              xK.getSize(xJ),
              this.hasNonUniformScale && xJ.divide(this.scale);
            let N = { width: xJ.x, height: xJ.y, depth: xJ.z };
            return (this.geometry.userData.parameters = N), N;
          }
          updateBoundingSphere(_) {
            let L = this.originalGeometry;
            xK.min.set(_[0], _[2], _[4]),
              xK.max.set(_[1], _[3], _[5]),
              this.hasNonUniformScale &&
                (xK.min.applyMatrix4(this.shearScaleInv),
                xK.max.applyMatrix4(this.shearScaleInv)),
              null === L.boundingSphere && (L.boundingSphere = new ro());
            let R = L.boundingSphere.center;
            xK.getCenter(R), (L.boundingSphere.radius = R.distanceTo(xK.max));
          }
          freeSubdivPointer() {
            this.subdivPointer &&
              (vG.freeSubdivPointer(this.subdivPointer),
              (this.subdivPointer = 0)),
              (this.localGeometry = void 0),
              this.originalGeometry?.dispose(),
              this.subdividedGeometry?.dispose();
          }
          dispose() {
            super.dispose(), this.freeSubdivPointer();
          }
          updateByPatchedOpGeometry(_, L, R) {
            super.updateByPatchedOpGeometry(_, L, R),
              this.localGeometry && this.createGeometryByControls(L);
          }
        },
        x1 = {
          x: [1, 0, 0],
          "-x": [-1, 0, 0],
          y: [0, 1, 0],
          "-y": [0, -1, 0],
          z: [0, 0, 1],
          "-z": [0, 0, -1],
        },
        x2 = { polygon_center: 0, edge: 1, vertex: 2 },
        of = (_, L) => (R, N) => (L && 0 !== R && 0 !== _ ? (_ * N) / 100 : 0),
        et = (_, L) => {
          let R = Math.abs(L),
            N = -1 * R;
          return ((_ - -1) * (R - N)) / 2 + N;
        },
        x4 = new iq(),
        x5 = new iq(),
        x6 = new iq(),
        x8 = new iq();
      function Nu(_, L) {
        let R = x6.fromArray(_),
          N = x8.fromArray(L);
        x5.copy(N).sub(R);
        let z = x5.length();
        return (
          x5.normalize().multiplyScalar(0.5 * z), x4.copy(R).add(x5).toArray()
        );
      }
      var x9 = new se(),
        x7 = new iq(),
        bt = new iq(),
        bi = new iq(),
        Fb = (_) => 0.5 * (1 - Math.cos(_ * Math.PI)),
        br = class {
          constructor() {
            this.perlin = Array(4096);
          }
          noise(_, L = 0, R = 0) {
            if (null == this.perlin) {
              this.perlin = Array(4096);
              for (let _ = 0; _ < 4096; _++) this.perlin[_] = Math.random();
            }
            _ < 0 && (_ = -_), L < 0 && (L = -L), R < 0 && (R = -R);
            let N = Math.floor(_),
              z = Math.floor(L),
              F = Math.floor(R),
              U = _ - N,
              k = L - z,
              Y = R - F,
              X,
              Q,
              K = 0,
              J = 0.5,
              $,
              ee,
              er;
            for (let _ = 0; _ < 4; _++) {
              let _ = N + (z << 4) + (F << 8);
              (X = Fb(U)),
                (Q = Fb(k)),
                ($ = this.perlin[4095 & _]),
                ($ += X * (this.perlin[(_ + 1) & 4095] - $)),
                (ee = this.perlin[(_ + 16) & 4095]),
                (ee += X * (this.perlin[(_ + 16 + 1) & 4095] - ee)),
                ($ += Q * (ee - $)),
                (_ += 256),
                (ee = this.perlin[4095 & _]),
                (ee += X * (this.perlin[(_ + 1) & 4095] - ee)),
                (er = this.perlin[(_ + 16) & 4095]),
                (er += X * (this.perlin[(_ + 16 + 1) & 4095] - er)),
                (ee += Q * (er - ee)),
                ($ += Fb(Y) * (ee - $)),
                (K += $ * J),
                (J *= 0.5),
                (N <<= 1),
                (z <<= 1),
                (k *= 2),
                (F <<= 1),
                (Y *= 2),
                (U *= 2) >= 1 && (N++, U--),
                k >= 1 && (z++, k--),
                Y >= 1 && (F++, Y--);
            }
            return K;
          }
          noiseSeed(_) {
            let L, R;
            let N = {
              setSeed(_) {
                R = L = (_ ?? 4294967296 * Math.random()) >>> 0;
              },
              getSeed: () => L,
              rand: () =>
                (R = (1664525 * R + 1013904223) % 4294967296) / 4294967296,
            };
            N.setSeed(_), (this.perlin = Array(4096));
            for (let _ = 0; _ < 4096; _++) this.perlin[_] = N.rand();
          }
        },
        bn = new iq(),
        ba = new rw(),
        bo = new rx();
      function Gb(_) {
        let L = !1;
        return (
          _.scene.objects.traverse((_, R) => {
            "Mesh" === R.type && "TextGeometry" === R.geometry.type && (L = !0);
          }),
          L
        );
      }
      var bl,
        bh,
        bd,
        bu,
        bp = class extends xZ {
          constructor(_, L, R) {
            super(_, L, R), (this.data = L);
          }
          get textGeometry() {
            return this.geometry;
          }
          get charWidths() {
            return this.textGeometry.charWidths;
          }
          get charCoords() {
            return this.textGeometry.charCoords;
          }
          get wrappedText() {
            return this.textGeometry.wrappedText;
          }
          get font() {
            return this.textGeometry.font;
          }
          get initialOffsetY() {
            let _ = this.dataPatched;
            return (
              this.font?.getLineInitialOffsetY(
                this.lineHeight,
                this.wrappedText.length,
                _.geometry.height,
                this.fontScale,
                _.geometry.verticalAlign,
              ) ?? 0
            );
          }
          get fontScale() {
            let _ = this.dataPatched;
            return this.font ? _.geometry.fontSize / this.font.unitsPerEm : 1;
          }
          get AD() {
            return Math.abs(this.ascender - this.descender);
          }
          get ascender() {
            return (this.font?.ascender ?? 1) * this.fontScale;
          }
          get descender() {
            return (this.font?.descender ?? 1) * this.fontScale;
          }
          get lineHeight() {
            let _ = this.dataPatched;
            return _.geometry.fontSize * _.geometry.lineHeight;
          }
          raycast(_, L) {
            let { matrixWorld: R } = this;
            if (
              !(
                isNaN(_.ray.origin.x) ||
                0 === this.scale.x ||
                0 === this.scale.y ||
                0 === this.scale.z
              ) &&
              (ba.copy(R).invert(),
              bo.copy(_.ray).applyMatrix4(ba),
              bo.intersectBox(this.singleBBox, bn))
            ) {
              let N = bn.applyMatrix4(R),
                z = _.ray.origin.distanceTo(N);
              L.push({ distance: z, point: N.clone(), object: this });
            }
          }
        },
        bf = new iq(),
        bm = new iq();
      vR.then((_) => {
        (bh = [
          (bl = _).get_face_center,
          bl.get_edge_midpoint,
          bl.get_vertex_position,
        ]),
          (bd = [bl.get_face_normal, bl.get_edge_normal, bl.get_vertex_normal]),
          (bu = [bl.face_count, bl.edge_count, bl.vertex_count]);
      });
      var bg = new rw(),
        bv = new rw(),
        by = new iq(),
        bx = new iq(),
        bb = new iq(),
        bw = new iq(),
        b_ = new iq(),
        bS = new iq(),
        bA = new br(),
        bM = class extends au(rK) {
          constructor(_, L) {
            super(),
              (this.parameters = L),
              (this.objectForSample = void 0),
              (this._pendingMediaLoad = !1),
              (this.object = _);
          }
          resetOnMove() {
            this.removeFromParent(), (this.parent = null);
          }
          expandClones(_) {
            if (null === this.parent) this.updateState(this.parameters, _);
            else for (let _ of this.children) _ instanceof mK && _.expand();
          }
          invalidateTransform(_) {
            (this.matrixWorldNeedsUpdate = !0),
              this.traverse((L) => {
                L instanceof mK &&
                  L.object === _ &&
                  (L.matrixWorldNeedsUpdate = !0);
              });
          }
          onObjUpdateMatrix() {
            "toObject" !== this.parameters.type &&
              (this.matrixWorldNeedsUpdate = !0);
          }
          update() {
            switch ((this._updateCount(), this.parameters.type)) {
              case "radial":
                this._updateRadial(this.parameters);
                break;
              case "linear":
                this._updateLinear(this.parameters);
                break;
              case "grid":
                this._updateGrid(this.parameters);
                break;
              case "toObject":
                this._updateToObject(this.parameters);
            }
            for (let _ of this.children)
              _.updateMatrix(),
                _.hasNonUniformScale &&
                  (_.updateMatrixWorld(), _.updateMatrixWorldSVD());
          }
          _updateCount(_) {
            let L;
            if (
              ((L =
                void 0 !== _
                  ? _
                  : "grid" === this.parameters.type
                    ? Math.round(this.parameters.grid.count[0]) *
                      Math.round(this.parameters.grid.count[1]) *
                      Math.round(this.parameters.grid.count[2])
                    : this.parameters.count),
              "toObject" !== this.parameters.type ||
                this.parameters.toObject.object ||
                (L = 0),
              "toObject" === this.parameters.type && this.objectForSample)
            ) {
              for (let _ = 0, L = this.children.length; _ < L; ++_)
                this.remove(this.children[0]);
              let _ = this.children;
              if (_.length === L) return;
              if (_.length < L)
                for (let R = 0, N = L - _.length; R < N; ++R) {
                  let _ = new mK(this.object);
                  _.expand(), this.add(_);
                }
              else
                for (let R = 0, N = _.length - L; R < N; ++R) this.remove(_[R]);
            } else {
              if (this.children.length === L) return;
              if (this.children.length < L)
                for (let _ = 0, R = L - this.children.length; _ < R; ++_) {
                  let _ = new mK(this.object);
                  _.expand(), this.add(_);
                }
              else
                for (let _ = 0, R = this.children.length - L; _ < R; ++_)
                  this.remove(this.children[0]);
            }
          }
          _updateRadial(_) {
            let L = _.radial,
              R = L.start * iE.DEG2RAD,
              N = R - L.end * iE.DEG2RAD,
              z = new rN(L.rotation[0], L.rotation[1], L.rotation[2]),
              F;
            switch (L.axis) {
              case "z":
                F = new iq(0, 0, 1);
                break;
              case "y":
                F = new iq(0, 1, 0);
                break;
              default:
                F = new iq(1, 0, 0);
            }
            let U =
                _.randomnessObject ??
                pO.defaultData([1, 1, 1]).randomnessObject,
              k = "perlin" === U.noiseType;
            bA.noiseSeed(U.seed);
            let Y = ng((0, mN.default)(U.seed)),
              X = of(U.strength, this.parameters.randomness);
            for (let [Q, K] of this.children.entries()) {
              let J = Q * (U.freqScale / 10) + U.movement,
                $ = k ? bA.noise(J) : Y(J, J);
              (K.scale.x = L.scale[0] + X(Q, et($, U.scale[0])) || 1e-4),
                (K.scale.y = L.scale[1] + X(Q, et($, U.scale[1])) || 1e-4),
                (K.scale.z = L.scale[2] + X(Q, et($, U.scale[2])) || 1e-4),
                K.position.setScalar(0);
              let ee = (N / _.count) * Q - R;
              switch (L.axis) {
                case "x":
                  K.rotation.set(0, ee, 0);
                  break;
                case "y":
                  K.rotation.set(0, 0, ee);
                  break;
                case "z":
                  K.rotation.set(ee, 0, 0);
              }
              K.translateOnAxis(F, L.radius),
                (K.position.x += L.position[0] + X(Q, et($, U.position[0]))),
                (K.position.y += L.position[1] + X(Q, et($, U.position[1]))),
                (K.position.z += L.position[2] + X(Q, et($, U.position[2])));
              let er = X(Q, et($, U.rotation[0])),
                en = X(Q, et($, U.rotation[1])),
                ea = X(Q, et($, U.rotation[2]));
              !0 === L.alignment
                ? ((K.rotation.x += z.x + er),
                  (K.rotation.y += z.y + en),
                  (K.rotation.z += z.z + ea))
                : K.rotation.set(z.x + er, z.y + en, z.z + ea);
            }
          }
          _updateLinear(_) {
            if ("linear" !== _.type) throw Error();
            let L = _.linear,
              R = new rN(L.rotation[0], L.rotation[1], L.rotation[2]),
              N =
                _.randomnessObject ??
                pO.defaultData([1, 1, 1]).randomnessObject,
              z = "perlin" === N.noiseType;
            bA.noiseSeed(N.seed);
            let F = ng((0, mN.default)(N.seed)),
              U = of(N.strength, this.parameters.randomness);
            for (let [_, k] of this.children.entries()) {
              let Y = _ * (N.freqScale / 10) + N.movement,
                X = z ? bA.noise(Y) : F(Y, Y),
                Q = U(_, et(X, N.rotation[0])),
                K = U(_, et(X, N.rotation[1])),
                J = U(_, et(X, N.rotation[2]));
              (k.scale.x =
                1 + (L.scale[0] - 1) * _ + U(_, et(X, N.scale[0])) || 1e-4),
                (k.scale.y =
                  1 + (L.scale[1] - 1) * _ + U(_, et(X, N.scale[1])) || 1e-4),
                (k.scale.z =
                  1 + (L.scale[2] - 1) * _ + U(_, et(X, N.scale[2])) || 1e-4),
                (k.rotation.x = R.x * _ + Q),
                (k.rotation.y = R.y * _ + K),
                (k.rotation.z = R.z * _ + J),
                (k.position.x = L.position[0] * _ + U(_, et(X, N.position[0]))),
                (k.position.y = L.position[1] * _ + U(_, et(X, N.position[1]))),
                (k.position.z = L.position[2] * _ + U(_, et(X, N.position[2])));
            }
          }
          _updateGrid(_) {
            let L = 0,
              R = _.grid,
              N =
                _.randomnessObject ??
                pO.defaultData([1, 1, 1]).randomnessObject,
              z = of(N.strength, this.parameters.randomness),
              F = "perlin" === N.noiseType;
            bA.noiseSeed(N.seed);
            let U = (function (_ = Math.random) {
              let L = iM(_),
                R = new Float64Array(L).map((_) => mG[(_ % 12) * 3]),
                N = new Float64Array(L).map((_) => mG[(_ % 12) * 3 + 1]),
                z = new Float64Array(L).map((_) => mG[(_ % 12) * 3 + 2]);
              return function (_, F, U) {
                let k,
                  Y,
                  X,
                  Q,
                  K = (_ + F + U) * mU,
                  J = vh(_ + K),
                  $ = vh(F + K),
                  ee = vh(U + K),
                  er = (J + $ + ee) * mk,
                  en = _ - (J - er),
                  ea = F - ($ - er),
                  eo = U - (ee - er),
                  el,
                  ec,
                  ed,
                  eu,
                  ep,
                  ef;
                en >= ea
                  ? ea >= eo
                    ? ((el = 1),
                      (ec = 0),
                      (ed = 0),
                      (eu = 1),
                      (ep = 1),
                      (ef = 0))
                    : (en >= eo
                        ? ((el = 1), (ec = 0), (ed = 0))
                        : ((el = 0), (ec = 0), (ed = 1)),
                      (eu = 1),
                      (ep = 0),
                      (ef = 1))
                  : ea < eo
                    ? ((el = 0),
                      (ec = 0),
                      (ed = 1),
                      (eu = 0),
                      (ep = 1),
                      (ef = 1))
                    : en < eo
                      ? ((el = 0),
                        (ec = 1),
                        (ed = 0),
                        (eu = 0),
                        (ep = 1),
                        (ef = 1))
                      : ((el = 0),
                        (ec = 1),
                        (ed = 0),
                        (eu = 1),
                        (ep = 1),
                        (ef = 0));
                let ev = en - el + mk,
                  ex = ea - ec + mk,
                  eb = eo - ed + mk,
                  ew = en - eu + 2 * mk,
                  e_ = ea - ep + 2 * mk,
                  eA = eo - ef + 2 * mk,
                  eM = en - 1 + 3 * mk,
                  eE = ea - 1 + 3 * mk,
                  eC = eo - 1 + 3 * mk,
                  eP = 255 & J,
                  eD = 255 & $,
                  eO = 255 & ee,
                  eL = 0.6 - en * en - ea * ea - eo * eo;
                if (eL < 0) k = 0;
                else {
                  let _ = eP + L[eD + L[eO]];
                  (eL *= eL),
                    (k = eL * eL * (R[_] * en + N[_] * ea + z[_] * eo));
                }
                let eR = 0.6 - ev * ev - ex * ex - eb * eb;
                if (eR < 0) Y = 0;
                else {
                  let _ = eP + el + L[eD + ec + L[eO + ed]];
                  (eR *= eR),
                    (Y = eR * eR * (R[_] * ev + N[_] * ex + z[_] * eb));
                }
                let eI = 0.6 - ew * ew - e_ * e_ - eA * eA;
                if (eI < 0) X = 0;
                else {
                  let _ = eP + eu + L[eD + ep + L[eO + ef]];
                  (eI *= eI),
                    (X = eI * eI * (R[_] * ew + N[_] * e_ + z[_] * eA));
                }
                let eB = 0.6 - eM * eM - eE * eE - eC * eC;
                if (eB < 0) Q = 0;
                else {
                  let _ = eP + 1 + L[eD + 1 + L[eO + 1]];
                  (eB *= eB),
                    (Q = eB * eB * (R[_] * eM + N[_] * eE + z[_] * eC));
                }
                return 32 * (k + Y + X + Q);
              };
            })((0, mN.default)(N.seed));
            if (!0 === R.useCenter) {
              let _ = {
                  x: R.count[0] % 2 == 0 ? 2 : 1,
                  y: R.count[1] % 2 == 0 ? 2 : 1,
                  z: R.count[2] % 2 == 0 ? 2 : 1,
                },
                k = new iq(
                  R.size[0] * (R.count[0] - _.x) * 0.5,
                  R.size[1] * (R.count[1] - _.y) * 0.5,
                  R.size[2] * (R.count[2] - _.z) * 0.5,
                );
              for (let _ = 0; _ < R.count[0]; _++)
                for (let Y = 0; Y < R.count[1]; Y++)
                  for (let X = 0; X < R.count[2]; X++) {
                    let Q = [
                        (_ + 1) * (N.freqScale / 10) + N.movement,
                        (Y + 1) * (N.freqScale / 10) + N.movement,
                        (X + 1) * (N.freqScale / 10) + N.movement,
                      ],
                      K = F ? bA.noise(...Q) : U(...Q),
                      J = this.children[L++];
                    (J.scale.x = 1 + z(L, et(K, N.scale[0])) || 1e-4),
                      (J.scale.y = 1 + z(L, et(K, N.scale[1])) || 1e-4),
                      (J.scale.z = 1 + z(L, et(K, N.scale[2])) || 1e-4);
                    let $ = z(L, et(K, N.rotation[0])),
                      ee = z(L, et(K, N.rotation[1])),
                      er = z(L, et(K, N.rotation[2]));
                    J.rotation.set($, ee, er),
                      (J.position.x =
                        R.size[0] * _ - k.x + z(L, et(K, N.position[0]))),
                      (J.position.y =
                        R.size[1] * Y - k.y + z(L, et(K, N.position[1]))),
                      (J.position.z =
                        R.size[2] * X - k.z + z(L, et(K, N.position[2])));
                  }
            } else
              for (let _ = 0; _ < R.count[0]; _++)
                for (let k = 0; k < R.count[1]; k++)
                  for (let Y = 0; Y < R.count[2]; Y++) {
                    let X = [
                        (_ + 1) * (N.freqScale / 10) + N.movement,
                        (k + 1) * (N.freqScale / 10) + N.movement,
                        (Y + 1) * (N.freqScale / 10) + N.movement,
                      ],
                      Q = F ? bA.noise(...X) : U(...X),
                      K = this.children[L++];
                    (K.scale.x = 1 + z(L, et(Q, N.scale[0])) || 1e-4),
                      (K.scale.y = 1 + z(L, et(Q, N.scale[1])) || 1e-4),
                      (K.scale.z = 1 + z(L, et(Q, N.scale[2])) || 1e-4);
                    let J = z(L, et(Q, N.rotation[0])),
                      $ = z(L, et(Q, N.rotation[1])),
                      ee = z(L, et(Q, N.rotation[2]));
                    K.rotation.set(J, $, ee),
                      (K.position.x =
                        R.size[0] * _ + z(L, et(Q, N.position[0]))),
                      (K.position.y =
                        -R.size[1] * k + z(L, et(Q, N.position[1]))),
                      (K.position.z =
                        -R.size[2] * Y + z(L, et(Q, N.position[2])));
                  }
          }
          _updateToObject(_) {
            if ("toObject" !== _.type) throw Error();
            let { toObject: L } = _,
              R = new rN(L.rotation[0], L.rotation[1], L.rotation[2]),
              N =
                _.randomnessObject ??
                pO.defaultData([1, 1, 1]).randomnessObject,
              z = "perlin" === N.noiseType;
            bA.noiseSeed(N.seed);
            let F = ng((0, mN.default)(N.seed)),
              U = of(N.strength, this.parameters.randomness);
            if (!L.object) {
              for (let [, _] of this.children.entries())
                _.position.set(0, 0, 0),
                  _.scale.setScalar(1),
                  _.rotation.set(0, 0, 0);
              this.objectForSample = void 0;
              return;
            }
            if (!this.objectForSample) return;
            if (this.objectForSample instanceof bp) {
              if (
                this.objectForSample.font?.isLoaded &&
                void 0 !== this.objectForSample.geometry.attributes.position
              )
                this._pendingMediaLoad = !1;
              else {
                this._pendingMediaLoad = !0;
                return;
              }
            }
            if (
              void 0 === this.objectForSample.geometry &&
              this.objectForSample.isAncestorOf(this.object.uuid)
            ) {
              console.warn(
                `Oh no! The object "${this.object.name}" (${this.object.uuid}) seem to be a child/descendant of the object it's being cloned to. Please re-parent it so that they are siblings instead.`,
              );
              return;
            }
            let k = this.getSubdivData(),
              Y = [],
              d = (_) => {
                let L = _.length;
                return [
                  _.map((_) => _[0]).reduce((_, L) => _ + L, 0) / L,
                  _.map((_) => _[1]).reduce((_, L) => _ + L, 0) / L,
                  _.map((_) => _[2]).reduce((_, L) => _ + L, 0) / L,
                ];
              },
              h = (_) => Math.round(1e6 * _) / 1e6;
            k.forEach((_) => {
              let L = k.filter(
                (L) =>
                  h(_.pos[0]) === h(L.pos[0]) &&
                  h(_.pos[1]) === h(L.pos[1]) &&
                  h(_.pos[2]) === h(L.pos[2]),
              );
              L.length > 1
                ? Y.push({ pos: _.pos, norm: d(L.map((_) => _.norm)) })
                : Y.push(_);
            });
            let X = (function (_) {
              let L = [],
                R = {};
              for (var N = 0, z = _.length; N < z; N++) {
                var F = JSON.stringify(
                  _[N].pos.map((_) => Math.round(1e4 * _) / 1e4),
                );
                R[F] || (L.push(_[N]), (R[F] = !0));
              }
              return L;
            })(Y);
            if (k.length > 0) {
              let _ = Math.round((X.length * L.count) / 100);
              this._updateCount(_);
            }
            this.objectForSample.updateMatrixWorld();
            let Q = new mW(this.objectForSample).build(),
              K = x1[L.axis],
              J = this.children;
            for (let [_, k] of (Q.setRandomGenerator(
              (0, mN.default)(this.object.uuid + L.seed),
            ),
            J.entries())) {
              let Y = _ * (N.freqScale / 10) + N.movement,
                J = z ? bA.noise(Y) : F(Y, Y),
                $ = U(_, et(J, N.rotation[0])),
                ee = U(_, et(J, N.rotation[1])),
                er = U(_, et(J, N.rotation[2]));
              "random" === L.spreadType
                ? Q.sample(bb, bw)
                : (X.length &&
                    (bb.fromArray(X[_].pos), bw.fromArray(X[_].norm)),
                  this.objectForSample instanceof x$ &&
                    bb.applyMatrix4(
                      bg.copy(this.objectForSample.matrixWorld).invert(),
                    )),
                bb.applyMatrix4(this.object.hiddenMatrix.clone().invert()),
                k.position.copy(bb),
                by.fromArray(K);
              let en =
                  "normal" === L.align ? bw : this.object.getWorldDirection(bS),
                ea = bx.fromArray(L.position);
              (bx.x += bx.x + U(_, et(J, N.position[0]))),
                (bx.y += bx.y + U(_, et(J, N.position[1]))),
                (bx.z += bx.z + U(_, et(J, N.position[2])));
              let eo = Math.acos(en.dot(by)),
                el = b_.crossVectors(by, en).normalize(),
                ec = bv.makeRotationAxis(el, eo),
                ed = en.clone().cross(this.object.up).normalize(),
                eu = ed.clone().cross(en).normalize(),
                ep = new rw().makeBasis(ed, en, eu),
                ef = new iq(by.y, by.z, by.x).normalize(),
                ev = ef.clone().cross(by).normalize(),
                ex = new rw().makeBasis(ef, by, ev).invert(),
                eb = new rw().multiplyMatrices(ep, ex);
              k.rotation.setFromRotationMatrix(eb),
                ea.applyMatrix4(ec),
                k.position.add(ea),
                (k.rotation.x = k.rotation.x + R.x + $),
                (k.rotation.y = k.rotation.y + R.y + ee),
                (k.rotation.z = k.rotation.z + R.z + er),
                k.scale.setScalar(1),
                (k.scale.x =
                  k.scale.x + L.scale[0] + U(_, et(J, N.scale[0])) || 1e-4),
                (k.scale.y =
                  k.scale.y + L.scale[1] + U(_, et(J, N.scale[1])) || 1e-4),
                (k.scale.z =
                  k.scale.z + L.scale[2] + U(_, et(J, N.scale[2])) || 1e-4),
                k.scale.multiply(this.object.scale),
                (k.hiddenMatrix = this.object.hiddenMatrix);
            }
          }
          getSubdivData() {
            if (!this.objectForSample) return [];
            let _ = this.parameters.toObject.spreadType;
            if ("random" === _) return [];
            if (!(this.objectForSample instanceof x$))
              return (
                this.objectForSample.geometry.index
                  ? (function (_) {
                      let L = [];
                      for (let R = 0; R <= _.index.count; R++)
                        if (
                          (x7.fromArray(_.index.array, 3 * R),
                          x9.setFromAttributeAndIndices(
                            _.attributes.position,
                            x7.x,
                            x7.y,
                            x7.z,
                          ),
                          x9.getNormal(bt),
                          x9.getMidpoint(bi),
                          !(isNaN(bi.x) || isNaN(bi.y) || isNaN(bi.z)))
                        ) {
                          let { a: _, b: R, c: N } = x9,
                            z = _.toArray(),
                            F = R.toArray(),
                            U = N.toArray(),
                            k = _.distanceTo(R),
                            Y = R.distanceTo(N),
                            X = N.distanceTo(_),
                            Q = Nu(z, F),
                            K = Nu(F, U),
                            J = Nu(U, z),
                            $ = [k, Y, X],
                            ee = Math.max(...$),
                            er =
                              $.filter((_) => Math.round(_) === Math.round(ee))
                                .length > 1,
                            en = [],
                            ea = x9.getMidpoint(bi).toArray();
                          ee !== k || er || ((en = [K, J, J]), (ea = Q)),
                            ee !== Y || er || ((en = [Q, J, J]), (ea = K)),
                            ee !== X || er || ((en = [Q, K, K]), (ea = J)),
                            er && (en = [Q, K, J]),
                            L.push({
                              vertices: [z, F, U],
                              faceCenters: en,
                              midpoint: ea,
                              norm: x9.getNormal(bt).toArray(),
                            });
                        }
                      return L;
                    })(this.objectForSample.geometry)
                  : (function (_) {
                      let L = [],
                        { position: R } = _.attributes;
                      for (let _ = 0; _ < R.count; _++) {
                        x9.setFromAttributeAndIndices(
                          R,
                          3 * _,
                          3 * _ + 1,
                          3 * _ + 2,
                        ),
                          x9.getNormal(bt),
                          x9.getMidpoint(bi);
                        let N = x9.a.toArray(),
                          z = x9.b.toArray(),
                          F = x9.c.toArray();
                        L.push({
                          vertices: [N, z, F],
                          faceCenters: [Nu(N, z), Nu(z, F), Nu(F, N)],
                          midpoint: bi.toArray(),
                          norm: bt.toArray(),
                        });
                      }
                      return L;
                    })(this.objectForSample.geometry)
              )
                .map((L, R) =>
                  "polygon_center" === _
                    ? { pos: L.midpoint, norm: L.norm }
                    : "vertex" === _
                      ? [
                          { pos: L.vertices[0], norm: L.norm },
                          { pos: L.vertices[1], norm: L.norm },
                          { pos: L.vertices[2], norm: L.norm },
                        ]
                      : "edge" === _
                        ? [
                            { pos: L.faceCenters[0], norm: L.norm },
                            { pos: L.faceCenters[1], norm: L.norm },
                            { pos: L.faceCenters[2], norm: L.norm },
                          ]
                        : [],
                )
                .flat();
            {
              let L = this.objectForSample,
                R = x2[_],
                N = bu[R],
                z = bh[R],
                F = bd[R],
                U = [],
                k = N(L.subdivPointerNew);
              for (let _ = 0; _ <= k - 1; _++) {
                let R = z(L.subdivPointerNew, _),
                  N = F(L.subdivPointerNew, _);
                bf.fromArray(R).applyMatrix4(L.matrixWorld),
                  bm.fromArray(N),
                  U.push({ pos: bf.toArray(), norm: bm.toArray() });
              }
              return U;
            }
          }
          updateState(_, L) {
            if (
              ((this.parameters = Qs(_)), "toObject" !== this.parameters.type)
            )
              (null === this.parent || this.parent !== this.object) &&
                (this.removeFromParent(),
                this.object.parent?.add(this),
                (this.matrix = this.object.matrix),
                (this.hiddenMatrix = this.object.hiddenMatrix),
                (this.matrixWorldNeedsUpdate = !0),
                (this.matrixAutoUpdate = !1));
            else if (
              null === this.parent ||
              this.parent.uuid !== this.parameters.toObject.object
            ) {
              this.removeFromParent();
              let _ = L.find(this.parameters.toObject.object);
              _ instanceof v6
                ? (this.objectForSample = _)
                : (this.objectForSample = void 0),
                (this.matrix = new rw()),
                (this.hiddenMatrix = new rw()),
                (this.matrixWorldNeedsUpdate = !0),
                (this.matrixAutoUpdate = !1),
                _ && _.add(this);
            }
            this.update();
          }
          get pendingMediaLoad() {
            return this._pendingMediaLoad;
          }
        },
        xs = (_) => {
          var L;
          return (
            ((L = class extends _ {}).geometryHelper = new sW(30, 30, 30)), L
          );
        },
        bE = new rx(),
        bC = new ro(),
        bP = new rw(),
        bs = (_, L, R, N, z = !1) => {
          let F = _.matrixWorld;
          if (
            (null === L.boundingSphere && L.computeBoundingSphere(),
            bC.copy(L.boundingSphere),
            bC.applyMatrix4(F),
            !1 === R.ray.intersectsSphere(bC) ||
              (bP.copy(F).invert(),
              bE.copy(R.ray).applyMatrix4(bP),
              null !== L.boundingBox && !1 === bE.intersectsBox(L.boundingBox)))
          )
            return;
          let U,
            k = L.index,
            Y = L.attributes.position,
            X = L.drawRange,
            Q;
          if (!1 === z) {
            let L = Math.max(0, X.start),
              z = Math.min(k.count, X.start + X.count);
            for (Q = L; Q < z; Q += 3)
              if (
                (U = (function (_, L, R, N, z, F, U) {
                  let k = new iq(),
                    Y = new iq(),
                    X = new iq(),
                    Q = new iq(),
                    K = new iq();
                  if (
                    (k.fromBufferAttribute(N, z),
                    Y.fromBufferAttribute(N, F),
                    X.fromBufferAttribute(N, U),
                    null === R.intersectTriangle(k, Y, X, !1, Q))
                  )
                    return null;
                  K.copy(Q), K.applyMatrix4(_.matrixWorld);
                  let J = L.ray.origin.distanceTo(K);
                  return J < L.near || J > L.far
                    ? null
                    : {
                        faceIndex: 1,
                        distance: J,
                        point: K.clone(),
                        object: _,
                      };
                })(_, R, bE, Y, k.getX(Q), k.getX(Q + 1), k.getX(Q + 2)))
              ) {
                (U.faceIndex = Math.floor(Q / 3)), N.push(U);
                return;
              }
          } else {
            let z = L.attributes.position,
              F = new iq(),
              U = new iq(),
              k = new iq(),
              Y = new iq(),
              Q = 1 / ((_.scale.x + _.scale.y + _.scale.z) / 3),
              K = Q * Q,
              J = Math.max(0, X.start),
              $ = Math.min(z.count, X.start + X.count);
            for (let L = J, X = $ - 1; L < X; L += 2) {
              if (
                (F.fromBufferAttribute(z, L),
                U.fromBufferAttribute(z, L + 1),
                bE.distanceSqToSegment(F, U, Y, k) > K)
              )
                continue;
              Y.applyMatrix4(_.matrixWorld);
              let X = R.ray.origin.distanceTo(Y);
              X < R.near ||
                X > R.far ||
                N.push({
                  distance: X,
                  point: k.clone().applyMatrix4(_.matrixWorld),
                  object: _,
                });
            }
          }
        },
        bD = new iq(),
        bO = new sZ(),
        bL = class extends ah {
          constructor(_) {
            let L = new sP(),
              R = new n9({ color: 16777215, vertexColors: !0, toneMapped: !1 }),
              N = [],
              z = [],
              F = {},
              U = new iz(15711266),
              k = new iz(15711266),
              Y = new iz(2857471);
            function d(_, L, R) {
              h(_, R), h(L, R);
            }
            function h(_, L) {
              N.push(0, 0, 0),
                z.push(L.r, L.g, L.b),
                void 0 === F[_] && (F[_] = []),
                F[_].push(N.length / 3 - 1);
            }
            d("n1", "n2", U),
              d("n2", "n4", U),
              d("n4", "n3", U),
              d("n3", "n1", U),
              d("f1", "f2", U),
              d("f2", "f4", U),
              d("f4", "f3", U),
              d("f3", "f1", U),
              d("n1", "f1", U),
              d("n2", "f2", U),
              d("n3", "f3", U),
              d("n4", "f4", U),
              d("p", "n1", k),
              d("p", "n2", k),
              d("p", "n3", k),
              d("p", "n4", k),
              d("u1", "u2", Y),
              d("u2", "u3", Y),
              d("u3", "u1", Y),
              L.setAttribute("position", new sv(N, 3)),
              L.setAttribute("color", new sv(z, 3)),
              super(L, R),
              (this.type = "CameraHelper"),
              (this.camera = _),
              this.camera.updateProjectionMatrix &&
                this.camera.updateProjectionMatrix(),
              (this.matrix = _.matrixWorld),
              (this.matrixAutoUpdate = !1),
              (this.pointMap = F),
              this.update();
          }
          update() {
            let _ = this.geometry,
              L = this.pointMap;
            (bO.projectionMatrixInverse.elements = [
              0.5112609807824982, -0, -0, -0, -0, 0.41421356237309503, -0, -0,
              -0, -0, -0, -0.099999, -0, -0, -1.0000000000000002, 0.100001,
            ]),
              Wi("n1", L, _, bO, -1, -1, 0.8),
              Wi("n2", L, _, bO, 1, -1, 0.8),
              Wi("n3", L, _, bO, -1, 1, 0.8),
              Wi("n4", L, _, bO, 1, 1, 0.8),
              Wi("f1", L, _, bO, -1, -1, 0.8),
              Wi("f2", L, _, bO, 1, -1, 0.8),
              Wi("f3", L, _, bO, -1, 1, 0.8),
              Wi("f4", L, _, bO, 1, 1, 0.8),
              Wi("u1", L, _, bO, 0.35, 1.1, 0.8),
              Wi("u2", L, _, bO, -0.35, 1.1, 0.8),
              Wi("u3", L, _, bO, 0, 1.55, 0.8),
              (_.getAttribute("position").needsUpdate = !0);
          }
          dispose() {
            this.geometry.dispose(), this.material.dispose();
          }
        };
      function Wi(_, L, R, N, z, F, U) {
        bD.set(z, F, U).unproject(N);
        let k = L[_];
        if (void 0 !== k) {
          let _ = R.getAttribute("position");
          for (let L = 0, R = k.length; L < R; L++)
            _.setXYZ(k[L], bD.x, bD.y, bD.z);
        }
      }
      var bR = class extends xs(bL) {
        constructor(_) {
          super(_),
            (this.object = _),
            (this.object = _),
            (this.name = `CombinedCameraHelper: ${_.uuid}`);
        }
        updateMatrixWorld(_) {
          super.updateMatrixWorld(_), this.updateTarget();
        }
        updateTarget() {
          let _ = this.object.getTarget();
          this.updateWorldMatrix(!0, !1), this.worldToLocal(_);
        }
        raycast(_, L) {
          bs(this.object, this.geometry, _, L, !0);
        }
      };
      (wu || (wu = {})).is = (_) => "objectHelper" in _;
      var ia = (_, L) =>
          class extends og(_) {
            constructor() {
              super(...arguments),
                (this.objectHelper = new L(this)),
                (this.gizmos = {});
            }
            get geometryHelper() {
              return L.geometryHelper;
            }
            raycast(_, L) {
              this.objectHelper.raycast(_, L);
            }
            showGizmos() {
              for (let _ in this.gizmos) {
                let L = this.gizmos[_];
                L instanceof o2 && (L.visible = !0);
              }
            }
            updateEntityBoxSize(_, L) {
              this.objectHelper.visible && this.geometryHelper instanceof sW
                ? (_.setScalar(0),
                  L.set(
                    this.geometryHelper.parameters.width,
                    this.geometryHelper.parameters.height,
                    this.geometryHelper.parameters.height,
                  ).multiplyScalar(0.5))
                : super.updateEntityBoxSize(_, L);
            }
            hideGizmos() {
              for (let _ in this.gizmos) {
                let L = this.gizmos[_];
                L instanceof o2 && (L.visible = !1);
              }
            }
          },
        bB = new iq(),
        bN = new iq(),
        bz = new iX(),
        bF = new iq(),
        bU = new iq(),
        bk = new iq(),
        bj = class extends ia(sZ, bR) {
          constructor(_ = "", L = { ...f$.defaultData, name: "" }) {
            super(),
              (this._cameraType = "OrthographicCamera"),
              (this.targetOffset = pD.DefaultTargetOffset),
              (this.isUpVectorFlipped = !1),
              (this.angleOffsetFromUp = 0),
              (this.wasMovedByUser = !1),
              this.super_Entity(_, L),
              (this.matrixAutoUpdate = !0),
              (this.width = window.innerWidth),
              (this.height = window.innerHeight);
            let R = this.width,
              N = this.height;
            if (L.orthographic.autoZoom) {
              let _ = L.orthographic.autoZoomFrustumSize ?? 790,
                z = R / N,
                F = R > N ? z : 1,
                U = R > N ? 1 : z;
              this.orthoCamera = new na(
                -(0.5 * _) * F,
                0.5 * _ * F,
                0.5 * _ * (1 / U),
                -(0.5 * _) * (1 / U),
                -5e4,
                1e4,
              );
            } else
              this.orthoCamera = new na(
                -0.5 * R,
                0.5 * R,
                0.5 * N,
                -0.5 * N,
                -5e4,
                1e4,
              );
            (this.perspCamera = new sK(45, R / N, 50, 1e4)),
              (this.left = this.orthoCamera.left),
              (this.right = this.orthoCamera.right),
              (this.top = this.orthoCamera.top),
              (this.bottom = this.orthoCamera.bottom),
              (this.far = this.orthoCamera.far),
              (this.view = this.orthoCamera.view),
              (this.aspect = this.perspCamera.aspect),
              (this.focus = this.perspCamera.focus),
              (this.filmGauge = this.perspCamera.filmGauge),
              (this.filmOffset = this.perspCamera.filmOffset),
              this.objectHelper.update();
          }
          get isPerspectiveCamera() {
            return "PerspectiveCamera" === this.cameraType;
          }
          get isOrthographicCamera() {
            return !this.isPerspectiveCamera;
          }
          get cameraType() {
            return this._cameraType;
          }
          set fov(_) {
            this.perspCamera.fov = _;
          }
          get fov() {
            return this.perspCamera.fov;
          }
          setNear(_, L) {
            "PerspectiveCamera" === _
              ? (this.perspCamera.near = L)
              : (this.orthoCamera.near = L);
          }
          setZoom(_, L) {
            L >= 0 &&
              ("PerspectiveCamera" === _
                ? (this.perspCamera.zoom = L)
                : (this.orthoCamera.zoom = L));
          }
          set cameraType(_) {
            "PerspectiveCamera" === _
              ? this.toPerspective()
              : "OrthographicCamera" === _ && this.toOrthographic();
          }
          get near() {
            return "PerspectiveCamera" === this._cameraType
              ? this.perspCamera.near
              : this.orthoCamera.near;
          }
          set near(_) {
            "PerspectiveCamera" === this._cameraType
              ? (this.perspCamera.near = _)
              : (this.orthoCamera.near = _);
          }
          get zoom() {
            return "PerspectiveCamera" === this._cameraType
              ? this.perspCamera.zoom
              : this.orthoCamera.zoom;
          }
          set zoom(_) {
            _ >= 0 &&
              ("PerspectiveCamera" === this._cameraType
                ? (this.perspCamera.zoom = _)
                : (this.orthoCamera.zoom = _));
          }
          lookAt(_, L, R) {
            "number" == typeof _ && (_ = new iq(_, L, R)),
              super.lookAt(_),
              this.getWorldPosition(bB),
              (this.targetOffset = bB.distanceTo(_));
          }
          getTarget(_ = new iq()) {
            return (
              this.getWorldDirection(bN),
              this.getWorldPosition(bB),
              bN.multiplyScalar(this.targetOffset),
              _.copy(bB).add(bN),
              _
            );
          }
          getDistanceToTarget() {
            let _ = this.getTarget();
            return this.getWorldPosition(bB), bB.distanceTo(_);
          }
          updateUp() {
            this.getWorldQuaternion(bz),
              bF.set(0, 0, 1).applyQuaternion(bz),
              bU.copy(rK.DEFAULT_UP),
              this.isUpVectorFlipped && bU.negate(),
              bU.applyQuaternion(bz),
              bk.copy(rK.DEFAULT_UP).projectOnPlane(bF),
              (this.angleOffsetFromUp = bk.angleTo(bU)),
              (this.angleOffsetFromUp *= bk.cross(bU).dot(bF) >= 0 ? 1 : -1);
          }
          updateTransformState(_) {
            let L = super.updateTransformState(_);
            return (
              void 0 !== _.isUpVectorFlipped &&
                (this.isUpVectorFlipped = _.isUpVectorFlipped),
              this.updateUp(),
              L
            );
          }
          getViewFrontToObject(_) {
            let L = _.getWorldPosition(new iq()),
              R = _.getWorldDirection(new iq()).multiplyScalar(
                this.targetOffset,
              );
            return { position: L.clone().add(R), target: L };
          }
          getViewToObject(_) {
            let L = _.getWorldPosition(new iq()),
              R = this.getWorldDirection(new iq()).multiplyScalar(
                this.targetOffset,
              );
            return { position: L.clone().sub(R), target: L };
          }
          setViewplaneSize(_, L) {
            if (
              ((this.aspect = _ / L),
              "OrthographicCamera" === this.data.type &&
                this.data.orthographic.autoZoom)
            ) {
              let R = this.data.orthographic.autoZoomFrustumSize ?? 790,
                N = _ > L ? this.aspect : 1,
                z = _ > L ? 1 : this.aspect;
              (this.left = -(0.5 * R) * N),
                (this.right = 0.5 * R * N),
                (this.top = 0.5 * R * (1 / z)),
                (this.bottom = -(0.5 * R) * (1 / z));
            } else
              (this.left = -(0.5 * _)),
                (this.right = 0.5 * _),
                (this.top = 0.5 * L),
                (this.bottom = -(0.5 * L));
            this.updateProjectionMatrix();
          }
          toOrthographic() {
            (this.orthoCamera.left = this.left),
              (this.orthoCamera.right = this.right),
              (this.orthoCamera.top = this.top),
              (this.orthoCamera.bottom = this.bottom),
              (this.orthoCamera.view = this.view),
              (this.orthoCamera.far = this.far),
              this.orthoCamera.updateProjectionMatrix(),
              (this.projectionMatrix = this.orthoCamera.projectionMatrix),
              (this.projectionMatrixInverse =
                this.orthoCamera.projectionMatrixInverse),
              (this._cameraType = "OrthographicCamera"),
              this.objectHelper && this.objectHelper.update();
          }
          toPerspective() {
            (this.perspCamera.aspect = this.aspect),
              (this.perspCamera.fov = this.fov),
              (this.perspCamera.view = this.view),
              (this.perspCamera.far = this.far),
              this.perspCamera.updateProjectionMatrix(),
              (this.projectionMatrix = this.perspCamera.projectionMatrix),
              (this.projectionMatrixInverse =
                this.perspCamera.projectionMatrixInverse),
              (this._cameraType = "PerspectiveCamera"),
              this.objectHelper && this.objectHelper.update();
          }
          setFocalLength(_) {
            this.perspCamera.setFocalLength(_), this.toPerspective();
          }
          getFocalLength() {
            return this.perspCamera.getFocalLength();
          }
          getEffectiveFOV() {
            return this.perspCamera.getEffectiveFOV();
          }
          getFilmWidth() {
            return this.perspCamera.getFilmWidth();
          }
          getFilmHeight() {
            return this.perspCamera.getFilmHeight();
          }
          setViewOffset(_, L, R, N, z, F) {
            "PerspectiveCamera" === this._cameraType
              ? this.perspCamera.setViewOffset(_, L, R, N, z, F)
              : this.orthoCamera.setViewOffset(_, L, R, N, z, F);
          }
          clearViewOffset() {
            "PerspectiveCamera" === this._cameraType
              ? (this.perspCamera.clearViewOffset(), this.toPerspective())
              : (this.orthoCamera.clearViewOffset(), this.toOrthographic());
          }
          updateProjectionMatrix() {
            "PerspectiveCamera" === this._cameraType
              ? this.toPerspective()
              : "OrthographicCamera" === this._cameraType &&
                this.toOrthographic();
          }
          updateMatrixWorld(_) {
            super.updateMatrixWorld(_),
              this.matrixWorldInverse.copy(this.matrixWorld).invert();
          }
          updateWorldMatrix(_, L) {
            super.updateWorldMatrix(_, L),
              this.matrixWorldInverse.copy(this.matrixWorld).invert();
          }
          copy(_, L) {
            return (
              super.copy(_, L),
              this.orthoCamera.copy(_.orthoCamera),
              this.perspCamera.copy(_.perspCamera),
              (this.left = _.left),
              (this.right = _.right),
              (this.top = _.top),
              (this.bottom = _.bottom),
              (this.far = _.far),
              (this.view = null === _.view ? null : Object.assign({}, _.view)),
              (this._cameraType = _._cameraType),
              (this.aspect = _.aspect),
              (this.fov = _.fov),
              (this.focus = _.focus),
              (this.filmGauge = _.filmGauge),
              (this.filmOffset = _.filmOffset),
              (this.targetOffset = _.targetOffset),
              this.updateProjectionMatrix(),
              this
            );
          }
          toCameraState(_ = []) {
            return cH(
              {
                type: this.cameraType,
                far: this.far,
                orthographic: {
                  near: this.orthoCamera.near,
                  zoom: this.orthoCamera.zoom,
                  autoZoom: !0,
                  autoZoomFrustumSize: 790,
                },
                perspective: {
                  near: this.perspCamera.near,
                  fov: this.perspCamera.fov,
                  zoom: this.perspCamera.zoom,
                },
                up: this.up.toArray(),
                targetOffset: this.targetOffset,
                isUpVectorFlipped: this.isUpVectorFlipped,
              },
              _,
            );
          }
          updateCameraSubtype(_, L) {
            let R =
              "perspective" === _ ? "PerspectiveCamera" : "OrthographicCamera";
            void 0 !== L.zoom && this.setZoom(R, L.zoom),
              void 0 !== L.near && this.setNear(R, L.near),
              void 0 !== L.fov &&
                "PerspectiveCamera" === R &&
                (this.fov = L.fov);
          }
          updateState(_, L) {
            this.updateCameraState(_, L);
          }
          updateCameraState(_, L) {
            this.updateState_Entity(_, L),
              void 0 !== _.far && (this.far = _.far),
              void 0 !== _.orthographic &&
                this.updateCameraSubtype("orthographic", _.orthographic),
              void 0 !== _.perspective &&
                this.updateCameraSubtype("perspective", _.perspective),
              void 0 !== _.type && (this.cameraType = _.type),
              void 0 !== _.up && this.up.fromArray(_.up),
              void 0 !== _.targetOffset && (this.targetOffset = _.targetOffset),
              void 0 !== _.isUpVectorFlipped &&
                (this.isUpVectorFlipped = _.isUpVectorFlipped),
              this.updateProjectionMatrix();
          }
          updateByPatchedOp(_, L, R) {
            super.updateByPatchedOp(_, L, R),
              1 === _.path.length &&
                0 === _.type &&
                this.updateCameraSubtype(_.path[0], _.props);
          }
          toState(_) {
            return {
              ...super.toState(_),
              ...this.toCameraState(_),
              type: this.cameraType,
            };
          }
        },
        bG = new rw();
      function Yb(_) {
        let L = !1;
        return (
          _.scene.objects.traverse((_, R) => {
            R.geometry?.type === "BooleanGeometry" && (L = !0);
          }),
          L
        );
      }
      var bV = class extends xQ {
        constructor(_, L, R) {
          super(_, L),
            (this.data = L),
            (this.meshSetAddresses = []),
            (this.needsTransformForDownstream = !1),
            (this.geometry = new sP()),
            (this.geometry.userData.parameters = {
              width: 0,
              height: 0,
              depth: 0,
            });
        }
        get booleanOp() {
          return this.data.geometry.operation;
        }
        get phongAngle() {
          return this.data.geometry.phongAngle ?? 45;
        }
        get isLOD() {
          return this.recomputeBoolean(), !1;
        }
        updateByPatchedOp(_, L, R) {
          super.updateByPatchedOp(_, L, R),
            1 === _.path.length &&
              "geometry" === _.path[0] &&
              0 === _.type &&
              void 0 !== _.props.operation &&
              (this.freeBooleanPointer(), this.resetBBoxNeedsUpdate());
        }
        freeBooleanPointer() {
          super.freeBooleanPointer(), this.geometry.dispose();
        }
        recomputeBoolean(_, L = !0) {
          if (-1 !== this.booleanMeshSetAddress && !_) return;
          for (let R = 0; R < this.children.length; R++) {
            let N = this.children[R];
            N instanceof bV && N.recomputeBoolean(!0 === _, L);
          }
          this.meshSetAddresses = [];
          for (let R = 0; R < this.children.length; R++) {
            let N = this.children[R];
            if (
              N instanceof v6 &&
              !0 === N.dataPatched.visible &&
              N.geometry.attributes.position?.count > 0 &&
              N.geometry.drawRange.count > 0
            ) {
              if (-1 === N.booleanMeshSetAddress) {
                if (
                  ((N.geometry.index ?? N.geometry.getAttribute("position"))
                    .count /
                    3 <
                    15e5 &&
                    (N.booleanMeshSetAddress = vq.getMeshSet(
                      N.geometry,
                      !0 === _,
                      L,
                    )),
                  -1 === N.booleanMeshSetAddress)
                )
                  return;
                vq.transformMeshSet(N.booleanMeshSetAddress, N.matrix),
                  N.booleanMatrixInvOld.copy(N.matrix).invert(),
                  (N.booleanWasTransformed = !1);
              } else
                N instanceof bV && !0 === N.needsTransformForDownstream
                  ? (vq.transformMeshSet(N.booleanMeshSetAddress, N.matrix),
                    (N.needsTransformForDownstream = !1))
                  : !0 === N.booleanWasTransformed &&
                    (bG.multiplyMatrices(N.matrix, N.booleanMatrixInvOld),
                    vq.transformMeshSet(N.booleanMeshSetAddress, bG),
                    N.booleanMatrixInvOld.copy(N.matrix).invert(),
                    (N.booleanWasTransformed = !1));
              this.meshSetAddresses.push(N.booleanMeshSetAddress);
            }
          }
          if (0 === this.meshSetAddresses.length) {
            this.geometry.setAttribute("position", new sf([], 0)),
              this.geometry.setDrawRange(0, 0);
            return;
          }
          if (!0 === _)
            return vq.calcBooleanTopological(
              this.meshSetAddresses,
              this.booleanOp,
            );
          let R = this.geometry;
          R.dispose(),
            (this.geometry = new sP()),
            (this.geometry.userData = R.userData),
            (this.geometry.boundingSphere = R.boundingSphere);
          try {
            this.booleanMeshSetAddress = vq.calcBoolean(
              this.meshSetAddresses,
              this.booleanOp,
              this.geometry,
              this.phongAngle,
            );
          } catch (_) {
            (this.booleanMeshSetAddress = 0), console.error(_);
          }
          this.booleanMatrixInvOld.copy(this.matrix).invert(),
            (this.needsTransformForDownstream = !0),
            Lu(this),
            Ru(this);
        }
        dispose() {
          super.dispose(), this.geometry.dispose();
        }
      };
      (wp || (wp = {})).is = function (_) {
        return vu.is(_) && _ instanceof or;
      };
      var Gu = (_, L) =>
          class extends ia(_, L) {
            updateState_Light(_, L) {
              this.updateState_Entity(_, L),
                void 0 !== _.color && (this.color = L.shared.color(_.color)),
                void 0 !== _.intensity && (this.intensity = _.intensity),
                void 0 !== _.depth &&
                  ((this.shadow.camera.far = _.depth),
                  (this.shadow.needsUpdate = !0)),
                void 0 !== _.shadows && (this.castShadow = _.shadows);
            }
          },
        $r = (_) => _ instanceof v6,
        ei = (_) => null !== _ && _ instanceof bV,
        qC = (_) => _ instanceof bj,
        XC = (_) => wp.is(_),
        YC = (_) => wu.is(_),
        bH = class extends xs(o3) {
          constructor(_, L = 15) {
            super(L),
              (this.object = _),
              this.object.updateMatrixWorld(),
              (this.name = `EmptyObjectHelper: ${_.uuid}`),
              (this.matrix = _.matrixWorld),
              (this.matrixAutoUpdate = !1);
          }
          raycast(_, L) {
            bs(this.object, bH.geometryHelper, _, L);
          }
          update() {}
        },
        bW = class extends ia(nQ, bH) {
          constructor(_, L) {
            super(), this.super_Entity(_, L), this.objectHelper.update();
          }
          updateState(_, L) {
            this.updateState_Entity(_, L);
          }
        },
        bY = class extends xs(oK) {
          constructor(_, L = 15, R = 10066329) {
            super(_, L, R),
              (this.object = _),
              (this.added = !1),
              (this.name = `DirectionalLightHelper: ${_.uuid}`);
          }
          raycast(_, L) {
            bs(this.object, bY.geometryHelper, _, L);
          }
        },
        bX = class extends xs(oX) {
          constructor(_, L = 15, R = 6710886) {
            super(_, L, R),
              (this.object = _),
              (this.name = `PointLightHelper: ${_.uuid}`);
          }
          raycast(_, L) {
            bs(this.object, bX.geometryHelper, _, L);
          }
        },
        bq = class extends xs(oY) {
          constructor(_, L = 6710886) {
            super(_, L),
              (this.object = _),
              (this.name = `SpotLightHelper: ${_.uuid}`);
          }
          raycast(_, L) {
            bs(this.object, bq.geometryHelper, _, L);
          }
          update() {
            if (void 0 !== this.object) {
              let _ = bq._vector,
                L = this.object.distance ? this.object.distance : 1e3,
                R = L * Math.tan(this.object.angle);
              this.cone.scale.set(R, R, L),
                _.setFromMatrixPosition(this.object.target.matrixWorld),
                this.cone.lookAt(_);
              let N = void 0 !== this.color ? this.color : this.light.color;
              if (this.cone.material instanceof Array)
                for (let _ = 0, L = this.cone.material.length; _ < L; _++)
                  this.cone.material[_].color.set(N);
              else this.cone.material.color.set(N);
            }
          }
        },
        bQ = bq;
      bQ._vector = new iq();
      var bZ = class extends Gu(oS, bY) {
          constructor(_, L, R) {
            super(),
              this.super_Entity(_, L),
              (this.castShadow = !0),
              (this.shadow.mapSize.width = 2048),
              (this.shadow.mapSize.height = 2048),
              (this.shadow.normalBias = 1),
              this.layers.enable(3);
            let N = this.shadow.camera;
            (N.top = 1250),
              (N.bottom = -1250),
              (N.right = 1250),
              (N.left = -1250),
              (N.near = -1e4),
              (N.far = 2500);
            let z = new o0(this.shadow.camera);
            (z.visible = !1), (this.gizmos.shadowmap = z);
          }
          update() {
            for (let _ in (this.shadow.camera.updateProjectionMatrix(),
            this.gizmos)) {
              let L = this.gizmos[_];
              L instanceof o0 && L.update();
            }
          }
          updateMatrixWorld(_) {
            super.updateMatrixWorld(_),
              this.objectHelper && this.objectHelper.update();
          }
          updateState(_, L) {
            var R;
            this.updateState_Light(_, L);
            let N =
              (void 0 !== _.depth && _.depth !== this.shadow.camera.far) ||
              (void 0 !== _.size && _.size / 2 !== this.shadow.camera.right);
            void 0 !== _.size &&
              ((R = _.size),
              (this.shadow.camera.right = R / 2),
              (this.shadow.camera.left = -R / 2),
              (this.shadow.camera.top = R / 2),
              (this.shadow.camera.bottom = -R / 2),
              (this.shadow.needsUpdate = !0)),
              void 0 !== _.shadowRadius &&
                (this.shadow.radius = _.shadowRadius),
              void 0 !== _.shadowResolution &&
                (this.shadow.mapSize.set(
                  _.shadowResolution,
                  _.shadowResolution,
                ),
                this.shadow.map &&
                  (this.shadow.map.dispose(), (this.shadow.map = null))),
              N && this.update();
          }
        },
        bK = class extends Gu(ob, bX) {
          constructor(_, L, R) {
            super(),
              this.super_Entity(_, L),
              (this.castShadow = !0),
              (this.shadow.mapSize.width = 1024),
              (this.shadow.mapSize.height = 1024),
              (this.shadow.normalBias = 1),
              this.layers.enable(3);
            let N = this.shadow.camera;
            (N.fov = 90), (N.aspect = 1), (N.near = 100), (N.far = 2500);
            let z = new iq(
                -N.far + this.position.x,
                -N.far + this.position.y,
                -N.far + this.position.z,
              ),
              F = new iq(
                N.far + this.position.x,
                N.far + this.position.y,
                N.far + this.position.z,
              ),
              U = new iK(z, F),
              k = new o2(U, new iz(16755200));
            (k.visible = !1), (this.gizmos.shadowmap = k), this.update();
          }
          update() {
            if (
              this.shadow &&
              (this.shadow.camera.updateProjectionMatrix(), this.gizmos)
            )
              for (let _ in this.gizmos) {
                let L = this.gizmos[_];
                if (L instanceof o2) {
                  let _ = this.shadow.camera,
                    R = new iq(
                      -_.far + this.position.x,
                      -_.far + this.position.y,
                      -_.far + this.position.z,
                    ),
                    N = new iq(
                      _.far + this.position.x,
                      _.far + this.position.y,
                      _.far + this.position.z,
                    );
                  L.box.set(R, N), L.updateMatrixWorld(!0);
                }
              }
          }
          updateMatrixWorld(_) {
            super.updateMatrixWorld(_),
              this.objectHelper && this.objectHelper.update();
          }
          updateState(_, L) {
            this.updateState_Light(_, L),
              void 0 !== _.distance && (this.distance = _.distance),
              void 0 !== _.decay && (this.decay = _.decay),
              void 0 !== _.shadowRadius &&
                (this.shadow.radius = _.shadowRadius),
              void 0 !== _.shadowResolution &&
                (this.shadow.mapSize.set(
                  _.shadowResolution,
                  _.shadowResolution,
                ),
                this.shadow.map &&
                  (this.shadow.map.dispose(), (this.shadow.map = null)));
          }
        },
        bJ = new iq(),
        b$ = new iq(),
        b0 = new iX(),
        b1 = class extends Gu(od, bQ) {
          constructor(_, L, R) {
            super(),
              this.super_Entity(_, L),
              (this.castShadow = !0),
              (this.shadow.mapSize.width = 1024),
              (this.shadow.mapSize.height = 1024),
              (this.shadow.normalBias = 1),
              this.layers.enable(3);
            let N = this.shadow.camera;
            (N.fov = 2 * iE.RAD2DEG * this.angle),
              (N.aspect = 1),
              (N.near = 100),
              (N.far = 2500);
            let z = new o0(this.shadow.camera);
            (z.visible = !1), (this.gizmos.shadowmap = z), this.update();
          }
          update() {
            for (let _ in (this.shadow.camera.updateProjectionMatrix(),
            this.gizmos)) {
              let L = this.gizmos[_];
              L instanceof o0 && L.update();
            }
          }
          updateMatrixWorld(_) {
            super.updateMatrixWorld(_),
              b$.setFromMatrixPosition(this.matrixWorld),
              b0.setFromRotationMatrix(this.matrixWorld),
              bJ
                .copy(this.up)
                .applyQuaternion(b0)
                .negate()
                .multiplyScalar(this.distance),
              this.target.position.copy(b$).add(bJ),
              this.target.updateMatrixWorld(),
              this.objectHelper && this.objectHelper.update();
          }
          updateState(_, L) {
            this.updateState_Light(_, L),
              void 0 !== _.distance && (this.distance = _.distance),
              void 0 !== _.decay && (this.decay = _.decay),
              void 0 !== _.angle && (this.angle = _.angle),
              void 0 !== _.penumbra && (this.penumbra = _.penumbra),
              void 0 !== _.shadowRadius &&
                (this.shadow.radius = _.shadowRadius),
              void 0 !== _.shadowResolution &&
                (this.shadow.mapSize.set(
                  _.shadowResolution,
                  _.shadowResolution,
                ),
                this.shadow.map &&
                  (this.shadow.map.dispose(), (this.shadow.map = null)));
          }
        },
        b2 = class extends xZ {
          get forceComputeSize() {
            return !0;
          }
          get shape() {
            return this.geometry.userData.shape;
          }
          updateEntityBoxSize(_, L) {
            let R = this.geometry.getAttribute("position");
            void 0 !== R
              ? Lh(
                  R,
                  this.geometry.drawRange.start,
                  this.geometry.drawRange.count < 1 / 0
                    ? this.geometry.drawRange.count
                    : R.count,
                  _,
                  L,
                )
              : super.updateEntityBoxSize(_, L);
          }
        },
        b4 = class extends xZ {
          constructor(_, L, R) {
            super(_, L, R), (this._shapeId = null), (this._context = R);
          }
          updateState(_, L) {
            super.updateState(_, L), this.updateShape();
          }
          updateShape() {
            let _ = this.data.geometry.extrusion.shape,
              L;
            if ("Custom" === _.type) {
              let R = _.shapeId;
              if ((R !== this._shapeId && this.detachShape(), R)) {
                this._shapeId = R;
                let _ = this._context.scene.find(R);
                _?.data &&
                  (_.attachedPaths.add(this), (L = _.geometry.userData?.shape)),
                  L ||
                    this._context.scene.addPendingCommand(() =>
                      this.updateShape(),
                    );
              }
            } else {
              let R;
              switch (_.type) {
                case "Rectangle":
                  R = vv;
                  break;
                case "Ellipse":
                  R = gZ;
                  break;
                case "Polygon":
                  R = va;
                  break;
                case "Star":
                  R = vA;
                  break;
                default:
                  throw Error(`Unknown shape type: ${_.type}`);
              }
              L = R.create({ parameters: _ }).userData.shape;
            }
            let R = this.geometry;
            L &&
              R.inputs &&
              ((R.inputs.shapeData = L),
              R.build(),
              this.attachedSurfaceCloners.forEach((_) => _.update()));
          }
          detachShape() {
            null !== this._shapeId &&
              this._context.scene
                .find(this._shapeId)
                ?.attachedPaths.delete(this);
          }
          createGeometryDelayed(_) {
            (this.geometryCreateDeleyed = _.shared),
              this.updateShape(),
              this.refreshAttachedPaths(_);
          }
          updateTransformState(_) {
            return super.updateTransformState(_);
          }
          updateGeometryInteractions(_, L) {
            super.updateGeometryInteractions(_, L), this.updateShape();
          }
          updateEntityBoxSize(_, L) {
            let R = this.geometry.getAttribute("position");
            void 0 !== R
              ? Lh(
                  R,
                  this.geometry.drawRange.start,
                  this.geometry.drawRange.count < 1 / 0
                    ? this.geometry.drawRange.count
                    : R.count,
                  _,
                  L,
                )
              : super.updateEntityBoxSize(_, L);
          }
        },
        b5 = class extends ia(nQ, bH) {
          constructor(_, L, R) {
            super(),
              "Instance" === L.type &&
                "string" == typeof _ &&
                (L = this.transformAssignData(L, R)),
              this.super_Entity(_, L),
              this.objectHelper.update();
          }
          get isComponentRoot() {
            return (
              "Component" === this.data.type && "string" == typeof this.identity
            );
          }
          get isInstanceRoot() {
            return (
              "Instance" === this.data.type && "string" == typeof this.identity
            );
          }
          transformAssignData(_, L) {
            let R = L.scene.data.objects.get(_.component);
            if (R) {
              let L, N;
              for (let z of f4.rootOverrideProps)
                void 0 === _[z]
                  ? (void 0 === L && (L = { ..._ }), (L[z] = R.data[z]))
                  : (void 0 === N && (N = {}), (N[z] = _[z]));
              return (this.overrideData = N), L ?? _;
            }
            return _;
          }
          updateByOp(_, L, R, N) {
            let z;
            if (
              this.isInstanceRoot &&
              !N &&
              ((L = this.transformAssignData(L, R)),
              0 === _.type && 0 === _.path.length && this.component)
            )
              for (let L of f4.rootOverrideProps)
                L in _.props &&
                  void 0 === _.props[L] &&
                  (void 0 === z && (z = { ..._, props: { ..._.props } }),
                  (z.props[L] = this.component.data[L]));
            super.updateByOp(z ?? _, L, R, N);
          }
          updateState(_, L) {
            this.updateState_Entity(_, L);
          }
          expandInstanceChildren(_) {
            let L = this.data;
            if (void 0 === this.component) {
              this.component = _.scene.find(L.component) ?? null;
              let R = !1;
              if (this.component !== this.oldComponent) {
                if (this.oldComponent) {
                  let L = 0;
                  for (let R of this.children)
                    if (vu.is(R))
                      _.scene.disposeAndUnregisterEntityRecursivelyIfNotReregistered(
                        R,
                      ),
                        Xg(R),
                        (L += 1);
                    else break;
                  this.children.splice(0, L);
                }
                R = !0;
              }
              this.component &&
                (function $C(_, L, R, N, z, F, U, k) {
                  if (U > 50) return !1;
                  if (N.component !== z) {
                    if (N.component) {
                      let _ = N.component.instances.indexOf(N);
                      _ >= 0 && N.component.instances.splice(_, 1);
                    }
                    z.instances.push(N), (N.component = z);
                  }
                  z instanceof b5 &&
                    z.isInstanceRoot &&
                    z.expandInstanceChildren(_);
                  let Y = 0;
                  for (let X of z.children)
                    if (vu.is(X)) {
                      let z = [
                          ...L,
                          ...("string" == typeof X.identity
                            ? [X.identity]
                            : X.identity),
                        ],
                        Q = f2.resolve(R, z, 1),
                        K = null,
                        J;
                      if (!k) {
                        let L = N.children[Y];
                        if (null !== (K = vu.is(L) ? L : null)) {
                          let _ = JC(K, X, Q, z);
                          (J = _ >= 1 ? K.stateSelection : void 0),
                            2 !== _ && (K = null);
                        }
                        if (
                          null === K &&
                          null !== (K = _.scene.findInstance(z) ?? null)
                        ) {
                          let L = JC(K, X, Q, z);
                          if (
                            ((J = L >= 1 ? K.stateSelection : void 0), 2 !== L)
                          )
                            K = null;
                          else {
                            let L = K.parent.children.indexOf(K);
                            K.parent.children.splice(L, 1),
                              N.children.splice(Y, 0, K),
                              K.parent === N
                                ? L <= Y && console.error("not possible")
                                : ((K.parent = N),
                                  (K.matrixWorldNeedsUpdate = !0),
                                  K.resetBBoxNeedsUpdate(),
                                  K.updateVisible(),
                                  _.pendingDeletes.delete(K));
                          }
                        }
                      }
                      if (null === K) {
                        let L = Q ? c$.apply(X.data, Q) : X.data;
                        pC.is(L.type) && (L = { ...L, type: "Empty" }),
                          ((K = m9.createEntity(z, L, _)).overrideData = Q),
                          N.add(K),
                          N.children.splice(N.children.length - 1, 1),
                          N.children.splice(Y, 0, K),
                          K.updateState(K.data, _),
                          J && K.changeSelectedState(J, _),
                          _.scene.registerInstanceAndSetUuid(K);
                      }
                      (Y += 1), $C(_, L, R, K, X, F, U + 1, k);
                    }
                  if (!k) {
                    let L = Y;
                    for (;;) {
                      let L = N.children[Y];
                      if (vu.is(L)) _.pendingDeletes.add(L);
                      else break;
                      Y += 1;
                    }
                    N.children.splice(L, Y - L);
                  }
                  return !0;
                })(
                  _,
                  [this.uuid],
                  L.overrides,
                  this,
                  this.component,
                  this.component,
                  0,
                  R,
                ),
                (this.oldComponent = this.component);
            }
          }
        };
      function Xg(_) {
        if (_.component) {
          let L = _.component.instances.indexOf(_);
          for (let R of (L >= 0 && _.component.instances.splice(L, 1),
          _.children))
            vu.is(R) && Xg(R);
        }
      }
      function JC(_, L, R, N) {
        return _.component === L && Ha(_.identity, N)
          ? _.overrideData === R
            ? 2
            : 1
          : 0;
      }
      function Yg(_, L, R) {
        return "Mesh" === L.type
          ? "TextGeometry" === L.geometry.type
            ? new bp(_, L, R)
            : "SubdivGeometry" === L.geometry.type
              ? new x$(_, L, R)
              : "PathGeometry" === L.geometry.type
                ? new b4(_, L, R)
                : "VectorGeometry" === L.geometry.type
                  ? new b2(_, L, R)
                  : "BooleanGeometry" === L.geometry.type
                    ? new bV(_, L, R)
                    : new xZ(_, L, R)
          : "Empty" === L.type
            ? new bW(_, L)
            : "PointLight" === L.type
              ? new bK(_, L, R)
              : "SpotLight" === L.type
                ? new b1(_, L, R)
                : "DirectionalLight" === L.type
                  ? new bZ(_, L, R)
                  : "Component" === L.type || "Instance" === L.type
                    ? new b5(_, L, R)
                    : pC.is(L.type)
                      ? new bj(_, L)
                      : (console.error(L), new bW(_, L));
      }
      function tP(_, L) {
        let R = !1,
          N = L.getLayersOfType("transmission"),
          z = L.getLayersOfType("outline");
        return (
          z.length > 0 &&
            (_.layers.set(8),
            N.length > 0 && _.layers.enable(3),
            (R = !0),
            Ru(_),
            Lu(_)),
          0 === N.length && 0 === z.length && _.layers.set(0),
          R
        );
      }
      function nP(_, L) {
        if (!L.layers) return !1;
        let R = !1,
          N = L.getLayersOfType("transmission").filter((_) => _.data.visible),
          z = L.getLayersOfType("outline").filter((_) => _.data.visible);
        return (
          N.length > 0 &&
            (_.layers.set(3), z.length > 0 && _.layers.enable(8), (R = !0)),
          0 === N.length && 0 === z.length && _.layers.set(0),
          R
        );
      }
      (m9.createEntity = Yg),
        (m9.changeEntityProptotype = function (_, L, R) {
          let N = Yg(_.identity, L, R),
            z = _.children,
            F = _.attachedPaths,
            U = _.parent,
            k = _.component,
            Y = _.instances,
            X = _.overrideData,
            Q = _.uuid,
            K = _.stateSelection;
          for (let L of (_.dispose(), Object.keys(_))) delete _[L];
          for (let L of (Object.setPrototypeOf(_, Object.getPrototypeOf(N)),
          Object.keys(N)))
            _[L] = N[L];
          (_.children = [..._.children, ...z]),
            (_.attachedPaths = F),
            (_.parent = U),
            (_.component = k),
            (_.instances = Y),
            (_.uuid = Q),
            (_.overrideData = X),
            _.updateState(_.data, R),
            K && _.changeSelectedState(K, R),
            _.resetBBoxNeedsUpdate();
        }),
        (m9.Cloner = bM);
      var b6 = new oF(),
        b8 = new rw(),
        b9 = new rx(),
        _5 = (_) => `

// PCSS implementation based on:
// https://www.gamedev.net/articles/programming/graphics/contact-hardening-soft-shadows-made-fast-r4906/
// NOTE: This number affects how big the shadow blur can
// possibly get. Bigger number == bigger blur, but less precise results

const float  gPenumbraFilterSize = 80.0;
const int   gPenumbraSamples = ${_};
const int gShadowSamples = ${_};
const float gShadowSamplesRpc = 1.0f / float(gShadowSamples);

vec2 vogelDiskSample(int sample_index, int sample_count, float angle)
{
  const float goldenAngle = 2.399963f; // radians
  float r = sqrt(float(sample_index) + 0.5f) / sqrt(float(sample_count));
  float theta = float(sample_index) * goldenAngle + angle;
  float sine = sin(theta);
  float cosine = cos(theta);
  return vec2(cosine, sine) * r;
}

// NOTE: For now we aren't using this screen-space noise. But we should enable
// it again once we do some sort of temporal AA. Then we could potentially lower
// the number of samples needed and still get a pretty smooth result.
// Derived from the interleaved gradient function from Jimenez 2014 http:goo.gl/eomGso
float getNoiseInterleavedGradient(vec2 screenPos)
{
    vec3 magic = vec3(0.06711056f, 0.00583715f, 52.9829189f);
    return fract(magic.z * fract(dot(screenPos, magic.xy)));
}

#ifdef USE_SHADOWMAP
    #if NUM_DIR_LIGHT_SHADOWS > 0

        uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
        varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];

        struct DirectionalLightShadow {
            float shadowBias;
            float shadowNormalBias;
            float shadowRadius;
            vec2 shadowMapSize;
        };

        uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];

    #endif

    #if NUM_SPOT_LIGHT_SHADOWS > 0

        uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
        varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_SHADOWS ];

        struct SpotLightShadow {
            float shadowBias;
            float shadowNormalBias;
            float shadowRadius;
            vec2 shadowMapSize;
        };

        uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];

    #endif

    #if NUM_POINT_LIGHT_SHADOWS > 0

        uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
        varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];

        struct PointLightShadow {
            float shadowBias;
            float shadowNormalBias;
            float shadowRadius;
            vec2 shadowMapSize;
            float shadowCameraNear;
            float shadowCameraFar;
        };

        uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];

    #endif

    /*
    #if NUM_RECT_AREA_LIGHTS > 0

        // TODO (abelnation): create uniforms for area light shadows

    #endif
    */

float computePenumbra(int index, sampler2D shadowMap, float temporalAngle, float texelSize, vec2 uv, float compare, float texelScalar, float shadowRadius)
{
    float penumbra = 1.0;
    float blockerDepthAvg = 0.0;
    float blockerCount = 0.0;

    #pragma unroll_loop_start
    for(int i = 0; i < gPenumbraSamples; i ++)
    {
        vec2 offset = (vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize) * texelScalar;
        float depth = unpackRGBAToDepth( texture2D( shadowMap, uv + offset ) );

        if(depth < compare + 0.0001)
        {
            blockerDepthAvg += depth;
            blockerCount++;
        }
    }
    #pragma unroll_loop_end

    if (blockerCount > 0.0)
    {
        blockerDepthAvg /= blockerCount;

        // Compute penumbra
        penumbra = (compare - blockerDepthAvg) / (blockerDepthAvg);
        penumbra *= penumbra;
        penumbra *= 200.0 * penumbraSize[min(index, 5 - 1)]; // Magic number that affects how quickly the penumbra grows

        return clamp(penumbra, 0.00, 1.0);
    }
    return 0.0;
}

vec4 shadowmod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}
vec4 shadowperm(vec4 x){return shadowmod289(((x * 34.0) + 1.0) * x);}
float shadowNoise(vec3 p){
            vec3 a = floor(p);
            vec3 d = p - a;
            d = d * d * (3.0 - 2.0 * d);
            vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);
            vec4 k1 = shadowperm(b.xyxy);
            vec4 k2 = shadowperm(k1.xyxy + b.zzww);
            vec4 c = k2 + a.zzzz;
            vec4 k3 = shadowperm(c);
            vec4 k4 = shadowperm(c + 1.0);
            vec4 o1 = fract(k3 * (1.0 / 41.0));
            vec4 o2 = fract(k4 * (1.0 / 41.0));
            vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);
            vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);
            return o4.y * d.y + o4.x * (1.0 - d.y);
        }

float vogelShadow(int index, sampler2D shadowMap, vec2 uv, float texelSize, float compare, float shadowRadius)
{
    float shadow         = 0.0f;
    float temporalOffset = shadowNoise(floor(vWPosition * 10.));

    // NOTE: When using TAA, we should use screen space interleaved gradient noise
    //float temporalOffset = getNoiseInterleavedGradient(gl_FragCoord.xy);
    float temporalAngle  = temporalOffset * PI2;

    float texelScalar = (gPenumbraFilterSize) / (texelSize * 1024.);
    float penumbra = computePenumbra(index, shadowMap, temporalAngle, texelSize, uv, compare, texelScalar, shadowRadius);
    if (penumbra == -1.0) {
        return 1.0;
    }

    #pragma unroll_loop_start
    for (int i = 0; i < gShadowSamples; i++)
    {
        vec2 vogelSample =  vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;
        // Overall blurring offset
        vec2 offset = vogelSample * (shadowRadius * 2.);

        // Penumbra offset
        offset += vogelSample * (penumbra * texelScalar);

        shadow += step( compare, unpackRGBAToDepth( texture2D( shadowMap, uv + offset ) ) );
    }
    #pragma unroll_loop_end

    return shadow * gShadowSamplesRpc;
}


    float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {

        return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );

    }

    vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {

        return unpackRGBATo2Half( texture2D( shadow, uv ) );

    }

    float VSMShadow (sampler2D shadow, vec2 uv, float compare ){

        float occlusion = 1.0;

        vec2 distribution = texture2DDistribution( shadow, uv );

        float hard_shadow = step( compare , distribution.x ); // Hard Shadow

        if (hard_shadow != 1.0 ) {

            float distance = compare - distribution.x ;
            float variance = max( 0.00000, distribution.y * distribution.y );
            float softness_probability = variance / (variance + distance * distance ); // Chebeyshevs inequality
            softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 ); // 0.3 reduces light bleed
            occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );

        }
        return occlusion;

    }

    float getShadow( int i, sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {

        float shadow = 1.0;

        shadowCoord.xyz /= shadowCoord.w;
        shadowCoord.z += shadowBias;

        // if ( something && something ) breaks ATI OpenGL shader compiler
        // if ( all( something, something ) ) using this instead

        bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
        bool inFrustum = all( inFrustumVec );

        bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );

        bool frustumTest = all( frustumTestVec );

        if ( frustumTest ) {

        #if defined( SHADOWMAP_TYPE_PCF )

            vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
            return vogelShadow(i, shadowMap, shadowCoord.xy, texelSize.x, shadowCoord.z, shadowRadius );

        #elif defined( SHADOWMAP_TYPE_PCF_SOFT )

            vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
            float dx = texelSize.x;
            float dy = texelSize.y;

            vec2 uv = shadowCoord.xy;
            vec2 f = fract( uv * shadowMapSize + 0.5 );
            uv -= f * texelSize;

            shadow = (
                texture2DCompare( shadowMap, uv, shadowCoord.z ) +
                texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
                texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
                texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
                mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
                     texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
                     f.x ) +
                mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
                     texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
                     f.x ) +
                mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
                     texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
                     f.y ) +
                mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
                     texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
                     f.y ) +
                mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
                          texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
                          f.x ),
                     mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
                          texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
                          f.x ),
                     f.y )
            ) * ( 1.0 / 9.0 );

        #elif defined( SHADOWMAP_TYPE_VSM )

            shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );

        #else // no percentage-closer filtering:

            shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );

        #endif

        }

        return shadow;

    }

    // cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D
    // vector suitable for 2D texture mapping. This code uses the following layout for the
    // 2D texture:
    //
    // xzXZ
    //  y Y
    //
    // Y - Positive y direction
    // y - Negative y direction
    // X - Positive x direction
    // x - Negative x direction
    // Z - Positive z direction
    // z - Negative z direction
    //
    // Source and test bed:
    // https://gist.github.com/tschw/da10c43c467ce8afd0c4

    vec2 cubeToUV( vec3 v, float texelSizeY ) {

        // Number of texels to avoid at the edge of each square

        vec3 absV = abs( v );

        // Intersect unit cube

        float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
        absV *= scaleToCube;

        // Apply scale to avoid seams

        // two texels less per square (one texel will do for NEAREST)
        v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );

        // Unwrap

        // space: -1 ... 1 range for each square
        //
        // #X##         dim    := ( 4 , 2 )
        //  # #         center := ( 1 , 1 )

        vec2 planar = v.xy;

        float almostATexel = 1.5 * texelSizeY;
        float almostOne = 1.0 - almostATexel;

        if ( absV.z >= almostOne ) {

            if ( v.z > 0.0 )
                planar.x = 4.0 - v.x;

        } else if ( absV.x >= almostOne ) {

            float signX = sign( v.x );
            planar.x = v.z * signX + 2.0 * signX;

        } else if ( absV.y >= almostOne ) {

            float signY = sign( v.y );
            planar.x = v.x + 2.0 * signY + 2.0;
            planar.y = v.z * signY - 2.0;

        }

        // Transform to UV space

        // scale := 0.5 / dim
        // translate := ( center + 0.5 ) / dim
        return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );

    }

    float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {

        float shadow = 1.0;
        vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );

        // for point lights, the uniform @vShadowCoord is re-purposed to hold
        // the vector from the light to the world-space position of the fragment.
        vec3 lightToPosition = shadowCoord.xyz;

        // dp = normalized distance from light to fragment position
        float compare = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear ); // need to clamp?
        compare += shadowBias;

        // bd3D = base direction 3D
        vec3 bd3D = normalize( lightToPosition );

        float temporalOffset = shadowNoise(floor(vWPosition * 10.));
        float temporalAngle  = temporalOffset * PI2;


        #if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_VSM )
            for (int i = 0; i < gShadowSamples; i++) {
                vec2 vogelSample = vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;

                // Overall blurring offset
                vec3 offset = vec3(vogelSample.x, vogelSample.y, -vogelSample.x) * (shadowRadius + 5.);

                // NOTE: Removed for now
                // Penumbra offset
                //offset += vec3(vogelSample.x, vogelSample.y, vogelSample.y)  * (penumbra * gPenumbraFilterSize);

                shadow += texture2DCompare( shadowMap, cubeToUV( bd3D + offset, texelSize.y ), compare );

            }
            return shadow * gShadowSamplesRpc;

        #elif defined( SHADOWMAP_TYPE_PCF_SOFT )
            for (int i = 0; i < 16; i++) {
                vec2 vogelSample = vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;

                // Overall blurring offset
                vec3 offset = vec3(vogelSample.x, vogelSample.y, -vogelSample.x) * (shadowRadius + 5.);

                shadow += texture2DCompare( shadowMap, cubeToUV( bd3D + offset, texelSize.y ), compare );

            }
            return shadow * (1.0 / 16.0);
        #else // no percentage-closer filtering

            return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), compare );

        #endif

    }

#endif
`,
        b7 = nt.lights_fragment_begin,
        we = nt.shadowmask_pars_fragment,
        wt = !1,
        M5 = (_) => {
          switch (_) {
            case "low":
              return 8;
            case "medium":
            default:
              return 16;
            case "high":
              return 32;
          }
        },
        aP = (_ = "medium") => {
          if (wt) return;
          wt = !0;
          let L = M5(_);
          nt.shadowmap_pars_fragment = _5(L);
          let R = b7.slice();
          (R = (R = R.replace(
            "getShadow( spotShadowMap[ i ]",
            "getShadow( UNROLLED_LOOP_INDEX + 3, spotShadowMap[ i ]",
          )).replace(
            "getShadow( directionalShadowMap[ i ]",
            "getShadow( UNROLLED_LOOP_INDEX, directionalShadowMap[ i ]",
          )),
            (nt.lights_fragment_begin = R);
          let N = we.slice();
          (N = N.replaceAll("getShadow(", "getShadow( UNROLLED_LOOP_INDEX, ")),
            (nt.shadowmask_pars_fragment = N);
        },
        wi = `
attribute vec3 randomColor;
varying vec3 vNormal;
flat out vec3 vColor;

void main()
{
vNormal = normal;
vColor = randomColor;
gl_Position = projectionMatrix * (modelViewMatrix * vec4(position, 1.0));
}
`,
        wr = `
uniform float depthContrast;
varying vec3 vNormal;
flat in vec3 vColor;
void main()
{
vec3 normal = (normalize(vNormal)).rgb;

float contrastDepth = (gl_FragCoord.z - 0.5) * depthContrast + 0.5;

vec3 resultColor = mix(mix(vColor, normal, 0.2), vec3(contrastDepth), 0.4);
gl_FragColor = vec4(resultColor, vColor.r);
}
`,
        ws = new sQ({
          vertexShader: wi,
          fragmentShader: wr,
          uniforms: { depthContrast: { value: 1 } },
        }),
        wn = class {
          constructor() {
            this._constraints = new Map();
          }
          setConstraint(_, L) {
            null === L
              ? this._constraints.delete(_)
              : this._constraints.set(_, L);
          }
          removeDependencies(_) {
            this._constraints.delete(_);
          }
          applyConstraints(_) {
            let L = new Set();
            this._constraints.forEach((R, N) => {
              let z = [N, R],
                F = R;
              for (; this._constraints.has(F); )
                (F = this._constraints.get(F)), L.has(F) || z.push(F);
              for (let R = z.length - 2; R >= 0; R--)
                if (!L.has(z[R])) {
                  let N = _.find(z[R]);
                  N
                    ? N.applyPathSnapping(_)
                    : console.warn(`missing entity ${z[R]}`),
                    L.add(z[R]);
                }
            });
          }
          findDependency(_, L) {
            let R = _;
            for (; this._constraints.has(R); )
              if ((R = this._constraints.get(R)) === L) return !0;
            return !1;
          }
        },
        wa = new ss();
      wa.wireframe = !0;
      var wl = new iq(),
        wh = class extends n2 {
          constructor(_, L) {
            super(),
              (this.data = _),
              (this.backupFog = new n0(16777215, 0.1, 2e3)),
              (this.fogUseBGColor = !1),
              (this.enableHelpers = !1),
              (this.wireframeState = !1),
              (this.needsTransmissionDirty = !0),
              (this.needsNormalDirty = !0),
              (this._needsTransmission = !1),
              (this._needsNormal = !1),
              (this.geometryCacheChanged = !1),
              (this.bgColor = new ys(1, 1, 1, 1)),
              (this.entityByUuid = {}),
              (this.entityIdentityToEntity = {}),
              (this.toExpandCloner = new Set()),
              (this.toUpdateCloner = new Set()),
              (this.pendingCommands = []),
              (this.pathConstraints = new wn()),
              (this.needsRecomputeInstances = !1),
              (this.ambientLight = new os(13882323, 8553090, 0.75)),
              (this.ambientLight.name = "Default Ambient Light"),
              this.ambientLight.layers.enable(3),
              (this.personalCamera = this.createPersonalCamera()),
              (this.activeCamera = this.personalCamera),
              (this.postprocessing = _.postprocessing),
              this.init(_, L),
              (this.matrixAutoUpdate = !1);
          }
          markGeometryCacheDirty() {
            this.geometryCacheChanged = !0;
          }
          markNeedsUpdateRendererDirty() {
            (this.needsTransmissionDirty = !0), (this.needsNormalDirty = !0);
          }
          needsTransmission() {
            let _;
            return (
              this.needsTransmissionDirty &&
                ((this._needsTransmission =
                  ((_ = !1),
                  this.traverseEntity((L) => {
                    if (L instanceof xQ) {
                      if (Array.isArray(L.material))
                        for (let R = 0; R < L.material.length; R++)
                          nP(L, L.material[R]) && (_ = !0);
                      else nP(L, L.material) && (_ = !0);
                    }
                  }),
                  _)),
                (this.needsTransmissionDirty = !1)),
              this._needsTransmission
            );
          }
          needsNormal() {
            let _;
            return (
              this.needsNormalDirty &&
                ((this._needsNormal =
                  ((_ = !1),
                  this.traverseEntity((L) => {
                    if (L instanceof xQ) {
                      if (Array.isArray(L.material))
                        for (let R = 0; R < L.material.length; R++)
                          tP(L, L.material[R]) && (_ = !0);
                      else tP(L, L.material) && (_ = !0);
                    }
                  }),
                  _)),
                (this.needsNormalDirty = !1)),
              this._needsNormal
            );
          }
          registerInstanceAndSetUuid(_) {
            let L = _.identity.join("-"),
              R = this.entityIdentityToEntity[L];
            R && (_.uuid = R.uuid),
              (this.entityIdentityToEntity[L] = _),
              (this.entityByUuid[_.uuid] = _);
          }
          findInstance(_) {
            return this.entityIdentityToEntity[_.join("-")];
          }
          getWithSortKey(_) {
            let L = this.find(_);
            if (void 0 === L) return;
            let R = [],
              N = L;
            for (; N !== this; ) {
              let _ = N,
                L = (N = N.parent).children.indexOf(_);
              R.splice(0, 0, L);
            }
            return { entity: L, sortKey: R };
          }
          getAllSorted(_) {
            let L = [];
            for (let R of _) {
              let _ = this.getWithSortKey(R.id);
              void 0 !== _ && L.push(_);
            }
            return (
              L.sort((_, L) =>
                (function (_, L) {
                  let R = 0;
                  for (; R < _.length && R < L.length; ) {
                    if (_[R] < L[R]) return -1;
                    if (_[R] > L[R]) return 1;
                    R += 1;
                  }
                  return R !== L.length ? -1 : R !== _.length ? 1 : 0;
                })(_.sortKey, L.sortKey),
              ),
              L.map((_) => _.entity)
            );
          }
          nonExistOrDescendantOf(_, L) {
            let R = this.find(_);
            if (void 0 === R) return !0;
            for (; R; ) {
              if (R.uuid === L) return !0;
              R = R.parent;
            }
            return !1;
          }
          find(_) {
            if ("" === _ || void 0 === _) return;
            let L = this.entityByUuid[_];
            return void 0 === L ? this.getObjectByProperty("uuid", _) : L;
          }
          debugEnsureEntity(_) {
            let L = this.find(_);
            L
              ? Array.isArray(L.identity) &&
                void 0 === this.findInstance(L.identity) &&
                console.error("not found instance")
              : console.error("not found");
          }
          addPendingExpandCloner(_) {
            this.toExpandCloner.add(_);
          }
          addPendingUpdateCloner(_) {
            this.toUpdateCloner.add(_);
          }
          markToExpandCloner(_) {
            this.toExpandCloner.add(_),
              _.traverseEntityAncestors((_) => {
                this.toExpandCloner.add(_);
              });
          }
          doPendingExpandCloner() {
            this.toExpandCloner.forEach((_) => {
              _.expandCloner(this);
            }),
              this.toExpandCloner.clear();
          }
          doPendingUpdateCloner() {
            this.toUpdateCloner.forEach((_) => {
              _.cloner?.update();
            }),
              this.toUpdateCloner.clear();
          }
          doPendingUpdates() {
            this.doPendingExpandCloner(),
              this.doPendingUpdateCloner(),
              this.applyPendingCommands();
          }
          addPendingCommand(_) {
            this.pendingCommands.push(_);
          }
          applyPendingCommands() {
            this.pendingCommands.forEach((_) => _()),
              (this.pendingCommands.length = 0);
          }
          updateTreeByOp(_, L) {
            if (0 === _.path.length && 7 === _.type) {
              let R = null === _.parent ? this : this.find(_.parent);
              if (void 0 === R) throw Error("unexpected");
              let N = this.createObject(
                _.id,
                _.data,
                _.children,
                R,
                _.localIndex,
                L,
              );
              N.updateVisible(),
                N.resetBBoxNeedsUpdate(),
                $r(N) &&
                  ei(N.parent) &&
                  (N.invalidateUpstreamBooleanData(),
                  N.parent
                    .invalidateDownstreamBooleanData()
                    .recomputeBoolean()),
                this.markNeedsRecomputeInstancesForAncessors(R),
                this.markNeedsRecomputeInstancesForChildren(N),
                this.markToExpandCloner(N);
            } else if (0 === _.path.length && 8 === _.type) {
              let L = this.find(_.id);
              if (void 0 === L) throw Error("unexpected");
              this.markToExpandCloner(L),
                L.resetBBoxNeedsUpdate(),
                this.unregisterObject(L);
              let R = L.parent;
              this.markNeedsRecomputeInstancesForAncessors(R),
                this.markNeedsRecomputeInstancesForChildren(L),
                L.parent.remove(L),
                ei(L.parent) &&
                  (L.parent.invalidateUpstreamBooleanData(),
                  L.parent
                    .invalidateDownstreamBooleanData()
                    .recomputeBoolean()),
                $r(L) &&
                  (L.freeBooleanPointer(),
                  R instanceof bV &&
                    R.invalidateDownstreamBooleanData().recomputeBoolean()),
                L instanceof b4 && L.detachShape(),
                this.disposeAndUnregisterEntityRecursivelyIfNotReregistered(L),
                this.pathConstraints.removeDependencies(L.uuid);
            } else if (0 === _.path.length && 9 === _.type) {
              let L = this.find(_.id);
              if (void 0 === L) throw Error("unexpected");
              this.markNeedsRecomputeInstancesForChildren(L);
              let R = L.parent;
              this.markNeedsRecomputeInstancesForAncessors(R),
                L.cloner?.resetOnMove(),
                this.markToExpandCloner(L);
              let N = null === _.parent ? this : this.find(_.parent);
              if (void 0 === N) throw Error("unexpected");
              N.add(L),
                this.markNeedsRecomputeInstancesForAncessors(N),
                this.markToExpandCloner(L),
                L.invalidateClonerTransform(L),
                L.updateVisible(),
                L.resetBBoxNeedsUpdate();
              let z = _.localIndex;
              N.children.splice(z, 0, N.children.pop()),
                $r(L) &&
                  (L.invalidateUpstreamBooleanData(),
                  ei(L.parent)
                    ? L.parent
                        .invalidateDownstreamBooleanData()
                        .recomputeBoolean()
                    : R instanceof bV &&
                      R.invalidateDownstreamBooleanData().recomputeBoolean());
            }
            this.markNeedsUpdateRendererDirty(), this.markGeometryCacheDirty();
          }
          updateEntityByOp(_, L, R, N) {
            if (0 === L.type) {
              if (
                (("overrides" in L.props || "component" in L.props) &&
                  this.markNeedsRecomputeInstances(),
                L.path.includes("overrides") && "states" in L.props)
              ) {
                let { states: _, rest: R } = L.props;
                (L = { ...L, props: R }), this.markNeedsRecomputeInstances();
              }
              "pathSnapping" === L.path[0] &&
                void 0 !== L.props.pathId &&
                this.pathConstraints.setConstraint(_, L.props.pathId);
            }
            let z = this.find(_);
            if (z)
              try {
                (function (_, L, R, N) {
                  _.updateByOp(L, R, N, !1);
                })(z, L, R, { scene: this, shared: N }),
                  z instanceof xZ && z.updateGeometryGroupsIfNeeded();
              } catch (_) {
                console.error(_);
              }
          }
          get enableFog() {
            return null !== this.fog;
          }
          set enableFog(_) {
            this.fog = !0 === _ ? this.backupFog : null;
          }
          init(_, L) {
            if (
              (this.createChildrenObjects(_.objects, this, L),
              this.personalCamera.removeFromParent(),
              this.add(this.personalCamera),
              this.ambientLight.removeFromParent(),
              this.add(this.ambientLight),
              this.setBackgroundColor(Sr(_.backgroundColor, L)),
              this.updateFog(_.fog, L),
              this.updateAmbientLight(_.environment.ambientLight, L),
              (this.activeCamera = this.personalCamera),
              null !== _.publish.playCamera)
            ) {
              let L = this.find(_.publish.playCamera);
              L instanceof bj && this.switchActiveCamera(L);
            }
            this.expandInstances(L, !0),
              this.traverseEntity((_) => {
                ei(_) && _.recomputeBoolean(), _ instanceof bj && _.updateUp();
              }),
              this.doPendingExpandCloner(),
              this.applyPendingCommands();
          }
          markNeedsRecomputeInstances() {
            this.needsRecomputeInstances = !0;
          }
          markNeedsRecomputeInstancesForChildren(_) {
            _.traverseEntity((_) => {
              ("Component" === _.data.type || "Instance" === _.data.type) &&
                this.markNeedsRecomputeInstances();
            });
          }
          markNeedsRecomputeInstancesForAncessors(_) {
            vu.is(_) &&
              ("Component" === _.data.type &&
                this.markNeedsRecomputeInstances(),
              _.traverseAncestors((_) => {
                vu.is(_) &&
                  "Component" === _.data.type &&
                  this.markNeedsRecomputeInstances();
              }));
          }
          relativeizeInner(_, L, R, N, z, F, U) {
            _ &&
              _ !== N.uuid &&
              N.find(_) &&
              z.forInstancesRec((N) => {
                N.isInstanceRoot ||
                  (N.data = Fc(N.data, (z) => {
                    let k = z.events.data(U.id),
                      Y = N.goUp(F);
                    if (Y) {
                      let N = [...Bm(Y.identity), _].join("-"),
                        z = this.entityIdentityToEntity[N];
                      if (z) {
                        let _ = z.uuid;
                        dx.zoom(k, L)[R] = _;
                      } else console.warn("cannot find instance");
                    }
                  }).data);
              });
          }
          rewriteEventsBeforeGoToPlayMode() {
            this.traverseEntity((_) => {
              if (
                _ instanceof b5 &&
                "string" == typeof _.identity &&
                "Component" === _.data.type
              )
                return (
                  _.traverseEntity((L, R) => {
                    L.data.events.forEach((N) => {
                      "GameControl" === N.data.type
                        ? L.forInstancesRec((_) => {
                            _.isInstanceRoot ||
                              (_.data = Fc(_.data, (_) => {
                                _.events.delete(N.id);
                              }).data);
                          })
                        : "Conditional" === N.data.type
                          ? ("Distance" === N.data.condition.type
                              ? (this.relativeizeInner(
                                  N.data.condition.fromObject,
                                  ["condition"],
                                  "fromObject",
                                  _,
                                  L,
                                  R,
                                  N,
                                ),
                                this.relativeizeInner(
                                  N.data.condition.toObject,
                                  ["condition"],
                                  "toObject",
                                  _,
                                  L,
                                  R,
                                  N,
                                ))
                              : "State" === N.data.condition.type
                                ? this.relativeizeInner(
                                    N.data.condition.object,
                                    ["condition"],
                                    "object",
                                    _,
                                    L,
                                    R,
                                    N,
                                  )
                                : "Comparison" === N.data.condition.type &&
                                  ("Property" ===
                                    N.data.condition.lOperand.type &&
                                    this.relativeizeInner(
                                      N.data.condition.lOperand.value[0],
                                      ["condition", "lOperand", "value"],
                                      0,
                                      _,
                                      L,
                                      R,
                                      N,
                                    ),
                                  "Property" ===
                                    N.data.condition.rOperand.type &&
                                    this.relativeizeInner(
                                      N.data.condition.rOperand.value[0],
                                      ["condition", "rOperand", "value"],
                                      0,
                                      _,
                                      L,
                                      R,
                                      N,
                                    )),
                            N.data.inActions.forEach((z) => {
                              "Transition" === z.data.type &&
                                this.relativeizeInner(
                                  z.data.object,
                                  ["inActions", z.id],
                                  "object",
                                  _,
                                  L,
                                  R,
                                  N,
                                );
                            }),
                            N.data.outActions.forEach((z) => {
                              "Transition" === z.data.type &&
                                this.relativeizeInner(
                                  z.data.object,
                                  ["outActions", z.id],
                                  "object",
                                  _,
                                  L,
                                  R,
                                  N,
                                );
                            }))
                          : "actions" in N.data &&
                            N.data.actions.forEach((z) => {
                              "Transition" === z.data.type &&
                                this.relativeizeInner(
                                  z.data.object,
                                  ["actions", z.id],
                                  "object",
                                  _,
                                  L,
                                  R,
                                  N,
                                );
                            });
                    });
                  }),
                  !0
                );
            });
          }
          expandInstances(_, L) {
            let R = new Set();
            for (let N of (this.traverseEntity((N) => {
              if (N instanceof b5 && N.isInstanceRoot)
                return (
                  N.expandInstanceChildren({
                    scene: this,
                    shared: _,
                    pendingDeletes: R,
                  }),
                  L || N.resetBBoxNeedsUpdate(),
                  !0
                );
            }),
            R))
              this.disposeAndUnregisterEntityRecursivelyIfNotReregistered(N),
                Xg(N);
          }
          recomputeInstances(_) {
            this.needsRecomputeInstances &&
              ((this.needsRecomputeInstances = !1),
              this.traverseEntity((_) => {
                _ instanceof b5 && _.isInstanceRoot && (_.component = void 0);
              }),
              this.expandInstances(_, !1));
          }
          disposeAndUnregisterEntityRecursivelyIfNotReregistered(_) {
            _.traverseEntity((_) => {
              let L =
                "string" == typeof _.identity
                  ? _.identity
                  : _.identity.join("-");
              this.entityIdentityToEntity[L] === _ &&
                (delete this.entityByUuid[_.uuid],
                delete this.entityIdentityToEntity[L]),
                _.dispose();
            });
          }
          clearScene() {
            for (let _ of this.children) vu.is(_) && _.disposeRecursively();
            this.children.length = 0;
          }
          resetAfterClear(_, L) {
            this.init(_, L);
          }
          createPersonalCamera() {
            let _ = new bj(wh.PERSONAL_CAMERA_ID, {
              ...f$.defaultData,
              name: "Personal Camera",
            });
            return (
              (_.objectHelper.visible = !1),
              this.registerObjectCreatedInLegacy(_),
              _
            );
          }
          raycast(_) {
            let L = [],
              i = (R) => {
                for (let N of R.children) {
                  let R = N.cloner;
                  vu.is(N) &&
                    !N.raycastLock &&
                    (N.visible || R?.object.data.visible) &&
                    (($r(N) ||
                      (YC(N) &&
                        this.enableHelpers &&
                        N.objectHelper.visible)) &&
                      (_.intersectObject(N, !1, L),
                      (function (_, L, R) {
                        let N = _.cloner;
                        if (N)
                          for (let z of N.children) {
                            let N = b8.copy(z.matrixWorld).invert(),
                              F = b9.copy(L.ray).applyMatrix4(N),
                              U = _.matrixWorld;
                            F.applyMatrix4(U),
                              b6.set(F.origin, F.direction),
                              (b6.near = L.near),
                              (b6.far = L.far),
                              b6.intersectObject(_, !1).length > 0 &&
                                R.push({ object: _ });
                          }
                      })(N, _, L)),
                    i(N));
                }
              };
            return i(this), L;
          }
          forEachEntity(_) {
            for (let L of this.children) vu.is(L) && _(L);
          }
          traverseEntity(_) {
            for (let L of this.children) vu.is(L) && L.traverseEntity(_);
          }
          traverseObject(_) {
            for (let L of this.children) mV.is(L) && L.traverseObject(_);
          }
          traverseVisibleEntity(_) {
            for (let L of this.children)
              vu.is(L) && L.visible && L.traverseVisibleEntity(_);
          }
          updateFog(_, L) {
            (this.enableFog = _.enabled),
              (this.fogUseBGColor = _.useBackgroundColor),
              _.useBackgroundColor
                ? this.backupFog.color.set(this.bgColor)
                : (this.backupFog.color = Sr(_.color, L)),
              (this.backupFog.near = _.near),
              (this.backupFog.far = _.far);
          }
          dispose() {
            this.clearScene();
          }
          updateAmbientLight(_, L) {
            void 0 !== _.color && (this.ambientLight.color = Sr(_.color, L)),
              void 0 !== _.intensity &&
                (this.ambientLight.intensity = _.intensity),
              void 0 !== _.groundColor &&
                (this.ambientLight.groundColor = Sr(_.groundColor, L)),
              void 0 !== _.enabled && (this.ambientLight.visible = _.enabled);
          }
          switchActiveCamera(_) {
            this.activeCamera !== this.personalCamera &&
              (this.activeCamera.objectHelper.visible = !0),
              (this.activeCamera = _),
              (_.objectHelper.visible = !1);
          }
          setBackgroundColor(_) {
            (this.bgColor = _),
              !0 === this.fogUseBGColor && (this.backupFog.color = _);
          }
          createChildrenObjects(_, L, R) {
            let N = 0;
            for (let z of _)
              this.createObject(z.id, z.data, z.children, L, N, R), (N += 1);
          }
          registerObjectCreatedInLegacy(_) {
            this.entityByUuid[_.uuid] = _;
          }
          unregisterObject(_) {
            for (let L of (delete this.entityByUuid[_.uuid], _.children))
              this.unregisterObject(L);
          }
          createObject(_, L, R, N, z, F) {
            let U = { scene: this, shared: F },
              k = Yg(_, L, U);
            return (
              k &&
                ((this.entityByUuid[_] = k),
                N.add(k),
                N.children.splice(z, 0, N.children.pop()),
                R.length > 0 &&
                  (k.isInstanceRoot
                    ? console.error("instance should not have children!")
                    : this.createChildrenObjects(R, k, F)),
                k.updateState(L, U),
                k instanceof xZ && k.updateGeometryGroupsIfNeeded(),
                k.updateVisible(),
                k.cloner && this.toExpandCloner.add(k),
                L.pathSnapping?.pathId &&
                  this.pathConstraints.setConstraint(_, L.pathSnapping.pathId)),
              k
            );
          }
          getCenter(_) {
            let L = [];
            for (let R = 0, N = _.length; R < N; ++R) {
              let { id: N, recursive: z } = _[R],
                F = this.find(N),
                U = z ? F.recursiveBBox : F.singleBBox;
              L.push(...U.vertices);
            }
            let R = new iK();
            return R.setFromPoints(L), R.getCenter(wl), wl;
          }
          copyMatrixWorld(_, L) {
            if (null === _) {
              L.identity();
              return;
            }
            let R = this.find(_);
            R ? L.copy(R.matrixWorld) : L.identity();
          }
          copyParentMatrixWorld(_, L) {
            if (null === _) {
              L.identity();
              return;
            }
            let R = this.find(_)?.parent;
            R ? L.copy(R.matrixWorld) : L.identity();
          }
          traverseMaterial(_) {
            this.traverseEntity((L) => {
              if (L instanceof v6) {
                if (Array.isArray(L.material))
                  for (let R = 0; R < L.material.length; R++)
                    L.material[R] instanceof xO && _(L.material[R]);
                else L.material instanceof xO && _(L.material);
              }
            });
          }
          updateCanvasSize(_, L) {
            let R, N;
            this.activeCamera.setViewplaneSize(_, L),
              _ >= L ? ((R = L / _), (N = 1)) : ((R = 1), (N = _ / L)),
              this.traverseMaterial((_) => {
                _.getLayersOfType("transmission").forEach((_) => {
                  (_.uniforms[`f${_.id}_aspectRatio`].value.x = R),
                    (_.uniforms[`f${_.id}_aspectRatio`].value.y = N);
                });
              });
          }
        };
      wh.PERSONAL_CAMERA_ID =
        "f23858d0-4a3b-4bd8-8173-66ed0af7f6fb-personalCamera";
      var df = (_, L) => {
          let R = L.x - _.x,
            N = L.y - _.y;
          return Math.sqrt(R * R + N * N);
        },
        cP = (_, L) => {
          let R = L.x - _.x;
          return I5(Math.atan2(L.y - _.y, R));
        },
        uP = (_, L, R) => {
          let N = { x: 0, y: 0 };
          return (
            (R = Jg(R)),
            (N.x = _.x - L * Math.cos(R)),
            (N.y = _.y - L * Math.sin(R)),
            N
          );
        },
        Jg = (_) => _ * (Math.PI / 180),
        I5 = (_) => _ * (180 / Math.PI),
        dP = (_) => (isNaN(_.buttons) ? 0 !== _.pressure : 0 !== _.buttons),
        wd = new Map(),
        Qb = (_) => {
          wd.has(_) && clearTimeout(wd.get(_)), wd.set(_, setTimeout(_, 100));
        },
        Vu = (_, L, R) => {
          let N = L.split(/[ ,]+/g),
            z;
          for (let L = 0; L < N.length; L += 1)
            (z = N[L]),
              _.addEventListener
                ? _.addEventListener(z, R, !1)
                : _.attachEvent && _.attachEvent(z, R);
        },
        Jb = (_, L, R) => {
          let N = L.split(/[ ,]+/g),
            z;
          for (let L = 0; L < N.length; L += 1)
            (z = N[L]),
              _.removeEventListener
                ? _.removeEventListener(z, R)
                : _.detachEvent && _.detachEvent(z, R);
        },
        $g = (_) => (
          _.preventDefault(), _.type.match(/^touch/) ? _.changedTouches : _
        ),
        $b = () => {
          if (!(typeof window > "u"))
            return {
              x:
                void 0 !== window.pageXOffset
                  ? window.pageXOffset
                  : (
                      document.documentElement ||
                      document.body.parentNode ||
                      document.body
                    ).scrollLeft,
              y:
                void 0 !== window.pageYOffset
                  ? window.pageYOffset
                  : (
                      document.documentElement ||
                      document.body.parentNode ||
                      document.body
                    ).scrollTop,
            };
        },
        ey = (_, L) => {
          L.top || L.right || L.bottom || L.left
            ? ((_.style.top = L.top),
              (_.style.right = L.right),
              (_.style.bottom = L.bottom),
              (_.style.left = L.left))
            : ((_.style.left = L.x + "px"), (_.style.top = L.y + "px"));
        },
        ty = (_, L, R) => {
          let N = fP(_);
          for (let _ in N)
            if (N.hasOwnProperty(_)) {
              if ("string" == typeof L) N[_] = L + " " + R;
              else {
                let z = "";
                for (let _ = 0, N = L.length; _ < N; _ += 1)
                  z += L[_] + " " + R + ", ";
                N[_] = z.slice(0, -2);
              }
            }
          return N;
        },
        hP = (_, L) => {
          let R = fP(_);
          for (let _ in R) R.hasOwnProperty(_) && (R[_] = L);
          return R;
        },
        fP = (_) => {
          let L = {};
          return (
            (L[_] = ""),
            ["webkit", "Moz", "o"].forEach(function (R) {
              L[R + _.charAt(0).toUpperCase() + _.slice(1)] = "";
            }),
            L
          );
        },
        ny = (_, L) => {
          for (let R in L) L.hasOwnProperty(R) && (_[R] = L[R]);
          return _;
        },
        pP = (_, L) => {
          let R = {};
          for (let N in _)
            _.hasOwnProperty(N) && L.hasOwnProperty(N)
              ? (R[N] = L[N])
              : _.hasOwnProperty(N) && (R[N] = _[N]);
          return R;
        },
        hf = (_, L) => {
          if (_.length) for (let R = 0, N = _.length; R < N; R += 1) L(_[R]);
          else L(_);
        },
        mP = (_, L, R) => ({
          x: Math.min(Math.max(_.x, L.x - R), L.x + R),
          y: Math.min(Math.max(_.y, L.y - R), L.y + R),
        });
      "u" > typeof window &&
        ((wf = "ontouchstart" in window),
        (wm = !!window.PointerEvent),
        (wg = !!window.MSPointerEvent));
      var wu,
        wp,
        wf,
        wm,
        wg,
        wv,
        wy = {
          touch: {
            start: "touchstart",
            move: "touchmove",
            end: "touchend, touchcancel",
          },
          mouse: { start: "mousedown", move: "mousemove", end: "mouseup" },
          pointer: {
            start: "pointerdown",
            move: "pointermove",
            end: "pointerup, pointercancel",
          },
          MSPointer: {
            start: "MSPointerDown",
            move: "MSPointerMove",
            end: "MSPointerUp",
          },
        },
        wx = {};
      function fl() {}
      function Ln(_, L) {
        return (
          (this.identifier = L.identifier),
          (this.position = L.position),
          (this.frontPosition = L.frontPosition),
          (this.collection = _),
          (this.defaults = {
            size: 100,
            threshold: 0.1,
            color: "white",
            fadeTime: 250,
            dataOnly: !1,
            restJoystick: !0,
            restOpacity: 1,
            mode: "dynamic",
            zone: document.body,
            lockX: !1,
            lockY: !1,
            shape: "circle",
          }),
          this.config(L),
          "dynamic" === this.options.mode && (this.options.restOpacity = 0),
          (this.id = Ln.id),
          (Ln.id += 1),
          this.buildEl().stylize(),
          (this.instance = {
            el: this.ui.el,
            on: this.on.bind(this),
            off: this.off.bind(this),
            show: this.show.bind(this),
            hide: this.hide.bind(this),
            add: this.addToDom.bind(this),
            remove: this.removeFromDom.bind(this),
            destroy: this.destroy.bind(this),
            setPosition: this.setPosition.bind(this),
            resetDirection: this.resetDirection.bind(this),
            computeDirection: this.computeDirection.bind(this),
            trigger: this.trigger.bind(this),
            position: this.position,
            frontPosition: this.frontPosition,
            ui: this.ui,
            identifier: this.identifier,
            id: this.id,
            options: this.options,
          }),
          this.instance
        );
      }
      function hn(_, L) {
        (this.nipples = []),
          (this.idles = []),
          (this.actives = []),
          (this.ids = []),
          (this.pressureIntervals = {}),
          (this.manager = _),
          (this.id = hn.id),
          (hn.id += 1),
          (this.defaults = {
            zone: document.body,
            multitouch: !1,
            maxNumberOfNipples: 10,
            mode: "dynamic",
            position: { top: 0, left: 0 },
            catchDistance: 200,
            size: 100,
            threshold: 0.1,
            color: "white",
            fadeTime: 250,
            dataOnly: !1,
            restJoystick: !0,
            restOpacity: 1,
            lockX: !1,
            lockY: !1,
            shape: "circle",
            dynamicPage: !1,
            follow: !1,
          }),
          this.config(L),
          ("static" === this.options.mode || "semi" === this.options.mode) &&
            (this.options.multitouch = !1),
          this.options.multitouch || (this.options.maxNumberOfNipples = 1);
        let R = getComputedStyle(this.options.zone.parentElement);
        return (
          R && "flex" === R.display && (this.parentIsFlex = !0),
          this.updateBox(),
          this.prepareNipples(),
          this.bindings(),
          this.begin(),
          this.nipples
        );
      }
      function Zn(_) {
        var L = this;
        (L.ids = {}),
          (L.index = 0),
          (L.collections = []),
          (L.scroll = $b()),
          L.config(_),
          L.prepareCollections();
        var e = function () {
          var _;
          L.collections.forEach(function (R) {
            R.forEach(function (R) {
              (_ = R.el.getBoundingClientRect()),
                (R.position = {
                  x: L.scroll.x + _.left,
                  y: L.scroll.y + _.top,
                });
            });
          });
        };
        if (typeof window > "u") return L.collections;
        Vu(window, "resize", function () {
          Qb(e);
        });
        var n = function () {
          L.scroll = $b();
        };
        return (
          Vu(window, "scroll", function () {
            Qb(n);
          }),
          L.collections
        );
      }
      wm
        ? (wv = wy.pointer)
        : wg
          ? (wv = wy.MSPointer)
          : wf
            ? ((wv = wy.touch), (wx = wy.mouse))
            : (wv = wy.mouse),
        (fl.prototype.on = function (_, L) {
          var R,
            N = _.split(/[ ,]+/g);
          this._handlers_ = this._handlers_ || {};
          for (var z = 0; z < N.length; z += 1)
            (R = N[z]),
              (this._handlers_[R] = this._handlers_[R] || []),
              this._handlers_[R].push(L);
          return this;
        }),
        (fl.prototype.off = function (_, L) {
          return (
            (this._handlers_ = this._handlers_ || {}),
            void 0 === _
              ? (this._handlers_ = {})
              : void 0 === L
                ? (this._handlers_[_] = null)
                : this._handlers_[_] &&
                  this._handlers_[_].indexOf(L) >= 0 &&
                  this._handlers_[_].splice(this._handlers_[_].indexOf(L), 1),
            this
          );
        }),
        (fl.prototype.trigger = function (_, L) {
          var R,
            N = this,
            z = _.split(/[ ,]+/g);
          N._handlers_ = N._handlers_ || {};
          for (var F = 0; F < z.length; F += 1)
            (R = z[F]),
              N._handlers_[R] &&
                N._handlers_[R].length &&
                N._handlers_[R].forEach(function (_) {
                  _.call(N, { type: R, target: N }, L);
                });
        }),
        (fl.prototype.config = function (_) {
          (this.options = this.defaults || {}),
            _ && (this.options = pP(this.options, _));
        }),
        (fl.prototype.bindEvt = function (_, L) {
          var R = this;
          return (
            (R._domHandlers_ = R._domHandlers_ || {}),
            (R._domHandlers_[L] = function () {
              "function" == typeof R["on" + L]
                ? R["on" + L].apply(R, arguments)
                : console.warn('[WARNING] : Missing "on' + L + '" handler.');
            }),
            Vu(_, wv[L], R._domHandlers_[L]),
            wx[L] && Vu(_, wx[L], R._domHandlers_[L]),
            R
          );
        }),
        (fl.prototype.unbindEvt = function (_, L) {
          return (
            (this._domHandlers_ = this._domHandlers_ || {}),
            Jb(_, wv[L], this._domHandlers_[L]),
            wx[L] && Jb(_, wx[L], this._domHandlers_[L]),
            delete this._domHandlers_[L],
            this
          );
        }),
        (Ln.prototype = new fl()),
        (Ln.constructor = Ln),
        (Ln.id = 0),
        (Ln.prototype.buildEl = function (_) {
          return (
            (this.ui = {}),
            this.options.dataOnly ||
              ((this.ui.el = document.createElement("div")),
              (this.ui.back = document.createElement("div")),
              (this.ui.front = document.createElement("div")),
              (this.ui.el.className =
                "nipple collection_" + this.collection.id),
              (this.ui.back.className = "back"),
              (this.ui.front.className = "front"),
              this.ui.el.setAttribute(
                "id",
                "nipple_" + this.collection.id + "_" + this.id,
              ),
              this.ui.el.appendChild(this.ui.back),
              this.ui.el.appendChild(this.ui.front)),
            this
          );
        }),
        (Ln.prototype.stylize = function () {
          if (this.options.dataOnly) return this;
          var _ = this.options.fadeTime + "ms",
            L = hP("borderRadius", "50%"),
            R = ty("transition", "opacity", _),
            N = {};
          return (
            (N.el = {
              position: "absolute",
              opacity: this.options.restOpacity,
              display: "block",
              zIndex: 999,
            }),
            (N.back = {
              position: "absolute",
              display: "block",
              width: this.options.size + "px",
              height: this.options.size + "px",
              marginLeft: -this.options.size / 2 + "px",
              marginTop: -this.options.size / 2 + "px",
              background: "rgba(255, 255, 255, .4)",
              border: "solid 2px rgba(0, 0, 0, .1)",
            }),
            (N.front = {
              width: this.options.size / 2 + "px",
              height: this.options.size / 2 + "px",
              position: "absolute",
              display: "block",
              marginLeft: -this.options.size / 4 + "px",
              marginTop: -this.options.size / 4 + "px",
              background: "rgba(255, 255, 255, .8)",
              border: "solid 2px rgba(0, 0, 0, .1)",
            }),
            ny(N.el, R),
            "circle" === this.options.shape && ny(N.back, L),
            ny(N.front, L),
            this.applyStyles(N),
            this
          );
        }),
        (Ln.prototype.applyStyles = function (_) {
          for (var L in this.ui)
            if (this.ui.hasOwnProperty(L))
              for (var R in _[L]) this.ui[L].style[R] = _[L][R];
          return this;
        }),
        (Ln.prototype.addToDom = function () {
          return (
            this.options.dataOnly ||
              document.body.contains(this.ui.el) ||
              this.options.zone.appendChild(this.ui.el),
            this
          );
        }),
        (Ln.prototype.removeFromDom = function () {
          return (
            this.options.dataOnly ||
              !document.body.contains(this.ui.el) ||
              this.options.zone.removeChild(this.ui.el),
            this
          );
        }),
        (Ln.prototype.destroy = function () {
          clearTimeout(this.removeTimeout),
            clearTimeout(this.showTimeout),
            clearTimeout(this.restTimeout),
            this.trigger("destroyed", this.instance),
            this.removeFromDom(),
            this.off();
        }),
        (Ln.prototype.show = function (_) {
          var L = this;
          return (
            L.options.dataOnly ||
              (clearTimeout(L.removeTimeout),
              clearTimeout(L.showTimeout),
              clearTimeout(L.restTimeout),
              L.addToDom(),
              L.restCallback(),
              setTimeout(function () {
                L.ui.el.style.opacity = 1;
              }, 0),
              (L.showTimeout = setTimeout(function () {
                L.trigger("shown", L.instance),
                  "function" == typeof _ && _.call(this);
              }, L.options.fadeTime))),
            L
          );
        }),
        (Ln.prototype.hide = function (_) {
          var L = this;
          if (L.options.dataOnly) return L;
          if (
            ((L.ui.el.style.opacity = L.options.restOpacity),
            clearTimeout(L.removeTimeout),
            clearTimeout(L.showTimeout),
            clearTimeout(L.restTimeout),
            (L.removeTimeout = setTimeout(function () {
              var R = "dynamic" === L.options.mode ? "none" : "block";
              (L.ui.el.style.display = R),
                "function" == typeof _ && _.call(L),
                L.trigger("hidden", L.instance);
            }, L.options.fadeTime)),
            L.options.restJoystick)
          ) {
            let R = L.options.restJoystick,
              N = {};
            (N.x = !0 === R || !1 !== R.x ? 0 : L.instance.frontPosition.x),
              (N.y = !0 === R || !1 !== R.y ? 0 : L.instance.frontPosition.y),
              L.setPosition(_, N);
          }
          return L;
        }),
        (Ln.prototype.setPosition = function (_, L) {
          var R = this;
          R.frontPosition = { x: L.x, y: L.y };
          var N = R.options.fadeTime + "ms",
            z = {};
          z.front = ty("transition", ["top", "left"], N);
          var F = { front: {} };
          (F.front = {
            left: R.frontPosition.x + "px",
            top: R.frontPosition.y + "px",
          }),
            R.applyStyles(z),
            R.applyStyles(F),
            (R.restTimeout = setTimeout(function () {
              "function" == typeof _ && _.call(R), R.restCallback();
            }, R.options.fadeTime));
        }),
        (Ln.prototype.restCallback = function () {
          var _ = {};
          (_.front = ty("transition", "none", "")),
            this.applyStyles(_),
            this.trigger("rested", this.instance);
        }),
        (Ln.prototype.resetDirection = function () {
          this.direction = { x: !1, y: !1, angle: !1 };
        }),
        (Ln.prototype.computeDirection = function (_) {
          var L,
            R,
            N,
            z = _.angle.radian,
            F = Math.PI / 4,
            U = Math.PI / 2;
          if (
            (z > F && z < 3 * F && !_.lockX
              ? (L = "up")
              : z > -F && z <= F && !_.lockY
                ? (L = "left")
                : z > -(3 * F) && z <= -F && !_.lockX
                  ? (L = "down")
                  : _.lockY || (L = "right"),
            _.lockY || (R = z > -U && z < U ? "left" : "right"),
            _.lockX || (N = z > 0 ? "up" : "down"),
            _.force > this.options.threshold)
          ) {
            var k,
              Y = {};
            for (k in this.direction)
              this.direction.hasOwnProperty(k) && (Y[k] = this.direction[k]);
            var X = {};
            for (k in ((this.direction = { x: R, y: N, angle: L }),
            (_.direction = this.direction),
            Y))
              Y[k] === this.direction[k] && (X[k] = !0);
            if (X.x && X.y && X.angle) return _;
            (X.x && X.y) || this.trigger("plain", _),
              X.x || this.trigger("plain:" + R, _),
              X.y || this.trigger("plain:" + N, _),
              X.angle || this.trigger("dir dir:" + L, _);
          } else this.resetDirection();
          return _;
        }),
        (hn.prototype = new fl()),
        (hn.constructor = hn),
        (hn.id = 0),
        (hn.prototype.prepareNipples = function () {
          var _ = this.nipples;
          (_.on = this.on.bind(this)),
            (_.off = this.off.bind(this)),
            (_.options = this.options),
            (_.destroy = this.destroy.bind(this)),
            (_.ids = this.ids),
            (_.id = this.id),
            (_.processOnMove = this.processOnMove.bind(this)),
            (_.processOnEnd = this.processOnEnd.bind(this)),
            (_.get = function (L) {
              if (void 0 === L) return _[0];
              for (var R = 0, N = _.length; R < N; R += 1)
                if (_[R].identifier === L) return _[R];
              return !1;
            });
        }),
        (hn.prototype.bindings = function () {
          this.bindEvt(this.options.zone, "start"),
            (this.options.zone.style.touchAction = "none"),
            (this.options.zone.style.msTouchAction = "none");
        }),
        (hn.prototype.begin = function () {
          var _ = this.options;
          if ("static" === _.mode) {
            var L = this.createNipple(_.position, this.manager.getIdentifier());
            L.add(), this.idles.push(L);
          }
        }),
        (hn.prototype.createNipple = function (_, L) {
          var R = this.manager.scroll,
            N = {},
            z = this.options,
            F = {
              x: this.parentIsFlex ? R.x : R.x + this.box.left,
              y: this.parentIsFlex ? R.y : R.y + this.box.top,
            };
          if (_.x && _.y) N = { x: _.x - F.x, y: _.y - F.y };
          else if (_.top || _.right || _.bottom || _.left) {
            var U = document.createElement("DIV");
            (U.style.display = "hidden"),
              (U.style.top = _.top),
              (U.style.right = _.right),
              (U.style.bottom = _.bottom),
              (U.style.left = _.left),
              (U.style.position = "absolute"),
              z.zone.appendChild(U);
            var k = U.getBoundingClientRect();
            z.zone.removeChild(U),
              (N = _),
              (_ = { x: k.left + R.x, y: k.top + R.y });
          }
          var Y = new Ln(this, {
            color: z.color,
            size: z.size,
            threshold: z.threshold,
            fadeTime: z.fadeTime,
            dataOnly: z.dataOnly,
            restJoystick: z.restJoystick,
            restOpacity: z.restOpacity,
            mode: z.mode,
            identifier: L,
            position: _,
            zone: z.zone,
            frontPosition: { x: 0, y: 0 },
            shape: z.shape,
          });
          return (
            z.dataOnly || (ey(Y.ui.el, N), ey(Y.ui.front, Y.frontPosition)),
            this.nipples.push(Y),
            this.trigger("added " + Y.identifier + ":added", Y),
            this.manager.trigger("added " + Y.identifier + ":added", Y),
            this.bindNipple(Y),
            Y
          );
        }),
        (hn.prototype.updateBox = function () {
          this.box = this.options.zone.getBoundingClientRect();
        }),
        (hn.prototype.bindNipple = function (_) {
          var L,
            R = this,
            n = function (_, N) {
              (L = _.type + " " + N.id + ":" + _.type), R.trigger(L, N);
            };
          _.on("destroyed", R.onDestroyed.bind(R)),
            _.on("shown hidden rested dir plain", n),
            _.on("dir:up dir:right dir:down dir:left", n),
            _.on("plain:up plain:right plain:down plain:left", n);
        }),
        (hn.prototype.pressureFn = function (_, L, R) {
          var N = this,
            z = 0;
          clearInterval(N.pressureIntervals[R]),
            (N.pressureIntervals[R] = setInterval(
              function () {
                var R = _.force || _.pressure || _.webkitForce || 0;
                R !== z &&
                  (L.trigger("pressure", R),
                  N.trigger("pressure " + L.identifier + ":pressure", R),
                  (z = R));
              }.bind(N),
              100,
            ));
        }),
        (hn.prototype.onstart = function (_) {
          var L = this,
            R = L.options,
            N = _;
          return (
            (_ = $g(_)),
            L.updateBox(),
            hf(_, function (z) {
              L.actives.length < R.maxNumberOfNipples
                ? L.processOnStart(z)
                : N.type.match(/^touch/) &&
                  (Object.keys(L.manager.ids).forEach(function (R) {
                    if (
                      0 >
                      Object.values(N.touches).findIndex(function (_) {
                        return _.identifier === R;
                      })
                    ) {
                      var z = [_[0]];
                      (z.identifier = R), L.processOnEnd(z);
                    }
                  }),
                  L.actives.length < R.maxNumberOfNipples &&
                    L.processOnStart(z));
            }),
            L.manager.bindDocument(),
            !1
          );
        }),
        (hn.prototype.processOnStart = function (_) {
          var L,
            R = this,
            N = R.options,
            z = R.manager.getIdentifier(_),
            F = _.force || _.pressure || _.webkitForce || 0,
            U = { x: _.pageX, y: _.pageY },
            k = R.getOrCreate(z, U);
          k.identifier !== z && R.manager.removeIdentifier(k.identifier),
            (k.identifier = z);
          var l = function (L) {
            L.trigger("start", L),
              R.trigger("start " + L.id + ":start", L),
              L.show(),
              F > 0 && R.pressureFn(_, L, L.identifier),
              R.processOnMove(_);
          };
          if (
            ((L = R.idles.indexOf(k)) >= 0 && R.idles.splice(L, 1),
            R.actives.push(k),
            R.ids.push(k.identifier),
            "semi" !== N.mode)
          )
            l(k);
          else if (df(U, k.position) <= N.catchDistance) l(k);
          else {
            k.destroy(), R.processOnStart(_);
            return;
          }
          return k;
        }),
        (hn.prototype.getOrCreate = function (_, L) {
          var R,
            N = this.options;
          return /(semi|static)/.test(N.mode)
            ? (R = this.idles[0])
              ? (this.idles.splice(0, 1), R)
              : "semi" === N.mode
                ? this.createNipple(L, _)
                : (console.warn("Coudln't find the needed nipple."), !1)
            : (R = this.createNipple(L, _));
        }),
        (hn.prototype.processOnMove = function (_) {
          var L = this.options,
            R = this.manager.getIdentifier(_),
            N = this.nipples.get(R),
            z = this.manager.scroll;
          if (!dP(_)) {
            this.processOnEnd(_);
            return;
          }
          if (!N) {
            console.error("Found zombie joystick with ID " + R),
              this.manager.removeIdentifier(R);
            return;
          }
          if (L.dynamicPage) {
            var F = N.el.getBoundingClientRect();
            N.position = { x: z.x + F.left, y: z.y + F.top };
          }
          N.identifier = R;
          var U = N.options.size / 2,
            k = { x: _.pageX, y: _.pageY };
          L.lockX && (k.y = N.position.y), L.lockY && (k.x = N.position.x);
          var Y,
            X,
            Q = df(k, N.position),
            K = cP(k, N.position),
            J = Jg(K),
            $ = Q / U,
            ee = { distance: Q, position: k };
          if (
            ("circle" === N.options.shape
              ? ((Y = Math.min(Q, U)), (X = uP(N.position, Y, K)))
              : (Y = df((X = mP(k, N.position, U)), N.position)),
            L.follow)
          ) {
            if (Q > U) {
              let _ = k.x - X.x,
                L = k.y - X.y;
              (N.position.x += _),
                (N.position.y += L),
                (N.el.style.top = N.position.y - (this.box.top + z.y) + "px"),
                (N.el.style.left = N.position.x - (this.box.left + z.x) + "px"),
                (Q = df(k, N.position));
            }
          } else (k = X), (Q = Y);
          var er = k.x - N.position.x,
            en = k.y - N.position.y;
          (N.frontPosition = { x: er, y: en }),
            L.dataOnly || ey(N.ui.front, N.frontPosition);
          var ea = {
            identifier: N.identifier,
            position: k,
            force: $,
            pressure: _.force || _.pressure || _.webkitForce || 0,
            distance: Q,
            angle: { radian: J, degree: K },
            vector: { x: er / U, y: -en / U },
            raw: ee,
            instance: N,
            lockX: L.lockX,
            lockY: L.lockY,
          };
          ((ea = N.computeDirection(ea)).angle = {
            radian: Jg(180 - K),
            degree: 180 - K,
          }),
            N.trigger("move", ea),
            this.trigger("move " + N.id + ":move", ea);
        }),
        (hn.prototype.processOnEnd = function (_) {
          var L = this,
            R = L.options,
            N = L.manager.getIdentifier(_),
            z = L.nipples.get(N),
            F = L.manager.removeIdentifier(z.identifier);
          !z ||
            (R.dataOnly ||
              z.hide(function () {
                "dynamic" === R.mode &&
                  (z.trigger("removed", z),
                  L.trigger("removed " + z.id + ":removed", z),
                  L.manager.trigger("removed " + z.id + ":removed", z),
                  z.destroy());
              }),
            clearInterval(L.pressureIntervals[z.identifier]),
            z.resetDirection(),
            z.trigger("end", z),
            L.trigger("end " + z.id + ":end", z),
            L.ids.indexOf(z.identifier) >= 0 &&
              L.ids.splice(L.ids.indexOf(z.identifier), 1),
            L.actives.indexOf(z) >= 0 &&
              L.actives.splice(L.actives.indexOf(z), 1),
            /(semi|static)/.test(R.mode)
              ? L.idles.push(z)
              : L.nipples.indexOf(z) >= 0 &&
                L.nipples.splice(L.nipples.indexOf(z), 1),
            L.manager.unbindDocument(),
            /(semi|static)/.test(R.mode) &&
              (L.manager.ids[F.id] = F.identifier));
        }),
        (hn.prototype.onDestroyed = function (_, L) {
          this.nipples.indexOf(L) >= 0 &&
            this.nipples.splice(this.nipples.indexOf(L), 1),
            this.actives.indexOf(L) >= 0 &&
              this.actives.splice(this.actives.indexOf(L), 1),
            this.idles.indexOf(L) >= 0 &&
              this.idles.splice(this.idles.indexOf(L), 1),
            this.ids.indexOf(L.identifier) >= 0 &&
              this.ids.splice(this.ids.indexOf(L.identifier), 1),
            this.manager.removeIdentifier(L.identifier),
            this.manager.unbindDocument();
        }),
        (hn.prototype.destroy = function () {
          for (var _ in (this.unbindEvt(this.options.zone, "start"),
          this.nipples.forEach(function (_) {
            _.destroy();
          }),
          this.pressureIntervals))
            this.pressureIntervals.hasOwnProperty(_) &&
              clearInterval(this.pressureIntervals[_]);
          this.trigger("destroyed", this.nipples),
            this.manager.unbindDocument(),
            this.off();
        }),
        (Zn.prototype = new fl()),
        (Zn.constructor = Zn),
        (Zn.prototype.prepareCollections = function () {
          var _ = this;
          (_.collections.create = _.create.bind(_)),
            (_.collections.on = _.on.bind(_)),
            (_.collections.off = _.off.bind(_)),
            (_.collections.destroy = _.destroy.bind(_)),
            (_.collections.get = function (L) {
              var R;
              return (
                _.collections.every(function (_) {
                  return !(R = _.get(L));
                }),
                R
              );
            });
        }),
        (Zn.prototype.create = function (_) {
          return this.createCollection(_);
        }),
        (Zn.prototype.createCollection = function (_) {
          var L = new hn(this, _);
          return this.bindCollection(L), this.collections.push(L), L;
        }),
        (Zn.prototype.bindCollection = function (_) {
          var L,
            R = this,
            n = function (_, N) {
              (L = _.type + " " + N.id + ":" + _.type), R.trigger(L, N);
            };
          _.on("destroyed", R.onDestroyed.bind(R)),
            _.on("shown hidden rested dir plain", n),
            _.on("dir:up dir:right dir:down dir:left", n),
            _.on("plain:up plain:right plain:down plain:left", n);
        }),
        (Zn.prototype.bindDocument = function () {
          this.binded ||
            (this.bindEvt(document, "move").bindEvt(document, "end"),
            (this.binded = !0));
        }),
        (Zn.prototype.unbindDocument = function (_) {
          (Object.keys(this.ids).length && !0 !== _) ||
            (this.unbindEvt(document, "move").unbindEvt(document, "end"),
            (this.binded = !1));
        }),
        (Zn.prototype.getIdentifier = function (_) {
          var L;
          return (
            _
              ? void 0 ===
                  (L = void 0 === _.identifier ? _.pointerId : _.identifier) &&
                (L = this.latest || 0)
              : (L = this.index),
            void 0 === this.ids[L] &&
              ((this.ids[L] = this.index), (this.index += 1)),
            (this.latest = L),
            this.ids[L]
          );
        }),
        (Zn.prototype.removeIdentifier = function (_) {
          var L = {};
          for (var R in this.ids)
            if (this.ids[R] === _) {
              (L.id = R), (L.identifier = this.ids[R]), delete this.ids[R];
              break;
            }
          return L;
        }),
        (Zn.prototype.onmove = function (_) {
          return this.onAny("move", _), !1;
        }),
        (Zn.prototype.onend = function (_) {
          return this.onAny("end", _), !1;
        }),
        (Zn.prototype.oncancel = function (_) {
          return this.onAny("end", _), !1;
        }),
        (Zn.prototype.onAny = function (_, L) {
          var R,
            N = this,
            z = "processOn" + _.charAt(0).toUpperCase() + _.slice(1);
          L = $g(L);
          var s = function (_, L, R) {
            R.ids.indexOf(L) >= 0 && (R[z](_), (_._found_ = !0));
          };
          return (
            hf(L, function (_) {
              (R = N.getIdentifier(_)),
                hf(N.collections, s.bind(null, _, R)),
                _._found_ || N.removeIdentifier(R);
            }),
            !1
          );
        }),
        (Zn.prototype.destroy = function () {
          this.unbindDocument(!0),
            (this.ids = {}),
            (this.index = 0),
            this.collections.forEach(function (_) {
              _.destroy();
            }),
            this.off();
        }),
        (Zn.prototype.onDestroyed = function (_, L) {
          if (0 > this.collections.indexOf(L)) return !1;
          this.collections.splice(this.collections.indexOf(L), 1);
        });
      var wb = new Zn(),
        ww = {
          create: function (_) {
            return wb.create(_);
          },
          factory: wb,
        },
        w_ = dd(ii());
      function pl(_, L) {
        let R = new sP();
        if (!_.getAttribute("position"))
          return R.setAttribute("position", new sv([], 3)), R.setIndex([]), R;
        let { positions: N, triIndices: z } = Dh(
          _.getAttribute("position"),
          _.getIndex(),
        );
        return (
          R.setAttribute("position", new sv(N, 3)),
          R.setIndex(z),
          L && R.applyMatrix4(L),
          R
        );
      }
      var wS = new rw(),
        wA = new rw(),
        wM = [
          [0, 0, 0],
          [0, 0, 0],
          [0, 0, 0],
        ];
      function eS(_) {
        let L = _.elements;
        (wM[0][0] = L[0]),
          (wM[0][1] = L[4]),
          (wM[0][2] = L[8]),
          (wM[1][0] = L[1]),
          (wM[1][1] = L[5]),
          (wM[1][2] = L[9]),
          (wM[2][0] = L[2]),
          (wM[2][1] = L[6]),
          (wM[2][2] = L[10]);
        let { u: R, v: N } = (0, w_.SVD)(wM),
          z = wS.set(
            R[0][0],
            R[0][1],
            R[0][2],
            0,
            R[1][0],
            R[1][1],
            R[1][2],
            0,
            R[2][0],
            R[2][1],
            R[2][2],
            0,
            0,
            0,
            0,
            1,
          ),
          F = wA.set(
            N[0][0],
            N[0][1],
            N[0][2],
            0,
            N[1][0],
            N[1][1],
            N[1][2],
            0,
            N[2][0],
            N[2][1],
            N[2][2],
            0,
            0,
            0,
            0,
            1,
          );
        return z.multiply(F.transpose());
      }
      var wT = class extends oF {
          constructor() {
            super(), this.layers.enable(3), this.layers.enable(8);
          }
          setFromCamera(_, L) {
            L.isOrthographicCamera
              ? (this.ray.origin.set(_.x, _.y, -1).unproject(L),
                this.ray.direction
                  .set(0, 0, -1)
                  .transformDirection(L.matrixWorld),
                (this.camera = L))
              : L.isPerspectiveCamera
                ? (this.ray.origin.set(_.x, _.y, -1).unproject(L),
                  this.ray.direction
                    .set(_.x, _.y, 0.5)
                    .unproject(L)
                    .sub(this.ray.origin)
                    .normalize(),
                  (this.camera = L))
                : console.error("Raycaster: Unsupported camera type.");
          }
          intersectVisibleObjects(_, L = !0, R = []) {
            return (
              _.forEach((_) => {
                _.visible && this.intersectObject(_, L, R);
              }),
              R
            );
          }
          createRaycastLineHelper() {
            let _ = new n9({ color: 65280, linewidth: 10 }),
              L = new iq(
                this.ray.origin.x,
                this.ray.origin.y,
                this.ray.origin.z,
              ),
              R = new iq(
                this.ray.direction.x,
                this.ray.direction.y,
                this.ray.direction.z,
              ),
              N = this.camera.far - this.camera.near,
              z = new iq().addVectors(L, R.multiplyScalar(N)),
              F = new sP();
            return F.setFromPoints([L, z]), new aa(F, _);
          }
        },
        TP = (_) => _ instanceof bW || _ instanceof b5;
      function L5(_, L) {
        return _.distance - L.distance;
      }
      function mf(_, L, R) {
        if (!R.some((L) => void 0 !== ju(_, L))) return [];
        let N = [];
        return (
          L.children.forEach((L) =>
            (function EP(_, L, R) {
              if (!(!so(L) || !L.visible))
                for (let N of ($r(L) && L.raycast(_, R), L.children))
                  EP(_, N, R);
            })(_, L, N),
          ),
          N.sort(L5),
          N
        );
      }
      function gf(_) {
        let L = [];
        if (_.length) {
          let R = _[0].object;
          so(R) && L.push(R);
          let N = R.parent;
          for (; N; ) TP(N) && L.push(N), (N = N.parent);
        }
        return L;
      }
      function ju(_, L) {
        if ($r(L)) {
          if (L.visible) {
            let R = [];
            return L.raycast(_, R), R.length ? R[0] : void 0;
          }
        } else if (TP(L))
          return (function MP(_, L) {
            if (!(!so(L) || !L.visible)) {
              if ($r(L)) {
                let R = [];
                if ((L.raycast(_, R), R.length)) return R[0];
              }
              for (let R of L.children) {
                let L = MP(_, R);
                if (L) return L;
              }
            }
          })(_, L);
      }
      var wC = class {
          constructor(_, L, R, N, z, F) {
            (this.isExport = F),
              (this.raycaster = new wT()),
              (this.raycasterNeedsUpdate = !0),
              (this.stopRaycast = !1),
              (this._useWindowEvents = !1),
              (this.sharedAssets = new xq(ms.emptyData())),
              (this.scene = new wh({ ...mi.defaultData }, this.sharedAssets)),
              (this.camera = new bj()),
              (this.renderer = _),
              (this._useWindowEvents =
                "window" === L.data.publish.mouseEventTarget),
              (this.domElement = _.domElement),
              (this.eventElement = this._useWindowEvents
                ? window
                : _.domElement),
              (this.stopRaycast = z),
              (this.sharedAssets = N),
              (this.scene = L),
              (this.camera = R);
          }
          set useWindowEvents(_) {
            (this._useWindowEvents = _),
              (this.eventElement = _ ? window : this.renderer.domElement);
          }
          get useWindowEvents() {
            return this._useWindowEvents;
          }
          updateRaycaster(_) {
            if (!this.raycasterNeedsUpdate) return;
            this.raycasterNeedsUpdate = !1;
            let { pageX: L, pageY: R } =
                void 0 !== _.touches && _.touches.length > 0 ? _.touches[0] : _,
              N = this.domElement.getBoundingClientRect();
            this.raycaster.setFromCamera(
              {
                x: ((L - (N.left + window.scrollX)) / N.width) * 2 - 1,
                y: -(2 * ((R - (N.top + window.scrollY)) / N.height)) + 1,
              },
              this.camera,
            );
          }
        },
        wP =
          (((wK = wP || {})[(wK.keydown = 0)] = "keydown"),
          (wK[(wK.keyup = 1)] = "keyup"),
          (wK[(wK.pointerdown = 2)] = "pointerdown"),
          (wK[(wK.pointerup = 3)] = "pointerup"),
          (wK[(wK.pointermove = 4)] = "pointermove"),
          (wK[(wK.wheel = 5)] = "wheel"),
          (wK[(wK.scroll = 6)] = "scroll"),
          wK),
        wD = class {
          constructor(_) {
            (this.eventContext = _),
              (this.domEventsNeeded = new Set()),
              (this.hasVideoAction = !1);
          }
          connect() {}
          disconnect() {}
        },
        wO = new Map(),
        wL = new Map(),
        wR = class {
          constructor(_, L, R, N) {
            this.data = L;
            let { audio: z, volume: F, delay: U, loop: k } = L;
            if (!z) throw Error("Missing property");
            let Y = "string" == typeof z ? N.getAudio(z).src : z.data;
            (this.audioPlayer = new xF({
              src: Y,
              volume: F,
              delay: U,
              loop: k,
            })),
              wL.has(R.uuid)
                ? wL.get(R.uuid).push(this)
                : wL.set(R.uuid, [this]),
              wO.set(_, this);
          }
          playByToggle() {
            "stop" === this.data.toggle
              ? "playing" === this.audioPlayer.status
                ? this.audioPlayer.stop()
                : (this.audioPlayer.stop(), this.audioPlayer.play())
              : "pause" === this.data.toggle
                ? "playing" === this.audioPlayer.status
                  ? this.audioPlayer.pause()
                  : this.audioPlayer.play()
                : (this.audioPlayer.stop(), this.audioPlayer.play());
          }
          dispose() {
            this.audioPlayer.stop();
          }
        },
        wI = class {
          constructor(_) {
            this.data = _;
          }
          dispatch() {
            this.data.playAudio
              ? this.pauseAudio(this.data.playAudio)
              : this.data.object
                ? this.pauseAllAudiosFromObject(this.data.object)
                : this.pauseAllAudios();
          }
          pauseAudio(_) {
            let L = wO.get(_);
            L &&
              (this.data.delay > 0
                ? (this.disposeDelay(),
                  (this.timeoutId = window.setTimeout(() => {
                    L.audioPlayer[this.data.interaction](), this.disposeDelay();
                  }, this.data.delay)))
                : L.audioPlayer[this.data.interaction]());
          }
          pauseAllAudiosFromObject(_) {
            let L = wL.get(_);
            L?.length &&
              (this.data.delay > 0
                ? (this.disposeDelay(),
                  (this.timeoutId = window.setTimeout(() => {
                    L.forEach((_) => _.audioPlayer[this.data.interaction]()),
                      this.disposeDelay();
                  }, this.data.delay)))
                : L.forEach((_) => _.audioPlayer[this.data.interaction]()));
          }
          pauseAllAudios() {
            let _ = [...wL.values()];
            _.length &&
              (this.data.delay > 0
                ? (this.disposeDelay(),
                  (this.timeoutId = window.setTimeout(() => {
                    _.forEach((_) => {
                      _.forEach((_) => {
                        _.audioPlayer[this.data.interaction]();
                      });
                    }),
                      this.disposeDelay();
                  }, this.data.delay)))
                : _.forEach((_) => {
                    _.forEach((_) => {
                      _.audioPlayer[this.data.interaction]();
                    });
                  }));
          }
          disposeDelay() {
            clearTimeout(this.timeoutId), delete this.timeoutId;
          }
          dispose() {
            clearTimeout(this.timeoutId), delete this.timeoutId;
          }
        },
        wB = class {
          constructor(_, L, R, N) {
            if (((this.data = L), "play" === L.interaction))
              this.interaction = new wR(_, L, R, N);
            else if ("pause" === L.interaction || "stop" === L.interaction)
              this.interaction = new wI(L);
            else throw Error("Missing property");
          }
          dispatchBasic() {
            this.interaction instanceof wR
              ? this.interaction.playByToggle()
              : this.interaction.dispatch();
          }
          dispatchConditional() {
            this.interaction instanceof wR
              ? this.interaction.audioPlayer.play()
              : this.interaction.dispatch();
          }
          dispatchGameControl(_) {
            this.interaction instanceof wR &&
              ("start" === _
                ? this.interaction.audioPlayer.play()
                : this.interaction.audioPlayer.stop());
          }
          dispose() {
            this.interaction.dispose();
          }
        },
        wN = new Map(),
        wz = new Map(),
        wF = class {
          constructor(_, L, R) {
            let N;
            (this.data = L), (this.delay = 0), (this.status = "stopped");
            let { layerId: z, loop: F, volume: U, delay: k } = L;
            if (((this.object = R), void 0 === z))
              throw Error("Missing property");
            let Y =
              (N = R.material.layers.find((_) => _.uuid === z)).color.texture
                .image.img instanceof HTMLVideoElement
                ? N.color.texture.image.img
                : void 0;
            if (Y)
              (this.videoElement = Y),
                (this.videoElement.loop = F === 1 / 0),
                (this.videoElement.autoplay = !0),
                void 0 !== U && (this.videoElement.volume = U);
            else throw Error("Missing property");
            void 0 !== k && (this.delay = k),
              wz.has(R.uuid)
                ? wz.get(R.uuid).push(this)
                : wz.set(R.uuid, [this]),
              wN.set(_, this),
              this.pause();
          }
          mute() {
            this.videoElement.muted = !0;
          }
          unMute() {
            this.videoElement.muted = !1;
          }
          play(_) {
            let L =
              /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
                navigator.userAgent,
              );
            _
              ? (this.mute(), (this.delay += 150))
              : L
                ? (this.mute(),
                  window.setTimeout(() => {
                    this.unMute();
                  }, 100))
                : this.unMute(),
              (this.delayTimerId = window.setTimeout(() => {
                this.videoElement.play(), this.clearDelay();
              }, this.delay)),
              (this.status = "playing");
          }
          clearDelay() {
            this.delayTimerId &&
              (clearTimeout(this.delayTimerId), delete this.delayTimerId);
          }
          pause() {
            this.videoElement.pause(), (this.status = "paused");
          }
          stop() {
            this.videoElement.pause(),
              (this.videoElement.currentTime = 0),
              (this.status = "stopped"),
              this.clearDelay();
          }
          playByToggle() {
            "stop" === this.data.toggle
              ? "playing" === this.status
                ? this.stop()
                : (this.stop(), this.play())
              : "pause" === this.data.toggle
                ? "playing" === this.status
                  ? this.pause()
                  : this.play()
                : (this.stop(), this.play());
          }
          dispose() {
            this.stop(), (this.videoElement.muted = !0);
          }
        },
        wU = class {
          constructor(_) {
            this.data = _;
          }
          dispatch() {
            this.data.playVideo
              ? this.pauseVideo(this.data.playVideo)
              : this.data.object
                ? this.pauseAllVideosFromObject(this.data.object)
                : this.pauseAllVideos();
          }
          pauseVideo(_) {
            let L = wN.get(_);
            L &&
              (this.data.delay > 0
                ? (this.disposeDelay(),
                  (this.timeoutId = window.setTimeout(() => {
                    L[this.data.interaction](), this.disposeDelay();
                  }, this.data.delay)))
                : L[this.data.interaction]());
          }
          pauseAllVideosFromObject(_) {
            let L = wz.get(_);
            L?.length &&
              (this.data.delay > 0
                ? (this.disposeDelay(),
                  (this.timeoutId = window.setTimeout(() => {
                    L.forEach((_) => _[this.data.interaction]()),
                      this.disposeDelay();
                  }, this.data.delay)))
                : L.forEach((_) => _[this.data.interaction]()));
          }
          pauseAllVideos() {
            let _ = [...wz.values()];
            _.length &&
              (this.data.delay > 0
                ? (this.disposeDelay(),
                  (this.timeoutId = window.setTimeout(() => {
                    _.forEach((_) => {
                      _.forEach((_) => {
                        _[this.data.interaction]();
                      });
                    }),
                      this.disposeDelay();
                  }, this.data.delay)))
                : _.forEach((_) => {
                    _.forEach((_) => {
                      _[this.data.interaction]();
                    });
                  }));
          }
          disposeDelay() {
            clearTimeout(this.timeoutId), delete this.timeoutId;
          }
          dispose() {
            clearTimeout(this.timeoutId), delete this.timeoutId;
          }
        },
        wk = class {
          constructor(_, L, R) {
            if (((this.data = L), "play" === L.interaction))
              this.interaction = new wF(_, L, R);
            else if ("pause" === L.interaction || "stop" === L.interaction)
              this.interaction = new wU(L);
            else throw Error("Missing property");
          }
          dispatchBasic() {
            this.interaction instanceof wF
              ? this.interaction.playByToggle()
              : this.interaction.dispatch();
          }
          dispatchConditional() {
            this.interaction instanceof wF
              ? this.interaction.play()
              : this.interaction.dispatch();
          }
          dispose() {
            this.interaction.dispose();
          }
        },
        DP = (_, L) =>
          L.some((L) => (L instanceof RegExp ? L.test(_) : L === _)),
        F5 = (_, { stripHash: L }) => {
          let R =
            /^data:(?<type>[^,]*?),(?<data>[^#]*?)(?:#(?<hash>.*))?$/.exec(_);
          if (!R) throw Error(`Invalid URL: ${_}`);
          let { type: N, data: z, hash: F } = R.groups,
            U = N.split(";");
          F = L ? "" : F;
          let k = !1;
          "base64" === U[U.length - 1] && (U.pop(), (k = !0));
          let Y = (U.shift() || "").toLowerCase(),
            X = [
              ...U.map((_) => {
                let [L, R = ""] = _.split("=").map((_) => _.trim());
                return "charset" === L && "us-ascii" === (R = R.toLowerCase())
                  ? ""
                  : `${L}${R ? `=${R}` : ""}`;
              }).filter(Boolean),
            ];
          return (
            k && X.push("base64"),
            (X.length > 0 || (Y && "text/plain" !== Y)) && X.unshift(Y),
            `data:${X.join(";")},${k ? z.trim() : z}${F ? `#${F}` : ""}`
          );
        },
        wj = class {
          constructor({ url: _, context: L }, R) {
            if (((this.managers = R), !_)) throw Error("Missing property");
            (this.url = _.startsWith("mailto:")
              ? _
              : (function (_, L) {
                  if (
                    ((L = {
                      defaultProtocol: "http:",
                      normalizeProtocol: !0,
                      forceHttp: !1,
                      forceHttps: !1,
                      stripAuthentication: !0,
                      stripHash: !1,
                      stripTextFragment: !0,
                      stripWWW: !0,
                      removeQueryParameters: [/^utm_\w+/i],
                      removeTrailingSlash: !0,
                      removeSingleSlash: !0,
                      removeDirectoryIndex: !1,
                      sortQueryParameters: !0,
                      ...L,
                    }),
                    (_ = _.trim()),
                    /^data:/i.test(_))
                  )
                    return F5(_, L);
                  if (/^view-source:/i.test(_))
                    throw Error(
                      "`view-source:` is not supported as it is a non-standard protocol",
                    );
                  let R = _.startsWith("//");
                  (!R && /^\.*\//.test(_)) ||
                    (_ = _.replace(
                      /^(?!(?:\w+:)?\/\/)|^\/\//,
                      L.defaultProtocol,
                    ));
                  let N = new URL(_);
                  if (L.forceHttp && L.forceHttps)
                    throw Error(
                      "The `forceHttp` and `forceHttps` options cannot be used together",
                    );
                  if (
                    (L.forceHttp &&
                      "https:" === N.protocol &&
                      (N.protocol = "http:"),
                    L.forceHttps &&
                      "http:" === N.protocol &&
                      (N.protocol = "https:"),
                    L.stripAuthentication &&
                      ((N.username = ""), (N.password = "")),
                    L.stripHash
                      ? (N.hash = "")
                      : L.stripTextFragment &&
                        (N.hash = N.hash.replace(/#?:~:text.*?$/i, "")),
                    N.pathname)
                  ) {
                    let _ = /\b[a-z][a-z\d+\-.]{1,50}:\/\//g,
                      L = 0,
                      R = "";
                    for (;;) {
                      let z = _.exec(N.pathname);
                      if (!z) break;
                      let F = z[0],
                        U = z.index;
                      (R += N.pathname.slice(L, U).replace(/\/{2,}/g, "/") + F),
                        (L = U + F.length);
                    }
                    (R += N.pathname
                      .slice(L, N.pathname.length)
                      .replace(/\/{2,}/g, "/")),
                      (N.pathname = R);
                  }
                  if (N.pathname)
                    try {
                      N.pathname = decodeURI(N.pathname);
                    } catch {}
                  if (
                    (!0 === L.removeDirectoryIndex &&
                      (L.removeDirectoryIndex = [/^index\.[a-z]+$/]),
                    Array.isArray(L.removeDirectoryIndex) &&
                      L.removeDirectoryIndex.length > 0)
                  ) {
                    let _ = N.pathname.split("/");
                    DP(_[_.length - 1], L.removeDirectoryIndex) &&
                      ((_ = _.slice(0, -1)),
                      (N.pathname = _.slice(1).join("/") + "/"));
                  }
                  if (
                    (N.hostname &&
                      ((N.hostname = N.hostname.replace(/\.$/, "")),
                      L.stripWWW &&
                        /^www\.(?!www\.)[a-z\-\d]{1,63}\.[a-z.\-\d]{2,63}$/.test(
                          N.hostname,
                        ) &&
                        (N.hostname = N.hostname.replace(/^www\./, ""))),
                    Array.isArray(L.removeQueryParameters))
                  )
                    for (let _ of [...N.searchParams.keys()])
                      DP(_, L.removeQueryParameters) &&
                        N.searchParams.delete(_);
                  if (
                    (!0 === L.removeQueryParameters && (N.search = ""),
                    L.sortQueryParameters)
                  ) {
                    N.searchParams.sort();
                    try {
                      N.search = decodeURIComponent(N.search);
                    } catch {}
                  }
                  L.removeTrailingSlash &&
                    (N.pathname = N.pathname.replace(/\/$/, ""));
                  let z = _;
                  return (
                    (_ = N.toString()),
                    L.removeSingleSlash ||
                      "/" !== N.pathname ||
                      z.endsWith("/") ||
                      "" !== N.hash ||
                      (_ = _.replace(/\/$/, "")),
                    (L.removeTrailingSlash || "/" === N.pathname) &&
                      "" === N.hash &&
                      L.removeSingleSlash &&
                      (_ = _.replace(/\/$/, "")),
                    R &&
                      !L.normalizeProtocol &&
                      (_ = _.replace(/^http:\/\//, "//")),
                    L.stripProtocol && (_ = _.replace(/^(?:https?:)?\/\//, "")),
                    _
                  );
                })(_, { removeTrailingSlash: !1, removeSingleSlash: !1 })),
              (this.context = L ?? "tab");
          }
          dispatch() {
            pZ
              ? window.location.assign(this.url)
              : ("tab" === this.context
                  ? window.open(this.url, "_blank")
                  : "window" === this.context
                    ? window.open(
                        this.url,
                        "_blank",
                        `width=${window.innerWidth}, height=${window.innerHeight}`,
                      )
                    : window.open(this.url, "_parent"),
                this.managers.controlsManager.orbitControls?.onPointerUp(p1[0]),
                p1.splice(0, p1.length));
          }
        },
        wG = class {
          constructor(_, L, R, N) {
            (this.scene = L),
              (this.sharedAssets = R),
              (this.sceneData = _),
              (this.managers = N);
          }
          dispatch() {
            ly(this.sceneData, this.scene, this.sharedAssets, !0),
              this.managers.eventManager?.reset(),
              this.managers.controlsManager.orbitControls?.reset(),
              this.managers.controlsManager?.gameControls.forEach((_) =>
                _.reset(!0),
              );
          }
        },
        wV = {
          update: null,
          begin: null,
          loopBegin: null,
          changeBegin: null,
          change: null,
          changeComplete: null,
          timelineChangeComplete: null,
          loopComplete: null,
          complete: null,
          loop: 1,
          direction: "normal",
          autoplay: !0,
          timelineOffset: 0,
          rewind: !0,
        },
        wH = {
          duration: 1e3,
          delay: 0,
          endDelay: 0,
          startOnceDelay: 0,
          pingPongDelayCorrection: 0,
          easing: "easeOutElastic(1, .5)",
          round: 0,
        },
        wW = [
          "translateX",
          "translateY",
          "translateZ",
          "rotate",
          "rotateX",
          "rotateY",
          "rotateZ",
          "scale",
          "scaleX",
          "scaleY",
          "scaleZ",
          "skew",
          "skewX",
          "skewY",
          "perspective",
          "matrix",
          "matrix3d",
        ],
        wY = { CSS: {}, springs: {} };
      function As(_, L, R) {
        return Math.min(Math.max(_, L), R);
      }
      function xf(_, L) {
        return _.indexOf(L) > -1;
      }
      function rS(_, L) {
        return _.apply(null, L);
      }
      var wX = {
        arr: function (_) {
          return Array.isArray(_);
        },
        obj: function (_) {
          return xf(Object.prototype.toString.call(_), "Object");
        },
        pth: function (_) {
          return wX.obj(_) && _.hasOwnProperty("totalLength");
        },
        svg: function (_) {
          return _ instanceof SVGElement;
        },
        inp: function (_) {
          return _ instanceof HTMLInputElement;
        },
        dom: function (_) {
          return !("isNode" in _) && (_.nodeType || wX.svg(_));
        },
        str: function (_) {
          return "string" == typeof _;
        },
        fnc: function (_) {
          return "function" == typeof _;
        },
        und: function (_) {
          return typeof _ > "u";
        },
        hex: function (_) {
          return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(_);
        },
        rgb: function (_) {
          return /^rgb/.test(_);
        },
        hsl: function (_) {
          return /^hsl/.test(_);
        },
        col: function (_) {
          return wX.hex(_) || wX.rgb(_) || wX.hsl(_);
        },
        key: function (_) {
          return (
            !wV.hasOwnProperty(_) &&
            !wH.hasOwnProperty(_) &&
            "targets" !== _ &&
            "keyframes" !== _
          );
        },
      };
      function UP(_) {
        var L = /\(([^)]+)\)/.exec(_);
        return L
          ? L[1].split(",").map(function (_) {
              return parseFloat(_);
            })
          : [];
      }
      function GP(_, L) {
        var R = UP(_),
          N = As(wX.und(R[0]) ? 1 : R[0], 0.1, 100),
          z = As(wX.und(R[1]) ? 100 : R[1], 0.1, 100),
          F = As(wX.und(R[2]) ? 10 : R[2], 0.1, 100),
          U = As(wX.und(R[3]) ? 0 : R[3], 0.1, 100),
          k = Math.sqrt(z / N),
          Y = F / (2 * Math.sqrt(z * N)),
          X = Y < 1 ? k * Math.sqrt(1 - Y * Y) : 0,
          Q = Y < 1 ? (Y * k + -U) / X : -U + k;
        function h(_) {
          var R = L ? (L * _) / 1e3 : _;
          return (
            (R =
              Y < 1
                ? Math.exp(-R * Y * k) *
                  (1 * Math.cos(X * R) + Q * Math.sin(X * R))
                : (1 + Q * R) * Math.exp(-R * k)),
            0 === _ || 1 === _ ? _ : 1 - R
          );
        }
        return L
          ? h
          : function () {
              var L = wY.springs[_];
              if (L) return L;
              for (var R = 1 / 6, N = 0, z = 0; ; )
                if (1 === h((N += R))) {
                  if (++z >= 16) break;
                } else z = 0;
              var F = N * R * 1e3;
              return (wY.springs[_] = F), F;
            };
      }
      function G5(_) {
        return (
          void 0 === _ && (_ = 10),
          function (L) {
            return Math.ceil(As(L, 1e-6, 1) * _) * (1 / _);
          }
        );
      }
      var wq = (function () {
          function s(_, L, R) {
            return (
              (((1 - 3 * R + 3 * L) * _ + (3 * R - 6 * L)) * _ + 3 * L) * _
            );
          }
          function o(_, L, R) {
            return (
              3 * (1 - 3 * R + 3 * L) * _ * _ + 2 * (3 * R - 6 * L) * _ + 3 * L
            );
          }
          return function (_, L, R, N) {
            if (0 <= _ && _ <= 1 && 0 <= R && R <= 1) {
              var z = new Float32Array(11);
              if (_ !== L || R !== N)
                for (var F = 0; F < 11; ++F) z[F] = s(0.1 * F, _, R);
              return function (F) {
                return (_ === L && R === N) || 0 === F || 1 === F
                  ? F
                  : s(
                      (function (L) {
                        for (var N = 0, F = 1; 10 !== F && z[F] <= L; ++F)
                          N += 0.1;
                        var U = N + ((L - z[--F]) / (z[F + 1] - z[F])) * 0.1,
                          k = o(U, _, R);
                        return k >= 0.001
                          ? (function (_, L, R, N) {
                              for (var z = 0; z < 4; ++z) {
                                var F = o(L, R, N);
                                if (0 === F) break;
                                var U = s(L, R, N) - _;
                                L -= U / F;
                              }
                              return L;
                            })(L, U, _, R)
                          : 0 === k
                            ? U
                            : (function (_, L, R, N, z) {
                                var F,
                                  U,
                                  k = 0;
                                do
                                  (F = s((U = L + (R - L) / 2), N, z) - _) > 0
                                    ? (R = U)
                                    : (L = U);
                                while (Math.abs(F) > 1e-7 && ++k < 10);
                                return U;
                              })(L, N, N + 0.1, _, R);
                      })(F),
                      L,
                      N,
                    );
              };
            }
          };
        })(),
        wQ =
          ((wJ = {
            linear: function () {
              return function (_) {
                return _;
              };
            },
          }),
          (w$ = {
            Sine: function () {
              return function (_) {
                return 1 - Math.cos((_ * Math.PI) / 2);
              };
            },
            Circ: function () {
              return function (_) {
                return 1 - Math.sqrt(1 - _ * _);
              };
            },
            Back: function () {
              return function (_) {
                return _ * _ * (3 * _ - 2);
              };
            },
            Bounce: function () {
              return function (_) {
                for (var L, R = 4; _ < ((L = Math.pow(2, --R)) - 1) / 11; );
                return (
                  1 / Math.pow(4, 3 - R) -
                  7.5625 * Math.pow((3 * L - 2) / 22 - _, 2)
                );
              };
            },
            Elastic: function (_, L) {
              void 0 === _ && (_ = 1), void 0 === L && (L = 0.5);
              var R = As(_, 1, 10),
                N = As(L, 0.1, 2);
              return function (_) {
                return 0 === _ || 1 === _
                  ? _
                  : -R *
                      Math.pow(2, 10 * (_ - 1)) *
                      Math.sin(
                        ((_ - 1 - (N / (2 * Math.PI)) * Math.asin(1 / R)) *
                          (2 * Math.PI)) /
                          N,
                      );
              };
            },
          }),
          ["Quad", "Cubic", "Quart", "Quint", "Expo"].forEach(function (_, L) {
            w$[_] = function () {
              return function (_) {
                return Math.pow(_, L + 2);
              };
            };
          }),
          Object.keys(w$).forEach(function (_) {
            var L = w$[_];
            (wJ["easeIn" + _] = L),
              (wJ["easeOut" + _] = function (_, R) {
                return function (N) {
                  return 1 - L(_, R)(1 - N);
                };
              }),
              (wJ["easeInOut" + _] = function (_, R) {
                return function (N) {
                  return N < 0.5
                    ? L(_, R)(2 * N) / 2
                    : 1 - L(_, R)(-2 * N + 2) / 2;
                };
              });
          }),
          wJ);
      function aS(_, L) {
        if (wX.fnc(_)) return _;
        var R = _.split("(")[0],
          N = wQ[R],
          z = UP(_);
        switch (R) {
          case "spring":
            return GP(_, L);
          case "cubicBezier":
            return rS(wq, z);
          case "steps":
            return rS(G5, z);
          default:
            return rS(N, z);
        }
      }
      function zP(_) {
        try {
          return document.querySelectorAll(_);
        } catch {
          return;
        }
      }
      function dy(_, L) {
        for (
          var R = _.length,
            N = arguments.length >= 2 ? arguments[1] : void 0,
            z = [],
            F = 0;
          F < R;
          F++
        )
          if (F in _) {
            var U = _[F];
            L.call(N, U, F, _) && z.push(U);
          }
        return z;
      }
      function hy(_) {
        return _.reduce(function (_, L) {
          return _.concat(wX.arr(L) ? hy(L) : L);
        }, []);
      }
      function OP(_) {
        return wX.arr(_)
          ? _
          : (wX.str(_) && (_ = zP(_) || _),
            _ instanceof NodeList || _ instanceof HTMLCollection
              ? [].slice.call(_)
              : [_]);
      }
      function lS(_, L) {
        return _.some(function (_) {
          return _ === L;
        });
      }
      function cS(_) {
        var L = {};
        for (var R in _) L[R] = _[R];
        return L;
      }
      function iS(_, L) {
        var R = cS(_);
        for (var N in _) R[N] = L.hasOwnProperty(N) ? L[N] : _[N];
        return R;
      }
      function fy(_, L) {
        var R = cS(_);
        for (var N in L) R[N] = wX.und(_[N]) ? L[N] : _[N];
        return R;
      }
      function fo(_) {
        var L =
          /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?(%|px|pt|em|rem|in|cm|mm|ex|ch|pc|vw|vh|vmin|vmax|deg|rad|turn)?$/.exec(
            _,
          );
        if (L) return L[1];
      }
      function sS(_, L) {
        return wX.fnc(_) ? _(L.target, L.id, L.total) : _;
      }
      function _s(_, L) {
        return _.getAttribute(L);
      }
      function uS(_, L, R) {
        if (lS([R, "deg", "rad", "turn"], fo(L))) return L;
        var N = wY.CSS[L + R];
        if (!wX.und(N)) return N;
        var z = document.createElement(_.tagName),
          F =
            _.parentNode && _.parentNode !== document
              ? _.parentNode
              : document.body;
        F.appendChild(z),
          (z.style.position = "absolute"),
          (z.style.width = 100 + R);
        var U = 100 / z.offsetWidth;
        F.removeChild(z);
        var k = U * parseFloat(L);
        return (wY.CSS[L + R] = k), k;
      }
      function VP(_, L, R) {
        if (L in _.style) {
          var N = L.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(),
            z = _.style[L] || getComputedStyle(_).getPropertyValue(N) || "0";
          return R ? uS(_, z, R) : z;
        }
      }
      function dS(_, L) {
        return wX.dom(_) && !wX.inp(_) && (_s(_, L) || (wX.svg(_) && _[L]))
          ? "attribute"
          : wX.dom(_) && lS(wW, L)
            ? "transform"
            : wX.dom(_) && "transform" !== L && VP(_, L)
              ? "css"
              : null != _[L]
                ? "object"
                : void 0;
      }
      function HP(_) {
        if (wX.dom(_)) {
          for (
            var L,
              R = _.style.transform || "",
              N = /(\w+)\(([^)]*)\)/g,
              z = new Map();
            (L = N.exec(R));

          )
            z.set(L[1], L[2]);
          return z;
        }
      }
      function hS(_, L, R, N) {
        switch (dS(_, L)) {
          case "transform":
            var z, F;
            return (
              (z = xf(L, "scale")
                ? 1
                : 0 +
                  (xf(L, "translate") || "perspective" === L
                    ? "px"
                    : xf(L, "rotate") || xf(L, "skew")
                      ? "deg"
                      : void 0)),
              (F = HP(_).get(L) || z),
              N && (N.transforms.list.set(L, F), (N.transforms.last = L)),
              R ? uS(_, F, R) : F
            );
          case "css":
            return VP(_, L, R);
          case "attribute":
            return _s(_, L);
          default:
            return _[L] || 0;
        }
      }
      function fS(_, L) {
        var R = /^(\*=|\+=|-=)/.exec(_);
        if (!R) return _;
        var N = fo(_) || 0,
          z = parseFloat(L),
          F = parseFloat(_.replace(R[0], ""));
        switch (R[0][0]) {
          case "+":
            return z + F + N;
          case "-":
            return z - F + N;
          case "*":
            return z * F + N;
        }
      }
      function WP(_, L) {
        if (wX.col(_)) {
          var R, N, z, F;
          return (
            (R = _),
            wX.rgb(R)
              ? (N = /rgb\((\d+,\s*[\d]+,\s*[\d]+)\)/g.exec(R))
                ? "rgba(" + N[1] + ",1)"
                : R
              : wX.hex(R)
                ? ((z = R.replace(
                    /^#?([a-f\d])([a-f\d])([a-f\d])$/i,
                    function (_, L, R, N) {
                      return L + L + R + R + N + N;
                    },
                  )),
                  "rgba(" +
                    parseInt(
                      (F = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(
                        z,
                      ))[1],
                      16,
                    ) +
                    "," +
                    parseInt(F[2], 16) +
                    "," +
                    parseInt(F[3], 16) +
                    ",1)")
                : wX.hsl(R)
                  ? (function (_) {
                      var L,
                        R,
                        N,
                        z =
                          /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(_) ||
                          /hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*([\d.]+)\)/g.exec(
                            _,
                          ),
                        F = parseInt(z[1], 10) / 360,
                        U = parseInt(z[2], 10) / 100,
                        k = parseInt(z[3], 10) / 100,
                        Y = z[4] || 1;
                      function o(_, L, R) {
                        return (
                          R < 0 && (R += 1),
                          R > 1 && (R -= 1),
                          R < 1 / 6
                            ? _ + (L - _) * 6 * R
                            : R < 0.5
                              ? L
                              : R < 2 / 3
                                ? _ + (L - _) * (2 / 3 - R) * 6
                                : _
                        );
                      }
                      if (0 == U) L = R = N = k;
                      else {
                        var X = k < 0.5 ? k * (1 + U) : k + U - k * U,
                          Q = 2 * k - X;
                        (L = o(Q, X, F + 1 / 3)),
                          (R = o(Q, X, F)),
                          (N = o(Q, X, F - 1 / 3));
                      }
                      return (
                        "rgba(" +
                        255 * L +
                        "," +
                        255 * R +
                        "," +
                        255 * N +
                        "," +
                        Y +
                        ")"
                      );
                    })(R)
                  : void 0
          );
        }
        if (/\s/g.test(_)) return _;
        var U = fo(_),
          k = U ? _.substr(0, _.length - U.length) : _;
        return L ? k + L : k;
      }
      function pS(_, L) {
        return Math.sqrt(Math.pow(L.x - _.x, 2) + Math.pow(L.y - _.y, 2));
      }
      function jP(_) {
        for (var L, R = _.points, N = 0, z = 0; z < R.numberOfItems; z++) {
          var F = R.getItem(z);
          z > 0 && (N += pS(L, F)), (L = F);
        }
        return N;
      }
      function qP(_) {
        var L;
        if (_.getTotalLength) return _.getTotalLength();
        switch (_.tagName.toLowerCase()) {
          case "circle":
            return 2 * Math.PI * _s(_, "r");
          case "rect":
            return 2 * _s(_, "width") + 2 * _s(_, "height");
          case "line":
            return pS(
              { x: _s(_, "x1"), y: _s(_, "y1") },
              { x: _s(_, "x2"), y: _s(_, "y2") },
            );
          case "polyline":
            return jP(_);
          case "polygon":
            return (
              (L = _.points),
              jP(_) + pS(L.getItem(L.numberOfItems - 1), L.getItem(0))
            );
        }
      }
      function XP(_, L) {
        var R = L || {},
          N =
            R.el ||
            (function (_) {
              for (var L = _.parentNode; wX.svg(L) && wX.svg(L.parentNode); )
                L = L.parentNode;
              return L;
            })(_),
          z = N.getBoundingClientRect(),
          F = _s(N, "viewBox"),
          U = z.width,
          k = z.height,
          Y = R.viewBox || (F ? F.split(" ") : [0, 0, U, k]);
        return {
          el: N,
          viewBox: Y,
          x: Y[0] / 1,
          y: Y[1] / 1,
          w: U / Y[2],
          h: k / Y[3],
        };
      }
      function LP(_, L) {
        var R = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?/g,
          N = WP(wX.pth(_) ? _.totalLength : _, L) + "";
        return {
          original: N,
          numbers: N.match(R) ? N.match(R).map(Number) : [0],
          strings: wX.str(_) || L ? N.split(R) : [],
        };
      }
      function YP(_) {
        return dy(
          _ ? hy(wX.arr(_) ? _.map(OP) : OP(_)) : [],
          function (_, L, R) {
            return R.indexOf(_) === L;
          },
        );
      }
      function KP(_) {
        var L = YP(_);
        return L.map(function (_, R) {
          return {
            target: _,
            id: R,
            total: L.length,
            transforms: { list: HP(_) },
          };
        });
      }
      var wZ = {
        css: function (_, L, R) {
          return (_.style[L] = R);
        },
        attribute: function (_, L, R) {
          return _.setAttribute(L, R);
        },
        object: function (_, L, R) {
          return (_[L] = R);
        },
        transform: function (_, L, R, N, z) {
          if ((N.list.set(L, R), L === N.last || z)) {
            var F = "";
            N.list.forEach(function (_, L) {
              F += L + "(" + _ + ") ";
            }),
              (_.style.transform = F);
          }
        },
      };
      function QP(_, L) {
        KP(_).forEach(function (_) {
          for (var R in L) {
            var N = sS(L[R], _),
              z = _.target,
              F = fo(N),
              U = hS(z, R, F, _),
              k = fS(WP(N, F || fo(U)), U);
            wZ[dS(z, R)](z, R, k, _.transforms, !0);
          }
        });
      }
      function JP(_, L) {
        var R = _.length,
          n = function (_) {
            return _.timelineOffset ? _.timelineOffset : 0;
          },
          N = {};
        return (
          (N.duration = R
            ? Math.max.apply(
                Math,
                _.map(function (_) {
                  let L = _.startOnceDelay ?? 0,
                    R = _.pingPongDelayCorrection ?? 0;
                  return n(_) + L + R + _.duration * (_.loop ?? 1);
                }),
              )
            : L.duration),
          (N.delay = R
            ? Math.min.apply(
                Math,
                _.map(function (_) {
                  let L = _.startOnceDelay ?? 0,
                    R = _.pingPongDelayCorrection ?? 0;
                  return n(_) + L + R + _.delay;
                }),
              )
            : L.delay),
          (N.endDelay = R
            ? N.duration -
              Math.max.apply(
                Math,
                _.map(function (_) {
                  let L = _.startOnceDelay ?? 0,
                    R = _.pingPongDelayCorrection ?? 0;
                  return n(_) + L + R + _.duration * (_.loop ?? 1) - _.endDelay;
                }),
              )
            : L.endDelay),
          N
        );
      }
      var wK,
        wJ,
        w$,
        w0,
        w1 = 0,
        w5 = [],
        w6 = [],
        w8 = (function () {
          function r() {
            w0 = requestAnimationFrame(t);
          }
          function t(_) {
            var L = w5.length;
            if (L) {
              for (var R = 0; R < L; ) {
                var N = w5[R];
                N.paused ? (w5.splice(R, 1), (L -= 1)) : (N.tick(_), R++);
              }
              r();
            } else w0 = cancelAnimationFrame(w0);
          }
          return r;
        })();
      function fn(_) {
        void 0 === _ && (_ = {});
        var L,
          R,
          N,
          z,
          F,
          U,
          k,
          Y,
          X,
          Q,
          K = 0,
          J = 0,
          $ = 0,
          ee = 0,
          er = null;
        function l(_) {
          var L =
            window.Promise &&
            new Promise(function (_) {
              return (er = _);
            });
          return (_.finished = L), L;
        }
        var en =
          ((R = iS(wV, (L = _))),
          (z = (function (_, L) {
            var R = [],
              N = L.keyframes;
            for (var z in (N &&
              (L = fy(
                (function (_) {
                  for (
                    var L = dy(
                        hy(
                          _.map(function (_) {
                            return Object.keys(_);
                          }),
                        ),
                        function (_) {
                          return wX.key(_);
                        },
                      ).reduce(function (_, L) {
                        return 0 > _.indexOf(L) && _.push(L), _;
                      }, []),
                      R = {},
                      N = 0;
                    N < L.length;
                    N++
                  )
                    !(function (N) {
                      var z = L[N];
                      R[z] = _.map(function (_) {
                        var L = {};
                        for (var R in _)
                          wX.key(R)
                            ? R == z && (L.value = _[R])
                            : (L[R] = _[R]);
                        return L;
                      });
                    })(N);
                  return R;
                })(N),
                L,
              )),
            L))
              wX.key(z) &&
                R.push({
                  name: z,
                  tweens: (function (_, L) {
                    var R = cS(L);
                    if (
                      (/^spring/.test(R.easing) && (R.duration = GP(R.easing)),
                      wX.arr(_))
                    ) {
                      var N = _.length;
                      2 !== N || wX.obj(_[0])
                        ? wX.fnc(L.duration) || (R.duration = L.duration / N)
                        : (_ = { value: _ });
                    }
                    var z = wX.arr(_) ? _ : [_];
                    return z
                      .map(function (_, R) {
                        var N = wX.obj(_) && !wX.pth(_) ? _ : { value: _ };
                        return (
                          wX.und(N.delay) && (N.delay = R ? 0 : L.delay),
                          wX.und(N.endDelay) &&
                            (N.endDelay = R === z.length - 1 ? L.endDelay : 0),
                          N
                        );
                      })
                      .map(function (_) {
                        return fy(_, R);
                      });
                  })(L[z], _),
                });
            return R;
          })((N = iS(wH, L)), L)),
          (k = JP(
            (U = dy(
              hy(
                (F = KP(L.targets)).map(function (_) {
                  return z.map(function (L) {
                    return (function (_, L) {
                      var R = dS(_.target, L.name);
                      if (R) {
                        var N,
                          z = L.tweens.map(function (R) {
                            var z = (function (_, L) {
                                var R = {};
                                for (var N in _) {
                                  var z = sS(_[N], L);
                                  wX.arr(z) &&
                                    1 ===
                                      (z = z.map(function (_) {
                                        return sS(_, L);
                                      })).length &&
                                    (z = z[0]),
                                    (R[N] = z);
                                }
                                return (
                                  (R.duration = parseFloat(R.duration)),
                                  (R.delay = parseFloat(R.delay)),
                                  R
                                );
                              })(R, _),
                              F = z.value,
                              U = wX.arr(F) ? F[1] : F,
                              k = fo(U),
                              Y = hS(_.target, L.name, k, _),
                              X = N ? N.to.original : Y,
                              Q = wX.arr(F) ? F[0] : X,
                              K = fo(Q) || fo(Y),
                              J = k || K;
                            return (
                              wX.und(U) && (U = X),
                              (z.from = LP(Q, J)),
                              (z.to = LP(fS(U, Q), J)),
                              (z.start = N ? N.end : 0),
                              (z.end =
                                z.start + z.delay + z.duration + z.endDelay),
                              (z.easing = aS(z.easing, z.duration)),
                              (z.isPath = wX.pth(F)),
                              (z.isColor = wX.col(z.from.original)),
                              z.isColor && (z.round = 1),
                              (N = z),
                              z
                            );
                          }),
                          F = z[z.length - 1];
                        return {
                          type: R,
                          property: L.name,
                          animatable: _,
                          tweens: z,
                          duration: F.end,
                          delay: z[0].delay,
                          endDelay: F.endDelay,
                        };
                      }
                    })(_, L);
                  });
                }),
              ),
              function (_) {
                return !wX.und(_);
              },
            )),
            N,
          )),
          (Y = w1),
          w1++,
          fy(R, {
            id: Y,
            children: [],
            animatables: F,
            animations: U,
            duration: k.duration,
            delay: k.delay,
            endDelay: k.endDelay,
            startOnceDelay: N.startOnceDelay,
            pingPongDelayCorrection: N.pingPongDelayCorrection,
          }));
        function d() {
          var _ = en.direction;
          "alternate" !== _ &&
            (en.direction = "normal" !== _ ? "normal" : "reverse"),
            (en.reversed = !en.reversed),
            Q.forEach(function (_) {
              return (_.reversed = en.reversed);
            });
        }
        function h(_) {
          return en.reversed ? en.duration - _ : _;
        }
        function g(_, L) {
          L &&
            (en.reversed
              ? L.seek(
                  L.duration * L.loop -
                    (_ - L.timelineOffset - L.pingPongDelayCorrection),
                )
              : L.seek(
                  _ -
                    L.timelineOffset -
                    L.startOnceDelay -
                    L.pingPongDelayCorrection,
                ));
        }
        function m(_) {
          var L = 0,
            R = en.animations,
            N = R.length;
          for (
            !0 === en.reversePlayback &&
            !1 === en.rewind &&
            (_ = en.duration + en.delay - en.endDelay - _);
            L < N;

          ) {
            var z = R[L],
              F = z.animatable,
              U = z.tweens,
              k = U.length - 1,
              Y = U[k];
            k &&
              (Y =
                dy(U, function (L) {
                  return _ < L.end;
                })[0] || Y);
            for (
              var X = As(_ - Y.start - Y.delay, 0, Y.duration) / Y.duration,
                Q = isNaN(X) ? 1 : Y.easing(X),
                K = Y.to.strings,
                J = Y.round,
                $ = [],
                ee = Y.to.numbers.length,
                er = void 0,
                ea = 0;
              ea < ee;
              ea++
            ) {
              var eo = void 0;
              if (!0 === en.reversePlayback && !1 === en.rewind)
                var el = Y.to.numbers[ea],
                  ec = Y.from.numbers[ea] || 0;
              else
                var ec = Y.to.numbers[ea],
                  el = Y.from.numbers[ea] || 0;
              (eo = Y.isPath
                ? (function (_, L) {
                    function e(R) {
                      void 0 === R && (R = 0);
                      var N = L + R >= 1 ? L + R : 0;
                      return _.el.getPointAtLength(N);
                    }
                    var R = XP(_.el, _.svg),
                      N = e(),
                      z = e(-1),
                      F = e(1);
                    switch (_.property) {
                      case "x":
                        return (N.x - R.x) * R.w;
                      case "y":
                        return (N.y - R.y) * R.h;
                      case "angle":
                        return (
                          (180 * Math.atan2(F.y - z.y, F.x - z.x)) / Math.PI
                        );
                    }
                  })(Y.value, Q * ec)
                : el + Q * (ec - el)),
                J && ((Y.isColor && ea > 2) || (eo = Math.round(eo * J) / J)),
                $.push(eo);
            }
            var ed = K.length;
            if (ed) {
              er = K[0];
              for (var eu = 0; eu < ed; eu++) {
                K[eu];
                var ep = K[eu + 1],
                  ef = $[eu];
                isNaN(ef) || (ep ? (er += ef + ep) : (er += ef + " "));
              }
            } else er = $[0];
            wZ[z.type](F.target, z.property, er, F.transforms),
              (z.currentValue = er),
              L++;
          }
        }
        function y(_) {
          en[_] && !en.passThrough && en[_](en);
        }
        function x(_) {
          var L = en.duration,
            R = en.delay,
            N = L - en.endDelay,
            z = h(_);
          if (
            ((en.progress = As((z / L) * 100, 0, 100)),
            (en.reversePlayback = z < en.currentTime),
            ee &&
              (function (_) {
                if (en.reversed) for (var L = ee; L--; ) g(_, Q[L]);
                else for (var R = 0; R < ee; R++) g(_, Q[R]);
              })(z),
            !en.began && en.currentTime >= 0 && ((en.began = !0), y("begin")),
            !en.loopBegan &&
              en.currentTime > 0 &&
              ((en.loopBegan = !0), y("loopBegin")),
            (en.reversed || z >= 0) &&
              z <= R &&
              0 !== en.currentTime &&
              (m(0), y("change")),
            ((z >= N && en.currentTime !== L) || !L) && (m(L), y("change")),
            z > R && z < N
              ? (en.changeBegan ||
                  ((en.changeBegan = !0),
                  (en.changeCompleted = !1),
                  y("changeBegin")),
                m(z),
                y("change"))
              : en.changeBegan
                ? ((en.changeCompleted = !0),
                  (en.changeBegan = !1),
                  y("change"),
                  ee && y("timelineChangeComplete"))
                : en.began && z > N && y("changeComplete"),
            (en.currentTime = As(z, 0, L)),
            en.began && y("update"),
            _ >= L)
          ) {
            if (
              (en.remaining && !0 !== en.remaining && en.remaining--,
              en.remaining)
            ) {
              for (let _ of (ee
                ? (K += en.duration / fn.speed)
                : (K += en.duration),
              Q))
                _.setStartTime(0), (_.remaining = _.loop);
              y("loopComplete"),
                (en.loopBegan = !1),
                "alternate" === en.direction && d();
            } else
              (en.paused = !0),
                en.completed ||
                  ((en.completed = !0),
                  y("loopComplete"),
                  y("complete"),
                  !en.passThrough && "Promise" in window && (er(), l(en)));
          }
        }
        return (
          l(en),
          (en.reset = function () {
            var _ = en.direction;
            (en.passThrough = !1),
              (en.currentTime = 0),
              (en.progress = 0),
              (en.paused = !0),
              (en.began = !1),
              (en.loopBegan = !1),
              (en.changeBegan = !1),
              (en.completed = !1),
              (en.changeCompleted = !1),
              (en.reversePlayback = !1),
              (en.reversed = "reverse" === _),
              (en.remaining = en.loop),
              (ee = (Q = en.children).length);
            for (var L = ee; L--; ) en.children[L].reset();
            ((en.reversed && !0 !== en.loop) ||
              ("alternate" === _ && 1 === en.loop)) &&
              en.remaining++,
              m(en.reversed ? en.duration : 0);
          }),
          (en.setStartTime = function (_) {
            K = _;
          }),
          (en.set = function (_, L) {
            return QP(_, L), en;
          }),
          (en.tick = function (_) {
            ($ = _), K || (K = $), x(($ + (J - K)) * fn.speed);
          }),
          (en.seek = function (_) {
            x(_ - K);
          }),
          (en.pause = function (_) {
            (en.paused = !0), ee && (X = _ ?? performance.now());
          }),
          (en.play = function (_) {
            !en.paused ||
              (en.completed && en.reset(),
              (en.paused = !1),
              w5.push(en),
              ee && void 0 !== X && (K += (_ ?? performance.now()) - X),
              w0 || w8());
          }),
          (en.reverse = function () {
            d(),
              (en.completed = !en.reversed),
              (K = 0),
              (J = h(en.currentTime) * (1 / fn.speed));
          }),
          (en.restart = function () {
            en.reset(), en.play();
          }),
          en.reset(),
          en.autoplay && en.play(),
          en
        );
      }
      function BP(_, L) {
        for (var R = L.length; R--; )
          lS(_, L[R].animatable.target) && L.splice(R, 1);
      }
      "u" > typeof document &&
        document.addEventListener("visibilitychange", function (_) {
          document.hidden
            ? (w5.forEach(function (L) {
                return L.pause(_.timeStamp);
              }),
              (w6 = w5.slice(0)),
              (fn.running = w5 = []))
            : w6.forEach(function (L) {
                return L.play(_.timeStamp);
              });
        }),
        (fn.version = "3.2.0"),
        (fn.speed = 1),
        (fn.running = w5),
        (fn.remove = function (_) {
          for (var L = YP(_), R = w5.length; R--; ) {
            var N = w5[R],
              z = N.animations,
              F = N.children;
            BP(L, z);
            for (var U = F.length; U--; ) {
              var k = F[U],
                Y = k.animations;
              BP(L, Y), Y.length || k.children.length || F.splice(U, 1);
            }
            z.length || F.length || N.pause();
          }
        }),
        (fn.get = hS),
        (fn.set = QP),
        (fn.convertPx = uS),
        (fn.path = function (_, L) {
          var R = wX.str(_) ? zP(_)[0] : _,
            N = L || 100;
          return function (_) {
            return {
              property: _,
              el: R,
              svg: XP(R),
              totalLength: qP(R) * (N / 100),
            };
          };
        }),
        (fn.setDashoffset = function (_) {
          var L = qP(_);
          return _.setAttribute("stroke-dasharray", L), L;
        }),
        (fn.stagger = function (_, L) {
          void 0 === L && (L = {});
          var R = L.direction || "normal",
            N = L.easing ? aS(L.easing) : null,
            z = L.grid,
            F = L.axis,
            U = L.from || 0,
            k = "first" === U,
            Y = "center" === U,
            X = "last" === U,
            Q = wX.arr(_),
            K = parseFloat(Q ? _[0] : _),
            J = Q ? parseFloat(_[1]) : 0,
            $ = fo(Q ? _[1] : _) || 0,
            ee = L.start || 0 + (Q ? K : 0),
            er = [],
            en = 0;
          return function (_, L, ea) {
            if (
              (k && (U = 0),
              Y && (U = (ea - 1) / 2),
              X && (U = ea - 1),
              !er.length)
            ) {
              for (var eo = 0; eo < ea; eo++) {
                if (z) {
                  var el = Y ? (z[0] - 1) / 2 : U % z[0],
                    ec = Y ? (z[1] - 1) / 2 : Math.floor(U / z[0]),
                    ed = eo % z[0],
                    eu = Math.floor(eo / z[0]),
                    ep = el - ed,
                    ef = ec - eu,
                    ev = Math.sqrt(ep * ep + ef * ef);
                  "x" === F && (ev = -ep), "y" === F && (ev = -ef), er.push(ev);
                } else er.push(Math.abs(U - eo));
                en = Math.max.apply(Math, er);
              }
              N &&
                (er = er.map(function (_) {
                  return N(_ / en) * en;
                })),
                "reverse" === R &&
                  (er = er.map(function (_) {
                    return F ? (_ < 0 ? -1 * _ : -_) : Math.abs(en - _);
                  }));
            }
            return (
              ee + (Q ? (J - K) / en : K) * (Math.round(100 * er[L]) / 100) + $
            );
          };
        }),
        (fn.timeline = function (_) {
          void 0 === _ && (_ = {});
          var L = fn(_);
          return (
            (L.duration = 0),
            (L.add = function (R, N) {
              var z = w5.indexOf(L),
                F = L.children;
              function o(_) {
                _.passThrough = !0;
              }
              z > -1 && w5.splice(z, 1);
              for (var U = 0; U < F.length; U++) o(F[U]);
              var k = fy(R, iS(wH, _));
              k.targets = k.targets || _.targets;
              var Y = L.duration;
              (k.autoplay = !1),
                (k.timelineOffset = wX.und(N) ? Y : fS(N, Y)),
                o(L);
              var X = fn(k);
              o(X), F.push(X);
              var Q = JP(F, _);
              return (
                (L.delay = Q.delay),
                (L.endDelay = Q.endDelay),
                (L.duration = Q.duration),
                !0 === X.loop && (L.duration = 1 / 0),
                L.seek(0),
                L.reset(),
                L.autoplay && L.play(),
                L
              );
            }),
            L
          );
        }),
        (fn.easing = aS),
        (fn.penner = wQ),
        (fn.random = function (_, L) {
          return Math.floor(Math.random() * (L - _ + 1)) + _;
        });
      var w9 = new iq(),
        w7 = new iq(),
        _e = new iX();
      function qi(_, L, R, N, z) {
        let F = R[_] ? R[_] : void 0,
          U = N[_];
        if (null == U) return;
        let k = F ?? L[_];
        if (k !== U)
          return {
            update: (R) => {
              let N = iE.lerp(k, U, R);
              z ? (L[_] = Math.trunc(N)) : (L[_] = N);
            },
            start: () => {
              L[_] = k;
            },
            end: () => {
              L[_] = U;
            },
          };
      }
      function mS(_, L, R, N, z) {
        let F = R[_] ? R[_] : void 0,
          U = N[_];
        if (!U) return;
        let k = L[_],
          Y = [...(F ?? k)],
          X = [...U];
        if (!(Y.length !== X.length || Ha(Y, X)))
          return {
            update: (R) => {
              Y.forEach((N, F) => {
                let U = iE.lerp(N, X[F], R);
                L[_][F] = z ? Math.trunc(U) : U;
              });
            },
            start: () => {
              Object.assign(L[_], Y);
            },
            end: () => {
              Object.assign(L[_], X);
            },
          };
      }
      function gS(_, L, R, N) {
        let z = R[_] ? R[_] : void 0,
          F = N[_];
        if (!F) return;
        let U = L[_],
          k = z ? new iq().fromArray(z) : U.clone(),
          Y = new iq().fromArray(F);
        if (!k.equals(Y))
          return {
            update: (_) => {
              U.lerpVectors(k, Y, _);
            },
            start: () => {
              U.copy(k);
            },
            end: () => {
              U.copy(Y);
            },
          };
      }
      function Ts(_, L, R, N) {
        return "number" == typeof L[_]
          ? qi(_, L, R ?? {}, N)
          : Array.isArray(L[_])
            ? mS(_, L, R ?? {}, N)
            : void 0;
      }
      function c2(_, L, R, N) {
        let z = [],
          F = tf(R, N) || (!!L.layers && tf(L, N));
        for (let U of (z.push({
          update: () => {
            _.transparent = F;
          },
        }),
        _.layers)) {
          let _ = L.layers?.data(U.uuid),
            F = R.layers.data(U.uuid);
          if (F && (U.visible ?? !0) && (F.visible ?? !0))
            for (let L of U.getNames().filter(
              (_) => !pV.some((L) => _.includes(L)),
            ))
              try {
                let R = U.getValue(L),
                  k;
                if ("colors" === L)
                  k = (function (_, L, R, N = "colors") {
                    if (!_.hasValue(N) || !(N in R)) return;
                    let z = [],
                      F = _.getValue(N),
                      U = L ? L[N] : F.map((_) => _.toArray()),
                      k = R[N];
                    for (let _ = 0; _ < F.length; ++_) {
                      let L = [...U[_]],
                        R = [...k[_]];
                      pv.isEqual(L, R) ||
                        z.push({
                          update: (N) => {
                            F[_].fromArray(pv.lerp(L, R, N));
                          },
                          start: () => {
                            F[_].fromArray(L);
                          },
                          end: () => {
                            F[_].fromArray(R);
                          },
                        });
                    }
                    return z.length ? z : void 0;
                  })(U, _, F, L);
                else if (Array.isArray(R))
                  "steps" === L &&
                    (k = (function (_, L, R, N = "steps") {
                      if (!_.hasValue(N) || !(N in R)) return;
                      let z = [],
                        F = _.getValue(N),
                        U = L ? L[N] : F,
                        k = R[N];
                      for (let _ = 0; _ < F.length; ++_) {
                        let L = U[_],
                          R = k[_];
                        L !== R &&
                          z.push({
                            update: (N) => {
                              F[_] = iE.lerp(L, R, N);
                            },
                            start: () => {
                              F[_] = L;
                            },
                            end: () => {
                              F[_] = R;
                            },
                          });
                      }
                      return z.length ? z : void 0;
                    })(U, _, F, L));
                else if ("number" == typeof R)
                  k = (function (_, L, R, N) {
                    if (!_.hasValue(N) || !(N in R)) return;
                    let z = L ? L[N] : _.getValue(N),
                      F = R[N];
                    if (z !== F)
                      return {
                        update: (L) => {
                          _.setValue(N, iE.lerp(z, F, L));
                        },
                        start: () => {
                          _.setValue(N, z);
                        },
                        end: () => {
                          _.setValue(N, F);
                        },
                      };
                  })(U, _, F, L);
                else {
                  if ("boolean" == typeof R) continue;
                  R instanceof iT
                    ? (k = (function (_, L, R, N) {
                        if (!_.hasValue(N) || !(N in R)) return;
                        let z = _.getValue(N),
                          F = L ? new iT().fromArray(L[N]) : z.clone(),
                          U = new iT().fromArray(R[N]);
                        if (!F.equals(U))
                          return {
                            update: (_) => {
                              z.lerpVectors(F, U, _);
                            },
                            start: () => {
                              z.copy(F);
                            },
                            end: () => {
                              z.copy(U);
                            },
                          };
                      })(U, _, F, L))
                    : R instanceof iq
                      ? (k = (function (_, L, R, N) {
                          if (!_.hasValue(N) || !(N in R)) return;
                          let z = _.getValue(N),
                            F = L ? new iq().fromArray(L[N]) : z.clone(),
                            U = new iq().fromArray(R[N]);
                          if (!F.equals(U))
                            return {
                              update: (_) => {
                                z.lerpVectors(F, U, _);
                              },
                              start: () => {
                                z.copy(F);
                              },
                              end: () => {
                                z.copy(U);
                              },
                            };
                        })(U, _, F, L))
                      : R instanceof ys
                        ? (k = (function (_, L, R, N, z) {
                            if (!_.hasValue(N) || !(N in R)) return;
                            let F = L ? L[N] : void 0,
                              U = R[N],
                              k = _.getValue(N),
                              Y = F
                                ? "string" == typeof F
                                  ? z.getColor(F).clone()
                                  : new iz().setRGB(F.r, F.g, F.b)
                                : k.clone(),
                              X =
                                "string" == typeof U
                                  ? z.getColor(U).clone()
                                  : new ys(U.r, U.g, U.b, U.a);
                            if (Y.equals(X)) return;
                            let Q = k.clone();
                            return (
                              _.setValue(N, Q),
                              {
                                update: (_) => {
                                  Q.lerpColors(Y, X, _);
                                },
                                start: () => {
                                  Q.copy(Y);
                                },
                                end: () => {
                                  Q.copy(X);
                                },
                              }
                            );
                          })(U, _, F, L, N))
                        : R instanceof iz
                          ? (k = (function (_, L, R, N, z) {
                              if (!_.hasValue(N) || !(N in R)) return;
                              let F = L ? L[N] : void 0,
                                U = R[N],
                                k = _.getValue(N),
                                Y = F
                                  ? "string" == typeof F
                                    ? z.getColor(F).clone()
                                    : new iz().setRGB(F.r, F.g, F.b)
                                  : k.clone(),
                                X =
                                  "string" == typeof U
                                    ? z.getColor(U).clone()
                                    : new iz().setRGB(U.r, U.g, U.b);
                              if (Y.equals(X)) return;
                              let Q = k.clone();
                              return (
                                _.setValue(N, Q),
                                {
                                  update: (_) => {
                                    Q.lerpColors(Y, X, _);
                                  },
                                  start: () => {
                                    Q.copy(Y);
                                  },
                                  end: () => {
                                    Q.copy(X);
                                  },
                                }
                              );
                            })(U, _, F, L, N))
                          : "isTexture" in R &&
                            (k = (function (_, L, R, N = "texture") {
                              if (!_.hasValue(N) || !(N in R)) return;
                              let z = _.getNode("mat");
                              if (!z) return;
                              let F = L ? L[N] : z,
                                U = R[N],
                                k = [...F.repeat],
                                Y = [...F.offset],
                                X = [...U.repeat],
                                Q = [...U.offset];
                              if (!pp.isEqual(k, X) || !pp.isEqual(Y, Q))
                                return {
                                  update: (_) => {
                                    (z.repeat = pp.lerp(k, X, _)),
                                      (z.offset = pp.lerp(Y, Q, _)),
                                      z.updateMatrix();
                                  },
                                  start: () => {
                                    (z.repeat = [...k]),
                                      (z.offset = [...Y]),
                                      z.updateMatrix();
                                  },
                                  end: () => {
                                    (z.repeat = [...X]),
                                      (z.offset = [...Q]),
                                      z.updateMatrix();
                                  },
                                };
                            })(U, _, F, L));
                }
                k && (Array.isArray(k) ? z.push(...k) : z.push(k));
              } catch (_) {
                console.error(
                  `lerpMaterial: unexpected material layer for ${L}`,
                  _,
                );
              }
        }
        return z;
      }
      var _t = new iq(),
        _i = new rN();
      function vS(_, L, R, N, z) {
        let F = [];
        return (
          _.data.visible &&
            F.push(
              ...(function (_, L, R, N) {
                let z = [],
                  F,
                  U,
                  k,
                  Y,
                  X,
                  Q,
                  K = {
                    slide: (L.pathSnapping ?? _.dataPatched.pathSnapping).slide,
                    offset: (L.pathSnapping ?? _.dataPatched.pathSnapping)
                      .offset,
                  };
                if (
                  ((X = qi(
                    "slide",
                    K,
                    L.pathSnapping ?? _.dataPatched.pathSnapping,
                    R.pathSnapping ?? _.dataPatched.pathSnapping,
                  )) && z.push(X),
                  (Q = qi(
                    "offset",
                    K,
                    L.pathSnapping ?? _.dataPatched.pathSnapping,
                    R.pathSnapping ?? _.dataPatched.pathSnapping,
                  )) && z.push(Q),
                  !X &&
                    !Q &&
                    ((F = gS("position", _, L, R)) && z.push(F),
                    (U = gS("scale", _, L, R)) && z.push(U),
                    (k = (function (_, L, R, N) {
                      let z = L?.rotation ? L.rotation : void 0,
                        F = R.rotation;
                      if (!F) return;
                      let U = z
                          ? new iq().fromArray(z)
                          : new iq().setFromEuler(_.rotation),
                        k = new iq().fromArray(F);
                      if (U.equals(k)) return;
                      let Y = _t.subVectors(k, U);
                      if (
                        !(
                          N &&
                          Y.toArray().every((_) => Math.abs(_) < 2 * Math.PI)
                        )
                      )
                        return {
                          update: (L) => {
                            _t.lerpVectors(U, k, L),
                              _.rotation.setFromVector3(_t);
                          },
                          start: () => {
                            _.rotation.setFromVector3(U);
                          },
                          end: () => {
                            _.rotation.setFromVector3(k);
                          },
                        };
                      {
                        let L = new iX().setFromEuler(_i.setFromVector3(U)),
                          R = new iX().setFromEuler(_i.setFromVector3(k));
                        return {
                          update: (N) => {
                            !(function (_, L, R, N) {
                              if (0 === N) return R.copy(_);
                              if (1 === N) return R.copy(L);
                              let z =
                                _.w * L.w + _.x * L.x + _.y * L.y + _.z * L.z;
                              if (z >= 1) return R.copy(_);
                              let F = 1 - z * z;
                              if (F <= Number.EPSILON) {
                                let z = 1 - N;
                                return (
                                  (R.w = z * _.w + N * L.w),
                                  (R.x = z * _.x + N * L.x),
                                  (R.y = z * _.y + N * L.y),
                                  (R.z = z * _.z + N * L.z),
                                  R.normalize()
                                );
                              }
                              let U = Math.sqrt(F),
                                k = Math.atan2(U, z),
                                Y = Math.sin((1 - N) * k) / U,
                                X = Math.sin(N * k) / U;
                              (R.w = _.w * Y + L.w * X),
                                (R.x = _.x * Y + L.x * X),
                                (R.y = _.y * Y + L.y * X),
                                (R.z = _.z * Y + L.z * X);
                            })(L, R, _.quaternion, N);
                          },
                          start: () => {
                            _.rotation.setFromVector3(U);
                          },
                          end: () => {
                            _.rotation.setFromVector3(k);
                          },
                        };
                      }
                    })(_, L, R, N)) && z.push(k),
                    (Y = (function (_, L, R, N) {
                      let z = R[_] ? R[_] : void 0,
                        F = N[_];
                      if (!F) return;
                      let U = L[_],
                        k = z ? new rw().fromArray(z) : U.clone(),
                        Y = new iq(),
                        X = new iX(),
                        Q = new iq();
                      k.decompose(Y, X, Q);
                      let K = new rw().fromArray(F),
                        J = new iq(),
                        $ = new iX(),
                        ee = new iq();
                      if ((K.decompose(J, $, ee), !k.equals(K)))
                        return {
                          update: (_) => {
                            _e.slerpQuaternions(X, $, _),
                              w9.lerpVectors(Y, J, _),
                              w7.lerpVectors(Q, ee, _),
                              U.compose(w9, _e, w7);
                          },
                          start: () => {
                            U.compose(Y, X, Q);
                          },
                          end: () => {
                            U.compose(J, $, ee);
                          },
                        };
                    })("hiddenMatrix", _, L, R)) && z.push(Y)),
                  F || U || k || Y || X || Q)
                ) {
                  let h = () => {
                    _.updateMatrix(),
                      _.hasNonUniformScale &&
                        (_.updateMatrixWorld(), _.updateMatrixWorldSVD()),
                      _.parent?.matrixWorldFusedFalse &&
                        (_.matrixWorld.multiplyMatrices(
                          _.parent.matrixWorldFusedFalse,
                          _.matrix,
                        ),
                        (_.matrixWorldNeedsUpdate = !1)),
                      $r(_) &&
                        ei(_.parent) &&
                        _.invalidateDownstreamBooleanData(!0),
                      _.updatePathSnapping(
                        Object.assign({}, L.pathSnapping, K),
                      );
                  };
                  z.push({ update: h, start: h, end: h });
                }
                return z;
              })(_, L, R, z),
            ),
          _.data.visible &&
            F.push(
              ...(function (_, L, R) {
                let N = [];
                if (!("cloner" in R) || !_.cloner) return N;
                let z = _.cloner,
                  F = "cloner" in L ? L.cloner : {},
                  U = R.cloner;
                uO.forEach((_) => {
                  let L;
                  (L =
                    "count" === _
                      ? qi("count", z.parameters, F, U, !0)
                      : Ts(_, z.parameters, F ?? {}, U)) && N.push(L);
                });
                let k = (function (_, L, R) {
                  if ("radial" !== _.parameters.type) return;
                  let N = L.radial,
                    z = R.radial;
                  if (!z) return;
                  let F = _.parameters.radial,
                    U = [];
                  return (
                    uL.forEach((_) => {
                      let L = Ts(_, F, N ?? {}, z);
                      L && U.push(L);
                    }),
                    U
                  );
                })(z, F, U);
                k?.length && N.push(...k);
                let Y = (function (_, L, R) {
                  if ("linear" !== _.parameters.type) return;
                  let N = L.linear,
                    z = R.linear;
                  if (!z) return;
                  let F = [],
                    U = _.parameters.linear;
                  return (
                    uR.forEach((_) => {
                      let L = Ts(_, U, N ?? {}, z);
                      L && F.push(L);
                    }),
                    F
                  );
                })(z, F, U);
                Y?.length && N.push(...Y);
                let X = (function (_, L, R) {
                  if ("grid" !== _.parameters.type) return;
                  let N = L.grid,
                    z = R.grid;
                  if (!z) return;
                  let F = [],
                    U = _.parameters.grid;
                  return (
                    uI.forEach((_) => {
                      let L;
                      (L =
                        "count" === _
                          ? mS(_, U, N ?? {}, z, !0)
                          : Ts(_, U, N ?? {}, z)) && F.push(L);
                    }),
                    F
                  );
                })(z, F, U);
                X?.length && N.push(...X);
                let Q = (function (_, L, R) {
                  if ("toObject" !== _.parameters.type) return;
                  let N = L.toObject,
                    z = R.toObject;
                  if (!z) return;
                  let F = [],
                    U = _.parameters.toObject;
                  return (
                    uB.forEach((_) => {
                      let L;
                      (L =
                        "count" === _
                          ? qi(_, U, N ?? {}, z, !0)
                          : Ts(_, U, N ?? {}, z)) && F.push(L);
                    }),
                    F
                  );
                })(z, F, U);
                Q?.length && N.push(...Q);
                let K = (function (_, L, R) {
                  if (!_.parameters.randomness) return;
                  let N = L.randomnessObject,
                    z = R.randomnessObject;
                  if (!z) return;
                  let F = [],
                    U = _.parameters.randomnessObject;
                  return (
                    uz.forEach((_) => {
                      let L = Ts(_, U, N ?? {}, z);
                      L && F.push(L);
                    }),
                    F
                  );
                })(z, F, U);
                return (
                  K?.length && N.push(...K),
                  N.length &&
                    N.push({
                      update: () => {
                        z.update();
                      },
                    }),
                  N
                );
              })(_, L, R),
            ),
          $r(_)
            ? (_ instanceof xZ &&
                _.data.visible &&
                F.push(
                  ...(function (_, L, R, N) {
                    let z = [];
                    if (!("geometry" in R)) return z;
                    let F = _.geometry.userData.parameters,
                      U = "geometry" in L ? L.geometry : {},
                      k = R.geometry;
                    if (_ instanceof x$) {
                      let L = (function (_, L, R, N) {
                        if (void 0 === R.scaleBaked) return;
                        let z = L.scaleBaked ?? _.data.geometry.scaleBaked,
                          F = R.scaleBaked;
                        if (pf.isEqual(z, F)) return;
                        let U = [];
                        return (
                          U.push({
                            update: (L) => {
                              _.updateGeometryInteractions(
                                {
                                  scaleBaked: [
                                    iE.lerp(z[0], F[0], L),
                                    iE.lerp(z[1], F[1], L),
                                    iE.lerp(z[2], F[2], L),
                                  ],
                                },
                                N,
                              ),
                                _.invalidateDownstreamBooleanData();
                            },
                            start: () => {
                              _.updateGeometryInteractions(
                                { scaleBaked: z },
                                N,
                              ),
                                _.invalidateDownstreamBooleanData();
                            },
                            end: () => {
                              _.updateGeometryInteractions(
                                { scaleBaked: F },
                                N,
                              ),
                                _.invalidateDownstreamBooleanData();
                            },
                          }),
                          U
                        );
                      })(_, U, k, N);
                      L && z.push(...L);
                    } else {
                      let L = {};
                      if (
                        (Object.assign(L, cW(F, pq)),
                        pq.forEach((_) => {
                          let R = Ts(_, L, U, k);
                          R && z.push(R);
                        }),
                        _ instanceof b4)
                      ) {
                        Object.assign(L, { extrusion: { ...F.extrusion } });
                        let _ = (function (_, L, R) {
                          if (!R.extrusion) return;
                          let N = _.extrusion,
                            z = L.extrusion ?? {},
                            F = R.extrusion,
                            U = [];
                          return (
                            pX.forEach((_) => {
                              let L = Ts(_, N, z, F);
                              L && U.push(L);
                            }),
                            U
                          );
                        })(L, U, k);
                        _ && z.push(..._);
                      }
                      z.length &&
                        z.push({
                          update: (R) => {
                            _.updateGeometryInteractions(L, N),
                              _.updateGeometryGroupsIfNeeded();
                          },
                          start: (R) => {
                            _.updateGeometryInteractions(L, N),
                              _.updateGeometryGroupsIfNeeded();
                          },
                          end: (R) => {
                            _.updateGeometryInteractions(L, N),
                              _.updateGeometryGroupsIfNeeded();
                          },
                        });
                    }
                    return z;
                  })(_, L, R, N),
                ),
              _.data.visible &&
                F.push(
                  ...(function (_, L, R, N) {
                    let z = [];
                    if (Array.isArray(_.material)) {
                      if (!("materials" in R && R.materials)) return z;
                      let F =
                          "materials" in L && L.materials ? L.materials : [],
                        U = R.materials;
                      _.material.forEach((_, L) => {
                        if (!U[L]) return;
                        let R = F[L] ?? {},
                          k = U[L];
                        "string" == typeof R ||
                          "string" == typeof k ||
                          z.push(...c2(_, R, k, N));
                      });
                    } else {
                      if (!("material" in R && R.material)) return z;
                      let F = "material" in L && L.material ? L.material : {},
                        U = R.material;
                      if ("string" == typeof F || "string" == typeof U)
                        return z;
                      z.push(...c2(_.material, F, U, N));
                    }
                    return z;
                  })(_, L, R, N),
                ))
            : XC(_)
              ? _.data.visible &&
                F.push(
                  ...(function (_, L, R, N) {
                    let z = [];
                    if (void 0 !== R.intensity) {
                      let N = qi("intensity", _, L, R);
                      N && z.push(N);
                    }
                    if (void 0 !== R.color) {
                      let F = (function (_, L, R, N, z) {
                        let F = R[_] ? R[_] : void 0,
                          U = N[_];
                        if (!U) return;
                        let k = L[_],
                          Y = F
                            ? "string" == typeof F
                              ? z.getColor(F).clone()
                              : new iz().setRGB(F.r, F.g, F.b)
                            : k.clone(),
                          X =
                            "string" == typeof U
                              ? z.getColor(U).clone()
                              : new iz().setRGB(U.r, U.g, U.b);
                        if (Y.equals(X)) return;
                        let Q = k.clone();
                        return (
                          (L[_] = Q),
                          {
                            update: (_) => {
                              Q.lerpColors(Y, X, _);
                            },
                            start: () => {
                              Q.copy(Y);
                            },
                            end: () => {
                              Q.copy(X);
                            },
                          }
                        );
                      })("color", _, L, R, N);
                      F && z.push(F);
                    }
                    return z;
                  })(_, L, R, N),
                )
              : qC(_) &&
                F.push(
                  ...(function (_, L, R) {
                    let N = [],
                      z =
                        "OrthographicCamera" === _.cameraType
                          ? L.orthographic?.zoom
                          : L.perspective?.zoom,
                      F =
                        "OrthographicCamera" === _.cameraType
                          ? R.orthographic?.zoom
                          : R.perspective?.zoom;
                    if (void 0 !== F) {
                      let L = z ?? _.zoom;
                      L !== F &&
                        N.push({
                          update: (R) => {
                            (_.zoom = iE.lerp(L, F, R)),
                              _.updateProjectionMatrix();
                          },
                          start: () => {
                            (_.zoom = L), _.updateProjectionMatrix();
                          },
                          end: () => {
                            (_.zoom = F), _.updateProjectionMatrix();
                          },
                        });
                    }
                    if (void 0 !== R.targetOffset) {
                      let z = qi("targetOffset", _, L, R);
                      z && N.push(z);
                    }
                    return N;
                  })(_, L, R),
                ),
          F.length
            ? {
                update: (_) => {
                  F.forEach((L) => L.update(_));
                },
                start: (_) => {
                  F.forEach((L) => L.start?.(_));
                },
                end: (_) => {
                  F.forEach((L) => L.end?.(_));
                },
              }
            : void 0
        );
      }
      var _a = new iq();
      function ly(_, L, R, N = !1) {
        let z = [];
        L.traverseObject((F) => {
          if (
            (N &&
              (F.rigidBody?.setTranslation(F.position0, !0),
              F.rigidBody?.setRotation(F.rotation0, !0),
              F.rigidBody?.setLinvel(_a, !0),
              F.rigidBody?.setAngvel(_a, !0)),
            !vu.is(F))
          )
            return;
          let U = F.uuid,
            k = F.data;
          if ((delete F.states, !k.states)) return;
          let Y = !1;
          for (let L of (z.some((L) => _.objects.isDescendantOf(U, L))
            ? (Y = !0)
            : k.physics?.fusedBody === !0 &&
              "dynamic" === k.physics.rigidBody &&
              z.push(U),
          (F.data = k),
          (F.currentState = null),
          (F.reversibleToState = null),
          (F.currentTransitionEvent = null),
          k.states))
            (!0 === _.environment.usePhysics &&
              k.physics &&
              ("dynamic" === k.physics.rigidBody || Y) &&
              (void 0 !== L.data.position ||
                void 0 !== L.data.rotation ||
                void 0 !== L.data.hiddenMatrix)) ||
              (F.states || (F.states = {}),
              (F.states[L.id] = f6.patch(k, L.data)));
          !(function (_, L, R, N, z = !1) {
            L instanceof xZ && L.removeInteractionGeometry(),
              L.changeSelectedState(null, { scene: _, shared: N }, z),
              L instanceof xZ && L.updateGeometryGroupsIfNeeded();
          })(
            L,
            F,
            0,
            R,
            void 0 !==
              k.events.find(
                (_) => "Follow" === _.data.type || "LookAt" === _.data.type,
              ),
          );
        });
      }
      function m2(_) {
        let L = { delay: 0, loop: -1 === _.repeat || _.repeat + 1 };
        if (0 === _.repeat)
          (L.direction = "normal"),
            (L.rewind = "pingpong-rewind" === _.direction);
        else
          switch (_.direction) {
            case "pingpong":
              (L.direction = "alternate"), (L.rewind = !1);
              break;
            case "pingpong-rewind":
              (L.direction = "alternate"), (L.rewind = !0);
              break;
            default:
              (L.direction = "normal"), (L.rewind = !1);
          }
        switch (
          ((L.delay = 0),
          (L.endDelay = 0),
          (L.startOnceDelay = 0),
          (L.pingPongDelayCorrection = 0),
          _.delayDirection)
        ) {
          case "start-once":
            L.startOnceDelay = _.delay;
            break;
          case "start":
            L.delay = _.delay;
            break;
          case "end":
            L.endDelay = _.delay;
            break;
          case "start-end":
          case void 0:
            (L.delay = _.delay), (L.endDelay = _.delay);
        }
        return (
          "alternate" === L.direction &&
            ((L.delay /= 2),
            (L.endDelay /= 2),
            0 !== L.delay && (L.pingPongDelayCorrection = L.delay)),
          L
        );
      }
      var _o = { type: "beginState" },
        _l = { type: "completeState", isfromEntity: !1 },
        _c = class {
          constructor(_, L, R, N, z, F) {
            if (
              ((this.object = _),
              (this.data = N),
              (this.sharedAssets = z),
              (this.allowSlerp = F),
              (this.targets = { t: 0 }),
              (this.firstLoop = !0),
              (this._changeBegan = !1),
              (this._changeCompleted = !0),
              (this.onChange = () => {
                this.callback &&
                  (this.callback.update(this.targets.t),
                  this.object.dispatchEvent({ type: "requestRender" })),
                  0 === this.targets.t || 1 === this.targets.t
                    ? this._changeCompleted ||
                      ((this._changeCompleted = !0),
                      (this._changeBegan = !1),
                      this.onChangeComplete())
                    : (this._changeCompleted && (this._changeCompleted = !1),
                      this._changeBegan ||
                        ((this._changeBegan = !0), this.onChangeBegin()));
              }),
              (this.onChangeBegin = () => {
                this.object.reversibleToState = this.to.id;
                let _ = this.targets.t > 0.5 ? this.from.id : this.to.id;
                this.object.prevState !== this.object.currentState &&
                  (this.object.prevState = this.object.currentState),
                  (this.object.currentState = _),
                  this.object.dispatchEvent({ type: "beginState", state: _ }),
                  this.object.traverseEntity((_) => {
                    _ !== this.object && _ instanceof bj && _.dispatchEvent(_o);
                  });
              }),
              (this.onChangeComplete = () => {
                this.firstLoop && (this.onFirstLoop(), (this.firstLoop = !1)),
                  (this.object.reversibleToState = this.to.id);
                let _ = this.targets.t < 0.5 ? this.from.id : this.to.id;
                this.object.prevState !== this.object.currentState &&
                  (this.object.prevState = this.object.currentState),
                  (this.object.currentState = _),
                  this.object.dispatchEvent({
                    type: "completeState",
                    state: _,
                  }),
                  this.object.traverseEntity((_) => {
                    _ !== this.object && _ instanceof bj && _.dispatchEvent(_l);
                  });
              }),
              (this.onFirstLoop = () => {
                this.useCurrentState &&
                  (this.callback = vS(
                    this.object,
                    this.from.data,
                    this.to.data,
                    this.sharedAssets,
                    this.allowSlerp,
                  ));
              }),
              void 0 === L)
            ) {
              let _ = py(
                this.object,
                this.object.currentState === R
                  ? this.object.prevState
                  : this.object.currentState,
              );
              if (!_) throw Error("Missing property");
              this.from = _;
            } else {
              let _ = py(this.object, L);
              if (!_) throw Error("Missing property");
              this.from = _;
            }
            if (void 0 === R) throw Error("Missing property");
            {
              let _ = py(this.object, R);
              if (!_) throw Error("Missing property");
              this.to = _;
            }
            (this.useCurrentState = void 0 === L || void 0 === R),
              (this.params = {
                targets: this.targets,
                t: 1,
                autoplay: !1,
                ...m2(N),
                ...(function (_) {
                  let L;
                  switch (_.easing) {
                    case 0:
                      L = "cubicBezier( 0, 0, 1, 1 )";
                      break;
                    case 1:
                      L = "cubicBezier( .25, .1, .25, 1 )";
                      break;
                    case 2:
                      L = "cubicBezier( .42, 0, 1, 1 )";
                      break;
                    case 3:
                      L = "cubicBezier( 0, 0, .58, 1 )";
                      break;
                    case 4:
                      L = "cubicBezier( .42, 0, .58, 1 )";
                      break;
                    case 5:
                      let { control1: R, control2: N } = _;
                      L = `cubicBezier(
				${R[0]}, ${R[1]}, ${N[0]}, ${N[1]}
			)`;
                      break;
                    case 6:
                      let {
                        mass: z,
                        stiffness: F,
                        damping: U,
                        velocity: k,
                      } = _;
                      L = `spring( ${z}, ${F}, ${U}, ${k} )`;
                      break;
                    default:
                      L = "linear";
                  }
                  return { duration: _.duration, easing: L };
                })(N),
                change: this.onChange,
              }),
              (this.callback = vS(
                this.object,
                void 0 === L ? {} : this.from.data,
                void 0 === R ? {} : this.to.data,
                this.sharedAssets,
                this.allowSlerp,
              ));
          }
          get changeBegan() {
            return this._changeBegan;
          }
          get changeCompleted() {
            return this._changeCompleted;
          }
        },
        _d = class extends ig {
          constructor(_, L, R) {
            if (
              (super(),
              (this.data = _),
              (this.scene = L),
              (this.sharedAssets = R),
              (this.toggleIsForward = !1),
              (this.timelineNeedsRebuild = !1),
              (this.useToggle = !1),
              (this.onTimelineChangeComplete = () => {
                "normal" !== this.data.tweens[0].data.direction &&
                  (this.toggleIsForward = !this.toggleIsForward),
                  !1 !== this.timelineNeedsRebuild &&
                    (this.timeline?.pause(),
                    this.buildTimeline({
                      isForward: this.toggleIsForward,
                      isRebuild: !0,
                    }),
                    this.timeline.play());
              }),
              !_.object)
            )
              throw Error("Missing property");
            let N = L.find(_.object);
            if (!N || !N.states || ((this.object = N), _.tweens.length < 2))
              throw Error("Missing property");
            (this.tweens = Array(this.data.tweens.length - 1)),
              (this.startOnceDelay =
                "start-once" === _.tweens[0].data.delayDirection
                  ? _.tweens[0].data.delay
                  : 0),
              this.init();
          }
          get playing() {
            return this.tweens.some((_) => _.changeBegan) ?? !1;
          }
          init() {
            (this.initialCurrentState = py(
              this.object,
              this.object.currentState,
            ).id),
              (this.toggleIsForward = !1);
          }
          get currentState() {
            return this.useToggle
              ? this.initialCurrentState
              : this.object.currentState;
          }
          buildTimeline({ isForward: _ = !0, isRebuild: L = !1 } = {}) {
            try {
              let R = m2(this.data.tweens[0].data),
                N = R.loop;
              L && "number" == typeof R.loop && R.loop--,
                this.timeline?.pause(),
                (this.timeline = fn.timeline({
                  autoplay: !1,
                  ...R,
                  ...(!0 === N || N > 1
                    ? { timelineChangeComplete: this.onTimelineChangeComplete }
                    : {}),
                }));
              let z = this.tweens.findIndex((_) => _?.changeBegan);
              if (
                ((this.timelineNeedsRebuild = -1 !== z && (!0 === N || N > 1)),
                R.pingPongDelayCorrection &&
                  !1 === L &&
                  (this.timelineNeedsRebuild = !0),
                _)
              ) {
                let _ = -1 === z ? 0 : z;
                for (let N = _; N < this.data.tweens.length - 1; N++) {
                  let F = this.data.tweens[N],
                    U = this.data.tweens[N + 1],
                    k;
                  N === _ &&
                  (!0 === this.object.wasMovedByUser ||
                    this.object.previousAction?.playing === !0)
                    ? ((k = void 0),
                      this.object instanceof bj &&
                        (this.object.wasMovedByUser = !1))
                    : (k =
                        void 0 === F.data.state
                          ? this.currentState
                          : F.data.state);
                  let Y = new _c(
                    this.object,
                    k,
                    void 0 === U.data.state ? this.currentState : U.data.state,
                    U.data,
                    this.sharedAssets,
                    this.data.allowSlerp ?? !1,
                  );
                  -1 !== z &&
                    N === _ &&
                    Object.assign(Y.params, { startOnceDelay: 0 }),
                    (this.tweens[N] = Y),
                    this.timeline.add(
                      Y.params,
                      this.timeline.duration +
                        (N === _ ? R.delay : 0) +
                        (N !== _ || L ? 0 : R.pingPongDelayCorrection),
                    );
                }
                this.timeline.duration += R.endDelay;
              } else {
                let _ = -1 === z ? this.data.tweens.length - 1 : z + 1;
                for (let L = _; L > 0; L--) {
                  let N = this.data.tweens[L],
                    F = this.data.tweens[L - 1],
                    U;
                  L === _ &&
                  (!0 === this.object.wasMovedByUser ||
                    this.object.previousAction?.playing === !0)
                    ? ((U = void 0),
                      this.object instanceof bj &&
                        (this.object.wasMovedByUser = !1))
                    : (U =
                        void 0 === N.data.state
                          ? this.currentState
                          : N.data.state);
                  let k = new _c(
                    this.object,
                    U,
                    void 0 === F.data.state ? this.currentState : F.data.state,
                    N.data,
                    this.sharedAssets,
                    this.data.allowSlerp ?? !1,
                  );
                  -1 !== z &&
                    L === _ &&
                    Object.assign(k.params, { startOnceDelay: 0 }),
                    (this.tweens[L - 1] = k),
                    this.timeline.add(
                      k.params,
                      this.timeline.duration + (L === _ ? R.endDelay : 0),
                    );
                }
                this.timeline.duration +=
                  R.delay + (L ? 0 : R.pingPongDelayCorrection);
              }
            } catch (_) {
              _ instanceof Error && console.error(_.message);
            }
            this.object.previousAction?.playing === !0 &&
              this.object.previousAction.pause(),
              (this.object.previousAction = this);
          }
          play() {
            if (this.playing) return !1;
            clearTimeout(this.timeoutId),
              (this.timeoutId = window.setTimeout(() => {
                try {
                  this.buildTimeline(), this.timeline.play();
                } catch (_) {
                  _ instanceof Error && console.error(_.message);
                }
              }, this.startOnceDelay));
          }
          pause() {
            this.timeline?.pause(),
              clearTimeout(this.timeoutId),
              (this.tweens = Array(this.data.tweens.length - 1)),
              delete this.timeoutId;
          }
          stop() {
            this.pause();
            let _ =
              void 0 === this.data.tweens[0].data.state
                ? this.initialCurrentState
                : this.data.tweens[0].data.state;
            this.object.changeSelectedState(_, {
              scene: this.scene,
              shared: this.sharedAssets,
            }),
              (this.object.currentState = _);
          }
          seek(_) {
            void 0 === this.timeline && this.buildTimeline(),
              this.timeline?.seek(_ * this.timeline.duration);
          }
          toggle(_) {
            (this.useToggle = !0),
              clearTimeout(this.timeoutId),
              (this.toggleIsForward = _ ?? !this.toggleIsForward),
              this.playing
                ? (this.timeline?.pause(),
                  this.buildTimeline({ isForward: this.toggleIsForward }),
                  this.timeline.play())
                : (this.timeoutId = window.setTimeout(() => {
                    this.timeline?.pause(),
                      this.buildTimeline({ isForward: this.toggleIsForward }),
                      this.timeline.play();
                  }, this.startOnceDelay));
          }
          playFromCurrent() {
            this.toggle(!0);
          }
          reverseFromCurrent() {
            this.toggle(!1);
          }
          dispose() {
            this.pause();
          }
        };
      function py(_, L) {
        let R, N;
        if (
          ("string" == typeof L
            ? ((R = L), (N = _.states?.[R]))
            : null === L && ((R = null), (N = _.data)),
          !(void 0 === R || void 0 === N))
        )
          return { id: R, data: N };
      }
      function Nr(_, L, R, N, z, F) {
        let U = { Audio: [], Video: [], Link: [], Reset: [], Transition: [] };
        return (
          L.forEach(({ id: L, data: k }) => {
            try {
              "Audio" === k.type
                ? uD[_.type].includes("Audio") &&
                  U.Audio.push(new wB(L, k, R, z))
                : "Video" === k.type
                  ? uD[_.type].includes("Video") &&
                    U.Video.push(new wk(L, k, R))
                  : "Link" === k.type
                    ? uD[_.type].includes("Link") && U.Link.push(new wj(k, F))
                    : "Reset" === k.type
                      ? uD[_.type].includes("Reset") &&
                        U.Reset.push(new wG(N.data, N, z, F))
                      : "Transition" === k.type &&
                        uD[_.type].includes("Transition") &&
                        U.Transition.push(new _d(k, N, z));
            } catch (_) {}
          }),
          U
        );
      }
      function Br(_) {
        Object.values(_).forEach((_) => {
          _.forEach((_) => {
            (_ instanceof wB || _ instanceof wk || _ instanceof _d) &&
              _.dispose();
          });
        });
      }
      var _u = [
          ["start", "Start"],
          ["keyDown", "KeyDown"],
          ["keyUp", "KeyUp"],
          ["mouseDown", "MouseDown"],
          ["mouseUp", "MouseUp"],
          ["mouseHover", "MouseHover"],
          ["collision", "Collision"],
          ["lookAt", "LookAt"],
          ["follow", "Follow"],
          ["scroll", "Scroll"],
        ],
        g2 = (_) => _u.find(([L, R]) => R === _)?.[0],
        Ms = (_) => _u.find(([L]) => L === _)?.[1],
        NW = (_, L) => {
          let R = g2(_);
          if (R) {
            let _ = new CustomEvent(R, { bubbles: !0 });
            return (
              Object.defineProperty(_, "target", { writable: !1, value: L }), _
            );
          }
        },
        _p = class extends wD {
          constructor(_) {
            super(_),
              (this.objectsPerEvents = new Map()),
              (this.splineEvents = {}),
              (this.onBeginEvent = (_) => {
                if (!_.eventName || !_.target || "Scroll" === _.eventName)
                  return;
                let L = this.splineEvents[g2(_.eventName)]?.[_.target.uuid];
                if (!L) return;
                "Scroll" === _.eventName &&
                  void 0 !== _.deltaY &&
                  Object.assign(L, { deltaY: _.deltaY });
                let { domElement: R } = this.eventContext;
                R.dispatchEvent(L);
              });
            let { scene: L } = this.eventContext;
            L.traverseEntity((_) => {
              if (_.data?.events.length) {
                for (let [L, R] of _u)
                  if (
                    _.data.events.some(
                      (_) => _.data.type === R && !_.data.disabled,
                    )
                  ) {
                    this.objectsPerEvents.has(L)
                      ? this.objectsPerEvents.get(L)?.push(_)
                      : this.objectsPerEvents.set(L, [_]);
                    let N = NW(R, { id: _.uuid, name: _.name }),
                      z = this.splineEvents[L];
                    z
                      ? (z[_.uuid] = N)
                      : (this.splineEvents[L] = { [_.uuid]: N });
                  }
              }
            });
          }
          connect() {
            this.objectsPerEvents.forEach((_) => {
              _.forEach((_) => {
                _.addEventListener("beginEvent", this.onBeginEvent);
              });
            });
          }
          disconnect() {
            this.objectsPerEvents.forEach((_) => {
              _.forEach((_) => {
                _.removeEventListener("beginEvent", this.onBeginEvent);
              });
            });
          }
        },
        _f = class {
          constructor(_, L, R, N, z, F) {
            if (
              ((this.id = _),
              (this.data = L),
              (this.object = R),
              (this.entered = !1),
              (this.useToggle = L.toggle),
              ("KeyDown" === L.type ||
                "KeyUp" === L.type ||
                "KeyPress" === L.type) &&
                !L.key)
            )
              throw Error("Missing property");
            this.actions = Nr(L, L.actions, R, N, z, F);
          }
          disconnect() {
            Br(this.actions);
          }
          dispatch() {
            let _ = new Set();
            this.actions.Transition.forEach((L) => {
              L.object.currentTransitionEvent !== this
                ? ((L.object.currentTransitionEvent = this), L.init())
                : !1 === this.useToggle && _.add(L);
            }),
              this.useToggle
                ? this.actions.Transition.forEach((_) => {
                    _.toggle();
                  })
                : "MousePress" === this.data.type ||
                    "KeyPress" === this.data.type
                  ? this.entered ||
                    ((this.entered = !0),
                    this.actions.Transition.forEach((_) => _.playFromCurrent()))
                  : this.actions.Transition.some((_) => _.playing) ||
                    this.actions.Transition.forEach((L) => {
                      !1 === _.has(L) && L.play();
                    }),
              this.actions.Link.forEach((_) => {
                _.dispatch();
              }),
              this.actions.Reset.forEach((_) => {
                _.dispatch();
              }),
              this.actions.Audio.forEach((_) => {
                _.dispatchBasic();
              }),
              this.actions.Video.forEach((_) => {
                _.dispatchBasic();
              });
          }
          dispatchRelease() {
            this.entered &&
              ((this.entered = !1),
              this.actions.Transition.forEach((_) => _.reverseFromCurrent()));
          }
          dispatchUserEvent(_) {
            this.actions.Transition.forEach((_) => {
              _.object.currentTransitionEvent !== this &&
                ((_.object.currentTransitionEvent = this), _.init());
            }),
              _
                ? this.actions.Transition.forEach((_) => _.reverseFromCurrent())
                : this.actions.Transition.forEach((_) => _.playFromCurrent()),
              this.actions.Link.forEach((_) => {
                _.dispatch();
              }),
              this.actions.Reset.forEach((_) => {
                _.dispatch();
              }),
              this.actions.Audio.forEach((_) => {
                _.dispatchBasic();
              }),
              this.actions.Video.forEach((_) => {
                _.dispatchBasic();
              });
          }
        },
        _m = class extends wD {
          constructor(_, L, R) {
            super(_),
              (this.objectsPerTypes = {
                MouseDown: [],
                MouseUp: [],
                MousePress: [],
                KeyDown: [],
                KeyUp: [],
                KeyPress: [],
              }),
              (this.eventsPerObjects = {
                MouseDown: {},
                MouseUp: {},
                MousePress: {},
                KeyDown: {},
                KeyUp: {},
                KeyPress: {},
              }),
              (this.heldKeys = {}),
              (this.heldKeysPress = {}),
              (this._prevObjects = []),
              (this.onMouseDown = (_) => {
                p1.length > 1 ||
                  (this.eventContext.updateRaycaster(_),
                  this.handleMouseEvent("MouseDown"));
              }),
              (this.onMouseUp = (_) => {
                p1.length > 1 ||
                  (this.eventContext.updateRaycaster(_),
                  this.handleMouseEvent("MouseUp"));
              }),
              (this.onMousePressDown = (_) => {
                p1.length > 1 ||
                  (this.eventContext.updateRaycaster(_),
                  this.handleMousePressEvent());
              }),
              (this.onMousePressRelease = (_) => {
                p1.length > 1 ||
                  (this.eventContext.updateRaycaster(_),
                  this.handleMousePressEvent(!0));
              }),
              (this.onKeyDown = (_) => {
                this.heldKeys[_.key] || this.handleKeyEvent(_, "KeyDown"),
                  (this.heldKeys[_.key] = !0);
              }),
              (this.onKeyUp = (_) => {
                this.handleKeyEvent(_, "KeyUp");
              }),
              (this.onKeyPressDown = (_) => {
                this.heldKeysPress[_.key] || this.handleKeyEvent(_, "KeyPress"),
                  (this.heldKeysPress[_.key] = !0);
              }),
              (this.onKeyPressUp = (_) => {
                this.handleKeyEvent(_, "KeyPress", !0);
              }),
              (this.releaseHeldKey = (_) => {
                delete this.heldKeys[_.key];
              }),
              (this.releaseHeldKeyPress = (_) => {
                delete this.heldKeysPress[_.key];
              }),
              (this._onUserEvent = ({
                eventName: _,
                target: L,
                reverse: R,
              }) => {
                if (!_ || !L) return;
                let N = Ms(_);
                N &&
                  ("MouseDown" === N || "MouseUp" === N || "MousePress" === N
                    ? (L.dispatchEvent({ type: "beginEvent", eventName: N }),
                      this.eventsPerObjects[N]?.[L.uuid]?.forEach((_) => {
                        _.dispatchUserEvent(R);
                      }))
                    : ("KeyDown" === N || "KeyUp" === N || "KeyPress" === N) &&
                      (L.dispatchEvent({ type: "beginEvent", eventName: N }),
                      this.eventsPerObjects[N]?.[L.uuid]?.forEach((_) => {
                        _.dispatchUserEvent();
                      })));
              });
            let { scene: N, sharedAssets: z } = this.eventContext;
            N.traverseEntity((_) => {
              if (_.data?.events.length)
                for (let F of _.visible
                  ? [
                      "MouseDown",
                      "MouseUp",
                      "MousePress",
                      "KeyDown",
                      "KeyUp",
                      "KeyPress",
                    ]
                  : ["KeyDown", "KeyUp", "KeyPress"]) {
                  let U = this.eventsPerObjects[F];
                  _.data.events
                    .filter(({ data: _ }) => _.type === F && !0 !== _.disabled)
                    .forEach(({ id: F, data: k }) => {
                      try {
                        let Y = new _f(F, k, _, N, z, {
                          controlsManager: L,
                          eventManager: R,
                        });
                        Y.actions.Video.length && (this.hasVideoAction = !0),
                          U[_.uuid] ? U[_.uuid].push(Y) : (U[_.uuid] = [Y]);
                      } catch (_) {}
                    }),
                    U[_.uuid]?.length && this.objectsPerTypes[F].push(_);
                }
            });
          }
          connect() {
            let { domElement: _ } = this.eventContext;
            (this.heldKeys = {}),
              (this.heldKeysPress = {}),
              this.domEventsNeeded.clear(),
              this.objectsPerTypes.MouseDown?.length &&
                (this.domEventsNeeded.add("pointerdown"),
                _.addEventListener("pointerdown", this.onMouseDown)),
              this.objectsPerTypes.MouseUp?.length &&
                (this.domEventsNeeded.add("pointerup"),
                _.addEventListener("pointerup", this.onMouseUp)),
              this.objectsPerTypes.MousePress?.length &&
                (this.domEventsNeeded.add("pointerdown"),
                _.addEventListener("pointerdown", this.onMousePressDown),
                this.domEventsNeeded.add("pointerup"),
                _.addEventListener("pointerup", this.onMousePressRelease)),
              this.objectsPerTypes.KeyDown?.length &&
                (this.domEventsNeeded.add("keydown"),
                document.addEventListener("keydown", this.onKeyDown),
                document.addEventListener("keyup", this.releaseHeldKey)),
              this.objectsPerTypes.KeyUp?.length &&
                (this.domEventsNeeded.add("keyup"),
                document.addEventListener("keyup", this.onKeyUp)),
              this.objectsPerTypes.KeyPress?.length &&
                (this.domEventsNeeded.add("keydown"),
                document.addEventListener("keydown", this.onKeyPressDown),
                document.addEventListener("keyup", this.releaseHeldKeyPress),
                this.domEventsNeeded.add("keyup"),
                document.addEventListener("keyup", this.onKeyPressUp)),
              Object.entries(this.objectsPerTypes).forEach(([_, L]) => {
                L.forEach((_) => {
                  _.addEventListener("userEvent", this._onUserEvent);
                });
              });
          }
          disconnect() {
            let { domElement: _ } = this.eventContext;
            this.domEventsNeeded.clear(),
              (this.heldKeys = {}),
              (this.heldKeysPress = {}),
              _.removeEventListener("pointerdown", this.onMouseDown),
              _.removeEventListener("pointerdown", this.onMousePressDown),
              _.removeEventListener("pointerup", this.onMouseUp),
              _.removeEventListener("pointerup", this.onMousePressRelease),
              document.removeEventListener("keydown", this.onKeyDown),
              document.removeEventListener("keyup", this.onKeyUp),
              document.removeEventListener("keydown", this.onKeyPressDown),
              document.removeEventListener("keyup", this.onKeyPressUp),
              document.removeEventListener("keyup", this.releaseHeldKey),
              Object.values(this.eventsPerObjects).forEach((_) => {
                Object.values(_).forEach((_) => {
                  _.forEach((_) => {
                    _.disconnect();
                  });
                });
              }),
              Object.entries(this.objectsPerTypes).forEach(([_, L]) => {
                L.forEach((_) => {
                  _.removeEventListener("userEvent", this._onUserEvent);
                });
              });
          }
          handleMouseEvent(_) {
            let { stopRaycast: L, raycaster: R, scene: N } = this.eventContext,
              z = this.objectsPerTypes[_];
            z.length &&
              (L
                ? gf(mf(R, N, z)).forEach((L) => {
                    this.eventsPerObjects[_][L.uuid] &&
                      this.handleObjectMouseEventDispatch(L, _);
                  })
                : z.forEach((L) => {
                    ju(R, L) && this.handleObjectMouseEventDispatch(L, _);
                  }));
          }
          handleMousePressEvent(_ = !1) {
            let L = "MousePress",
              R = this.objectsPerTypes[L],
              N = [];
            if (R.length) {
              if (!_) {
                let {
                  stopRaycast: _,
                  raycaster: L,
                  scene: z,
                } = this.eventContext;
                _
                  ? (N = gf(mf(L, z, R)))
                  : R.forEach((_) => {
                      ju(L, _) && N.push(_);
                    });
              }
              this._prevObjects.length &&
                this._prevObjects.forEach((_) => {
                  N.includes(_) ||
                    this.handleObjectMouseEventDispatchRelease(_, L);
                }),
                N.length &&
                  N.forEach((_) => {
                    this.handleObjectMouseEventDispatch(_, L);
                  }),
                (this._prevObjects = N);
            }
          }
          handleObjectMouseEventDispatch(_, L) {
            _.dispatchEvent({ type: "beginEvent", eventName: L }),
              this.eventsPerObjects[L]?.[_.uuid]?.forEach((_) => {
                _.dispatch();
              });
          }
          handleObjectMouseEventDispatchRelease(_, L) {
            _.dispatchEvent({ type: "beginEvent", eventName: L }),
              this.eventsPerObjects[L]?.[_.uuid]?.forEach((_) => {
                _.dispatchRelease();
              });
          }
          handleKeyEvent(_, L, R = !1) {
            this.objectsPerTypes[L].forEach((N) => {
              let z = this.eventsPerObjects[L][N.uuid];
              z.some(({ data: L }) => "key" in L && L.key === _.key) &&
                N.dispatchEvent({ type: "beginEvent", eventName: L }),
                z.forEach((L) => {
                  "key" in L.data &&
                    L.data.key === _.key &&
                    (R ? L.dispatchRelease() : L.dispatch());
                });
            });
          }
        },
        _g = new iq(),
        _v = new iq(),
        _y = class {
          constructor(_, L, R, N) {
            (this.actionsIn = Nr(_, _.inActions, L, R, N)),
              (this.actionsOut = Nr(_, _.outActions, L, R, N));
          }
          disconnect() {
            Br(this.actionsIn), Br(this.actionsOut);
          }
        },
        _x = class extends _y {
          constructor(_, L, R, N, z) {
            super(L, R, N, z),
              (this.id = _),
              (this.data = L),
              (this.object = R),
              (this.stage = "out"),
              (this.objects = []),
              (this.onUpdateMatrix = () => {
                let _ = _g.setFromMatrixPosition(this.objects[0].matrixWorld),
                  L = _v.setFromMatrixPosition(this.objects[1].matrixWorld),
                  R = _.distanceTo(L) <= this.distance ? "in" : "out";
                if (this.stage !== R) {
                  let _ = "in" === R ? this.actionsIn : this.actionsOut;
                  _.Audio.forEach((_) => _.dispatchConditional()),
                    _.Video.forEach((_) => _.dispatchConditional()),
                    _.Transition.forEach((_) => {
                      _.object.currentTransitionEvent !== this &&
                        (_.object.currentTransitionEvent = this),
                        _.init();
                    }),
                    _.Transition.forEach((_) => _.play()),
                    (this.stage = R);
                }
              });
            let { distance: F, fromObject: U, toObject: k } = L.condition;
            for (let _ of ((this.distance = F), [U, k])) {
              if (!_) throw Error("Missing property");
              let L = N.find(_);
              if (!L) throw Error("Missing property");
              this.objects.push(L);
            }
          }
          connect() {
            this.objects.forEach((_) => {
              _.addEventListener("updateMatrix", this.onUpdateMatrix);
            }),
              this.onUpdateMatrix();
          }
          disconnect() {
            super.disconnect(),
              (this.stage = "out"),
              this.objects.forEach((_) => {
                _.removeEventListener("updateMatrix", this.onUpdateMatrix);
              });
          }
        },
        _b = class extends _y {
          constructor(_, L, R, N, z) {
            super(L, R, N, z),
              (this.id = _),
              (this.data = L),
              (this.object = R),
              (this.onBegin = ({ target: _, state: L }) => {
                this.toState !== L &&
                  (this.actionsOut.Audio.forEach((_) =>
                    _.dispatchConditional(),
                  ),
                  this.actionsOut.Video.forEach((_) => _.dispatchConditional()),
                  this.actionsIn.Transition.forEach((_) => _.pause()),
                  (this.object.currentTransitionEvent = this),
                  this.actionsOut.Transition.forEach((_) => _.play()));
              }),
              (this.onComplete = ({ target: _, state: L }) => {
                this.toState === L &&
                  (this.actionsIn.Audio.forEach((_) => _.dispatchConditional()),
                  this.actionsIn.Video.forEach((_) => _.dispatchConditional()),
                  this.actionsOut.Transition.forEach((_) => _.pause()),
                  (this.object.currentTransitionEvent = this),
                  this.actionsIn.Transition.forEach((_) => _.play()));
              });
            let { condition: F } = L;
            if (!F.object) throw Error("Missing property");
            let U = N.find(F.object);
            if (
              !U ||
              ((this.toObject = U), F.state && !this.toObject.states?.[F.state])
            )
              throw Error("Missing property");
            this.toState = F.state;
          }
          connect() {
            (this.actionsOut.Audio.length ||
              this.actionsOut.Video.length ||
              this.actionsOut.Transition.length) &&
              this.toObject.addEventListener("beginState", this.onBegin),
              (this.actionsIn.Audio.length ||
                this.actionsIn.Video.length ||
                this.actionsIn.Transition.length) &&
                this.toObject.addEventListener(
                  "completeState",
                  this.onComplete,
                );
          }
          disconnect() {
            super.disconnect(),
              (this.actionsOut.Audio.length ||
                this.actionsOut.Video.length ||
                this.actionsOut.Transition.length) &&
                this.toObject.removeEventListener("beginState", this.onBegin),
              (this.actionsIn.Audio.length ||
                this.actionsIn.Video.length ||
                this.actionsIn.Transition.length) &&
                this.toObject.removeEventListener(
                  "completeState",
                  this.onComplete,
                );
          }
        },
        _w = class extends wD {
          constructor(_) {
            super(_),
              (this.eventsPerConditions = {
                Comparison: [],
                Distance: [],
                State: [],
              }),
              (this.hasVideoAction = !1);
            let { scene: L, sharedAssets: R } = this.eventContext;
            L.traverseEntity((_) => {
              if (_.data?.events.length) {
                for (let { id: N, data: z } of _.data.events)
                  if (!z.disabled && "Conditional" === z.type)
                    try {
                      let F;
                      "Comparison" === z.condition.type ||
                        ("Distance" === z.condition.type
                          ? (F = new _x(N, z, _, L, R))
                          : "State" === z.condition.type &&
                            (F = new _b(N, z, _, L, R))),
                        F &&
                          (this.eventsPerConditions[z.condition.type].push(F),
                          (F.actionsIn.Video.length ||
                            F.actionsOut.Video.length) &&
                            (this.hasVideoAction = !0));
                    } catch (_) {}
              }
            });
          }
          connect() {
            super.connect(),
              Object.values(this.eventsPerConditions).forEach((_) =>
                _.forEach((_) => _.connect()),
              );
          }
          disconnect() {
            super.disconnect(),
              Object.values(this.eventsPerConditions).forEach((_) =>
                _.forEach((_) => _.disconnect()),
              );
          }
        },
        _S = new iq(),
        _M = new iq(),
        _E = new iq(),
        _T = new iq(),
        _C = new s6(),
        _P = { type: "requestRender" },
        _D =
          ((tQ = new iq()),
          (tZ = new iq()),
          (_, L, R) =>
            R > 0
              ? (tQ.subVectors(_, L),
                tQ.length() <= R
                  ? _
                  : tZ.copy(L).add(tQ.normalize().multiplyScalar(R)))
              : L),
        _O =
          ((tK = new rw()),
          (_, L) => {
            _.position.copy(L),
              null !== _.parent &&
                (tK.copy(_.parent.matrixWorld).invert(),
                _.position.applyMatrix4(tK)),
              tK.copy(_.hiddenMatrix).invert(),
              _.position.applyMatrix4(tK),
              _.updateMatrix(),
              _.hasNonUniformScale &&
                (_.updateMatrixWorld(), _.updateMatrixWorldSVD()),
              _ instanceof v6 &&
                ei(_.parent) &&
                _.invalidateDownstreamBooleanData(!0);
          }),
        _L = class {
          constructor(_, L, R) {
            (this.data = _),
              (this.object = L),
              (this.paused = !1),
              (this.currentDampingFactor = 1),
              (this.snapComplete = !1),
              (this.isReset = !1),
              (this.worldPosition0 = new iq()),
              (this.timeoutId = null),
              (this.delayFinished = !0),
              (this.wasOutside = !1),
              (this.data = {
                ...pr.defaultData,
                ..._,
                ...(void 0 === _.resetOnPointerLeave && {
                  resetOnPointerLeave: !1,
                }),
              }),
              void 0 === _.target ||
                "cursor" === _.target ||
                ("personal camera" === _.target
                  ? (this.target = R.find(wh.PERSONAL_CAMERA_ID))
                  : (this.target = R.find(_.target))),
              this.data.dampingFactor &&
                (this.currentDampingFactor = this.data.dampingFactor),
              (this.resetDampingFactor = 80 / this.data.resetSpeed + 1),
              this.object.getWorldPosition(this.worldPosition0);
          }
        },
        _I = class extends wD {
          constructor(_) {
            super(_),
              (this.events = []),
              (this.pairOfEventListeners = []),
              (this.onMouseMove = (_) => {
                if (!(p1.length > 1))
                  for (let L of (this.eventContext.updateRaycaster(_),
                  this.events))
                    void 0 === L.target && this.updateSingleEvent(L);
              }),
              (this.onMouseEnter = (_) => {
                for (let _ of this.events)
                  void 0 === _.target &&
                    ((_.isReset = !1),
                    (_.currentDampingFactor = _.data.dampingFactor));
              }),
              (this.onMouseLeave = (_) => {
                for (let _ of this.events)
                  void 0 === _.target &&
                    (_.data.resetOnPointerLeave &&
                      ((_.isReset = !0),
                      (_.currentDampingFactor = _.resetDampingFactor)),
                    this.updateSingleEvent(_));
              }),
              (this.onTargetChange = (_) => () => {
                this.updateSingleEvent(_);
              });
            let { scene: L } = this.eventContext;
            L.traverseEntity((_) => {
              let R = _.data?.events.find(
                (_) => "Follow" === _.data.type && !_.data.disabled,
              );
              R &&
                (!L.data.environment.usePhysics ||
                  _.dataPatched.physics?.rigidBody !== "dynamic") &&
                this.events.push(new _L(R.data, _, L));
            });
          }
          connect() {
            if (!this.events.length) return;
            let { domElement: _, eventElement: L } = this.eventContext;
            for (let R of (this.domEventsNeeded.clear(),
            pJ &&
              (this.domEventsNeeded.add("pointerdown"),
              _.addEventListener("pointerdown", this.onMouseMove)),
            this.domEventsNeeded.add("pointermove"),
            L.addEventListener("pointermove", this.onMouseMove),
            this.eventContext.useWindowEvents ||
              (_.addEventListener("pointerenter", this.onMouseEnter),
              _.addEventListener("pointerleave", this.onMouseLeave)),
            this.events))
              if (void 0 !== R.target) {
                let _ = R.target,
                  L = this.onTargetChange(R);
                this.pairOfEventListeners.push([_, L]),
                  _.addEventListener("requestRender", L);
              }
          }
          disconnect() {
            if (!this.events.length) return;
            let { domElement: _, eventElement: L } = this.eventContext;
            for (let [R, N] of (this.domEventsNeeded.clear(),
            pJ && _.removeEventListener("pointerdown", this.onMouseMove),
            L.removeEventListener("pointermove", this.onMouseMove),
            _.removeEventListener("pointerenter", this.onMouseEnter),
            _.removeEventListener("pointerleave", this.onMouseLeave),
            this.pairOfEventListeners))
              R.removeEventListener("requestRender", N);
            for (let _ of this.events) (_.paused = !0), (_.isReset = !1);
          }
          onAnimationFrameDamping() {
            for (let _ of this.events) _.paused || this.updateSingleEvent(_);
          }
          updateSingleEvent(_) {
            let {
              plane: L,
              limitDistance: R,
              limitDistanceEnabled: N,
            } = _.data;
            if ((_.object.getWorldPosition(_E), _.isReset))
              _T.copy(_.worldPosition0);
            else if (_.target) _.target.getWorldPosition(_T);
            else {
              let { camera: _, raycaster: R } = this.eventContext;
              if (
                ("custom" === L
                  ? (_.getWorldDirection(_M), _M.negate(), _S.copy(_M))
                  : "xy" === L
                    ? _S.set(0, 0, 1)
                    : "xz" === L
                      ? _S.set(0, 1, 0)
                      : "yz" === L && _S.set(1, 0, 0),
                _C.setFromNormalAndCoplanarPoint(_S, _E),
                !R.ray.intersectPlane(_C, _T))
              )
                return;
            }
            if (!_.isReset) {
              if (_T.distanceTo(_.worldPosition0) > R && N && _.target) {
                if (
                  ((_.snapComplete = !1),
                  _.data.snapDelay &&
                    ((_.delayFinished = !1),
                    "u" > typeof window &&
                      null !== _.timeoutId &&
                      (window.clearTimeout(_.timeoutId), (_.timeoutId = null))),
                  (_.wasOutside = !0),
                  !_.data.resetAfterDistanceLimit)
                )
                  return;
                _T.copy(_.worldPosition0),
                  (_.currentDampingFactor = _.resetDampingFactor);
              } else if (
                (_.wasOutside &&
                  (_.data.snapDelay &&
                    "u" > typeof window &&
                    (_.timeoutId = window.setTimeout(() => {
                      (_.delayFinished = !0),
                        (_.paused = !1),
                        this.updateSingleEvent(_);
                    }, 1e3 * _.data.snapDelay)),
                  (_.currentDampingFactor = _.data.dampingFactor),
                  (_.wasOutside = !1)),
                !1 === _.delayFinished)
              )
                return;
            }
            !1 === _.data.enabledTranslation[0] && (_T.x = _E.x),
              !1 === _.data.enabledTranslation[1] && (_T.y = _E.y),
              !1 === _.data.enabledTranslation[2] && (_T.z = _E.z);
            let z = _D(_E, _T, _.wasOutside ? 0 : _.data.maxDelta);
            if (_.currentDampingFactor > 1) {
              let L = _S.subVectors(z, _E).divideScalar(_.currentDampingFactor);
              _E.add(L), _O(_.object, _E), (_.paused = 0.01 > L.length());
            } else _O(_.object, z), (_.paused = !0);
            _.object?.dispatchEvent({
              type: "beginEvent",
              eventName: "Follow",
            }),
              _.object.dispatchEvent(_P);
          }
        },
        _B = new iq(),
        _N = new iq(),
        _z = new rw(),
        _F = new iX(),
        _U = new iX(),
        _k = new iq(),
        _j = new iq(),
        _G = new iq(),
        _V = new iq(),
        _W = new s6(),
        _Y = { type: "requestRender" },
        _X = { type: "changeRotation" },
        _q =
          ((tJ = new rw()),
          function (_, L) {
            null !== _.parent
              ? tJ.multiplyMatrices(_.parent.matrixWorld, _.hiddenMatrix)
              : tJ.copy(_.hiddenMatrix),
              L.premultiply(eS(tJ).invert()),
              _.rotation.setFromRotationMatrix(L),
              _.updateMatrix(),
              _ instanceof v6 &&
                ei(_.parent) &&
                _.invalidateDownstreamBooleanData(!0);
          }),
        _Q = class {
          constructor(_, L, R) {
            (this.object = L),
              (this.paused = !1),
              (this.currentDampingFactor = 1),
              (this.isReset = !1),
              (this.worldQuaternion0 = new iX()),
              (this.timeoutId = null),
              (this.delayFinished = !0),
              (this.wasOutside = !1),
              (this.data = {
                ...pn.defaultData,
                ..._,
                ...(void 0 === _.resetOnPointerLeave && {
                  resetOnPointerLeave: !1,
                }),
              }),
              void 0 === _.target ||
                "cursor" === _.target ||
                ("personal camera" === _.target
                  ? (this.target = R.find(wh.PERSONAL_CAMERA_ID))
                  : (this.target = R.find(_.target))),
              this.data.dampingFactor &&
                (this.currentDampingFactor = this.data.dampingFactor),
              this.object.getWorldQuaternion(this.worldQuaternion0),
              (this.resetDampingFactor = 80 / this.data.resetSpeed + 1);
          }
        },
        _Z = class extends wD {
          constructor(_) {
            super(_),
              (this.events = []),
              (this.pairOfEventListeners = []),
              (this.pairOfUserEventListeners = []),
              (this.onMouseMove = (_) => {
                if (!(p1.length > 1))
                  for (let L of ((this._lastMouseEvent = _),
                  this.eventContext.updateRaycaster(_),
                  this.events))
                    void 0 === L.target && this.updateSingleEvent(L);
              }),
              (this.onMouseEnter = (_) => {
                for (let _ of this.events)
                  void 0 === _.target &&
                    ((_.isReset = !1),
                    (_.currentDampingFactor = _.data.dampingFactor));
              }),
              (this.onMouseLeave = (_) => {
                for (let _ of this.events)
                  void 0 === _.target &&
                    (_.data.resetOnPointerLeave &&
                      ((_.isReset = !0),
                      (_.currentDampingFactor = _.resetDampingFactor)),
                    this.updateSingleEvent(_));
              }),
              (this.onScroll = (_) => {
                if (this._lastMouseEvent) {
                  let _ = new PointerEvent("pointermove", {
                    clientX: this._lastMouseEvent.clientX,
                    clientY: this._lastMouseEvent.clientY,
                    bubbles: !0,
                    cancelable: !0,
                    view: window,
                  });
                  this.eventContext.eventElement.dispatchEvent(_);
                }
              }),
              (this.onTargetChange = (_) => () => {
                this.updateSingleEvent(_);
              }),
              (this.createUserEventListener =
                (_) =>
                ({ eventName: L, target: R }) => {
                  if (!L || !R) return;
                  let N = Ms(L);
                  N && "LookAt" === N && this.updateSingleEvent(_);
                });
            let { scene: L } = this.eventContext;
            L.traverseEntity((_) => {
              let R = _.data?.events.find(
                (_) => "LookAt" === _.data.type && !_.data.disabled,
              );
              R &&
                (!L.data.environment.usePhysics ||
                  _.dataPatched.physics?.rigidBody !== "dynamic") &&
                this.events.push(new _Q(R.data, _, L));
            });
          }
          connect() {
            if (!this.events.length) return;
            let { domElement: _, eventElement: L } = this.eventContext;
            for (let R of (this.domEventsNeeded.clear(),
            pJ &&
              (this.domEventsNeeded.add("pointerdown"),
              _.addEventListener("pointerdown", this.onMouseMove)),
            this.domEventsNeeded.add("pointermove"),
            L.addEventListener("pointermove", this.onMouseMove),
            this.eventContext.useWindowEvents
              ? L.addEventListener("scroll", this.onScroll)
              : (_.addEventListener("pointerenter", this.onMouseEnter),
                _.addEventListener("pointerleave", this.onMouseLeave)),
            this.events)) {
              if (void 0 !== R.target) {
                let _ = this.onTargetChange(R),
                  L = R.target;
                this.pairOfEventListeners.push([L, _]),
                  L.addEventListener("requestRender", _);
              }
              let _ = this.createUserEventListener(R),
                L = R.object;
              this.pairOfUserEventListeners.push([L, _]),
                L.addEventListener("userEvent", _);
            }
          }
          disconnect() {
            if (!this.events.length) return;
            let { domElement: _, eventElement: L } = this.eventContext;
            for (let [R, N] of (this.domEventsNeeded.clear(),
            pJ && _.removeEventListener("pointerdown", this.onMouseMove),
            L.removeEventListener("pointermove", this.onMouseMove),
            _.removeEventListener("pointerenter", this.onMouseEnter),
            _.removeEventListener("pointerleave", this.onMouseLeave),
            L.removeEventListener("scroll", this.onScroll),
            this.pairOfEventListeners))
              R.removeEventListener("requestRender", N);
            for (let [_, L] of this.pairOfUserEventListeners)
              _.removeEventListener("userEvent", L);
            for (let _ of this.events) (_.paused = !0), (_.isReset = !1);
          }
          onAnimationFrameDamping() {
            for (let _ of this.events) _.paused || this.updateSingleEvent(_);
          }
          updateSingleEvent(_) {
            let {
                tilt: L,
                axis: R,
                distance: N,
                plane: z,
                limitDistance: F,
                enabledRotation: U,
                limitDistanceEnabled: k,
              } = _.data,
              { camera: Y, raycaster: X } = this.eventContext,
              { object: Q, target: K } = _;
            if ((Q.getWorldPosition(_k), !_.isReset)) {
              if (_.target) _.target.getWorldPosition(_j);
              else {
                if (
                  ("custom" === z
                    ? (Y.getWorldDirection(_N),
                      _N.negate(),
                      _W.setFromNormalAndCoplanarPoint(_N, _k))
                    : ("xy" === z
                        ? _B.set(0, 0, 1)
                        : "xz" === z
                          ? _B.set(0, 1, 0)
                          : "yz" === z && _B.set(1, 0, 0),
                      _W.setFromNormalAndCoplanarPoint(_B, _k)),
                  !X.ray.intersectPlane(_W, _j))
                )
                  return;
                N > 0 &&
                  ("custom" === z || void 0 === z) &&
                  _j.addScaledVector(_N, N);
              }
            }
            if (
              (_.isReset ||
                (K
                  ? "target" === L
                    ? _G
                        .copy(K.up)
                        .applyMatrix4(_z.extractRotation(K.matrixWorld))
                        .normalize()
                    : U.some((_) => !1 === _)
                      ? ("x" === R
                          ? (_V.set(0, 0, 1), !1 === U[2] && _V.set(0, 1, 0))
                          : "y" === R
                            ? (_V.set(1, 0, 0), !1 === U[0] && _V.set(0, 0, 1))
                            : (_V.set(0, 1, 0), !1 === U[1] && _V.set(1, 0, 0)),
                        _G
                          .copy(_V)
                          .applyQuaternion(_.worldQuaternion0)
                          .normalize())
                      : _G.set(0, 1, 0)
                  : "custom" === z
                    ? _G.set(0, 1, 0)
                    : _G.copy(_B)),
              _.isReset)
            )
              _U.copy(_.worldQuaternion0);
            else if (_k.distanceTo(_j) > F && k && K) {
              if (
                (_.data.snapDelay &&
                  ((_.delayFinished = !1),
                  "u" > typeof window &&
                    null !== _.timeoutId &&
                    (window.clearTimeout(_.timeoutId), (_.timeoutId = null))),
                (_.wasOutside = !0),
                !_.data.resetAfterDistanceLimit)
              )
                return;
              _U.copy(_.worldQuaternion0),
                (_.currentDampingFactor = _.resetDampingFactor);
            } else {
              let N;
              if (
                (_.wasOutside &&
                  (_.data.snapDelay &&
                    "u" > typeof window &&
                    (_.timeoutId = window.setTimeout(() => {
                      (_.delayFinished = !0),
                        (_.paused = !1),
                        this.updateSingleEvent(_);
                    }, 1e3 * _.data.snapDelay)),
                  (_.currentDampingFactor = _.data.dampingFactor),
                  (_.wasOutside = !1)),
                !1 === _.delayFinished)
              )
                return;
              (N = _z.elements),
                _$.subVectors(_j, _k),
                0 === _$.lengthSq() && (_$.z = 1),
                _$.normalize(),
                _J.crossVectors(_G, _$),
                0 === _J.lengthSq() &&
                  (1 === Math.abs(_G.z) ? (_$.x += 1e-4) : (_$.z += 1e-4),
                  _$.normalize(),
                  _J.crossVectors(_G, _$)),
                _J.normalize(),
                _K.crossVectors(_$, _J),
                "x" === R
                  ? 1 === _V.z
                    ? ([_J, _K, _$] = [_$, _J, _K])
                    : (_J.negate(), ([_J, _$] = [_$, _J]))
                  : "y" === R
                    ? 1 === _V.x
                      ? ([_J, _K, _$] = [_K, _$, _J])
                      : (_J.negate(), ([_K, _$] = [_$, _K]))
                    : 1 === _V.x && (_J.negate(), ([_J, _K] = [_K, _J])),
                (N[0] = _J.x),
                (N[4] = _K.x),
                (N[8] = _$.x),
                (N[1] = _J.y),
                (N[5] = _K.y),
                (N[9] = _$.y),
                (N[2] = _J.z),
                (N[6] = _K.z),
                (N[10] = _$.z),
                _U.setFromRotationMatrix(_z),
                _F.setFromUnitVectors(_V.applyQuaternion(_U), _G),
                U.some((_) => !1 === _) &&
                  "target" !== L &&
                  _U.premultiply(_F).normalize();
            }
            _.currentDampingFactor > 1
              ? (Q.updateWorldMatrix(!0, !1),
                _F.setFromRotationMatrix(eS(Q.matrixWorld)),
                _F.slerp(_U, 1 / _.currentDampingFactor),
                _q(Q, _z.makeRotationFromQuaternion(_F)),
                (_.paused = 8 * (1 - _F.dot(_U)) < 1e-6))
              : (_q(Q, _z.makeRotationFromQuaternion(_U)), (_.paused = !0)),
              _.object?.dispatchEvent({
                type: "beginEvent",
                eventName: "LookAt",
              }),
              Q.dispatchEvent(_Y),
              Q.dispatchEvent(_X);
          }
        },
        _K = new iq(),
        _J = new iq(),
        _$ = new iq(),
        _0 = class {
          constructor(_, L, R, N, z) {
            (this.id = _),
              (this.data = L),
              (this.object = R),
              (this.entered = !1),
              (this.actions = Nr(L, L.actions, R, N, z));
          }
          disconnect() {
            Br(this.actions);
          }
          dispatchEnter() {
            this.actions.Transition.forEach((_) => {
              _.object.currentTransitionEvent !== this &&
                ((_.object.currentTransitionEvent = this), _.init());
            }),
              this.entered ||
                ((this.entered = !0),
                this.actions.Transition.forEach((_) => _.playFromCurrent()));
          }
          dispatchLeave() {
            this.actions.Transition.forEach((_) => {
              _.object.currentTransitionEvent !== this &&
                ((_.object.currentTransitionEvent = this), _.init());
            }),
              this.entered &&
                ((this.entered = !1),
                this.actions.Transition.forEach((_) => _.reverseFromCurrent()));
          }
          dispatchUserEvent(_) {
            this.actions.Transition.forEach((_) => {
              _.object.currentTransitionEvent !== this &&
                ((_.object.currentTransitionEvent = this), _.init());
            }),
              _
                ? this.actions.Transition.forEach((_) => _.reverseFromCurrent())
                : this.actions.Transition.forEach((_) => _.playFromCurrent());
          }
        },
        _2 = class extends wD {
          constructor(_) {
            super(_),
              (this.eventsPerObjects = {}),
              (this.objects = []),
              (this._prevObjects = []),
              (this.onMouseDown = (_) => {
                p1.length > 1 ||
                  (this.eventContext.updateRaycaster(_),
                  this.handleMouseHoverEvent());
              }),
              (this.onMouseUp = (_) => {
                p1.length > 1 || this.handleMouseHoverEvent(!0);
              }),
              (this.onMouseMove = (_) => {
                p1.length > 1 ||
                  (this.eventContext.updateRaycaster(_),
                  this.handleMouseHoverEvent());
              }),
              (this.onUserEvent = ({ eventName: _, target: L, reverse: R }) => {
                if (!_ || !L) return;
                let N = Ms(_);
                N &&
                  "MouseHover" === N &&
                  (L.dispatchEvent({
                    type: "beginEvent",
                    eventName: "MouseHover",
                  }),
                  this.eventsPerObjects[L.uuid]?.forEach((_) =>
                    _.dispatchUserEvent(R),
                  ));
              });
            let { scene: L, sharedAssets: R } = this.eventContext;
            L.traverseEntity((_) => {
              if (!(!_.visible || !_.data?.events.length)) {
                for (let { id: N, data: z } of _.data.events)
                  if (!z.disabled && "MouseHover" === z.type)
                    try {
                      let F = new _0(N, z, _, L, R);
                      this.eventsPerObjects[_.uuid]
                        ? this.eventsPerObjects[_.uuid].push(F)
                        : (this.eventsPerObjects[_.uuid] = [F]);
                    } catch (_) {}
                this.eventsPerObjects[_.uuid]?.length && this.objects.push(_);
              }
            });
          }
          connect() {
            if (!this.objects.length) return;
            let { domElement: _ } = this.eventContext;
            this.domEventsNeeded.clear(),
              pJ &&
                (this.domEventsNeeded.add("pointerdown"),
                _.addEventListener("pointerdown", this.onMouseDown),
                this.domEventsNeeded.add("pointerup"),
                _.addEventListener("pointerup", this.onMouseUp)),
              this.domEventsNeeded.add("pointermove"),
              _.addEventListener("pointermove", this.onMouseMove),
              this.objects.forEach((_) => {
                _.addEventListener("userEvent", this.onUserEvent);
              });
          }
          disconnect() {
            if (!this.objects.length) return;
            let { domElement: _ } = this.eventContext;
            this.domEventsNeeded.clear(),
              pJ &&
                (_.removeEventListener("pointerdown", this.onMouseDown),
                _.removeEventListener("pointerup", this.onMouseUp)),
              _.removeEventListener("pointermove", this.onMouseMove),
              Object.values(this.eventsPerObjects).forEach((_) => {
                _.forEach((_) => {
                  _.disconnect();
                });
              }),
              this.objects.forEach((_) => {
                _.removeEventListener("userEvent", this.onUserEvent);
              });
          }
          handleMouseHoverEvent(_ = !1) {
            let L = [];
            if (!_) {
              let {
                stopRaycast: _,
                raycaster: R,
                scene: N,
              } = this.eventContext;
              _
                ? (L = gf(mf(R, N, this.objects)))
                : this.objects.forEach((_) => {
                    ju(R, _) && L.push(_);
                  });
            }
            this._prevObjects.length &&
              this._prevObjects.forEach((_) => {
                L.includes(_) ||
                  (_.dispatchEvent({
                    type: "beginEvent",
                    eventName: "MouseHover",
                  }),
                  this.eventsPerObjects[_.uuid]?.forEach((_) =>
                    _.dispatchLeave(),
                  ));
              }),
              L.length &&
                L.forEach((_) => {
                  _.dispatchEvent({
                    type: "beginEvent",
                    eventName: "MouseHover",
                  }),
                    this.eventsPerObjects[_.uuid]?.forEach((_) =>
                      _.dispatchEnter(),
                    );
                }),
              (this._prevObjects = L);
          }
        },
        _4 = class {
          constructor(_, L, R, N, z) {
            (this.id = _),
              (this.data = L),
              (this.object = R),
              (this.scrollCounter = 0),
              (this.actions = Nr(L, L.actions, R, N, z));
          }
          connect() {
            this.scrollCounter = 0;
          }
          disconnect() {
            Br(this.actions);
          }
          dispatch(_) {
            this.actions.Transition.forEach((_) => {
              _.object.currentTransitionEvent !== this &&
                ((_.object.currentTransitionEvent = this), _.init());
            }),
              (this.scrollCounter += _ > 0 ? 1 : -1),
              (this.scrollCounter = Math.min(
                Math.max(this.scrollCounter, 0),
                this.data.steps,
              ));
            let L = this.scrollCounter / this.data.steps;
            this.actions.Transition.forEach((_) => _.seek(L));
          }
          dispatchUserEvent(_) {
            this.actions.Transition.forEach((_) => {
              _.object.currentTransitionEvent !== this &&
                ((_.object.currentTransitionEvent = this), _.init());
            }),
              _
                ? this.actions.Transition.forEach((_) => _.reverseFromCurrent())
                : this.actions.Transition.forEach((_) => {
                    _.playFromCurrent();
                  });
          }
        },
        _6 = class {
          constructor(_, L, R, N, z, F) {
            (this.id = _),
              (this.data = L),
              (this.object = R),
              (this.domElement = F),
              (this.scrollStart = 0),
              (this.scrollEnd = 0),
              (this.actions = Nr(L, L.actions, R, N, z));
          }
          computeScrollBounds() {
            let _ = this.domElement.getBoundingClientRect(),
              L = document.body,
              R = document.documentElement,
              N = window.pageYOffset || R.scrollTop || L.scrollTop,
              z = R.clientTop || L.clientTop || 0,
              F = Math.round(_.top + N - z);
            if ("enter" === this.data.startFrom) {
              let L = window.innerHeight,
                R = _.height,
                N = this.data.enterAnchor;
              this.scrollStart =
                F - ("top" === N ? L : "bottom" === N ? L - R : L - 0.5 * R);
            } else this.scrollStart = 0;
            (this.scrollStart += this.data.startOffset ?? 0),
              (this.scrollEnd = this.scrollStart + (this.data.endAfter ?? 400)),
              this.dispatch({ x: window.scrollX, y: window.scrollY });
          }
          connect() {
            this.computeScrollBounds();
          }
          disconnect() {
            Br(this.actions);
          }
          handleResize() {
            this.computeScrollBounds();
          }
          dispatch({ x: _, y: L }) {
            this.actions.Transition.forEach((_) => {
              _.object.currentTransitionEvent !== this &&
                ((_.object.currentTransitionEvent = this), _.init());
            });
            let R = this.scrollEnd - this.scrollStart,
              N = Math.min(1, Math.max(0, (L - this.scrollStart) / R));
            this.actions.Transition.forEach((_) => _.seek(N));
          }
          dispatchUserEvent(_) {
            this.actions.Transition.forEach((_) => {
              _.object.currentTransitionEvent !== this &&
                ((_.object.currentTransitionEvent = this), _.init());
            }),
              _
                ? this.actions.Transition.forEach((_) => _.reverseFromCurrent())
                : this.actions.Transition.forEach((_) => {
                    _.playFromCurrent();
                  });
          }
        },
        _8 = class extends wD {
          constructor(_) {
            super(_),
              (this.wheelEventsPerObject = new Map()),
              (this.scrollEventsPerObject = new Map()),
              (this.isInview = !0),
              (this.handleResize = () => {
                [...this.scrollEventsPerObject.entries()].forEach(([_, L]) => {
                  L.forEach((_) => _.handleResize());
                });
              }),
              (this.onScroll = (_) => {
                if (!this.isInview) return;
                let L = { y: window.scrollY, x: window.scrollX };
                [...this.scrollEventsPerObject.entries()].forEach(([_, R]) => {
                  _.dispatchEvent({
                    type: "beginEvent",
                    eventName: "Scroll",
                    scroll: L,
                  }),
                    R.forEach((_) => _.dispatch(L));
                });
              }),
              (this.onWheel = (_) => {
                !this.isInview ||
                  _.ctrlKey ||
                  [...this.wheelEventsPerObject.entries()].forEach(([L, R]) => {
                    L.dispatchEvent({
                      type: "beginEvent",
                      eventName: "Scroll",
                      deltaY: _.deltaY,
                    }),
                      R.forEach((L) => L.dispatch(_.deltaY));
                  });
              }),
              (this.onUserEvent = ({ eventName: _, target: L, reverse: R }) => {
                if (!_ || !L) return;
                let N = Ms(_);
                N &&
                  "Scroll" === N &&
                  (L.dispatchEvent({ type: "beginEvent", eventName: "Scroll" }),
                  this.wheelEventsPerObject.get(L)?.forEach((_) => {
                    _.dispatchUserEvent(R);
                  }));
              });
            let {
              scene: L,
              sharedAssets: R,
              domElement: N,
              isExport: z,
            } = this.eventContext;
            L.traverseEntity((_) => {
              if (_.data?.events.length) {
                for (let { id: F, data: U } of _.data.events)
                  if (!U.disabled && "Scroll" === U.type) {
                    if ("load" !== U.trigger && z) {
                      let z = new _6(F, U, _, L, R, N);
                      this.scrollEventsPerObject.has(_)
                        ? this.scrollEventsPerObject.get(_)?.push(z)
                        : this.scrollEventsPerObject.set(_, [z]);
                    } else {
                      let N = new _4(F, U, _, L, R);
                      this.wheelEventsPerObject.has(_)
                        ? this.wheelEventsPerObject.get(_)?.push(N)
                        : this.wheelEventsPerObject.set(_, [N]);
                    }
                  }
              }
            }),
              (this.intersectionObserver = new IntersectionObserver(
                (_) => {
                  let L = _[0];
                  L && (this.isInview = L.isIntersecting);
                },
                { root: null },
              ));
          }
          connect() {
            this.intersectionObserver.observe(this.eventContext.domElement),
              [...this.wheelEventsPerObject.entries()].forEach(([_, L]) => {
                L.forEach((_) => _.connect()),
                  _.addEventListener("userEvent", this.onUserEvent);
              }),
              [...this.scrollEventsPerObject.entries()].forEach(([_, L]) => {
                L.forEach((_) => _.connect()),
                  _.addEventListener("userEvent", this.onUserEvent);
              }),
              [...this.wheelEventsPerObject.values()].some((_) => _.length) &&
                (this.domEventsNeeded.add("wheel"),
                window.addEventListener("wheel", this.onWheel)),
              [...this.scrollEventsPerObject.values()].some((_) => _.length) &&
                (this.domEventsNeeded.add("scroll"),
                window.addEventListener("scroll", this.onScroll),
                window.addEventListener("resize", this.handleResize));
          }
          disconnect() {
            window.removeEventListener("wheel", this.onWheel),
              window.removeEventListener("scroll", this.onScroll),
              window.removeEventListener("resize", this.handleResize),
              this.intersectionObserver.unobserve(this.eventContext.domElement),
              this.domEventsNeeded.clear(),
              [...this.wheelEventsPerObject.entries()].forEach(([_, L]) => {
                L.forEach((_) => _.disconnect()),
                  _.removeEventListener("userEvent", this.onUserEvent);
              }),
              [...this.scrollEventsPerObject.entries()].forEach(([_, L]) => {
                L.forEach((_) => _.disconnect()),
                  _.removeEventListener("userEvent", this.onUserEvent);
              });
          }
        },
        _9 = class {
          constructor(_, L, R, N, z) {
            (this.id = _),
              (this.data = L),
              (this.object = R),
              (this.actions = Nr(L, L.actions, R, N, z));
          }
          disconnect() {
            Br(this.actions);
          }
          dispatch() {
            this.actions.Transition.forEach((_) => {
              _.play();
            });
          }
          dispatchAfter(_) {
            this.actions.Audio.forEach((L) => {
              (L.interaction.data.triggerAfter ?? "any") === _ &&
                (L.interaction instanceof wR
                  ? L.interaction.audioPlayer.play()
                  : L.interaction instanceof wI && L.interaction.dispatch());
            }),
              this.actions.Video.forEach((L) => {
                let R = L.interaction.data.triggerAfter ?? "autoplay";
                R === _ &&
                  (L.interaction instanceof wF
                    ? L.interaction.play("autoplay" === R)
                    : L.interaction instanceof wU && L.interaction.dispatch());
              });
          }
          dispatchUserEvent(_) {
            this.actions.Transition.forEach((_) => {
              _.object.currentTransitionEvent !== this &&
                ((_.object.currentTransitionEvent = this), _.init());
            }),
              _
                ? this.actions.Transition.forEach((_) => _.reverseFromCurrent())
                : this.actions.Transition.forEach((_) => _.playFromCurrent()),
              this.actions.Audio.forEach((_) => {
                _.interaction instanceof wR
                  ? _.interaction.audioPlayer.play()
                  : _.interaction instanceof wI && _.interaction.dispatch();
              }),
              this.actions.Video.forEach((_) => {
                _.interaction instanceof wF
                  ? _.interaction.play()
                  : _.interaction instanceof wU && _.interaction.dispatch();
              });
          }
        },
        _7 = class extends wD {
          constructor(_) {
            super(_),
              (this.eventsPerObject = new Map()),
              (this.eventsAfterPerObject = new Map()),
              (this.onMouseDown = () => {
                [...this.eventsAfterPerObject.entries()].forEach(([_, L]) => {
                  _.dispatchEvent({ type: "beginEvent", eventName: "Start" }),
                    L.forEach((_) => {
                      _.dispatchAfter("mouseDown");
                    });
                });
              }),
              (this.onKeyDown = () => {
                [...this.eventsAfterPerObject.entries()].forEach(([_, L]) => {
                  _.dispatchEvent({ type: "beginEvent", eventName: "Start" }),
                    L.forEach((_) => {
                      _.dispatchAfter("keyDown");
                    });
                });
              }),
              (this.onAny = () => {
                let { domElement: _, isExport: L } = this.eventContext;
                (L ? document : _).removeEventListener(
                  "pointerdown",
                  this.onAny,
                ),
                  document.removeEventListener("keydown", this.onAny),
                  [...this.eventsAfterPerObject.entries()].forEach(([_, L]) => {
                    _.dispatchEvent({ type: "beginEvent", eventName: "Start" }),
                      L.forEach((_) => {
                        _.dispatchAfter("any");
                      });
                  });
              }),
              (this.onPlay = () => {
                [...this.eventsAfterPerObject.entries()].forEach(([_, L]) => {
                  _.dispatchEvent({ type: "beginEvent", eventName: "Start" }),
                    L.forEach((_) => {
                      _.dispatchAfter("autoplay");
                    });
                });
              }),
              (this.onUserEvent = ({ eventName: _, target: L, reverse: R }) => {
                if (!_ || !L) return;
                let N = Ms(_);
                N &&
                  "Start" === N &&
                  (L.dispatchEvent({ type: "beginEvent", eventName: "Start" }),
                  this.eventsPerObject.get(L)?.forEach((_) => {
                    _.dispatchUserEvent(R);
                  }),
                  this.eventsAfterPerObject.get(L)?.forEach((_) => {
                    _.dispatchUserEvent(R);
                  }));
              });
            let { scene: L, sharedAssets: R } = this.eventContext;
            L.traverseEntity((_) => {
              if (_.data?.events.length)
                for (let { id: N, data: z } of _.data.events) {
                  if (z.disabled || "Start" !== z.type) continue;
                  let F = new _9(N, z, _, L, R);
                  F.actions.Transition.length &&
                    (this.eventsPerObject.has(_)
                      ? this.eventsPerObject.get(_)?.push(F)
                      : this.eventsPerObject.set(_, [F])),
                    F.actions.Audio.length &&
                      (this.eventsAfterPerObject.has(_)
                        ? this.eventsAfterPerObject.get(_)?.push(F)
                        : this.eventsAfterPerObject.set(_, [F])),
                    F.actions.Video.length &&
                      ((this.hasVideoAction = !0),
                      this.eventsAfterPerObject.has(_)
                        ? this.eventsAfterPerObject.get(_)?.push(F)
                        : this.eventsAfterPerObject.set(_, [F]));
                }
            });
          }
          connect() {
            if ([...this.eventsAfterPerObject.values()].some((_) => _.length)) {
              let { domElement: _, isExport: L } = this.eventContext,
                R = L ? document : _;
              R.addEventListener("pointerdown", this.onMouseDown, { once: !0 }),
                document.addEventListener("keydown", this.onKeyDown, {
                  once: !0,
                }),
                R.addEventListener("pointerdown", this.onAny),
                document.addEventListener("keydown", this.onAny),
                [...this.eventsAfterPerObject.entries()].forEach(([_, L]) => {
                  _.addEventListener("userEvent", this.onUserEvent);
                }),
                this.onPlay();
            }
            [...this.eventsPerObject.entries()].forEach(([_, L]) => {
              _.dispatchEvent({ type: "beginEvent", eventName: "Start" }),
                L.forEach((_) => _.dispatch()),
                _.addEventListener("userEvent", this.onUserEvent);
            });
          }
          disconnect() {
            if ([...this.eventsAfterPerObject.values()].some((_) => _.length)) {
              let { domElement: _, isExport: L } = this.eventContext,
                R = L ? document : _;
              R.removeEventListener("pointerdown", this.onMouseDown),
                document.removeEventListener("keydown", this.onKeyDown),
                R.removeEventListener("pointerdown", this.onAny),
                document.removeEventListener("keydown", this.onAny),
                [...this.eventsAfterPerObject.entries()].forEach(([_, L]) => {
                  _.removeEventListener("userEvent", this.onUserEvent),
                    L.forEach((_) => _.disconnect());
                });
            }
            [...this.eventsPerObject.entries()].forEach(([_, L]) => {
              _.removeEventListener("userEvent", this.onUserEvent),
                L.forEach((_) => _.disconnect());
            });
          }
        },
        Se = class {
          constructor(_, L, R, N, z) {
            (this.id = _),
              (this.data = L),
              (this.object = R),
              (this.disabled = !0),
              (this.actions = Nr(L, L.actions, R, N, z)),
              (this.target = L.target),
              (this.useToggle = L.toggle);
          }
          disconnect() {
            Br(this.actions);
          }
          dispatch() {
            this.disabled ||
              (this.actions.Transition.forEach((_) => {
                _.object.currentTransitionEvent !== this &&
                  ((_.object.currentTransitionEvent = this), _.init());
              }),
              this.object.dispatchEvent({
                type: "beginEvent",
                eventName: "Collision",
              }),
              this.useToggle
                ? this.actions.Transition.forEach((_) => {
                    _.toggle();
                  })
                : this.actions.Transition.forEach((_) => {
                    _.play();
                  }),
              this.actions.Link.forEach((_) => {
                _.dispatch();
              }),
              this.actions.Audio.forEach((_) => {
                _.dispatchBasic();
              }),
              this.actions.Video.forEach((_) => {
                _.dispatchBasic();
              }));
          }
        };
      cY.then((_) => (t$ = _));
      var St = new iq(),
        Si = new iX(),
        Ss = new iq(),
        Sn = new rN(0, 0, 0, "YXZ"),
        Sa = { type: "updateMatrix" },
        So = { type: "beginEvent", eventName: "Collision" },
        S2 = (_) =>
          _.states.some(
            (_) =>
              void 0 !== _.data.position ||
              void 0 !== _.data.rotation ||
              void 0 !== _.data.hiddenMatrix ||
              void 0 !== _.data.cloner ||
              void 0 !== _.data.pathSnapping,
          ),
        w2 = (_) =>
          _.events.find(
            (_) => !0 !== _.data.disabled && "Follow" === _.data.type,
          ),
        Sl = class {
          constructor(_, L, R, N, z, F = !1) {
            let U;
            (this.scene = L),
              (this.sharedAssets = z),
              (this.isExport = F),
              (this.orbitControlsNeedsUpdate = !0),
              (this.gameControls = []),
              (this.gameControlStates = []),
              (this.joysticks = []),
              (this.joystickToGameControls = []),
              (this.sharedGameControlGlobals = {
                entitiesWithTransformAnim: [],
                eventsPerObjects: {},
                colliderToEntity: {},
                gamePads: [],
              }),
              (this.needsCollisionDetection = !1),
              (this.initializationCounter = -1),
              (this.rigidBodyToMesh = new Map()),
              (this.nActiveRigidBodies = 0),
              (this.collisionEvents = []),
              (this.processRigidBody = (_) => {
                if (_.bodyType() !== t$.RigidBodyType.Dynamic) return;
                _.isSleeping() || this.nActiveRigidBodies++;
                let [L, R, N] = this.rigidBodyToMesh.get(_.handle);
                if (
                  (St.copy(_.translation()).multiplyScalar(this.pixelsPerMeter),
                  Si.copy(_.rotation()),
                  L.matrixWorld.compose(St, Si, R),
                  L.hasNonUniformScale && L.matrixWorld.multiply(L.shearScale),
                  L.dispatchEvent(Sa),
                  N)
                ) {
                  let _ = L.cloner;
                  if (_ && void 0 === _.objectForSample)
                    for (let R of (_.matrixWorld.copy(L.matrixWorld),
                    _.children))
                      R.updateMatrixWorld(!0);
                  for (let _ of L.children) _.updateMatrixWorld(!0);
                }
              }),
              (this.handleCollisionEvents = (_, L, R) => {
                if (!1 !== R) {
                  if (
                    this.gameControls.some(
                      (L) =>
                        L.object ===
                        this.sharedGameControlGlobals.colliderToEntity[_],
                    )
                  ) {
                    let _ = this.sharedGameControlGlobals.colliderToEntity[L],
                      R =
                        this.sharedGameControlGlobals.eventsPerObjects[_.uuid];
                    if (void 0 !== R)
                      for (let L of R)
                        "character" === L.data.target &&
                          this.dispatchCollisionEvent(L, _);
                  } else if (
                    this.gameControls.some(
                      (_) =>
                        _.object ===
                        this.sharedGameControlGlobals.colliderToEntity[L],
                    )
                  ) {
                    let L = this.sharedGameControlGlobals.colliderToEntity[_],
                      R =
                        this.sharedGameControlGlobals.eventsPerObjects[L.uuid];
                    if (void 0 === R) return;
                    for (let _ of R)
                      "character" === _.data.target &&
                        this.dispatchCollisionEvent(_, L);
                  } else {
                    let R = this.sharedGameControlGlobals.colliderToEntity[_],
                      N =
                        this.sharedGameControlGlobals.eventsPerObjects[R.uuid];
                    if (void 0 !== N)
                      for (let _ of N)
                        "scene" === _.data.target &&
                          this.dispatchCollisionEvent(_, R);
                    let z = this.sharedGameControlGlobals.colliderToEntity[L],
                      F =
                        this.sharedGameControlGlobals.eventsPerObjects[z?.uuid];
                    if (void 0 !== F)
                      for (let _ of F)
                        "scene" === _.data.target &&
                          this.dispatchCollisionEvent(_, z);
                  }
                }
              }),
              (this.domElement = R.domElement),
              (U =
                null === _.scene.publish.playCamera
                  ? wh.PERSONAL_CAMERA_ID
                  : _.scene.publish.playCamera);
            let k = this.scene.find(U),
              Y = !1,
              X,
              Q = 5,
              K = 8,
              J = 9,
              $ = "drag";
            if (
              ((this.usePhysics =
                _.scene.environment.usePhysics ?? mt.defaultData.usePhysics),
              (this.pixelsPerMeter =
                _.scene.environment.pixelsPerMeter ??
                mt.defaultData.pixelsPerMeter),
              _.scene.objects
                .data(_.scene.publish.gameControlObject)
                ?.events.forEach((_) => {
                  !0 !== _.data.disabled &&
                    "GameControl" === _.data.type &&
                    ((X = _.data.keyAssignments),
                    (Q = _.data.joystickPosLoc),
                    (K = _.data.joystickRotLoc),
                    (J = _.data.jumpTouchButtonLoc),
                    ($ = _.data.rotByTouch));
                }),
              this.scene.traverseEntity((_) => {
                _.dataPatched.events.forEach((L) => {
                  if (L.data.disabled || "GameControl" !== L.data.type) return;
                  let R = _;
                  for (; (R = R.parent)?.parent !== null; )
                    if (R.dataPatched.physics?.fusedBody) return;
                  L.data.collisionEnabled &&
                    (this.needsCollisionDetection = !0),
                    this.gameControlStates.push([_, L.data]);
                });
              }),
              this.usePhysics &&
                this.initPhysics(
                  _.scene.environment.gravity ?? mt.defaultData.gravity,
                ),
              this.gameControlStates.forEach(([L, F]) => {
                Y = Y || F.camera === k.uuid || L.uuid === k.uuid;
                let U = new SU(
                  L,
                  R.domElement,
                  { ...F, keyAssignments: X },
                  _.scene.environment,
                  this.sharedGameControlGlobals,
                  L.uuid !== k.uuid && F.camera === k.uuid,
                  k,
                  this.scene,
                  z,
                );
                U.addEventListener("change", N),
                  U.addEventListener("end", N),
                  U.addEventListener("start", N),
                  this.gameControls.push(U),
                  pJ &&
                    F.touchControl &&
                    (void 0 !== this.joystickToGameControls[Q]
                      ? this.joystickToGameControls[Q].push([U, "pos"])
                      : (this.joystickToGameControls[Q] = [[U, "pos"]]),
                    "walk" === F.moveMode &&
                      (void 0 !== this.joystickToGameControls[J]
                        ? this.joystickToGameControls[J].push([U, "jmp"])
                        : (this.joystickToGameControls[J] = [[U, "jmp"]])),
                    "joystick" === $ &&
                      (void 0 !== this.joystickToGameControls[K]
                        ? this.joystickToGameControls[K].push([U, "rot"])
                        : (this.joystickToGameControls[K] = [[U, "rot"]])));
              }),
              !1 === Y)
            ) {
              let {
                enableRotate: L,
                enablePan: z,
                enableZoom: F,
                autoRotate: U,
                hoverRotatePanMode: Y,
              } = _.scene.publish.orbitControls;
              (L || z || F || U || 0 !== Y) &&
                ((this.orbitControls = new S1(k, R.domElement, {
                  isExport: this.isExport,
                  isPlayMode: !0,
                })),
                this.orbitControls.addEventListener("change", N),
                this.orbitControls.addEventListener("end", N),
                this.orbitControls.addEventListener("start", N),
                this.orbitControls.fromJSON(
                  _.scene.publish.orbitControls,
                  _.scene.publish.mouseEventTarget,
                ),
                (this.orbitControls.useKeyEvents = !1),
                this.orbitControls.addEventListenersToCamera(),
                this.orbitControls.connect(),
                this.orbitControls.update());
            }
            let ee = R.domElement.width / R.getPixelRatio(),
              er = R.domElement.height / R.getPixelRatio();
            this.joystickToGameControls.forEach((L, R) => {
              let z = document.body.appendChild(document.createElement("div")),
                [F, U, k] = (_.scene.publish.joystickSizeAndXYOffset ??
                  f7.defaultData.joystickSizeAndXYOffset)[R],
                Y = (ee - 5 * F) / 4 + F,
                X = {},
                Q = L.some((_) => "jmp" === _[1]),
                K = Q ? 0 : F;
              for (let _ in (R < 10
                ? (R < 5 ? (X.top = K / 2) : (X.bottom = K / 2),
                  (X.left = K / 2 + (R % 5) * Y))
                : (10 === R ? (X.left = K / 2) : (X.right = K / 2),
                  (X.top = er / 2)),
              X.top ? (X.top -= U[1]) : (X.bottom += U[1]),
              X.left ? (X.left += U[0]) : (X.right -= U[0]),
              X))
                X[_] += "px";
              if (Q) {
                let _ = z.appendChild(document.createElement("div"));
                Object.assign(_.style, X, {
                  position: "absolute",
                  width: F + "px",
                  height: F + "px",
                  backgroundColor: `rgba(255,255,255,${
                    "show" === k ? 0.4 : 0
                  })`,
                  zIndex: "9999",
                  borderRadius: F + "px",
                  border: "show" === k ? "solid 2px rgba(0, 0, 0, .1)" : "none",
                  display: "flex",
                  alignItems: "center",
                  justifyContent: "center",
                  touchAction: "none",
                });
                let U = (F / 16) * 6.4;
                "show" === k &&
                  (_.innerHTML = `
						<svg width="${U}" height="${
              0.4 * F
            }" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
							<path d="M2 10L8 4L14 10" stroke="black" stroke-opacity="40%" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
						</svg>
					`),
                  _.addEventListener("pointerdown", () => {
                    L.forEach((_) => {
                      _[0].movementState.jump = 1;
                    }),
                      N();
                  }),
                  _.addEventListener("touchend", (_) => _.preventDefault()),
                  (this.joysticks[R] = [void 0, z]);
                return;
              }
              let J = { zone: z, mode: "static", position: X, size: F };
              "hide" === k && (J.restOpacity = 0);
              let $ = ww.create(J);
              $.on("move", (_, R) => {
                L.forEach((_) => {
                  let L = _[0];
                  "pos" === _[1]
                    ? R.force < 0.2
                      ? (L.moveForce = 0)
                      : ((L.movementState.movePosZ = Math.sin(-R.angle.radian)),
                        (L.movementState.movePosX = Math.cos(-R.angle.radian)),
                        R.force < 0.3
                          ? (L.moveForce = (R.force - 0.2) / 0.1)
                          : (L.moveForce = 1))
                    : R.force < 0.2
                      ? (L.rotForce = 0)
                      : ((L.movementState.rotPosX = R.vector.y),
                        (L.movementState.rotPosY = -R.vector.x),
                        R.force < 0.3
                          ? (L.rotForce = (R.force - 0.2) / 0.1)
                          : (L.rotForce = 1));
                }),
                  N();
              }),
                $.on("end", (_, R) => {
                  L.forEach((_) => {
                    let L = _[0];
                    "pos" === _[1]
                      ? ((L.movementState.movePosZ = 0),
                        (L.movementState.movePosX = 0),
                        (L.moveForce = 1))
                      : ((L.movementState.rotPosX = 0),
                        (L.movementState.rotPosY = 0),
                        (L.rotForce = 1));
                  });
                }),
                (this.joysticks[R] = [$, z]);
            }),
              !1 === this.usePhysics &&
                this.needsCollisionDetection &&
                this.initBVH(),
              this.initializationCounter++,
              window.setTimeout(
                () => this.collisionEvents.forEach((_) => (_.disabled = !1)),
                80,
              );
          }
          attachVRControllers(_) {
            _.forEach((_) => {
              _.addEventListener("connected", (_) => {
                "gamepad" in _.data &&
                  "axes" in _.data.gamepad &&
                  this.sharedGameControlGlobals.gamePads.push(_.data.gamepad);
              });
            });
          }
          initBVH() {
            let _ = [];
            if (
              (this.scene.traverseObject((L) => {
                let R;
                if (L instanceof bM) return;
                let N = (R = L instanceof mK ? L.object : L).dataPatched;
                if (!N.visible || w2(N)) return !0;
                let z = L.geometry;
                if (
                  S2(N) ||
                  R.dataPatched.events.some(
                    (_) =>
                      !0 !== _.data.disabled && "GameControl" === _.data.type,
                  )
                ) {
                  L.updateMatrixWorldSVD();
                  let _ = [];
                  if (
                    (z?.getAttribute("position") !== void 0 &&
                      _.push(pl(z, L.shearScale)),
                    L.traverseObject(this.gatherChildrenGeom(L, _)),
                    L.children.forEach((_) => _.updateMatrixWorld(!0)),
                    _.length > 0)
                  ) {
                    let R = no(_, !1);
                    (L.boundsTree = new mD(R)),
                      this.sharedGameControlGlobals.entitiesWithTransformAnim.push(
                        L,
                      );
                  }
                  return !0;
                }
                z && _.push(pl(z, L.matrixWorld));
              }),
              _.length > 0)
            ) {
              let L = no(_, !1);
              this.sharedGameControlGlobals.staticMeshBVH = new mD(L);
            }
          }
          addCollider(_, L, R, N, z, F = !0) {
            let U;
            if (
              N?.getAttribute("position").count === 0 ||
              N?.getIndex()?.count === 0
            )
              return;
            void 0 !== z
              ? (U =
                  "sphere" === z.collider.type
                    ? t$.ColliderDesc.ball(
                        z.collider.radius / this.pixelsPerMeter,
                      )
                    : "capsule" === z.collider.type
                      ? t$.ColliderDesc.capsule(
                          (z.collider.height / 2 - z.collider.radius) /
                            this.pixelsPerMeter,
                          z.collider.radius / this.pixelsPerMeter,
                        )
                      : t$.ColliderDesc.cuboid(
                          z.collider.width / this.pixelsPerMeter / 2,
                          z.collider.height / this.pixelsPerMeter / 2,
                          z.collider.depth / this.pixelsPerMeter / 2,
                        ))
              : N &&
                (U =
                  "trimesh" === R.colliderType
                    ? t$.ColliderDesc.trimesh(
                        N.getAttribute("position").array,
                        N.getIndex().array,
                      )
                    : t$.ColliderDesc.convexMesh(
                        N.getAttribute("position").array,
                        F ? N.getIndex().array : void 0,
                      )),
              U.setFrictionCombineRule(t$.CoefficientCombineRule.Average)
                .setRestitutionCombineRule(t$.CoefficientCombineRule.Average)
                .setDensity(R.density)
                .setFriction(R.friction)
                .setRestitution(R.restitution);
            let k = this.sharedGameControlGlobals.rapierWorld.createCollider(
              U,
              L,
            );
            if (
              ((this.sharedGameControlGlobals.colliderToEntity[k.handle] = _),
              void 0 !== z)
            ) {
              St.fromArray(z.collider.position)
                .multiply(Ss.setFromMatrixScale(_.matrixWorld))
                .divideScalar(this.pixelsPerMeter),
                k.setTranslationWrtParent(St);
              let L = new iX().setFromEuler(
                new rN().setFromVector3(
                  new iq().fromArray(z.collider.rotation),
                ),
              );
              k.setRotationWrtParent(L),
                k.setActiveEvents(t$.ActiveEvents.COLLISION_EVENTS);
            } else
              this.sharedGameControlGlobals.eventsPerObjects[_.uuid]?.some(
                (_) => "scene" === _.target,
              ) && k.setActiveEvents(t$.ActiveEvents.COLLISION_EVENTS);
          }
          gatherChildrenGeom(_, L) {
            return (R, N) => {
              if (0 === N) return;
              1 === N
                ? _.hasNonUniformScale
                  ? R.matrixWorld.multiplyMatrices(_.shearScale, R.hiddenMatrix)
                  : R.matrixWorld.copy(R.hiddenMatrix)
                : R.matrixWorld.multiplyMatrices(
                    R.parent.matrixWorld,
                    R.hiddenMatrix,
                  ),
                R.matrixWorld.multiply(R.matrix);
              let z = R.geometry;
              z?.getAttribute("position") !== void 0 &&
                L.push(pl(z, R.matrixWorld));
            };
          }
          initPhysics(_) {
            (this.sharedGameControlGlobals.rapierWorld = new t$.World(
              new t$.Vector3(0, _ ?? -10, 0),
            )),
              (this.events = new t$.EventQueue(!0));
            let L = [];
            if (
              (this.scene.traverseObject((_) => {
                let R;
                if (_ instanceof bM) {
                  if (!_.objectForSample)
                    return (
                      (!0 === _.object.dataPatched.physics.fusedBody &&
                        "dynamic" === _.object.dataPatched.physics.rigidBody) ||
                      void 0
                    );
                  if (_.objectForSample.dataPatched.physics.fusedBody) return;
                  R = _.object;
                } else R = _ instanceof mK ? _.object : _;
                let N = R.dataPatched;
                if (!N.physics || !N.visible) return !0;
                _.updateMatrixWorldSVD();
                let z = S2(N),
                  F = w2(N),
                  U,
                  k = !1;
                for (let _ of N.events)
                  if (!0 !== _.data.disabled) {
                    if ("GameControl" === _.data.type) U = _.data;
                    else if ("Collision" === _.data.type) {
                      k = !0;
                      let L = new Se(
                        _.id,
                        _.data,
                        R,
                        this.scene,
                        this.sharedAssets,
                      );
                      this.collisionEvents.push(L),
                        this.sharedGameControlGlobals.eventsPerObjects[R.uuid]
                          ? this.sharedGameControlGlobals.eventsPerObjects[
                              R.uuid
                            ].push(L)
                          : (this.sharedGameControlGlobals.eventsPerObjects[
                              R.uuid
                            ] = [L]);
                    }
                  }
                "dynamic" === N.physics.rigidBody &&
                  !1 === N.physics.fusedBody &&
                  (_.matrixWorldFusedFalse = _.matrixWorld.clone());
                let Y = _.geometry;
                if (
                  "dynamic" === N.physics.rigidBody ||
                  z ||
                  F ||
                  k ||
                  void 0 !== U
                ) {
                  let L = [];
                  if (
                    (Y?.getAttribute("position") !== void 0 &&
                      L.push(pl(Y, _.shearScale)),
                    N.physics.fusedBody)
                  ) {
                    let R = this.gatherChildrenGeom(_, L);
                    _.traverseObject(R),
                      _.children.forEach((_) => _.updateMatrixWorld(!0));
                    let z = _.cloner;
                    z &&
                      void 0 === z.objectForSample &&
                      "dynamic" === N.physics.rigidBody &&
                      (z.traverseObject(R),
                      z.children.forEach((_) => _.updateMatrixWorld(!0)));
                  }
                  if (L.length > 0 || void 0 !== U) {
                    let k, X;
                    void 0 !== U
                      ? (k = t$.RigidBodyDesc.kinematicPositionBased())
                      : "dynamic" === N.physics.rigidBody
                        ? (k = t$.RigidBodyDesc.dynamic())
                            .setLinearDamping(N.physics.damping)
                            .setAdditionalMass(1e-9)
                            .setGravityScale(N.physics.gravityScale)
                            .enabledRotations(...N.physics.enabledRotation)
                            .enabledTranslations(
                              ...N.physics.enabledTranslation,
                            )
                        : z || F
                          ? ((k = t$.RigidBodyDesc.kinematicPositionBased()),
                            this.sharedGameControlGlobals.entitiesWithTransformAnim.push(
                              _,
                            ))
                          : (k = t$.RigidBodyDesc.fixed()),
                      (X = L.length > 0 ? no(L) : void 0),
                      (_.hasNonUniformScale
                        ? _.matrixWorldRigid
                        : _.matrixWorld
                      ).decompose(St, Si, Ss),
                      (_.position0 = St.clone().divideScalar(
                        this.pixelsPerMeter,
                      )),
                      (_.rotation0 = Si.clone()),
                      St.divideScalar(this.pixelsPerMeter),
                      k.setTranslation(St.x, St.y, St.z).setRotation(Si),
                      Y
                        ? X?.scale(
                            1 / this.pixelsPerMeter,
                            1 / this.pixelsPerMeter,
                            1 / this.pixelsPerMeter,
                          )
                        : X?.scale(
                            Ss.x / this.pixelsPerMeter,
                            Ss.y / this.pixelsPerMeter,
                            Ss.z / this.pixelsPerMeter,
                          );
                    let Q =
                      this.sharedGameControlGlobals.rapierWorld.createRigidBody(
                        k,
                      );
                    void 0 === U &&
                      "dynamic" === N.physics.rigidBody &&
                      this.rigidBodyToMesh.set(Q.handle, [
                        _,
                        Ss.clone(),
                        N.physics.fusedBody,
                      ]),
                      (_.rigidBody = Q);
                    let K = !(
                      void 0 === N.geometry ||
                      "SubdivGeometry" === N.geometry.type ||
                      "NonParametricGeometry" === N.geometry.type ||
                      "BooleanGeometry" === N.geometry.type ||
                      "VectorGeometry" === N.geometry.type ||
                      "StarGeometry" === N.geometry.type ||
                      "RectangleGeometry" === N.geometry.type ||
                      "EllipseGeometry" === N.geometry.type ||
                      "TriangleGeometry" === N.geometry.type ||
                      "TorusGeometry" === N.geometry.type ||
                      "HelixGeometry" === N.geometry.type
                    );
                    try {
                      this.addCollider(R, Q, N.physics, X, U, K);
                    } catch {
                      try {
                        this.addCollider(R, Q, N.physics, X, U, !1);
                      } catch (_) {
                        console.error(_);
                      }
                    }
                  }
                } else
                  Y && L.push(pl(Y, _.matrixWorld)),
                    N.physics.fusedBody &&
                      _.traverse((R) => {
                        R.geometry &&
                          R !== _ &&
                          L.push(pl(R.geometry, R.matrixWorld));
                      });
                if (N.physics?.fusedBody === !0 || U) return !0;
              }),
              0 === L.length)
            )
              return;
            let R = no(L);
            R.scale(
              1 / this.pixelsPerMeter,
              1 / this.pixelsPerMeter,
              1 / this.pixelsPerMeter,
            );
            let N = t$.RigidBodyDesc.fixed(),
              z = this.sharedGameControlGlobals.rapierWorld.createRigidBody(N),
              F = t$.ColliderDesc.trimesh(
                R.getAttribute("position").array,
                R.getIndex().array,
              )
                .setFrictionCombineRule(t$.CoefficientCombineRule.Multiply)
                .setRestitutionCombineRule(t$.CoefficientCombineRule.Multiply)
                .setFriction(1)
                .setRestitution(1);
            this.sharedGameControlGlobals.rapierWorld.createCollider(F, z);
          }
          updatePositions() {
            return (
              (this.nActiveRigidBodies = 0),
              this.sharedGameControlGlobals.rapierWorld.forEachRigidBody(
                this.processRigidBody,
              ),
              this.nActiveRigidBodies > 0
            );
          }
          dispose() {
            for (let _ of (this.scene.traverse((_) => {
              _.matrixWorldFusedFalse && (_.matrixWorldFusedFalse = void 0),
                _.rigidBody && (_.rigidBody = void 0),
                _.position0 && (_.position0 = void 0),
                _.rotation0 && (_.rotation0 = void 0);
            }),
            this.sharedGameControlGlobals.rapierWorld?.free(),
            (this.sharedGameControlGlobals.staticMeshBVH = void 0),
            (this.sharedGameControlGlobals.entitiesWithTransformAnim = []),
            this.gameControls.forEach((_) => {
              _.reset(), _.dispose();
            }),
            (this.gameControls = []),
            this.joysticks.forEach(([_, L]) => {
              _?.destroy(), L.remove();
            }),
            (this.joystickToGameControls = []),
            (this.joysticks = []),
            this.orbitControls &&
              (this.orbitControls.dispose(), (this.orbitControls = void 0)),
            Object.values(this.sharedGameControlGlobals.eventsPerObjects)))
              _.forEach((_) => _.disconnect());
            (this.sharedGameControlGlobals.eventsPerObjects = {}),
              this.scene.updateMatrixWorld(!0);
          }
          update(_, L, R) {
            let N = !0;
            if (
              (void 0 !== this.orbitControls &&
                this.orbitControls.needsUpdate &&
                (N = !this.orbitControls.update()),
              this.initializationCounter >= 0 && this.initializationCounter < 2)
            )
              this.initializationCounter++, (N = !1);
            else if (2 === this.initializationCounter)
              for (let z of this.gameControls) N = !z.update(_, L, R) && N;
            if (this.usePhysics) {
              for (let _ of this.sharedGameControlGlobals
                .entitiesWithTransformAnim)
                (_.hasNonUniformScale
                  ? _.matrixWorldRigid
                  : _.matrixWorld
                ).decompose(St, Si, Ss),
                  Sn.setFromQuaternion(Si),
                  void 0 === _.prevR
                    ? ((_.prevR = Sn.clone()), (_.prevT = St.clone()))
                    : (_.prevR.copy(Sn), _.prevT.copy(St)),
                  _.rigidBody.setNextKinematicTranslation(
                    St.divideScalar(this.pixelsPerMeter),
                  ),
                  _.rigidBody.setNextKinematicRotation(Si);
              this.sharedGameControlGlobals.rapierWorld.step(this.events),
                this.events?.drainCollisionEvents(this.handleCollisionEvents),
                (N = !this.updatePositions() && N);
            }
            return N;
          }
          dispatchCollisionEvent(_, L) {
            L.dispatchEvent(So), _.dispatch();
          }
          updateUseWindowEvents(_) {
            this.orbitControls?.updateUseWindowEvents(_);
          }
        },
        Sh = { type: "change" },
        Su = { type: "lock" },
        Sp = { type: "unlock" },
        Sf = (new iq(), new iq()),
        Sm = new iq(),
        Sg = new iq(),
        Sv = new iq(),
        Sy = new iq(),
        Sb = new iq(),
        Sw = new rw(),
        S_ = new rw(),
        SS = new rw(),
        SM = (new rw(), new iX()),
        SC = new iX(),
        SP = new rN(0, 0, 0, "YXZ"),
        SD = new iq(1, 0, 0),
        SO = new iq(0, 1, 0),
        SL = new iq(0, 0, 1),
        SR = new iq(1, 1, 1),
        SI = new oH(),
        SB = new iK(),
        SN = { type: "requestRender" },
        Sz = Math.PI / 6,
        SF = class extends ig {
          constructor(_, L, R, N, z, F, U, k, Y) {
            super(),
              (this.object = _),
              (this.domElement = L),
              (this.sharedGameControlGlobals = z),
              (this.cameraFollow = F),
              (this.camera = U),
              (this.scene = k),
              (this.sharedAssets = Y),
              (this.enableDamping = !0),
              (this.position0 = new iq()),
              (this.rotation0 = new rN(0, 0, 0, "XYZ")),
              (this.scale0 = new iq()),
              (this.hiddenMatrix0 = new rw()),
              (this.target0 = new iq()),
              (this.zoom0 = 1),
              (this.rotForce = 1),
              (this.moveForce = 1),
              (this.euler0 = new rN(0, 0, 0, "YXZ")),
              (this.position0Cam = new iq()),
              (this.quat0Cam = new iX()),
              (this.scale0Cam = new iq()),
              (this.hiddenMatrix0Cam = new rw()),
              (this.threshEndTranslate = 0.01),
              (this.threshEndRotate = 1e-8),
              (this.threshEndRotVel = 0.005),
              (this.collider = {
                type: "capsule",
                radius: 40,
                segment: new oH(new iq(0, -40, 0), new iq(0, 40, 0)),
                matrix: new rw(),
                position: new iq(),
                rotation: new iX(),
              }),
              (this.euler = new rN(0, 0, 0, "YXZ")),
              (this.eulerDelta = new iq()),
              (this.lastPosition = new iq()),
              (this.lastCameraQuaternion = new iX()),
              (this.lastCameraPosition = new iq()),
              (this.PI_2 = Math.PI / 2),
              (this.prevMouse = new iT()),
              (this.velocityTarget = new iq()),
              (this.velocity = new iq()),
              (this.directionXZ = new iq()),
              (this.rotVelocityStick = new iq()),
              (this.rotVelocityTarget = new iq()),
              (this.rotVelocity = new iq()),
              (this.rotDirection = new iq()),
              (this.nonColliderRotOffset = new rw()),
              (this.nonColliderPosOffset = new rw()),
              (this.firstPointerId = -1),
              (this.rot = new iq()),
              (this.movementState = {
                moveNegZ: 0,
                movePosZ: 0,
                moveNegX: 0,
                movePosX: 0,
                moveNegY: 0,
                movePosY: 0,
                rotPosX: 0,
                rotNegX: 0,
                rotPosY: 0,
                rotNegY: 0,
                jump: 0,
              }),
              (this.vrEulerYOffset = 0),
              (this.onObject = !1),
              (this.actionState = {}),
              (this.keyAssignments = [
                ["moveNegZ", "W"],
                ["moveNegX", "A"],
                ["movePosZ", "S"],
                ["movePosX", "D"],
                ["rotPosX", "ArrowUp"],
                ["rotPosY", "ArrowLeft"],
                ["rotNegX", "ArrowDown"],
                ["rotNegY", "ArrowRight"],
                ["jump", " "],
              ]),
              (this.collisionEnabled = !0),
              (this.offsetMatrix = new rw()),
              (this.objectToTarget = new iq()),
              (this.objectToTarget0 = new iq()),
              (this.objectToCamXZ = new iq()),
              (this.objectToCamXZ0 = new iq()),
              (this.targetToCamera = new iq()),
              (this.targetToCamera0 = new iq()),
              (this.cameraPolarAxis0 = new iq()),
              (this.targetPos = new iq()),
              (this.targetQuat = new iX()),
              (this.lerpFactorPos = new iq().setScalar(0.3)),
              (this.lerpFactorPosStart = 0.3),
              (this.lerpFactorPosEnd = 0.3),
              (this.lerpFactorRotStart = 0.3),
              (this.lerpFactorRotEnd = 0.3),
              (this.lerpFactorPosCamera = 0.3),
              (this.lerpFactorRotCamera = 0.3),
              (this.objXZQuat = new iX()),
              (this.objXZQuatInv = new iX()),
              (this.objXZRotMat = new rw()),
              (this.isFirstPerson = !1),
              (this.actions = {}),
              (this.didHit = !1),
              (this.groundVelocity = new iq()),
              (this.pushedVelocity = new iq()),
              (this.groundYRotation = 0),
              (this.objectRealQuat = new iX()),
              (this.colliderWorldQuat = new iX()),
              (this.groundNormal = new iq()),
              (this.groundTilt = new iX()),
              (this.groundTiltInv = new iX()),
              (this.lastHitObj = null),
              (this.isFirstFrame = !0),
              (this.rotationAccumWhenOrientWithCamera = 0),
              (this.onPointerDown = (_) => {
                _.target !== this.domElement ||
                  -1 !== this.firstPointerId ||
                  ((this.firstPointerId = _.pointerId),
                  this.domElement.ownerDocument.addEventListener(
                    "pointermove",
                    this.onPointerMove,
                  ),
                  this.domElement.ownerDocument.addEventListener(
                    "pointerup",
                    this.onPointerUp,
                  ),
                  "keys" === this.rotBy ||
                    pJ ||
                    (p$ && !(p0 >= 15.5)) ||
                    this.domElement.requestPointerLock(),
                  this.prevMouse.set(_.clientX, _.clientY));
              }),
              (this.onPointerUp = (_) => {
                (this.firstPointerId = -1),
                  this.domElement.ownerDocument.removeEventListener(
                    "pointermove",
                    this.onPointerMove,
                  ),
                  this.domElement.ownerDocument.removeEventListener(
                    "pointerup",
                    this.onPointerUp,
                  ),
                  "mouse" === _.pointerType &&
                    this.domElement.ownerDocument.exitPointerLock();
              }),
              (this.onPointerMove = (_) => {
                if (_.pointerId !== this.firstPointerId) return;
                let L = _.clientX - this.prevMouse.x,
                  R = _.clientY - this.prevMouse.y;
                this.prevMouse.set(_.clientX, _.clientY),
                  "mouse" === _.pointerType &&
                    "keys" !== this.rotBy &&
                    (p$ && p0 < 15.5 && !pJ
                      ? ((this.eulerDelta.y = -L * this.mouseOrbitSensitivity),
                        (this.eulerDelta.x = -R * this.mouseOrbitSensitivity))
                      : ((this.eulerDelta.y =
                          -_.movementX * this.mouseOrbitSensitivity),
                        (this.eulerDelta.x =
                          -_.movementY * this.mouseOrbitSensitivity))),
                  "mouse" !== _.pointerType &&
                    "drag" === this.rotByTouch &&
                    ((this.eulerDelta.y = -L * this.mouseOrbitSensitivity * 5),
                    (this.eulerDelta.x = -R * this.mouseOrbitSensitivity * 5)),
                  this.dispatchEvent(Sh);
              }),
              (this.onPointerlockChange = (_) => {
                this.domElement.ownerDocument.pointerLockElement ===
                this.domElement
                  ? (this.dispatchEvent(Su), (SF.isLocked = !0))
                  : (this.dispatchEvent(Sp), (SF.isLocked = !1));
              }),
              (this.onPointerlockError = () => {
                console.error(
                  "SPE.GameControls: Unable to use Pointer Lock API",
                );
              }),
              (this.onKeyDown = (_) => {
                for (let L of (_.target instanceof HTMLInputElement ||
                  ("ArrowLeft" !== _.code &&
                    "ArrowUp" !== _.code &&
                    "ArrowRight" !== _.code &&
                    "ArrowDown" !== _.code &&
                    "Space" !== _.code) ||
                  _.preventDefault(),
                this.keyAssignments))
                  if (_.key.toUpperCase() === L[1] || _.key === L[1]) {
                    this.movementState[L[0]] = 1;
                    break;
                  }
                this.dispatchEvent(Sh);
              }),
              (this.onKeyUp = (_) => {
                for (let L of this.keyAssignments)
                  if (
                    _.key.toUpperCase() === L[1] ||
                    _.key === L[1] ||
                    _.code.slice(3, _.code.length).toUpperCase() === L[1]
                  ) {
                    this.movementState[L[0]] = 0;
                    break;
                  }
              }),
              (this.copyVRGamePadValues = (_, L) => {
                for (let R = 2; R < 4; R++) {
                  let N = _.axes[R];
                  0 === L
                    ? 2 === R
                      ? (this.movementState.movePosX = N)
                      : (this.movementState.movePosZ = N)
                    : (_.buttons[3].pressed
                        ? (this.movementState.jump = 1)
                        : (this.movementState.jump = 0),
                      2 === R
                        ? (0.3 > Math.abs(this.movementState.rotPosY) &&
                            Math.abs(N) >= 0.3 &&
                            (this.vrEulerYOffset += N < 0 ? 1 : -1),
                          (this.movementState.rotPosY = N))
                        : "fly" === this.moveMode &&
                          (this.movementState.moveNegY = N));
                }
              }),
              _ === U && (this.isFirstPerson = !0),
              this.position0.copy(this.object.position),
              this.rotation0.copy(this.object.rotation),
              this.scale0.copy(this.object.scale),
              this.hiddenMatrix0.copy(this.object.hiddenMatrix),
              this.object.parent
                ? this.object.hiddenMatrix
                    .copy(this.object.parent.matrixWorld)
                    .invert()
                : this.object.hiddenMatrix.identity(),
              this.object.matrix.copy(this.object.matrixWorld),
              this.object.matrix.decompose(
                this.object.position,
                this.object.quaternion,
                this.object.scale,
              ),
              this.object.rotation.reorder("YXZ"),
              this.euler0.copy(this.object.rotation);
            let X = this.object.rotation.y;
            if (
              (this.objectRealQuat.copy(this.object.quaternion),
              (this.object.rotation.y = 0),
              this.objXZQuat.copy(this.object.quaternion),
              this.objXZQuatInv.copy(this.objXZQuat).invert(),
              this.objXZRotMat.makeRotationFromQuaternion(
                this.object.quaternion,
              ),
              this.object.rotation.set(0, X, 0),
              this.rot.setFromEuler(this.object.rotation),
              (this.object.matrixAutoUpdate = !1),
              (this.isFirstPerson || !0 === this.cameraFollow) &&
                (this.target0.copy(this.camera.getTarget()),
                (this.zoom0 = this.camera.zoom)),
              !0 === this.cameraFollow)
            ) {
              let _;
              if (
                (this.position0Cam.copy(this.camera.position),
                this.quat0Cam.copy(this.camera.quaternion),
                this.scale0Cam.copy(this.camera.scale),
                this.hiddenMatrix0Cam.copy(this.camera.hiddenMatrix),
                this.camera?.parent?.parent)
              ) {
                let _ = this.camera.matrix
                    .clone()
                    .invert()
                    .premultiply(this.camera.matrixWorld),
                  L = _.clone().invert();
                this.camera.hiddenMatrix.multiply(L),
                  this.camera.matrix.premultiply(_),
                  this.camera.matrixWorld.decompose(
                    this.camera.position,
                    this.camera.quaternion,
                    this.camera.scale,
                  );
              }
              (this.camera.matrixAutoUpdate = !1),
                this.offsetMatrix
                  .copy(this.object.matrix)
                  .invert()
                  .multiply(this.camera.matrix);
              let L = new iq(0, 0, -1).applyQuaternion(this.camera.quaternion),
                R = new iq().subVectors(
                  this.object.position,
                  this.camera.position,
                );
              if (
                (this.objectToCamXZ.copy(R),
                (this.objectToCamXZ.y = 0),
                this.objectToCamXZ0.copy(this.objectToCamXZ),
                1e-6 > Math.abs(L.y))
              ) {
                (R.y = 0), (L.y = 0);
                let N = R.projectOnVector(L);
                this.targetToCamera0.copy(N).negate(),
                  (_ = this.camera.position.clone().add(N));
              } else {
                let N = L.multiplyScalar(R.y / L.y);
                this.targetToCamera0.copy(N).negate(),
                  (_ = N.clone().add(this.camera.position));
              }
              this.objectToTarget0.subVectors(_, this.object.position);
              let N = new rN().setFromQuaternion(this.camera.quaternion, "YXZ");
              (this.cameraPolarOffset = -N.x),
                (N.x = 0),
                (N.z = 0),
                (N.y -= Math.PI / 2),
                this.cameraPolarAxis0.set(0, 0, -1).applyEuler(N);
            }
            if (
              (this.object instanceof bj && (this.object.matrixAutoUpdate = !1),
              this.euler.setFromQuaternion(this.object.quaternion, "YXZ"),
              this.connect(),
              (this.rotByTouch = R.rotByTouch ?? "joystick"),
              (this.rotBy = R.rotBy ?? "keys"),
              (this.rotationMode = R.rotationMode ?? "normal"),
              (this.moveMode = R.moveMode ?? "walk"),
              (this.collisionEnabled = R.collisionEnabled),
              (this.speedTranslate = (R.speedTranslate ?? 250) * 1),
              (this.speedOrbit = (R.speedRotate ?? 100) * 0.025),
              (this.mouseOrbitSensitivity = (R.speedRotate ?? 100) * 16e-6),
              (this.keyAssignments = R.keyAssignments.map((_) => {
                let L = [_[0], _[1]];
                return (
                  "" === L[1]
                    ? (L[1] = "ArrowUp")
                    : "" === L[1]
                      ? (L[1] = "ArrowLeft")
                      : "" === L[1]
                        ? (L[1] = "ArrowDown")
                        : "" === L[1]
                          ? (L[1] = "ArrowRight")
                          : "" === L[1]
                            ? (L[1] = "Shift")
                            : "" === L[1]
                              ? (L[1] = "Enter")
                              : "Space" === L[1]
                                ? (L[1] = " ")
                                : "" === L[1]
                                  ? (L[1] = "Meta")
                                  : "Ctrl" === L[1]
                                    ? (L[1] = "Control")
                                    : "Esc" === L[1] && (L[1] = "Escape"),
                  L
                );
              })),
              "mouse" === R.rotBy)
            ) {
              let _;
              -1 !==
                (_ = this.keyAssignments.findIndex(
                  (_) => "rotNegX" === _[0],
                )) && (this.keyAssignments[_][1] = ""),
                -1 !==
                  (_ = this.keyAssignments.findIndex(
                    (_) => "rotPosX" === _[0],
                  )) && (this.keyAssignments[_][1] = ""),
                -1 !==
                  (_ = this.keyAssignments.findIndex(
                    (_) => "rotPosY" === _[0],
                  )) && (this.keyAssignments[_][1] = ""),
                -1 !==
                  (_ = this.keyAssignments.findIndex(
                    (_) => "rotNegY" === _[0],
                  )) && (this.keyAssignments[_][1] = "");
            }
            (this.lerpFactorPosStart =
              1 - 0.02 ** (1 / ((R.delayPos[0] ?? 0.3) * 60))),
              (this.lerpFactorPosEnd =
                1 - 0.02 ** (1 / ((R.delayPos[1] ?? 0.3) * 60))),
              this.lerpFactorPos.setScalar(this.lerpFactorPosStart),
              (this.lerpFactorRotStart =
                1 - 0.02 ** (1 / ((R.delayRot[0] ?? 0.3) * 60))),
              (this.lerpFactorRotEnd =
                1 - 0.02 ** (1 / ((R.delayRot[1] ?? 0.3) * 60))),
              (this.lerpFactorPosCamera =
                1 - 0.02 ** (1 / ((R.delayPosCamera ?? 0.3) * 60))),
              (this.lerpFactorRotCamera =
                1 - 0.02 ** (1 / ((R.delayRotCamera ?? 0.3) * 60))),
              (this.gravity = (N.gravity ?? mt.defaultData.gravity) * 12),
              (this.pixelsPerMeter =
                N.pixelsPerMeter ?? mt.defaultData.pixelsPerMeter),
              (this.usePhysics = N.usePhysics ?? mt.defaultData.usePhysics),
              (this.jumpPower = 20 * R.jumpPower),
              (this.resetYPosition =
                this.object.position.y +
                Math.abs(R.resetYPosition) * (this.gravity > 0 ? 1 : -1)),
              (this.alignToGround = R.alignToGround ?? !1),
              (this.orientMode = R.autoOrientMove ? R.orientMode : "none"),
              (this.orientWith =
                R.orientWith ?? mn.defaultDataThirdPerson.orientWith);
            let Q = N.skinWidthRelative ?? mt.defaultData.skinWidthRelative,
              K = N.stepThreshRelative ?? mt.defaultData.stepThreshRelative;
            (this.slopeThresh =
              ((N.slopeThresh ?? mt.defaultData.slopeThresh) * Math.PI) / 180),
              "capsule" === R.collider.type
                ? ((this.collider.radius = R.collider.radius),
                  (this.collider.segment.start.y =
                    R.collider.height / 2 - R.collider.radius),
                  (this.collider.segment.end.y =
                    -this.collider.segment.start.y),
                  (this.offset = (R.collider.height * Q) / this.pixelsPerMeter),
                  (this.stepThresh =
                    (R.collider.height * K) / this.pixelsPerMeter))
                : "sphere" === R.collider.type
                  ? ((this.collider.radius = R.collider.radius),
                    (this.collider.segment.start.y = 0),
                    (this.collider.segment.end.y = 0),
                    (this.offset =
                      (2 * R.collider.radius * Q) / this.pixelsPerMeter),
                    (this.stepThresh =
                      (2 * R.collider.radius * K) / this.pixelsPerMeter))
                  : ((this.offset =
                      (R.collider.height * Q) / this.pixelsPerMeter),
                    (this.stepThresh =
                      (R.collider.height * K) / this.pixelsPerMeter)),
              (this.collider.type = R.collider.type);
            let J = new iq().fromArray(R.collider.position),
              $ = new iX().setFromEuler(
                new rN().fromArray([...R.collider.rotation, "XYZ"]),
              );
            this.collider.position.copy(J).multiply(this.object.scale),
              this.collider.rotation.copy($),
              this.collider.matrix.compose(J, $, SR),
              void 0 !== R.cameraXAxis &&
                ((this.cameraXAxis = R.cameraXAxis),
                (this.cameraYAxis = R.cameraYAxis),
                (this.minPolarAngle = R.cameraRotXLimits[0]),
                (this.maxPolarAngle = R.cameraRotXLimits[1]),
                (this.minAzimuthAngleRel = R.cameraRotYLimits[0]),
                (this.maxAzimuthAngleRel = R.cameraRotYLimits[1])),
              void 0 !== R.gameActions &&
                Object.entries(R.gameActions).forEach(([L, R], N) => {
                  R.forEach(({ id: R, data: N }) => {
                    try {
                      void 0 === this.actions[L] && (this.actions[L] = []),
                        "Transition" === N.type
                          ? this.actions[L].push(new _d(N, k, Y))
                          : "Audio" === N.type
                            ? this.actions[L].push(new wB(R, N, _, Y))
                            : "Video" === N.type &&
                              this.actions[L].push(new wk(R, N, _));
                    } catch {}
                  });
                }),
              this.dispatchStopEvent("move"),
              this.dispatchStopEvent("jump"),
              this.dispatchStartEvent("idle");
          }
          reset(_ = !1) {
            if (
              (this.object.rotation.copy(this.rotation0),
              this.object.position.copy(this.position0),
              this.object.scale.copy(this.scale0),
              this.object.hiddenMatrix.copy(this.hiddenMatrix0),
              !0 === _)
            ) {
              this.object.updateMatrix(),
                this.object.updateMatrixWorld(),
                this.object.matrix.copy(this.object.matrixWorld),
                this.object.matrix.decompose(
                  this.object.position,
                  this.object.quaternion,
                  this.object.scale,
                ),
                this.object.parent
                  ? this.object.hiddenMatrix
                      .copy(this.object.parent.matrixWorld)
                      .invert()
                  : this.object.hiddenMatrix.identity(),
                this.object.rotation.reorder("YXZ");
              let _ = this.object.rotation.y;
              (this.object.rotation.y = 0),
                this.objXZQuat.copy(this.object.quaternion),
                this.objXZQuatInv.copy(this.objXZQuat).invert(),
                this.objXZRotMat.makeRotationFromQuaternion(
                  this.object.quaternion,
                ),
                this.object.rotation.set(0, _, 0),
                this.rot.setFromEuler(this.object.rotation),
                this.euler.setFromQuaternion(this.object.quaternion, "YXZ"),
                this.velocityTarget.set(0, 0, 0),
                this.velocity.set(0, 0, 0);
            }
            !1 === _ &&
              (this.object instanceof bj
                ? (this.object.matrixAutoUpdate = !0)
                : this.object.updateMatrix()),
              !0 === this.cameraFollow &&
                (this.camera.quaternion.copy(this.quat0Cam),
                this.camera.position.copy(this.position0Cam),
                this.camera.scale.copy(this.scale0Cam),
                this.camera.hiddenMatrix.copy(this.hiddenMatrix0Cam),
                (this.camera.matrixAutoUpdate = !0)),
              this.dispatchEvent(Sh);
          }
          connect() {
            this.domElement.ownerDocument.addEventListener(
              "pointerdown",
              this.onPointerDown,
            ),
              this.domElement.ownerDocument.addEventListener(
                "keydown",
                this.onKeyDown,
              ),
              this.domElement.ownerDocument.addEventListener(
                "keyup",
                this.onKeyUp,
              ),
              this.domElement.ownerDocument.addEventListener(
                "pointerlockchange",
                this.onPointerlockChange,
              ),
              this.domElement.ownerDocument.addEventListener(
                "pointerlockerror",
                this.onPointerlockError,
              );
          }
          disconnect() {
            this.domElement.ownerDocument.removeEventListener(
              "pointerdown",
              this.onPointerDown,
            ),
              this.domElement.ownerDocument.removeEventListener(
                "keydown",
                this.onKeyDown,
              ),
              this.domElement.ownerDocument.removeEventListener(
                "keyup",
                this.onKeyUp,
              ),
              this.domElement.ownerDocument.removeEventListener(
                "pointerlockchange",
                this.onPointerlockChange,
              ),
              this.domElement.ownerDocument.removeEventListener(
                "pointerlockerror",
                this.onPointerlockError,
              );
          }
          dispose() {
            this.disconnect(),
              Object.values(this.actions).forEach((_) => {
                _.forEach((_) => {
                  (_ instanceof _d || _ instanceof wB || _ instanceof wk) &&
                    _.dispose();
                });
              });
          }
          dispatchStartEvent(_) {
            void 0 !== this.actions[_] &&
              (this.actionState[_] ||
                ((this.actionState[_] = !0),
                this.actions[_].forEach((_) => {
                  _ instanceof _d
                    ? _.play()
                    : _ instanceof wB && _.dispatchGameControl("start");
                })));
          }
          dispatchStopEvent(_) {
            void 0 === this.actions[_] ||
              (this.actionState[_] &&
                ((this.actionState[_] = !1),
                this.actions[_].forEach((_) => {
                  _ instanceof _d
                    ? _.stop()
                    : _ instanceof wB && _.dispatchGameControl("stop");
                }),
                this.object.traverseEntity((_) => {
                  null !== _.currentState &&
                    _.changeSelectedState(null, {
                      scene: this.scene,
                      shared: this.sharedAssets,
                    });
                })));
          }
          update(_, L, R) {
            if (
              this.gravity < 0
                ? this.object.position.y < this.resetYPosition
                : this.object.position.y > this.resetYPosition
            )
              return this.reset(!0), !0;
            this.sharedGameControlGlobals.gamePads.forEach(
              this.copyVRGamePadValues,
            );
            let N = (this.isFirstFrame ? 16.6 : _) / 1e3;
            this.isFirstFrame && (this.isFirstFrame = !1);
            let z = 60 * N,
              F = !1;
            if (this.usePhysics && this.collisionEnabled) {
              let _ = Sy.set(
                  0,
                  (0 === this.velocity.y
                    ? this.pixelsPerMeter *
                      Math.max(Math.abs(this.gravity) / 120, 1) *
                      (this.gravity > 0 ? 1 : -1)
                    : this.velocity.y) * N,
                  0,
                ).divideScalar(this.pixelsPerMeter),
                L = this.sharedGameControlGlobals.rapierWorld.castShape(
                  Sv.copy(this.collider.position)
                    .applyQuaternion(this.objectRealQuat)
                    .add(this.object.position)
                    .divideScalar(this.pixelsPerMeter),
                  this.colliderWorldQuat,
                  _,
                  this.object.rigidBody?.collider(0).shape,
                  1,
                  !1,
                  void 0,
                  void 0,
                  void 0,
                  this.object.rigidBody,
                );
              if (L) {
                (this.onObject = !0),
                  this.groundNormal
                    .set(L.normal2.x, L.normal2.y, L.normal2.z)
                    .applyQuaternion(this.colliderWorldQuat)
                    .negate(),
                  this.alignToGround &&
                    this.groundTiltAdjustment(this.groundNormal),
                  Math.acos(this.groundNormal.y) < this.slopeThresh && (F = !0),
                  L.collider.parent()?.bodyType() === 0 &&
                    Math.acos(this.groundNormal.y) * (180 / Math.PI) > 45 &&
                    (this.onObject = !1);
                let _ = L.collider.parent();
                for (let L of ((this.groundYRotation = 0),
                this.groundVelocity.set(0, 0, 0),
                this.sharedGameControlGlobals.entitiesWithTransformAnim))
                  if (L.rigidBody === _) {
                    (L.hasNonUniformScale
                      ? L.matrixWorldRigid
                      : L.matrixWorld
                    ).decompose(Sv, SC, Sy),
                      this.groundVelocity.subVectors(Sv, L.prevT),
                      this.object
                        .getWorldPosition(Sy)
                        .add(this.collider.position)
                        .sub(L.position),
                      (this.groundYRotation =
                        SP.setFromQuaternion(SC).y - L.prevR.y),
                      Sb.copy(Sy).applyAxisAngle(SO, this.groundYRotation),
                      this.groundVelocity.add(Sb.sub(Sy)).divideScalar(N);
                    break;
                  }
              } else this.onObject = !1;
            }
            "walk" === this.moveMode &&
              this.collisionEnabled &&
              (1 === this.movementState.jump &&
                this.onObject &&
                ((this.velocityTarget.y = this.jumpPower),
                (this.movementState.jump = 0),
                this.dispatchStopEvent("idle"),
                this.dispatchStopEvent("move"),
                this.dispatchStopEvent("jump"),
                this.dispatchStartEvent("jump"),
                (this.onObject = !1)),
              this.onObject
                ? (this.velocityTarget.y /= 2)
                : (this.velocityTarget.y += this.gravity * z)),
              "fly" === this.moveMode &&
                (this.velocityTarget.y =
                  (this.movementState.movePosY - this.movementState.moveNegY) *
                  this.speedTranslate),
              (this.directionXZ.z =
                this.movementState.movePosZ - this.movementState.moveNegZ),
              (this.directionXZ.x =
                this.movementState.movePosX - this.movementState.moveNegX),
              this.directionXZ.normalize(),
              this.movementState.moveNegZ || this.movementState.movePosZ
                ? (this.velocityTarget.z =
                    this.directionXZ.z * this.speedTranslate * this.moveForce)
                : (this.velocityTarget.z = 0),
              this.movementState.moveNegX || this.movementState.movePosX
                ? (this.velocityTarget.x =
                    this.directionXZ.x * this.speedTranslate * this.moveForce)
                : (this.velocityTarget.x = 0),
              (
                "walk" === this.moveMode
                  ? this.velocityTarget.x + this.velocityTarget.z === 0
                  : 0 === this.velocityTarget.manhattanLength()
              )
                ? this.lerpFactorPos.setScalar(this.lerpFactorPosEnd)
                : this.lerpFactorPos.setScalar(this.lerpFactorPosStart),
              "walk" === this.moveMode && (this.lerpFactorPos.y = 1),
              (!1 === this.didHit &&
                0 === this.pushedVelocity.manhattanLength()) ||
              !1 === this.usePhysics
                ? ((this.velocity.x +=
                    (this.velocityTarget.x - this.velocity.x) *
                    (1 - (1 - this.lerpFactorPos.x) ** z)),
                  (this.velocity.y +=
                    (this.velocityTarget.y - this.velocity.y) *
                    (1 - (1 - this.lerpFactorPos.y) ** z)),
                  (this.velocity.z +=
                    (this.velocityTarget.z - this.velocity.z) *
                    (1 - (1 - this.lerpFactorPos.z) ** z)))
                : this.velocity.copy(this.velocityTarget),
              (
                "walk" === this.moveMode
                  ? this.velocity.x ** 2 + this.velocity.z ** 2 <
                    this.speedTranslate
                  : this.velocity.lengthSq() < this.speedTranslate
              )
                ? (this.dispatchStopEvent("move"),
                  this.onObject &&
                    (this.dispatchStopEvent("jump"),
                    this.dispatchStartEvent("idle")))
                : (this.dispatchStopEvent("idle"),
                  this.onObject &&
                    (this.dispatchStopEvent("jump"),
                    this.dispatchStartEvent("move")));
            let U = Sg.copy(this.velocity);
            if ("none" !== this.orientMode && !1 === this.isFirstPerson) {
              let _ = Sy.copy(U);
              (_.y = 0), U.set(0, U.y, -1 * _.length());
            }
            if (
              (SP.setFromVector3(this.rot),
              "walk" === this.moveMode && (SP.x = 0),
              U.applyEuler(SP),
              F &&
                (SC.setFromUnitVectors(SO, this.groundNormal),
                U.applyQuaternion(SC)),
              R)
            ) {
              let _ = SP.set(0, this.vrEulerYOffset * Sz, 0);
              R.applyEuler(_),
                (U.x += R.x),
                (U.z += R.z),
                (this.nonColliderPosOffset.elements[13] += R.y * N);
            }
            if (!0 === this.usePhysics) {
              for (let _ of (this.pushedVelocity.set(0, 0, 0),
              this.sharedGameControlGlobals.entitiesWithTransformAnim)) {
                let L = Sb.setFromMatrixPosition(_.matrixWorld)
                    .sub(_.prevT)
                    .divideScalar(N)
                    .divideScalar(this.pixelsPerMeter),
                  R = _.rigidBody
                    .collider(0)
                    .castCollider(
                      L,
                      this.object.rigidBody.collider(0),
                      Sv.copy(U).divideScalar(this.pixelsPerMeter),
                      N,
                      !1,
                    );
                if ((L.multiplyScalar(this.pixelsPerMeter), null !== R)) {
                  this.pushedVelocity.copy(L),
                    Sy.copy(R.normal1).applyQuaternion(_.quaternion);
                  break;
                }
              }
              if (0 !== this.pushedVelocity.manhattanLength()) {
                let _ = Sy.dot(U);
                _ < 0 && U.addScaledVector(Sy, -_), U.add(this.pushedVelocity);
              } else U.add(this.groundVelocity);
            }
            if (
              ((this.rotDirection.y =
                Number(this.movementState.rotPosY) -
                Number(this.movementState.rotNegY)),
              (this.rotDirection.x =
                Number(this.movementState.rotPosX) -
                Number(this.movementState.rotNegX)),
              this.rotDirection.normalize(),
              ("normal" === this.rotationMode &&
                (this.movementState.rotPosX || this.movementState.rotNegX)) ||
              ("steer" === this.rotationMode &&
                (this.movementState.rotPosX || this.movementState.rotNegX) &&
                (this.movementState.movePosZ ||
                  this.movementState.moveNegZ ||
                  "walk" === this.moveMode))
                ? (this.rotVelocityStick.x =
                    -this.rotDirection.x * this.speedOrbit * this.rotForce)
                : (this.rotVelocityStick.x = 0),
              ("normal" === this.rotationMode &&
                (this.movementState.rotPosY || this.movementState.rotNegY)) ||
              ("steer" === this.rotationMode &&
                (this.movementState.rotPosY || this.movementState.rotNegY) &&
                (this.movementState.movePosZ || this.movementState.moveNegZ))
                ? (this.rotVelocityStick.y =
                    -this.rotDirection.y * this.speedOrbit * this.rotForce)
                : (this.rotVelocityStick.y = 0),
              this.rotVelocityTarget.subVectors(
                this.eulerDelta.divideScalar(N),
                this.rotVelocityStick,
              ),
              0 === this.rotVelocityTarget.manhattanLength()
                ? this.rotVelocity.lerp(
                    this.rotVelocityTarget,
                    1 - (1 - this.lerpFactorRotEnd) ** z,
                  )
                : this.rotVelocity.lerp(
                    this.rotVelocityTarget,
                    1 - (1 - this.lerpFactorRotStart) ** z,
                  ),
              (this.euler.x += this.rotVelocity.x * N),
              (this.euler.y += this.rotVelocity.y * N + this.groundYRotation),
              0 === this.rotVelocityTarget.y &&
              0 === this.directionXZ.manhattanLength()
                ? (this.rotationAccumWhenOrientWithCamera = 0)
                : (!1 === this.cameraFollow || "Locked" === this.cameraYAxis) &&
                  (this.rotationAccumWhenOrientWithCamera +=
                    this.rotVelocity.y * N),
              !1 === this.isFirstPerson &&
                "none" !== this.orientMode &&
                this.directionXZ.manhattanLength() > 0)
            ) {
              let _ = Sy.copy(this.directionXZ);
              (_.x *= -1), this.camera.getWorldDirection(Sv);
              let L = Sb.copy(SO).multiplyScalar(Sv.dot(SO));
              if (
                (Sv.sub(L),
                "camera" === this.orientWith
                  ? (this.rot.y =
                      Sv.angleTo(_) * (Sv.cross(_).y > 0 ? -1 : 1) +
                      this.rotationAccumWhenOrientWithCamera)
                  : (this.rot.y =
                      this.euler.y +
                      Math.atan2(-this.directionXZ.z, this.directionXZ.x) -
                      Math.PI / 2),
                "radial" === this.orientMode)
              ) {
                this.objectToCamXZ
                  .copy(this.objectToCamXZ0)
                  .applyAxisAngle(SO, this.euler.y - this.euler0.y);
                let _ = Sy.copy(this.objectToCamXZ).normalize(),
                  L = Sb.copy(U).multiplyScalar(N);
                L.y = 0;
                let R = L.sub(Sv.copy(_).multiplyScalar(L.dot(_))).cross(_).y;
                this.euler.y -= Math.atan2(R, this.objectToCamXZ.length());
              }
            } else
              (this.rot.y += this.rotVelocity.y * N + this.groundYRotation),
                0 !== this.rotVelocityTarget.y &&
                  (!1 === this.cameraFollow || "Locked" === this.cameraYAxis) &&
                  (this.euler.y = this.rot.y);
            if (
              (!0 === this.cameraFollow &&
                ("walk" === this.moveMode
                  ? "Limit" === this.cameraXAxis
                    ? (this.euler.x = iE.clamp(
                        this.euler.x,
                        -this.maxPolarAngle + this.cameraPolarOffset + 1e-6,
                        -this.minPolarAngle + this.cameraPolarOffset - 1e-6,
                      ))
                    : (this.euler.x = iE.clamp(
                        this.euler.x,
                        -this.PI_2 + this.cameraPolarOffset,
                        this.PI_2 + this.cameraPolarOffset,
                      ))
                  : "Limit" === this.cameraXAxis &&
                    (this.euler.x = iE.clamp(
                      this.euler.x,
                      -this.PI_2,
                      this.PI_2,
                    ))),
              "fly" === this.moveMode
                ? (this.rot.x = this.euler.x)
                : this.isFirstPerson &&
                  (L ? SP.copy(L) : SP.copy(this.euler),
                  (SP.y = 0),
                  this.nonColliderRotOffset.makeRotationFromEuler(SP)),
              L &&
                ("walk" === this.moveMode
                  ? ((this.rot.y = L.y), (this.rot.x = 0), (this.rot.z = 0))
                  : this.rot.setFromEuler(L),
                (this.rot.y += this.vrEulerYOffset * Sz)),
              SM.setFromAxisAngle(SD, this.rot.x),
              SC.setFromAxisAngle(SO, this.rot.y),
              SC.multiply(SM),
              SM.setFromAxisAngle(SL, this.rot.z),
              SC.multiply(SM),
              this.object.quaternion.copy(SC),
              this.objectRealQuat.multiplyQuaternions(
                this.object.quaternion,
                this.objXZQuat,
              ),
              this.objectRealQuat.multiply(this.objXZQuat),
              this.colliderWorldQuat
                .copy(this.objectRealQuat)
                .multiply(this.collider.rotation),
              this.collisionEnabled)
            ) {
              if (this.usePhysics) {
                let _ = Sy.copy(U).multiplyScalar(N / this.pixelsPerMeter),
                  L = null;
                this.didHit = !1;
                let R = new iq();
                for (let N = 0; N < 5; N++) {
                  let z = _.length(),
                    F = Sb.copy(_).normalize();
                  if (
                    null !==
                    (L = this.sharedGameControlGlobals.rapierWorld.castShape(
                      Sv.copy(this.collider.position)
                        .applyQuaternion(this.objectRealQuat)
                        .add(this.object.position)
                        .divideScalar(this.pixelsPerMeter)
                        .add(R),
                      this.colliderWorldQuat,
                      F,
                      this.object.rigidBody?.collider(0).shape,
                      z,
                      !1,
                      8,
                      void 0,
                      void 0,
                      this.object.rigidBody,
                    ))
                  ) {
                    this.didHit = !0;
                    let U =
                      this.sharedGameControlGlobals.colliderToEntity[
                        L.collider.handle
                      ];
                    if (U !== this.lastHitObj && 0 === N) {
                      this.lastHitObj = U;
                      let _ =
                        this.sharedGameControlGlobals.eventsPerObjects[U?.uuid];
                      if (_)
                        for (let L of _)
                          "character" === L.data.target &&
                            (U.dispatchEvent(So), L.dispatch());
                    }
                    let k = Sf.set(
                        L.normal2.x,
                        L.normal2.y,
                        L.normal2.z,
                      ).applyQuaternion(this.colliderWorldQuat),
                      Y = Sm.copy(F).multiplyScalar(L.toi).dot(k),
                      X = L.toi;
                    if (
                      (0 === X &&
                        (this.object.position.y +=
                          this.offset * this.pixelsPerMeter),
                      Y > this.offset &&
                        ((X = (L.toi * (Y - this.offset)) / Y),
                        R.addScaledVector(F, X)),
                      _.copy(F).multiplyScalar(z - X),
                      Math.acos(-k.y) > this.slopeThresh)
                    ) {
                      let N = Sv.copy(this.collider.position)
                          .applyQuaternion(this.objectRealQuat)
                          .add(this.object.position)
                          .divideScalar(this.pixelsPerMeter)
                          .add(R),
                        z = Sb.copy(L.witness2).applyQuaternion(
                          this.colliderWorldQuat,
                        );
                      z.y = 0;
                      let F = N.add(z);
                      F.y += this.stepThresh;
                      let U =
                        this.sharedGameControlGlobals.rapierWorld.castShape(
                          F,
                          this.colliderWorldQuat,
                          _,
                          this.object.rigidBody?.collider(0).shape,
                          1,
                          !1,
                          8,
                          void 0,
                          void 0,
                          this.object.rigidBody,
                        );
                      null !== U && 0 === U.toi && ((k.y = 0), k.normalize());
                    }
                    _.addScaledVector(k, -_.dot(k));
                  } else {
                    0 === N &&
                      0 !== this.directionXZ.manhattanLength() &&
                      (this.lastHitObj = null),
                      R.add(_);
                    break;
                  }
                }
                this.object.position.addScaledVector(R, this.pixelsPerMeter),
                  this.object.rigidBody?.setTranslation(
                    Sv.copy(this.object.position).divideScalar(
                      this.pixelsPerMeter,
                    ),
                    !0,
                  ),
                  this.object.rigidBody?.setRotation(
                    SM.copy(this.object.quaternion)
                      .premultiply(this.groundTilt)
                      .multiply(this.objXZQuat),
                    !0,
                  );
              } else {
                let _ = this.onObject ? 1 : 5,
                  L = U.multiplyScalar(N / _);
                for (let R = 0; R < _; R++)
                  this.object.position.add(L), this.collisionAdjustment(N / _);
              }
            } else this.object.position.addScaledVector(U, N);
            if (
              ("walk" === this.moveMode &&
                this.onObject &&
                ((this.velocityTarget.y = 0), (this.velocity.y = 0)),
              this.object.quaternion
                .premultiply(this.groundTilt)
                .multiply(this.objXZQuat),
              this.object.updateMatrix(),
              this.object.matrix
                .multiply(this.nonColliderPosOffset)
                .multiply(this.nonColliderRotOffset),
              this.object.quaternion
                .premultiply(this.groundTiltInv)
                .multiply(this.objXZQuatInv),
              !0 === this.cameraFollow)
            ) {
              this.updateFollowArms();
              let _ = this.objectToTarget.add(this.object.position),
                L = this.targetToCamera.add(_);
              Sw.lookAt(L, _, SO).setPosition(L),
                Sw.decompose(this.targetPos, this.targetQuat, Sv),
                this.camera.quaternion.slerp(
                  this.targetQuat,
                  1 - (1 - this.lerpFactorRotCamera) ** z,
                ),
                this.camera.position.lerp(
                  this.targetPos,
                  1 - (1 - this.lerpFactorPosCamera) ** z,
                ),
                this.camera.updateMatrix(),
                this.camera.updateMatrixWorld(),
                "Limit" === this.cameraYAxis &&
                  "cartesian" === this.orientMode &&
                  (this.euler.y = iE.clamp(
                    this.euler.y,
                    this.minAzimuthAngleRel,
                    this.maxAzimuthAngleRel,
                  )),
                (this.euler.x = iE.clamp(
                  this.euler.x,
                  -this.PI_2 +
                    (this.cameraPolarOffset < 0 ? this.cameraPolarOffset : 0),
                  this.PI_2 +
                    (this.cameraPolarOffset > 0 ? this.cameraPolarOffset : 0),
                ));
            }
            return (
              this.eulerDelta.set(0, 0, 0),
              (!(
                this.lastPosition.distanceToSquared(this.object.position) <
                  this.threshEndTranslate &&
                Math.abs(this.rotVelocity.x) < this.threshEndRotVel &&
                Math.abs(this.rotVelocity.y) < this.threshEndRotVel &&
                (void 0 === this.camera ||
                  this.isFirstPerson ||
                  (this.lastCameraPosition.distanceToSquared(
                    this.camera.position,
                  ) < this.threshEndTranslate &&
                    8 *
                      (1 -
                        this.lastCameraQuaternion.dot(this.camera.quaternion)) <
                      this.threshEndRotate))
              ) ||
                ("fly" !== this.moveMode &&
                  !0 !== this.onObject &&
                  !1 !== this.collisionEnabled)) &&
                (this.camera &&
                  (this.lastCameraPosition.copy(this.camera.position),
                  this.lastCameraQuaternion.copy(this.camera.quaternion)),
                this.lastPosition.copy(this.object.position),
                this.object.dispatchEvent(SN),
                !0)
            );
          }
          updateFollowArms() {
            let _;
            this.objectToTarget.copy(this.objectToTarget0),
              this.targetToCamera.copy(this.targetToCamera0);
            let L = SM.setFromAxisAngle(
              SO,
              "Limit" === this.cameraYAxis && "radial" !== this.orientMode
                ? iE.clamp(
                    this.euler.y - this.euler0.y,
                    this.minAzimuthAngleRel,
                    this.maxAzimuthAngleRel,
                  )
                : this.euler.y - this.euler0.y,
            );
            ("Locked" !== this.cameraYAxis || "radial" === this.orientMode) &&
              this.objectToTarget.applyQuaternion(L),
              (_ =
                "Limit" === this.cameraXAxis
                  ? iE.clamp(
                      this.euler.x,
                      -this.maxPolarAngle + this.cameraPolarOffset + 1e-6,
                      -this.minPolarAngle + this.cameraPolarOffset - 1e-6,
                    )
                  : iE.clamp(
                      this.euler.x,
                      -this.PI_2 + this.cameraPolarOffset + 1e-6,
                      this.PI_2 + this.cameraPolarOffset - 1e-6,
                    ));
            let R = Sv.copy(this.cameraPolarAxis0);
            ("Locked" !== this.cameraYAxis || "radial" === this.orientMode) &&
              R.applyQuaternion(L);
            let N = SC.setFromAxisAngle(R, _);
            "Locked" !== this.cameraYAxis &&
              this.targetToCamera.applyQuaternion(L),
              "Locked" !== this.cameraXAxis &&
                this.targetToCamera.applyQuaternion(N);
          }
          groundTiltAdjustment(_) {
            (180 * SO.angleTo(_)) / Math.PI < 15 ||
            (180 * SO.angleTo(_)) / Math.PI > 85
              ? SM.identity()
              : SM.setFromUnitVectors(SO, _),
              this.groundTilt.slerp(SM, 0.06),
              this.groundTiltInv.copy(this.groundTilt).invert();
          }
          collisionAdjustment(_) {
            let L = Sm.set(0, 0, 0);
            this.object.updateMatrix();
            let R = Sw.multiplyMatrices(this.object.matrix, this.objXZRotMat)
              .multiply(this.collider.matrix)
              .decompose(Sv, SM, Sy)
              .compose(Sv, SM, SR);
            this.sharedGameControlGlobals.entitiesWithTransformAnim.forEach(
              (_) => {
                if (_ === this.object || _.isDescendantOf(this.object)) return;
                SB.makeEmpty(), _.updateMatrixWorldSVD();
                let N = _.matrixWorldRigid,
                  z = S_.copy(N).invert(),
                  F = SS.copy(S_).multiply(R);
                SI.copy(this.collider.segment),
                  SI.start.applyMatrix4(F),
                  SI.end.applyMatrix4(F);
                let U = Sf.copy(this.object.position).applyMatrix4(z);
                SB.expandByPoint(SI.start),
                  SB.expandByPoint(SI.end),
                  SB.min.addScalar(-this.collider.radius),
                  SB.max.addScalar(this.collider.radius),
                  _.boundsTree.shapecast({
                    intersectsBounds: (_) => _.intersectsBox(SB),
                    intersectsTriangle: (_) => {
                      let R = _.closestPointToSegment(SI, Sv, Sy);
                      if (R < this.collider.radius) {
                        let _ = this.collider.radius - R,
                          z = Sy.sub(Sv).normalize(),
                          F = Sb.copy(U);
                        F.addScaledVector(z, _);
                        let k = F.applyMatrix4(N).sub(this.object.position);
                        L.add(k),
                          SI.start.addScaledVector(z, _),
                          SI.end.addScaledVector(z, _);
                      }
                    },
                  });
              },
            ),
              SB.makeEmpty(),
              SI.copy(this.collider.segment),
              SI.start.applyMatrix4(R),
              SI.end.applyMatrix4(R),
              SB.expandByPoint(SI.start),
              SB.expandByPoint(SI.end),
              SB.min.addScalar(-this.collider.radius),
              SB.max.addScalar(this.collider.radius),
              this.sharedGameControlGlobals.staticMeshBVH?.shapecast({
                intersectsBounds: (_) => _.intersectsBox(SB),
                intersectsTriangle: (_) => {
                  let R = _.closestPointToSegment(SI, Sv, Sy);
                  if (R < this.collider.radius) {
                    let _ = this.collider.radius - R,
                      N = Sy.sub(Sv).normalize();
                    this.alignToGround && this.groundTiltAdjustment(N),
                      L.addScaledVector(N, _),
                      SI.start.addScaledVector(N, _),
                      SI.end.addScaledVector(N, _);
                  }
                },
              }),
              (this.onObject =
                Math.abs(L.y) > Math.abs(_ * this.velocity.y * 0.25)),
              this.onObject && this.dispatchStopEvent("jump");
            let N = Math.max(0, L.length() - 1e-5);
            L.normalize().multiplyScalar(N), this.object.position.add(L);
          }
        },
        SU = SF;
      SU.isLocked = !1;
      var Sk = { type: "change" },
        Sj = { type: "changeZoom" },
        SG = { type: "changePan" },
        SV = { type: "start" },
        SH = { type: "end", changed: !0 },
        SW = { type: "end", changed: !1 },
        SY = new iX(),
        SX = new iT(),
        Sq = 2 * Math.PI,
        SQ = new iq(),
        SZ = new iT(),
        SK = new iq(),
        SJ = new iX(),
        S$ = new rw(),
        S0 = { type: "requestRender" },
        S1 = class extends ig {
          constructor(_, L, R = { isPlayMode: !1, isExport: !1 }) {
            super(),
              (this.object = _),
              (this.domElement = L),
              (this.options = R),
              (this.enabled = !0),
              (this.useKeyEvents = !0),
              (this.enableDamping = !1),
              (this.enableZoom = !0),
              (this.enableRotate = !0),
              (this.enablePan = !0),
              (this.autoRotate = !1),
              (this.rotationLimitsMode = 0),
              (this.panLimitsMode = 0),
              (this.rotationSoftLimit = 2),
              (this.panSoftLimit = 2),
              (this.hoverRotatePanMode = 0),
              (this.zoomLimitsEnabled = !1),
              (this.mouseButtons = [0, 5]),
              (this.mouseButtonsPlay = [3, 4, 5]),
              (this.touches = [null, ih.DOLLY_ROTATE, ih.PAN]),
              (this.offset = new iq()),
              (this.eye = new iq()),
              (this.lastPosition = new iq()),
              (this.lastQuaternion = new iX()),
              (this.current = new iT()),
              (this.overShoot = new iT()),
              (this.overRatio = new iT()),
              (this.spherical = new oU()),
              (this.sphericalDelta = new oU()),
              (this.panOffset = new iq()),
              (this.panLeftV = new iq()),
              (this.panUpV = new iq()),
              (this.panV = new iq()),
              (this.rotateStart = new iT()),
              (this.rotateEnd = new iT()),
              (this.rotateDelta = new iT()),
              (this.panStart = new iT()),
              (this.panEnd = new iT()),
              (this.panDelta = new iT()),
              (this.dollyStart = new iT()),
              (this.dollyEnd = new iT()),
              (this.dollyDelta = new iT()),
              (this.rotationRangeFactor = new iT()),
              (this.panRangeFactor = new iT()),
              (this.state = -1),
              (this.zoomChanged = !1),
              (this.isPointerDown = !1),
              (this.isThetaFlipped = !1),
              (this.prevScale = 0),
              (this.scale = 1),
              (this.gesture = !1),
              (this.timer = -1),
              (this.timerHover = -1),
              (this.minDistance = 0),
              (this.maxDistance = 1 / 0),
              (this.minZoom = 0),
              (this.maxZoom = 1 / 0),
              (this.minPhi = 0),
              (this.maxPhi = Math.PI),
              (this.minTheta = -1 / 0),
              (this.maxTheta = 1 / 0),
              (this.minH = 0),
              (this.maxH = Math.PI),
              (this.minV = -1 / 0),
              (this.maxV = 1 / 0),
              (this.autoRotateClockwise = !0),
              (this.isPanOverShoot = !1),
              (this.isRotateOverShoot = !1),
              (this.resetHoverEffectOnPointerLeave = !1),
              (this.hasChange = !1),
              (this.useWindowEvents = !1),
              (this.isTouchZoom = !0),
              (this.autoRotateSpeed = 2),
              (this.dampingFactor = 0.125),
              (this.zoomSpeed = 2),
              (this.rotateSpeed = 1),
              (this.panSpeed = 1),
              (this.hoverRotatePanStrength = 0.1),
              (this.thetaIsFree = !1),
              (this.phiIsFree = !1),
              (this.needsUpdate = !0),
              (this.update = () => {
                this.object.updateWorldMatrix(!0, !1),
                  this.object.matrixWorld.decompose(SK, SJ, SQ),
                  this.offset.copy(SK).sub(this.target),
                  this.spherical.setFromVector3(this.offset),
                  this.object.isUpVectorFlipped &&
                    ((this.spherical.phi *= -1),
                    (this.spherical.theta -= Math.PI)),
                  this.autoRotate &&
                    -1 === this.state &&
                    this.rotateLeft(
                      (!0 === this.autoRotateClockwise ? 1 : -1) *
                        this.getAutoRotationAngle(),
                    ),
                  0 !== this.rotationLimitsMode &&
                    this.applyLimits(
                      this.sphericalDelta,
                      this.rotationLimitsMode,
                      this.rotationSoftLimit,
                      this.maxTheta,
                      this.minTheta,
                      this.maxPhi,
                      this.minPhi,
                      this.rotationRangeFactor,
                    ),
                  2 !== this.rotationLimitsMode &&
                    (this.spherical.phi += this.sphericalDelta.phi),
                  (1 !== this.rotationLimitsMode || !0 === this.autoRotate) &&
                    (this.spherical.theta += this.sphericalDelta.theta),
                  (this.spherical.radius *= this.scale),
                  this.zoomLimitsEnabled &&
                    (this.spherical.radius = Math.max(
                      this.minDistance,
                      Math.min(this.maxDistance, this.spherical.radius),
                    )),
                  0 !== this.panLimitsMode &&
                    (this.target.applyQuaternion(SY.copy(SJ).invert()),
                    this.panOffset.applyQuaternion(SY),
                    this.applyLimits(
                      this.panOffset,
                      this.panLimitsMode,
                      this.panSoftLimit,
                      this.maxH,
                      this.minH,
                      this.maxV,
                      this.minV,
                      this.panRangeFactor,
                    ),
                    this.target.applyQuaternion(SJ),
                    this.panOffset.applyQuaternion(SJ)),
                  2 === this.panLimitsMode && (this.panOffset.y = 0),
                  1 === this.panLimitsMode && (this.panOffset.x = 0),
                  -1 !== this.state || this.gesture
                    ? (this.target.add(this.panOffset),
                      this.panOffset.set(0, 0, 0))
                    : (this.panOffset.multiplyScalar(1 - this.dampingFactor),
                      this.target.add(this.panOffset)),
                  this.offset.setFromSpherical(this.spherical),
                  SK.copy(this.target).add(this.offset),
                  this.object.position.copy(this.target).add(this.offset),
                  this.object.parent &&
                    (S$.copy(this.object.parent.matrixWorld).invert(),
                    this.object.position.applyMatrix4(S$));
                let _ = this.spherical.phi % Sq;
                return (
                  this.eye.copy(this.offset).normalize(),
                  this.object.up
                    .copy(rK.DEFAULT_UP)
                    .applyAxisAngle(this.eye, this.object.angleOffsetFromUp),
                  (_ > 0 && _ > Math.PI) || (_ < 0 && _ > -Math.PI)
                    ? (this.object.up.negate(),
                      this.object.lookAt(this.target),
                      (this.object.isUpVectorFlipped = !0))
                    : (this.object.lookAt(this.target),
                      (this.object.isUpVectorFlipped = !1)),
                  -1 === this.state || !0 === this.enableDamping
                    ? ((this.sphericalDelta.theta *= 1 - this.dampingFactor),
                      (this.sphericalDelta.phi *= 1 - this.dampingFactor))
                    : this.sphericalDelta.set(0, 0, 0),
                  (this.scale = 1),
                  (this.object.wasMovedByUser = !0),
                  this.zoomChanged ||
                  this.lastPosition.distanceToSquared(this.object.position) >
                    0.01 ||
                  8 * (1 - this.lastQuaternion.dot(this.object.quaternion)) >
                    1e-8
                    ? (this.dispatchEvent(Sk),
                      this.object.dispatchEvent(S0),
                      this.lastPosition.copy(this.object.position),
                      this.lastQuaternion.copy(this.object.quaternion),
                      (this.zoomChanged = !1),
                      !0)
                    : ((this.isPanOverShoot = !1),
                      (this.isRotateOverShoot = !1),
                      this.sphericalDelta.set(0, 0, 0),
                      this.panOffset.set(0, 0, 0),
                      !1)
                );
              }),
              (this.onPointerDown = (_) => {
                !1 !== this.enabled &&
                  ("touch" === _.pointerType || ("pen" === _.pointerType && pJ)
                    ? this.onPointerDownTouch(_)
                    : this.onPointerDownMouse(_),
                  -1 !== this.state &&
                    ((this.isPointerDown = !0),
                    this.dispatchEvent(SV),
                    this.domElement.addEventListener(
                      "pointermove",
                      this.onPointerMove,
                    ),
                    this.domElement.addEventListener(
                      "pointerup",
                      this.onPointerUp,
                    ),
                    _.stopPropagation(),
                    "touch" === _.pointerType ||
                      ("pen" === _.pointerType && pJ) ||
                      this.domElement.setPointerCapture(_.pointerId)));
              }),
              (this.onPointerLeave = (_) => {
                this.resetHoverEffectOnPointerLeave && !this.useWindowEvents
                  ? (1 === this.hoverRotatePanMode
                      ? ((this.sphericalDelta.theta = -this.spherical.theta),
                        (this.sphericalDelta.phi = -this.spherical.phi),
                        SQ.subVectors(this.position0, this.target0),
                        this.spherical.setFromVector3(SQ),
                        (this.sphericalDelta.theta += this.spherical.theta),
                        (this.sphericalDelta.phi += this.spherical.phi),
                        (this.sphericalDelta.theta /= 8),
                        (this.sphericalDelta.phi /= 8))
                      : 2 === this.hoverRotatePanMode &&
                        this.panOffset
                          .subVectors(this.target0, this.target)
                          .divideScalar(8),
                    this.update())
                  : (this.pointerLeaveEvent = _);
              }),
              (this.onPointerEnter = (_) => {
                this.resetHoverEffectOnPointerLeave ||
                void 0 === this.pointerLeaveEvent
                  ? SZ.set(
                      _.clientX - this.domElement.clientWidth / 2,
                      _.clientY - this.domElement.clientHeight / 2,
                    )
                  : SZ.set(
                      _.clientX - this.pointerLeaveEvent.clientX,
                      _.clientY - this.pointerLeaveEvent.clientY,
                    ),
                  1 === this.hoverRotatePanMode
                    ? (this.rotateDelta
                        .copy(SZ)
                        .multiplyScalar(
                          this.rotateSpeed * this.hoverRotatePanStrength,
                        )
                        .rotateAround(SX, -this.object.angleOffsetFromUp),
                      this.rotateLeft(
                        (2 * Math.PI * this.rotateDelta.x) /
                          this.domElement.clientHeight,
                      ),
                      this.rotateUp(
                        (2 * Math.PI * this.rotateDelta.y) /
                          this.domElement.clientHeight,
                      ),
                      this.rotateStart.set(_.clientX, _.clientY))
                    : 2 === this.hoverRotatePanMode &&
                      (this.panDelta
                        .copy(SZ)
                        .multiplyScalar(
                          this.panSpeed * this.hoverRotatePanStrength,
                        ),
                      this.pan(this.panDelta.x, this.panDelta.y),
                      this.panStart.set(_.clientX, _.clientY)),
                  this.update();
              }),
              (this.onPointerMove = (_) => {
                !1 !== this.enabled &&
                  ("touch" === _.pointerType || ("pen" === _.pointerType && pJ)
                    ? this.onPointerMoveTouch(_)
                    : this.onPointerMoveMouse(_),
                  _.stopPropagation());
              }),
              (this.onPointerUp = (_) => {
                (this.isPointerDown = !1),
                  0 === p1.length &&
                    (this.domElement.removeEventListener(
                      "pointermove",
                      this.onPointerMove,
                    ),
                    this.domElement.removeEventListener(
                      "pointerup",
                      this.onPointerUp,
                    )),
                  this.hasChange
                    ? this.dispatchEvent(SH)
                    : this.dispatchEvent(SW),
                  (this.state = -1),
                  _ &&
                    (_.stopPropagation(),
                    "touch" === _.pointerType ||
                      ("pen" === _.pointerType && pJ) ||
                      this.domElement.releasePointerCapture(_.pointerId));
              }),
              (this.onPointerDownMouse = (_) => {
                switch (
                  this.useKeyEvents
                    ? this.mouseButtons[_.button]
                    : this.mouseButtonsPlay[_.button]
                ) {
                  case 0:
                    if (!0 !== _.altKey || _.shiftKey || uh(_)) {
                      if (" " === this.key) {
                        if (!1 === this.enablePan) return;
                        this.handleMouseDownPan(_), (this.state = 2);
                      }
                    } else {
                      if (!1 === this.enableRotate) return;
                      this.handleMouseDownRotate(_), (this.state = 0);
                    }
                    break;
                  case 4:
                    if (!1 === this.enablePan) return;
                    this.handleMouseDownPan(_), (this.state = 2);
                    break;
                  case 3:
                    if (uh(_) || _.shiftKey) {
                      if (!1 === this.enablePan) return;
                      this.handleMouseDownPan(_), (this.state = 2);
                    } else {
                      if (!1 === this.enableRotate) return;
                      this.handleMouseDownRotate(_), (this.state = 0);
                    }
                    break;
                  case 5:
                    if (uh(_) || _.shiftKey) {
                      if (!1 === this.enableRotate) return;
                      this.handleMouseDownRotate(_), (this.state = 0);
                    } else {
                      if (!1 === this.enablePan) return;
                      this.handleMouseDownPan(_), (this.state = 2);
                    }
                    break;
                  default:
                    this.state = -1;
                }
              }),
              (this.onPointerMoveMouse = (_) => {
                switch (this.state) {
                  case 0:
                    if (!1 === this.enableRotate) return;
                    this.handleMouseMoveRotate(_);
                    break;
                  case 1:
                    if (!1 === this.enableZoom) return;
                    this.handleMouseMoveDolly(_);
                    break;
                  case 2:
                    if (!1 === this.enablePan) return;
                    this.handleMouseMovePan(_);
                }
              }),
              (this.onPointerDownTouch = (_) => {
                switch (this.touches[p1.length - 1]) {
                  case ih.ROTATE:
                    if (!1 === this.enableRotate) {
                      this.state = -1;
                      return;
                    }
                    this.handleTouchStartRotate(), (this.state = 3);
                    break;
                  case ih.PAN:
                    if (!1 === this.enablePan) {
                      this.state = -1;
                      return;
                    }
                    this.handleTouchStartPan(), (this.state = 4);
                    break;
                  case ih.DOLLY_PAN:
                    if (
                      (!1 === this.enableZoom && !1 === this.enablePan) ||
                      !1 === this.isTouchZoom
                    )
                      return;
                    this.handleTouchStartDollyPan(), (this.state = 5);
                    break;
                  case ih.DOLLY_ROTATE:
                    if (
                      (!1 === this.enableZoom && !1 === this.enableRotate) ||
                      !1 === this.isTouchZoom
                    )
                      return;
                    this.handleTouchStartDollyRotate(), (this.state = 6);
                    break;
                  default:
                    this.state = -1;
                }
              }),
              (this.onPointerMoveTouch = (_) => {
                switch (this.state) {
                  case 3:
                    if (!1 === this.enableRotate) return;
                    this.handleTouchMoveRotate(_), this.update();
                    break;
                  case 4:
                    if (!1 === this.enablePan) return;
                    this.handleTouchMovePan(_), this.update();
                    break;
                  case 5:
                    if (
                      (!1 === this.enableZoom && !1 === this.enablePan) ||
                      !1 === this.isTouchZoom
                    )
                      return;
                    this.handleTouchMoveDollyPan(_), this.update();
                    break;
                  case 6:
                    if (
                      (!1 === this.enableZoom && !1 === this.enableRotate) ||
                      !1 === this.isTouchZoom
                    )
                      return;
                    this.handleTouchMoveDollyRotate(_), this.update();
                    break;
                  default:
                    this.state = -1;
                }
              }),
              (this.dispatchEndDebounced = Qd(
                () => this.dispatchEvent(SH),
                33,
              )),
              (this.onMouseWheel = (_) => {
                !1 === this.enabled ||
                  (!1 === this.enableZoom && !1 === this.enablePan) ||
                  (!1 === this.options.isExport &&
                    this.domElement.clientHeight ===
                      document.body.clientHeight &&
                    this.domElement.clientWidth === document.body.clientWidth &&
                    _.preventDefault(),
                  this.dispatchEvent(SV),
                  this.handleMouseWheel(_),
                  this.dispatchEndDebounced());
              }),
              (this.onGesture = (_) => {
                !1 !== this.enabled &&
                  ((_.preventDefault(), "gesturechange" === _.type)
                    ? !1 !== this.enableZoom &&
                      !1 !== this.isTouchZoom &&
                      (this.dispatchEvent(SV),
                      _.scale > this.prevScale
                        ? this.dollyIn(this.getZoomScale())
                        : _.scale < this.prevScale &&
                          this.dollyOut(this.getZoomScale()),
                      (this.prevScale = _.scale),
                      this.update())
                    : this.dispatchEvent(SH));
              }),
              (this.onContextMenu = (_) => {
                !1 !== this.enabled && _.preventDefault();
              }),
              (this.onTouchEnd = (_) => {
                _.preventDefault();
              }),
              (this.onKeyDown = (_) => {
                !1 !== this.enabled &&
                  ((this.key = _.key), " " === _.key && this.dispatchEvent(SV));
              }),
              (this.onKeyUp = (_) => {
                !1 !== this.enabled &&
                  ((this.key = void 0),
                  -1 !== this.state && this.onPointerUp(p1[0]),
                  " " === _.key && this.dispatchEvent(SH));
              }),
              (this.onPointerHover = (_) => {
                "mouse" !== _.pointerType ||
                  !1 === this.enabled ||
                  -1 !== this.state ||
                  (2 === this.hoverRotatePanMode && this.isPanOverShoot) ||
                  (1 === this.hoverRotatePanMode && this.isRotateOverShoot) ||
                  ((this.isPointerDown = !0),
                  2 === this.hoverRotatePanMode
                    ? this.handleMouseMovePan(_, this.hoverRotatePanStrength)
                    : 1 === this.hoverRotatePanMode &&
                      this.handleMouseMoveRotate(
                        _,
                        this.hoverRotatePanStrength,
                      ));
              }),
              (this.onBeginState = () => {
                (this.enabled = !1), (this.needsUpdate = !1);
              }),
              (this.onCompleteState = (_) => {
                (_.isfromEntity && this.options.isPlayMode) ||
                  ((this.enabled = !0),
                  (this.needsUpdate = !0),
                  this.object.updateUp(),
                  this.object.getTarget(this.target));
              }),
              (this.target = this.object.getTarget()),
              (this.target0 = this.target.clone()),
              (this.position0 = this.object.position.clone()),
              (this.zoom0 = this.object.zoom),
              (this.quat0 = this.object.quaternion.clone()),
              (this.isUpVectorFlipped0 = this.object.isUpVectorFlipped),
              this.offset.copy(this.object.position).sub(this.target),
              this.spherical.setFromVector3(this.offset),
              this.object.isUpVectorFlipped &&
                ((this.spherical.phi *= -1), (this.spherical.theta -= Math.PI)),
              this.addEventListenersToCamera();
          }
          dispatchEvent(_) {
            "start" === _.type ? (this.hasChange = !1) : (this.hasChange = !0),
              super.dispatchEvent(_);
          }
          addEventListenersToCamera() {
            this.object.addEventListener("beginState", this.onBeginState),
              this.object.addEventListener(
                "completeState",
                this.onCompleteState,
              );
          }
          removeEventListenersFromCamera() {
            this.object.removeEventListener("beginState", this.onBeginState),
              this.object.removeEventListener(
                "completeState",
                this.onCompleteState,
              );
          }
          reset() {
            this.object.quaternion.copy(this.quat0),
              this.target.copy(this.target0),
              this.object.position.copy(this.position0),
              (this.object.zoom = this.zoom0),
              (this.object.isUpVectorFlipped = this.isUpVectorFlipped0),
              this.object.updateProjectionMatrix(),
              this.dispatchEvent(Sk),
              (this.state = -1),
              (this.pointerLeaveEvent = void 0);
          }
          resetTo(_, L, R, N, z = !1) {
            this.object.quaternion.copy(N),
              this.target.copy(_),
              this.object.position.copy(L),
              (this.object.zoom = R),
              (this.object.isUpVectorFlipped = z),
              this.object.updateProjectionMatrix(),
              this.dispatchEvent(Sk),
              this.update(),
              (this.state = -1);
          }
          updateUseWindowEvents(_) {
            if (
              (window.removeEventListener("pointermove", this.onPointerHover),
              this.domElement.removeEventListener(
                "pointermove",
                this.onPointerHover,
              ),
              (this.useWindowEvents = _),
              0 !== this.hoverRotatePanMode &&
                (this.useWindowEvents
                  ? window.addEventListener("pointermove", this.onPointerHover)
                  : this.domElement.addEventListener(
                      "pointermove",
                      this.onPointerHover,
                    )),
              this.domElement.removeEventListener(
                "pointerleave",
                this.onPointerLeave,
              ),
              this.domElement.removeEventListener(
                "pointerenter",
                this.onPointerEnter,
              ),
              window.removeEventListener("pointerleave", this.onPointerLeave),
              window.removeEventListener("pointerenter", this.onPointerEnter),
              0 !== this.hoverRotatePanMode && !this.useWindowEvents)
            ) {
              let _ = this.useWindowEvents ? window : this.domElement;
              _.addEventListener("pointerleave", this.onPointerLeave),
                _.addEventListener("pointerenter", this.onPointerEnter);
            }
          }
          fromJSON(_, L) {
            this.setEnableDampingSpeed(_.enableDamping),
              (this.enablePan = _.enablePan),
              (this.enableZoom = _.enableZoom),
              (this.enableRotate = _.enableRotate),
              (this.rotationLimitsMode = _.rotationLimitsMode),
              (this.thetaIsFree =
                _.rotationHorizontalOffset.min ===
                  _.rotationHorizontalOffset.max &&
                _.rotationHorizontalOffset.min === Math.PI),
              (this.phiIsFree =
                _.rotationVerticalOffset.min === _.rotationVerticalOffset.max &&
                _.rotationVerticalOffset.min === Math.PI),
              (this.panLimitsMode = _.panLimitsMode),
              (this.panSoftLimit = _.panSoftLimit),
              (this.rotationSoftLimit = _.rotationSoftLimit),
              (this.hoverRotatePanMode = _.hoverRotatePanMode),
              (this.useWindowEvents = "window" === L),
              0 !== this.hoverRotatePanMode &&
                (this.useWindowEvents
                  ? window.addEventListener("pointermove", this.onPointerHover)
                  : this.domElement.addEventListener(
                      "pointermove",
                      this.onPointerHover,
                    ));
            let R = _.hoverRotatePanStrength / 100;
            (this.hoverRotatePanStrength = R ** 2),
              (this.zoomLimitsEnabled = _.zoomLimitsEnabled),
              (this.minZoom = _.zoomLimits.min),
              (this.maxZoom = Math.max(_.zoomLimits.min, _.zoomLimits.max)),
              (this.minDistance = 1e3 / _.zoomLimits.max),
              (this.maxDistance = Math.max(
                this.minDistance,
                1e3 / _.zoomLimits.min,
              )),
              (this.autoRotate = _.autoRotate),
              (this.autoRotateSpeed = _.autoRotateSpeed),
              (this.autoRotateClockwise = _.autoRotateClockwise);
            let N = this.object
              .getTarget()
              .applyQuaternion(SY.copy(this.object.quaternion).invert());
            (this.minV = -_.panVerticalOffset.min + N.y),
              (this.maxV = _.panVerticalOffset.max + N.y),
              (this.minH = -_.panHorizontalOffset.min + N.x),
              (this.maxH = _.panHorizontalOffset.max + N.x),
              this.panRangeFactor
                .set(this.maxH - this.minH, this.maxV - this.minV)
                .divideScalar(2),
              this.rotationRangeFactor.setScalar(Math.PI).divideScalar(4),
              (this.minPhi = Ps(
                this.spherical.phi - _.rotationVerticalOffset.min,
              )),
              (this.maxPhi = Ps(
                this.spherical.phi + _.rotationVerticalOffset.max,
              )),
              (this.minTheta = Ps(
                Ps(this.spherical.theta) - _.rotationHorizontalOffset.min,
              )),
              (this.maxTheta = Ps(
                Ps(this.spherical.theta) + _.rotationHorizontalOffset.max,
              )),
              (this.isThetaFlipped = this.minTheta > this.maxTheta),
              1 === _.orbitTouches && (this.touches[0] = ih.ROTATE),
              1 === _.panTouches && (this.touches[0] = ih.PAN),
              2 === _.orbitTouches && (this.touches[1] = ih.DOLLY_ROTATE),
              2 === _.panTouches && (this.touches[1] = ih.DOLLY_PAN),
              3 === _.orbitTouches && (this.touches[2] = ih.ROTATE),
              3 === _.panTouches && (this.touches[2] = ih.PAN),
              (this.isTouchZoom = _.isTouchZoom),
              (this.resetHoverEffectOnPointerLeave =
                _.resetHoverEffectOnPointerLeave ?? !1);
          }
          connect() {
            if (
              (this.domElement.addEventListener(
                "contextmenu",
                this.onContextMenu,
              ),
              this.domElement.addEventListener(
                "pointerdown",
                this.onPointerDown,
              ),
              this.domElement.addEventListener("wheel", this.onMouseWheel),
              window.addEventListener("keydown", this.onKeyDown, !1),
              window.addEventListener("keyup", this.onKeyUp, !1),
              pZ ||
                (this.domElement.addEventListener(
                  "gesturestart",
                  this.onGesture,
                ),
                this.domElement.addEventListener(
                  "gesturechange",
                  this.onGesture,
                ),
                this.domElement.addEventListener("gestureend", this.onGesture)),
              this.domElement.addEventListener("touchend", this.onTouchEnd),
              0 !== this.hoverRotatePanMode && !this.useWindowEvents)
            ) {
              let _ = this.useWindowEvents ? window : this.domElement;
              _.addEventListener("pointerleave", this.onPointerLeave),
                _.addEventListener("pointerenter", this.onPointerEnter);
            }
            this.pointerLeaveEvent = void 0;
          }
          dispose() {
            this.removeEventListenersFromCamera(),
              this.domElement.removeEventListener(
                "contextmenu",
                this.onContextMenu,
              ),
              this.domElement.removeEventListener(
                "pointerdown",
                this.onPointerDown,
              ),
              this.domElement.removeEventListener("wheel", this.onMouseWheel),
              window.removeEventListener("keydown", this.onKeyDown, !1),
              window.removeEventListener("keyup", this.onKeyUp, !1),
              this.domElement.removeEventListener(
                "pointermove",
                this.onPointerHover,
              ),
              window.removeEventListener("pointermove", this.onPointerHover),
              pZ ||
                (this.domElement.removeEventListener(
                  "gesturestart",
                  this.onGesture,
                ),
                this.domElement.removeEventListener(
                  "gesturechange",
                  this.onGesture,
                ),
                this.domElement.removeEventListener(
                  "gestureend",
                  this.onGesture,
                )),
              this.domElement.removeEventListener("touchend", this.onTouchEnd),
              this.domElement.removeEventListener(
                "pointerleave",
                this.onPointerLeave,
              ),
              this.domElement.removeEventListener(
                "pointerenter",
                this.onPointerEnter,
              ),
              window.removeEventListener("pointerleave", this.onPointerLeave),
              window.removeEventListener("pointerenter", this.onPointerEnter),
              this.domElement.removeEventListener(
                "pointermove",
                this.onPointerMove,
              ),
              this.domElement.removeEventListener(
                "pointerup",
                this.onPointerUp,
              );
          }
          applyLimits(_, L, R, N, z, F, U, k) {
            let Y, X, Q;
            this.overShoot.set(0, 0),
              _ instanceof iq
                ? ((Y = _.x),
                  (X = _.y),
                  this.current.set(this.target.x, this.target.y),
                  (Q = !0))
                : ((Y = _.theta),
                  (X = _.phi),
                  this.current.set(
                    Ps(this.spherical.theta),
                    Ps(this.spherical.phi),
                  ),
                  (Q = !1)),
              0 === R && ((this.current.x += Y), (this.current.y += X)),
              (3 === L || 2 === L) &&
                (!Q && this.isThetaFlipped
                  ? this.current.x > N && this.current.x < 0
                    ? (this.overShoot.x = N - this.current.x)
                    : this.current.x < z &&
                      this.current.x > 0 &&
                      (this.overShoot.x = z - this.current.x)
                  : this.current.x > N
                    ? (this.overShoot.x = N - this.current.x)
                    : this.current.x < z &&
                      (this.overShoot.x = z - this.current.x)),
              (3 === L || 1 === L) &&
                (this.current.y > F
                  ? (this.overShoot.y = F - this.current.y)
                  : this.current.y < U &&
                    (this.overShoot.y = U - this.current.y)),
              Q ||
                ((this.overShoot.x = Ps(this.overShoot.x)),
                (this.overShoot.y = Ps(this.overShoot.y))),
              0 !== R
                ? (this.overRatio.copy(this.overShoot).divide(k),
                  (this.overRatio.x = Math.min(Math.abs(this.overRatio.x), 1)),
                  (this.overRatio.y = Math.min(Math.abs(this.overRatio.y), 1)),
                  1 === R &&
                    ((this.overRatio.x = L2(Math.abs(this.overRatio.x))),
                    (this.overRatio.y = L2(Math.abs(this.overRatio.y)))),
                  this.isPointerDown || 1 === R
                    ? 2 === R &&
                      ((this.overRatio.x > 0.9 && !this.thetaIsFree) ||
                        (this.overRatio.y > 0.9 && !this.phiIsFree))
                      ? (this.isPointerDown = !1)
                      : (Y * this.overShoot.x < 0 &&
                          !this.thetaIsFree &&
                          (Y *= 1 - this.overRatio.x),
                        X * this.overShoot.y < 0 &&
                          !this.phiIsFree &&
                          (X *= 1 - this.overRatio.y))
                    : 2 === R &&
                      ((!Q &&
                        ((this.overRatio.x > 0.002 && !this.thetaIsFree) ||
                          (this.overRatio.y > 0.002 && !this.phiIsFree))) ||
                      (Q &&
                        (Math.abs(this.overShoot.x) > 2 ||
                          Math.abs(this.overShoot.y) > 2))
                        ? (this.thetaIsFree || (Y = 0.05 * this.overShoot.x),
                          this.phiIsFree || (X = 0.05 * this.overShoot.y),
                          Q
                            ? (this.isPanOverShoot = !0)
                            : (this.isRotateOverShoot = !0))
                        : Q
                          ? (this.isPanOverShoot = !1)
                          : (this.isRotateOverShoot = !1)))
                : ((Y += this.overShoot.x), (X += this.overShoot.y)),
              _ instanceof iq
                ? ((_.x = Y), (_.y = X))
                : (this.thetaIsFree || (_.theta = Y),
                  this.phiIsFree || (_.phi = X));
          }
          setEnableDampingSpeed(_) {
            (this.enableDamping = _), (this.rotateSpeed = !0 === _ ? 0.2 : 1);
          }
          stopDamping() {
            (this.sphericalDelta.theta = 0), (this.sphericalDelta.phi = 0);
          }
          getAutoRotationAngle() {
            return ((2 * Math.PI) / 60 / 60) * this.autoRotateSpeed;
          }
          getZoomScale() {
            return Math.pow(0.95, this.zoomSpeed);
          }
          rotateLeft(_) {
            this.sphericalDelta.theta -= _;
          }
          rotateUp(_) {
            this.sphericalDelta.phi -= _;
          }
          panLeft(_, L) {
            this.panLeftV.setFromMatrixColumn(L, 0),
              this.panLeftV.multiplyScalar(-_),
              this.panOffset.add(this.panLeftV);
          }
          panUp(_, L) {
            this.panUpV.setFromMatrixColumn(L, 1),
              this.panUpV.multiplyScalar(_),
              this.panOffset.add(this.panUpV);
          }
          pan(_, L) {
            let R = this.domElement;
            if (R && this.object.isPerspectiveCamera) {
              let N = this.object.position;
              this.panV.copy(N).sub(this.target);
              let z = this.panV.length();
              (z *= Math.tan(((this.object.fov / 2) * Math.PI) / 180)),
                this.panLeft(
                  (2 * _ * z) / R.clientHeight,
                  this.object.matrixWorld,
                ),
                this.panUp(
                  (2 * L * z) / R.clientHeight,
                  this.object.matrixWorld,
                );
            } else
              R &&
                this.object.isOrthographicCamera &&
                (this.panLeft(
                  (_ * (this.object.right - this.object.left)) /
                    this.object.zoom /
                    R.clientWidth,
                  this.object.matrixWorld,
                ),
                this.panUp(
                  (L * (this.object.top - this.object.bottom)) /
                    this.object.zoom /
                    R.clientHeight,
                  this.object.matrixWorld,
                ));
            this.dispatchEvent(SG);
          }
          dollyOut(_) {
            this.object.isPerspectiveCamera
              ? (this.scale /= _)
              : this.object.isOrthographicCamera &&
                ((this.object.zoom *= _),
                this.zoomLimitsEnabled &&
                  (this.object.zoom = Math.max(
                    this.minZoom,
                    Math.min(this.maxZoom, this.object.zoom),
                  )),
                this.object.updateProjectionMatrix(),
                (this.zoomChanged = !0)),
              this.dispatchEvent(Sj);
          }
          dollyIn(_) {
            this.object.isPerspectiveCamera
              ? (this.scale *= _)
              : this.object.isOrthographicCamera &&
                ((this.object.zoom /= _),
                this.zoomLimitsEnabled &&
                  (this.object.zoom = Math.max(
                    this.minZoom,
                    Math.min(this.maxZoom, this.object.zoom),
                  )),
                this.object.updateProjectionMatrix(),
                (this.zoomChanged = !0)),
              this.dispatchEvent(Sj);
          }
          zoomOut(_ = this.getZoomScale()) {
            this.dispatchEvent(SV), this.dollyOut(_), this.dispatchEvent(SH);
          }
          zoomIn(_ = this.getZoomScale()) {
            this.dispatchEvent(SV), this.dollyIn(_), this.dispatchEvent(SH);
          }
          handleMouseDownRotate(_) {
            this.rotateStart.set(_.clientX, _.clientY);
          }
          handleMouseDownDolly(_) {
            this.dollyStart.set(_.clientX, _.clientY);
          }
          handleMouseDownPan(_) {
            this.panStart.set(_.clientX, _.clientY);
          }
          handleMouseMoveRotate(_, L = 1) {
            void 0 !== _.movementX
              ? this.rotateDelta.set(_.movementX, _.movementY)
              : (this.rotateEnd.set(_.clientX, _.clientY),
                this.rotateDelta.subVectors(this.rotateEnd, this.rotateStart),
                this.rotateStart.copy(this.rotateEnd)),
              this.rotateDelta
                .multiplyScalar(this.rotateSpeed * L)
                .rotateAround(SX, -this.object.angleOffsetFromUp);
            let R = this.domElement,
              N = this.useWindowEvents ? window.innerHeight : R.clientHeight,
              z = (2 * Math.PI * this.rotateDelta.x) / N,
              F = (2 * Math.PI * this.rotateDelta.y) / N;
            this.rotateLeft(z), this.rotateUp(F), this.update();
          }
          handleMouseMoveDolly(_) {
            this.dollyEnd.set(_.clientX, _.clientY),
              this.dollyDelta.subVectors(this.dollyEnd, this.dollyStart),
              this.dollyDelta.y > 0
                ? this.dollyOut(this.getZoomScale())
                : this.dollyDelta.y < 0 && this.dollyIn(this.getZoomScale()),
              this.dollyStart.copy(this.dollyEnd),
              this.update();
          }
          handleMouseMovePan(_, L = 1) {
            void 0 !== _.movementX
              ? this.panDelta.set(_.movementX, _.movementY)
              : (this.panEnd.set(_.clientX, _.clientY),
                this.panDelta.subVectors(this.panEnd, this.panStart),
                this.panStart.copy(this.panEnd)),
              this.panDelta.multiplyScalar(this.panSpeed * L),
              this.pan(this.panDelta.x, this.panDelta.y),
              this.update();
          }
          handleMouseWheel(_) {
            if (
              !1 === pK &&
              !1 === uh(_) &&
              !0 ==
                (0 === _.wheelDeltaY || 0 === _.deltaY
                  ? !(pQ && _.shiftKey && Math.abs(_.wheelDeltaX) >= 120) &&
                    (_.wheelDeltaX
                      ? _.wheelDeltaX === -3 * _.deltaX
                      : 0 === _.deltaMode)
                  : _.wheelDeltaY
                    ? _.wheelDeltaY === -3 * _.deltaY
                    : 0 === _.deltaMode)
            )
              !1 !== this.enablePan &&
                (this.gesture
                  ? (this.panDelta
                      .set(-_.deltaX, -_.deltaY)
                      .multiplyScalar(this.panSpeed),
                    (this.panDelta.x =
                      Math.min(Math.abs(this.panDelta.x), 100) *
                      (this.panDelta.x < 0 ? -1 : 1)),
                    (this.panDelta.y =
                      Math.min(Math.abs(this.panDelta.y), 100) *
                      (this.panDelta.y < 0 ? -1 : 1)),
                    _.altKey
                      ? this.pan(0, this.panDelta.y)
                      : _.shiftKey
                        ? this.pan(this.panDelta.x, 0)
                        : this.pan(this.panDelta.x, this.panDelta.y),
                    this.update())
                  : ((this.gesture = !0), (this.isPointerDown = !0)),
                window.clearTimeout(this.timer),
                (this.timer = window.setTimeout(() => {
                  (this.gesture = !1), (this.isPointerDown = !1);
                }, 30)));
            else {
              if (!1 === this.enableZoom) return;
              0 === _.deltaY
                ? _.deltaX < 0
                  ? this.dollyIn(this.getZoomScale())
                  : _.deltaX > 0 && this.dollyOut(this.getZoomScale())
                : _.deltaY < 0
                  ? this.dollyIn(this.getZoomScale())
                  : _.deltaY > 0 && this.dollyOut(this.getZoomScale()),
                this.update(),
                (this.gesture = !1),
                (this.isPointerDown = !1);
            }
          }
          handleTouchStartRotate() {
            if (2 === p1.length) {
              let _ = 0.5 * (p1[0].pageX + p1[1].pageX),
                L = 0.5 * (p1[0].pageY + p1[1].pageY);
              this.rotateStart.set(_, L);
            } else this.rotateStart.set(p1[0].pageX, p1[0].pageY);
          }
          handleTouchStartPan() {
            if (2 === p1.length) {
              let _ = 0.5 * (p1[0].pageX + p1[1].pageX),
                L = 0.5 * (p1[0].pageY + p1[1].pageY);
              this.panStart.set(_, L);
            } else this.panStart.set(p1[0].pageX, p1[0].pageY);
          }
          handleTouchStartDolly() {
            let _ = p1[0].pageX - p1[1].pageX,
              L = p1[0].pageY - p1[1].pageY,
              R = Math.sqrt(_ * _ + L * L);
            this.dollyStart.set(0, R);
          }
          handleTouchStartDollyPan() {
            this.enableZoom && this.handleTouchStartDolly(),
              this.enablePan && this.handleTouchStartPan();
          }
          handleTouchStartDollyRotate() {
            this.enableZoom && this.handleTouchStartDolly(),
              this.enableRotate && this.handleTouchStartRotate();
          }
          handleTouchMoveRotate(_) {
            if (2 === p1.length) {
              let L = km(_),
                R = 0.5 * (_.pageX + L.x),
                N = 0.5 * (_.pageY + L.y);
              this.rotateEnd.set(R, N);
            } else {
              if (_.pointerId !== p1[0].pointerId) return;
              this.rotateEnd.set(_.pageX, _.pageY);
            }
            this.rotateDelta
              .subVectors(this.rotateEnd, this.rotateStart)
              .multiplyScalar(this.rotateSpeed);
            let L = this.domElement;
            L &&
              (this.rotateLeft(
                (2 * Math.PI * this.rotateDelta.x) / L.clientHeight,
              ),
              this.rotateUp(
                (2 * Math.PI * this.rotateDelta.y) / L.clientHeight,
              )),
              this.rotateStart.copy(this.rotateEnd);
          }
          handleTouchMovePan(_) {
            if (2 === p1.length) {
              let L = km(_),
                R = 0.5 * (_.pageX + L.x),
                N = 0.5 * (_.pageY + L.y);
              this.panEnd.set(R, N);
            } else {
              if (_.pointerId !== p1[0].pointerId) return;
              this.panEnd.set(_.pageX, _.pageY);
            }
            this.panDelta
              .subVectors(this.panEnd, this.panStart)
              .multiplyScalar(this.panSpeed),
              this.pan(this.panDelta.x, this.panDelta.y),
              this.panStart.copy(this.panEnd);
          }
          handleTouchMoveDolly(_) {
            let L = km(_),
              R = _.pageX - L.x,
              N = _.pageY - L.y,
              z = Math.sqrt(R * R + N * N);
            this.dollyEnd.set(0, z),
              this.dollyDelta.set(
                0,
                Math.pow(this.dollyEnd.y / this.dollyStart.y, this.zoomSpeed),
              ),
              this.dollyOut(this.dollyDelta.y),
              this.dollyStart.copy(this.dollyEnd);
          }
          handleTouchMoveDollyPan(_) {
            this.enableZoom && this.handleTouchMoveDolly(_),
              this.enablePan && this.handleTouchMovePan(_);
          }
          handleTouchMoveDollyRotate(_) {
            this.enableZoom && this.handleTouchMoveDolly(_),
              this.enableRotate && this.handleTouchMoveRotate(_);
          }
        };
      function Ps(_) {
        let L = 2 * Math.PI;
        for (; _ <= -Math.PI; ) _ += L;
        for (; _ > Math.PI; ) _ -= L;
        return _;
      }
      function L2(_) {
        return 1 - Math.pow(1 - _, 4);
      }
      var S4 = new WeakMap(),
        S5 = class extends a9 {
          constructor(_) {
            super(_),
              (this.decoderPath = ""),
              (this.decoderConfig = {}),
              (this.decoderBinary = null),
              (this.decoderPending = null),
              (this.workerLimit = 4),
              (this.workerPool = []),
              (this.workerNextTaskID = 1),
              (this.workerSourceURL = ""),
              (this.defaultAttributeIDs = {
                position: "POSITION",
                normal: "NORMAL",
                color: "COLOR",
                uv: "TEX_COORD",
              }),
              (this.defaultAttributeTypes = {
                position: "Float32Array",
                normal: "Float32Array",
                color: "Float32Array",
                uv: "Float32Array",
              });
          }
          setDecoderPath(_) {
            return (this.decoderPath = _), this;
          }
          setDecoderConfig(_) {
            return (this.decoderConfig = _), this;
          }
          setWorkerLimit(_) {
            return (this.workerLimit = _), this;
          }
          load(_, L, R, N) {
            let z = new oi(this.manager);
            z.setPath(this.path),
              z.setResponseType("arraybuffer"),
              z.setRequestHeader(this.requestHeader),
              z.setWithCredentials(this.withCredentials),
              z.load(
                _,
                (_) => {
                  this.decodeDracoFile(_, L).catch(N);
                },
                R,
                N,
              );
          }
          decodeDracoFile(_, L, R, N) {
            let z = {
              attributeIDs: R || this.defaultAttributeIDs,
              attributeTypes: N || this.defaultAttributeTypes,
              useUniqueIDs: !!R,
            };
            return this.decodeGeometry(_, z).then(L);
          }
          decodeGeometry(_, L) {
            let R = JSON.stringify(L);
            if (S4.has(_)) {
              let L = S4.get(_);
              if (L.key === R) return L.promise;
              if (0 === _.byteLength)
                throw Error(
                  "THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.",
                );
            }
            let N,
              z = this.workerNextTaskID++,
              F = _.byteLength,
              U = this._getWorker(z, F)
                .then(
                  (R) => (
                    (N = R),
                    new Promise((R, F) => {
                      (N._callbacks[z] = { resolve: R, reject: F }),
                        N.postMessage(
                          { type: "decode", id: z, taskConfig: L, buffer: _ },
                          [_],
                        );
                    })
                  ),
                )
                .then((_) => this._createGeometry(_.geometry));
            return (
              U.catch(() => !0).then(() => {
                N && z && this._releaseTask(N, z);
              }),
              S4.set(_, { key: R, promise: U }),
              U
            );
          }
          _createGeometry(_) {
            let L = new sP();
            _.index && L.setIndex(new sh(_.index.array, 1));
            for (let R = 0; R < _.attributes.length; R++) {
              let N = _.attributes[R],
                z = N.name,
                F = N.array,
                U = N.itemSize;
              L.setAttribute(z, new sh(F, U));
            }
            return L;
          }
          _loadLibrary(_, L) {
            let R = new oi(this.manager);
            return (
              R.setPath(this.decoderPath),
              R.setResponseType(L),
              R.setWithCredentials(this.withCredentials),
              new Promise((L, N) => {
                R.load(_, L, void 0, N);
              })
            );
          }
          preload() {
            return this._initDecoder(), this;
          }
          _initDecoder() {
            if (this.decoderPending) return this.decoderPending;
            let _ =
                "object" != typeof WebAssembly ||
                "js" === this.decoderConfig.type,
              L = [];
            return (
              _
                ? L.push(this._loadLibrary("draco_decoder.js", "text"))
                : (L.push(this._loadLibrary("draco_wasm_wrapper.js", "text")),
                  L.push(
                    this._loadLibrary("draco_decoder.wasm", "arraybuffer"),
                  )),
              (this.decoderPending = Promise.all(L).then((L) => {
                let R = L[0];
                _ || (this.decoderConfig.wasmBinary = L[1]);
                let N = uj.toString(),
                  z = [
                    "/* draco decoder */",
                    R,
                    "",
                    "/* worker */",
                    N.substring(N.indexOf("{") + 1, N.lastIndexOf("}")),
                  ].join(`
`);
                this.workerSourceURL = URL.createObjectURL(new Blob([z]));
              })),
              this.decoderPending
            );
          }
          _getWorker(_, L) {
            return this._initDecoder().then(() => {
              if (this.workerPool.length < this.workerLimit) {
                let _ = new Worker(this.workerSourceURL);
                (_._callbacks = {}),
                  (_._taskCosts = {}),
                  (_._taskLoad = 0),
                  _.postMessage({
                    type: "init",
                    decoderConfig: this.decoderConfig,
                  }),
                  (_.onmessage = function (L) {
                    let R = L.data;
                    switch (R.type) {
                      case "decode":
                        _._callbacks[R.id].resolve(R);
                        break;
                      case "error":
                        _._callbacks[R.id].reject(R);
                        break;
                      default:
                        console.error(
                          'THREE.DRACOLoader: Unexpected message, "' +
                            R.type +
                            '"',
                        );
                    }
                  }),
                  this.workerPool.push(_);
              } else
                this.workerPool.sort(function (_, L) {
                  return _._taskLoad > L._taskLoad ? -1 : 1;
                });
              let R = this.workerPool[this.workerPool.length - 1];
              return (R._taskCosts[_] = L), (R._taskLoad += L), R;
            });
          }
          _releaseTask(_, L) {
            (_._taskLoad -= _._taskCosts[L]),
              delete _._callbacks[L],
              delete _._taskCosts[L];
          }
          debug() {
            console.log(
              "Task load: ",
              this.workerPool.map((_) => _._taskLoad),
            );
          }
          dispose() {
            for (let _ = 0; _ < this.workerPool.length; ++_)
              this.workerPool[_].terminate();
            return (
              (this.workerPool.length = 0),
              "" !== this.workerSourceURL &&
                URL.revokeObjectURL(this.workerSourceURL),
              this
            );
          }
        };
      function uj() {
        let _, L;
        onmessage = function (R) {
          let N = R.data;
          switch (N.type) {
            case "init":
              (_ = N.decoderConfig),
                (L = new Promise(function (L) {
                  (_.onModuleLoaded = function (_) {
                    L({ draco: _ });
                  }),
                    DracoDecoderModule(_);
                }));
              break;
            case "decode":
              let z = N.buffer,
                F = N.taskConfig;
              L.then((_) => {
                let L = _.draco,
                  R = new L.Decoder(),
                  U = new L.DecoderBuffer();
                U.Init(new Int8Array(z), z.byteLength);
                try {
                  let _ = (function (_, L, R, N) {
                      let z = N.attributeIDs,
                        F = N.attributeTypes,
                        U,
                        k,
                        Y = L.GetEncodedGeometryType(R);
                      if (Y === _.TRIANGULAR_MESH)
                        (U = new _.Mesh()), (k = L.DecodeBufferToMesh(R, U));
                      else if (Y === _.POINT_CLOUD)
                        (U = new _.PointCloud()),
                          (k = L.DecodeBufferToPointCloud(R, U));
                      else
                        throw Error(
                          "THREE.DRACOLoader: Unexpected geometry type.",
                        );
                      if (!k.ok() || 0 === U.ptr)
                        throw Error(
                          "THREE.DRACOLoader: Decoding failed: " +
                            k.error_msg(),
                        );
                      let X = { index: null, attributes: [] };
                      for (let R in z) {
                        let k = self[F[R]],
                          Y,
                          Q;
                        if (N.useUniqueIDs)
                          (Q = z[R]), (Y = L.GetAttributeByUniqueId(U, Q));
                        else {
                          if (-1 === (Q = L.GetAttributeId(U, _[z[R]])))
                            continue;
                          Y = L.GetAttribute(U, Q);
                        }
                        X.attributes.push(
                          (function (_, L, R, N, z, F) {
                            let U = F.num_components(),
                              k = R.num_points() * U,
                              Y = k * z.BYTES_PER_ELEMENT,
                              X = (function (_, L) {
                                switch (L) {
                                  case Float32Array:
                                    return _.DT_FLOAT32;
                                  case Int8Array:
                                    return _.DT_INT8;
                                  case Int16Array:
                                    return _.DT_INT16;
                                  case Int32Array:
                                    return _.DT_INT32;
                                  case Uint8Array:
                                    return _.DT_UINT8;
                                  case Uint16Array:
                                    return _.DT_UINT16;
                                  case Uint32Array:
                                    return _.DT_UINT32;
                                }
                              })(_, z),
                              Q = _._malloc(Y);
                            L.GetAttributeDataArrayForAllPoints(R, F, X, Y, Q);
                            let K = new z(_.HEAPF32.buffer, Q, k).slice();
                            return (
                              _._free(Q), { name: N, array: K, itemSize: U }
                            );
                          })(_, L, U, R, k, Y),
                        );
                      }
                      return (
                        Y === _.TRIANGULAR_MESH &&
                          (X.index = (function (_, L, R) {
                            let N = 3 * R.num_faces(),
                              z = 4 * N,
                              F = _._malloc(z);
                            L.GetTrianglesUInt32Array(R, z, F);
                            let U = new Uint32Array(
                              _.HEAPF32.buffer,
                              F,
                              N,
                            ).slice();
                            return _._free(F), { array: U, itemSize: 1 };
                          })(_, L, U)),
                        _.destroy(U),
                        X
                      );
                    })(L, R, U, F),
                    z = _.attributes.map((_) => _.array.buffer);
                  _.index && z.push(_.index.array.buffer),
                    self.postMessage(
                      { type: "decode", id: N.id, geometry: _ },
                      z,
                    );
                } catch (_) {
                  console.error(_),
                    self.postMessage({
                      type: "error",
                      id: N.id,
                      error: _.message,
                    });
                } finally {
                  L.destroy(U), L.destroy(R);
                }
              });
          }
        };
      }
      async function hj(_) {
        if (t0) {
          let L = {
              attributeIDs: t0.defaultAttributeIDs,
              attributeTypes: t0.defaultAttributeTypes,
              useUniqueIDs: !1,
            },
            R;
          try {
            R = await t0.decodeGeometry(new Int8Array(_).buffer, L);
          } catch (_) {
            console.error(_);
          }
          if (R)
            return {
              index: R.index ? { array: R.index.array } : void 0,
              attributes: Object.entries(R.attributes).map(([_, L]) => ({
                name: _,
                itemSize: L.itemSize,
                array: L.array,
              })),
            };
        }
        return null;
      }
      async function R2(_, L) {
        var R;
        let N,
          z,
          F,
          [U, k] = W0(uE.deserialize(new Uint8Array(_)));
        36 !== (F = (R = U).schema ?? 0) &&
          (console.warn("updating from ", F, "to ", 36),
          F < 1 && (Hm(R, TE), Vm(R, TE), (R.schema = 1)),
          F < 2 &&
            (Object.assign(R.scene.publish, {
              orbitControls: {
                ...f9.defaultData,
                ...Wn(R.scene.publish.orbitControls),
              },
            }),
            (R.schema = 2)),
          F < 3 &&
            ((function (_) {
              function t(_) {
                if (_.layers) {
                  for (let L of Object.values(_.layers))
                    if (L) {
                      for (let [_, R] of Object.entries(L))
                        if (
                          ((pV.includes(_) || "boolean" == typeof R) &&
                            delete L[_],
                          "texture" === _)
                        )
                          for (let [_, L] of Object.entries(R))
                            (pH.includes(_) || "boolean" == typeof L) &&
                              delete R[_];
                    }
                }
              }
              _.scene.objects.traverse((_, L) => {
                L.states.forEach((_) => {
                  _.material
                    ? t(_.material)
                    : _.materials &&
                      _.materials.forEach((_) => {
                        t(_);
                      });
                });
              });
            })(R),
            (R.schema = 3)),
          F < 4 && ((R.scene.publish.withBackground = !0), (R.schema = 4)),
          F < 5 &&
            ((R.scene.publish.settings.web = {
              compress: !0,
              preload: !0,
              preset: 1,
              logo: !0,
              hint: !1,
            }),
            (R.schema = 5)),
          F < 6 &&
            ((function (_) {
              _.scene.objects.traverse((_, L) => {
                let R = L.cloner;
                R &&
                  ((R.radial.scale = R.radial.scale.map((_) => _ + 1)),
                  (R.linear.scale = R.linear.scale.map((_) => _ + 1)));
              });
            })(R),
            (R.schema = 6)),
          F < 7 &&
            ((function (_) {
              _.scene.objects.traverse((_, L) => {
                let R = L.geometry;
                R &&
                  ("DodecahedronGeometry" === R.type ||
                    "IcosahedronGeometry" === R.type) &&
                  (R.detail = Math.round(R.detail));
              });
            })(R),
            (R.schema = 7)),
          F < 8 && (R.schema = 8),
          F < 9 && (ME(R), (R.schema = 9)),
          F < 10 &&
            ((function (_) {
              _.scene.objects.traverse((_, L) => {
                "Mesh" === L.type &&
                  ("BooleanGeometry" === L.geometry.type ||
                    "SubdivGeometry" === L.geometry.type) &&
                  (L.geometry.phongAngle = 35);
              });
            })(R),
            (R.schema = 10)),
          F < 11 &&
            ((R.scene.environment.ambientLight.softShadows = !1),
            (R.scene.environment.ambientLight.softShadowQuality = "low"),
            R.scene.objects.traverse((_, L) => {
              ("DirectionalLight" === L.type || "SpotLight" === L.type) &&
                ((L.shadowResolution = 1024),
                (L.shadowRadius = 1),
                (L.depth = 1e5));
            }),
            (R.shared.penumbraSize = [, , , , ,].fill(0.5)),
            (R.schema = 11)),
          F < 12 && (ME(R), (R.schema = 12)),
          F < 13 && ((R.shared.audios = Ri({}, cq.prototype)), (R.schema = 13)),
          F < 14 &&
            (Object.entries((N = R.shared.materials)).forEach(([_, L]) => {
              L.layers ||
                Object.assign(N, {
                  [_]: {
                    name: "Untitled Material",
                    layers: [
                      {
                        fi: 0,
                        data: {
                          type: "light",
                          category: "phong",
                          alpha: 0.6,
                          visible: !0,
                          mode: 0,
                          specular: { r: 0.2, g: 0.2, b: 0.2 },
                          shininess: 5,
                        },
                        id: "layer1",
                      },
                      {
                        fi: 1,
                        data: {
                          type: "color",
                          alpha: 1,
                          visible: !0,
                          mode: 0,
                          color: {
                            r: 0.2823529411764706,
                            g: 0.2823529411764706,
                            b: 0.30196078431372547,
                          },
                        },
                        id: "layer2",
                      },
                    ],
                  },
                });
            }),
            (R.schema = 14)),
          F < 15 &&
            (Object.entries(Wn(R.shared.images))
              .filter((_) => !1 === _[1].asset)
              .map((_) => _[0])
              .forEach((_) => {
                delete R.shared.images[_];
              }),
            Object.entries(Wn(R.shared.audios))
              .filter((_) => !1 === _[1].asset)
              .map((_) => _[0])
              .forEach((_) => {
                delete R.shared.audios[_];
              }),
            (R.schema = 15)),
          F < 16 &&
            ((R.scene.publish.settings.web.preload = !1), (R.schema = 16)),
          F < 17 && (Hm(R, CE), Vm(R, CE), (R.schema = 17)),
          F < 18 && (Hm(R, EE), Vm(R, EE), (R.schema = 18)),
          F < 19 &&
            (Object.assign(R.scene.publish.settings, {
              video: {
                ...f7.defaultData.settings.video,
                ...Wn(R.scene.publish.settings.video),
              },
            }),
            (R.schema = 19)),
          F < 20 &&
            ((R.shared.fonts = Ri({}, cq.prototype)),
            (z = []),
            R.scene.objects.traverse((_, L) => {
              if ("TextFrame" === L.type) {
                let N = fU.defaultTwoLayerData("phong"),
                  F =
                    "string" == typeof L.color
                      ? R.shared.colors[L.color]
                      : L.color;
                (N.layers[1].data.color = { r: F.r, g: F.g, b: F.b }),
                  (N.layers[1].data.alpha = L.alpha);
                let U = L.font
                  .replace(".typeface", "")
                  .replace(/optimer/gi, "open sans")
                  .replace("space_mono", "space mono")
                  .replace(/alma_mono/gi, "varela round")
                  .replace(/droid_sans_mono/gi, "noto sans mono")
                  .replace(
                    /droid_sans|gentilis|gnomon_(simple|foreground)|helvetiker/gi,
                    "roboto",
                  )
                  .replace(/droid_serif/gi, "roboto slab")
                  .replace("_sans", " sans")
                  .replace("crimson_text", "crimson text")
                  .replace("medium_medium", "medium")
                  .replace("fatface_fatface", "fatface")
                  .replace("100hairline", "thin")
                  .replace("200thin", "extralight")
                  .replace("300light", "light")
                  .replace("500medium", "medium")
                  .replace("600semi", "semibold")
                  .replace("800heavy", "extrabold")
                  .replace("900black", "black")
                  .replace(
                    /bodoni_(11|16|24|36|48|72|96)([^_])/gi,
                    "bodoni_$1_$2",
                  )
                  .replace(/bodoni_(11|16|24|36|48|72|96)/gi, "bodoni moda")
                  .replace(/(thin|hairline)(_regular)?/gi, "100")
                  .replace(/(extra|ultra)light(_regular)?/gi, "200")
                  .replace(/light(_regular)?/gi, "300")
                  .replace(/_book|_normal|_roman/gi, "_regular")
                  .replace(/medium(_regular)?/gi, "500")
                  .replace(/(semi|demi)bold(_regular)?/gi, "600")
                  .replace(/(extra|ultra)bold(_regular)?/gi, "800")
                  .replace(/bold(_regular)?/gi, "700")
                  .replace(/(black|heavy|fatface)(_regular)?/gi, "900")
                  .replace(/([1-9]00)_italic/gi, "$1italic")
                  .replace(/regularitalic/gi, "italic")
                  .replace(/regularitalic/gi, "italic")
                  .split(" ")
                  .map((_) => _.charAt(0).toUpperCase() + _.slice(1))
                  .join(" ");
                void 0 === R.shared.fonts[U] &&
                  (R.shared.fonts[U] = { name: U });
                let k = {
                    name: L.name,
                    ...fQ.defaultData,
                    ...fJ.defaultData,
                    flatShading: !1,
                    wireframe: !1,
                    geometry: {
                      ...fW.defaultData("TextGeometry"),
                      width: L.width,
                      height: L.height,
                      font: U,
                      depth: 0,
                      horizontalAlign: L.horizontalAlign,
                      verticalAlign: L.verticalAlign,
                      fontSize: 1.40625 * L.fontSize,
                      lineHeight: L.lineHeight / 1.40625,
                      letterSpacing: L.letterSpacing - 1,
                      text: L.text,
                      textTransform: L.textTransform,
                      extrudeBevelSize: 0,
                      extrudeBevelSegments: 1,
                    },
                    material: N,
                    states: Wn(L.states),
                    events: Wn(L.events),
                    visible: L.visible,
                    raycastLock: L.raycastLock,
                    position: L.position,
                    rotation: L.rotation,
                    scale: L.scale,
                    hiddenMatrix: L.hiddenMatrix,
                  },
                  Y = Wn(R.scene.objects).parent(_);
                R.scene.objects.insertAfter(Y ?? null, _, [
                  { id: _ + "new", data: k, children: [] },
                ]),
                  z.push(_);
              }
            }),
            z.forEach((_) => {
              R.scene.objects.delete(_);
            }),
            (R.schema = 20)),
          F < 21 &&
            ((function (_) {
              let L = {
                0: "MouseDown",
                1: "MouseUp",
                2: "MouseHover",
                5: "KeyDown",
                6: "KeyUp",
                7: "Start",
                9: "LookAt",
                10: "Follow",
                11: "Scroll",
                12: "Audio",
                13: "GameControl",
              };
              _.scene.objects.traverse((_, R) => {
                R.events.forEach((_) => {
                  if (L[Number(_.type)]) {
                    if (
                      (Object.assign(_, { type: L[Number(_.type)] }),
                      "Audio" === _.type &&
                        "audioEvent" in _ &&
                        (Object.assign(_, { playAudio: _.audioEvent }),
                        delete _.audioEvent),
                      "GameControl" === _.type)
                    )
                      Object.assign(_, {
                        gameActions: {
                          idle: new cK(),
                          move: new cK(),
                          jump: new cK(),
                        },
                      });
                    else {
                      let L = new cK();
                      Object.assign(_, { actions: L }),
                        ("MouseDown" === _.type ||
                          "MouseUp" === _.type ||
                          "KeyDown" === _.type ||
                          "KeyUp" === _.type) &&
                          "url" in _ &&
                          L.push({
                            fi: 0,
                            id: iE.generateUUID(),
                            data: { type: "Link", url: _.url, delay: 0 },
                          }),
                        "targets" in _ &&
                          (_.targets.forEach((_, R, N) => {
                            let z = { easing: _.easing, duration: _.duration };
                            6 === _.easing
                              ? Object.assign(
                                  z,
                                  cW(
                                    _,
                                    "mass",
                                    "stiffness",
                                    "damping",
                                    "velocity",
                                  ),
                                )
                              : 5 === _.easing &&
                                Object.assign(z, {
                                  control1: { ..._.control1 },
                                  control2: { ..._.control2 },
                                });
                            let F = {
                                repeat: _.repeat ? -1 : 0,
                                delay: _.delay,
                                delayDirection: _.delayDirection,
                                direction:
                                  _.cycle && _.rewind
                                    ? "pingpong-rewind"
                                    : _.cycle
                                      ? "pingpong"
                                      : "normal",
                              },
                              U = { state: _.state, ...F, ...z },
                              k = {
                                allowSlerp: !0,
                                type: "Transition",
                                object: _.object,
                                repeat: 0,
                                delay: 0,
                                delayDirection: void 0,
                                direction: "normal",
                                tweens: new cK(
                                  {
                                    fi: 0,
                                    id: iE.generateUUID(),
                                    data: {
                                      state: void 0,
                                      repeat: 0,
                                      delay: 0,
                                      delayDirection: void 0,
                                      direction: "normal",
                                      duration: 0,
                                      easing: 4,
                                    },
                                  },
                                  { fi: 1, id: iE.generateUUID(), data: U },
                                ),
                              };
                            L.push({ fi: N, id: R, data: k });
                          }),
                          delete _.targets);
                    }
                  }
                });
              });
            })(R),
            (function (_) {
              _.scene.objects.traverse((_, L) => {
                function n(_, R) {
                  let N = new cK(),
                    z = [];
                  if (
                    (L.events.forEach((_, L, F) => {
                      if ("Audio" === _.type && _.trigger === R) {
                        let R;
                        z.push(L),
                          "play" === _.interaction
                            ? (R = {
                                ...cW(
                                  _,
                                  "interaction",
                                  "audio",
                                  "delay",
                                  "volume",
                                  "loop",
                                ),
                                triggerAfter: "after" in _ ? _.after : void 0,
                                toggle: "after" in _ ? _.toggle : void 0,
                                type: "Audio",
                              })
                            : ("pause" === _.interaction ||
                                "stop" === _.interaction) &&
                              (R = {
                                ...cW(
                                  _,
                                  "interaction",
                                  "delay",
                                  "object",
                                  "playAudio",
                                ),
                                type: "Audio",
                              }),
                          R && N.push({ fi: F, id: L, data: R });
                      }
                    }),
                    z.forEach((_) => L.events.delete(_)),
                    N.length)
                  ) {
                    let R = L.events.find((L) => L.type === _)?.data;
                    R
                      ? "actions" in R && R.actions.insertBefore(null, N)
                      : L.events.insertBefore(null, [
                          {
                            id: iE.generateUUID(),
                            data: { type: _, actions: N },
                          },
                        ]);
                  }
                }
                n("Start", "start"),
                  n("MouseDown", "mouseDown"),
                  n("MouseUp", "mouseUp"),
                  n("KeyDown", "keyDown"),
                  n("KeyUp", "keyUp");
              });
            })(R),
            (R.schema = 21)),
          F < 22 && (IE(R), (R.schema = 22)),
          F < 23 &&
            ((function (_) {
              _.scene.objects.traverse((_, L) => {
                "Mesh" === L.type &&
                  "SubdivGeometry" === L.geometry.type &&
                  (L.geometry.scaleBaked ||
                    (L.geometry.scaleBaked = [1, 1, 1]));
              });
            })(R),
            (R.schema = 23)),
          F < 24 &&
            ((function (_) {
              _.scene.objects.traverse((_, L) => {
                ("Empty" !== L.type && "Mesh" !== L.type) ||
                  !L.cloner ||
                  L.cloner.randomnessObject ||
                  L.cloner.toObject ||
                  L.cloner.randomness ||
                  (L.cloner = {
                    ...L.cloner,
                    toObject: {
                      object: "",
                      spreadType: "random",
                      scale: [0, 0, 0],
                      rotation: [0, 0, 0],
                      position: [0, 0, 0],
                      axis: "x",
                      seed: 0,
                      count: 99,
                      align: "normal",
                    },
                    randomness: !1,
                    randomnessObject: {
                      strength: 100,
                      scale: [0, 0, 0],
                      rotation: [0, 0, 0],
                      position: [0, 0, 0],
                      movement: 1,
                      seed: 0,
                      freqScale: 10,
                      noiseType: "perlin",
                    },
                  });
              });
            })(R),
            (R.schema = 24)),
          (F < 25 || void 0 === R.shared.videos) &&
            ((R.shared.videos = Ri({}, cq.prototype)),
            F < 25 && (R.schema = 25)),
          F < 26 &&
            ((function (_) {
              _.scene.objects.traverse((L, R) => {
                let N = _.scene.objects.unproxy().parent(L);
                if (N) {
                  let L = Wn(_.scene.objects.data(N));
                  L &&
                    "Mesh" === L.type &&
                    "BooleanGeometry" === L.geometry.type &&
                    "Mesh" === R.type &&
                    (R.visible = !0 !== Wn(R).booleanExclude);
                }
              });
            })(R),
            (R.schema = 26)),
          F < 27 &&
            ((function (_) {
              _.scene.objects.traverse((_, L) => {
                "Mesh" === L.type &&
                  ("NonParametricGeometry" === L.geometry.type
                    ? void 0 !== L.material && delete L.material
                    : void 0 !== L.materials && delete L.materials);
              });
            })(R),
            (R.schema = 27)),
          F < 28 && (IE(R), (R.schema = 28)),
          F < 29 &&
            ((function (_) {
              function e(_) {
                for (let R in (Object.setPrototypeOf(_, c0.prototype), _)) {
                  var L;
                  Object.setPrototypeOf((L = _[R]), c0.prototype),
                    L.texture && Object.setPrototypeOf(L.texture, c0.prototype);
                }
              }
              _.scene.objects.traverse((_, L) => {
                L.states.forEach((_) => {
                  if (_.material) {
                    let L = Wn(_.material).layers;
                    e(L), (_.material.layers = L);
                  }
                  if (_.materials)
                    for (let L = 0; L < _.materials.length; L++) {
                      let R = _.materials[L],
                        N = Wn(R).layers;
                      e(N), (R.layers = N);
                    }
                });
              });
            })(R),
            (R.schema = 29)),
          F < 30 &&
            ((function (_) {
              _.scene.objects.traverse((_, L) => {
                "Mesh" !== L.type ||
                  "NonParametricGeometry" !== L.geometry.type ||
                  "material" in L ||
                  "materials" in L ||
                  (L.material = fU.defaultTwoLayerData("phong"));
              });
            })(R),
            (R.schema = 30)),
          F < 31 &&
            (void 0 === R.scene.publish.orbitControls.autoZoom &&
              (R.scene.publish.orbitControls.autoZoom = !1),
            R.scene.objects.traverse((_, L) => {
              ("OrthographicCamera" === L.type ||
                "PerspectiveCamera" === L.type) &&
                (void 0 === L.orthographic.autoZoom &&
                  (L.orthographic.autoZoom = !1),
                void 0 === L.orthographic.autoZoomFrustumSize &&
                  (L.orthographic.autoZoomFrustumSize = 790));
            }),
            (R.schema = 31)),
          F < 33 &&
            ((function (_) {
              _.scene.objects.traverse((_, L) => {
                void 0 === L.pathSnapping &&
                  (L.pathSnapping = {
                    pathId: null,
                    slide: 0,
                    offset: 0,
                    orientation: "tangential",
                  }),
                  void 0 === L.pathSnapping.offset &&
                    (L.pathSnapping.offset = 0);
              });
            })(R),
            (R.schema = 33)),
          F < 34 &&
            (void 0 === R.scene.publish.mouseEventTarget &&
              (R.scene.publish.mouseEventTarget = "canvas"),
            void 0 === R.scene.publish.settings.web.hint &&
              (R.scene.publish.settings.web.hint = !1),
            (R.schema = 34)),
          F < 35 &&
            ((function (_) {
              let { video: L } = _.scene.publish.settings;
              "gif" === L.format && L.fps > 48 && (L.fps = 15);
            })(R),
            (R.schema = 35)),
          F < 36 &&
            ((function (_) {
              _.scene.objects.traverse((_, L) => {
                L.events.forEach((_) => {
                  "GameControl" === _.type &&
                    (_.resetYPosition = Math.abs(
                      _.resetYPosition - L.position[1],
                    ));
                });
              });
            })(R),
            (R.schema = 36)));
        let Y = [];
        for (let _ of (U.scene.objects.traverse((_, L) => {
          "Mesh" === L.type &&
            "NonParametricGeometry" === L.geometry.type &&
            void 0 !== L.geometry.data.draco &&
            Y.push(L);
        }),
        Y.length &&
          (await (t0 ||
            (t0 = new S5())
              .setDecoderPath(
                "https://www.gstatic.com/draco/versioned/decoders/1.5.2/",
              )
              .preload(),
          t0.decoderPending)),
        Y)) {
          let L = await hj(Wn(_.geometry.data.draco));
          if (L) {
            L.index &&
              (_.geometry.data.index = {
                array: L.index.array,
                itemSize: 1,
                normalized: !1,
                type: "Uint32Array",
              });
            let R = {};
            L.attributes.forEach(({ name: _, array: L, itemSize: N }) => {
              R[_] = {
                array: L,
                itemSize: N,
                type: "Float32Array",
                normalized: !1,
              };
            }),
              (_.geometry.data.attributes = R),
              (_.geometry.data.draco = void 0);
          }
        }
        return L && L(U), k.result().data;
      }
      var S6 = Object.keys(wP).filter((_) => isNaN(Number(_))),
        S8 = class {
          constructor(_, L, R, N, z, F, U, k, Y, X, Q) {
            (this.preventScroll = z),
              (this.preventTouchScroll = F),
              (this.hideCursor = U),
              (this.requestRender = Y),
              (this.isEnable = !1),
              (this.onResetRaycaster = () => {
                this.eventContext.raycasterNeedsUpdate = !0;
              }),
              (this.onTouchMovePreventScroll = (_) => {
                (_.touches.length > 1 || this.preventTouchScroll) &&
                  _.preventDefault();
              }),
              (this.onMouseWheelPreventScroll = (_) => {
                this.preventScroll && _.preventDefault();
              }),
              (this.eventContext = new wC(_, L, R, k, N, Q ?? !1)),
              (this.handlers = {
                Spline: new _p(this.eventContext),
                Conditional: new _w(this.eventContext),
                Start: new _7(this.eventContext),
                Basic: new _m(this.eventContext, X, this),
                MouseHover: new _2(this.eventContext),
                Scroll: new _8(this.eventContext),
                Follow: new _I(this.eventContext),
                LookAt: new _Z(this.eventContext),
              });
          }
          activate() {
            let {
              scene: _,
              domElement: L,
              eventElement: R,
            } = this.eventContext;
            this.hideCursor && (L.style.cursor = "none"),
              (this.isEnable = !0),
              _.traverseEntity((_) => {
                _.addEventListener("requestRender", this.requestRender);
              }),
              Object.values(this.handlers).forEach((_) => _.connect()),
              S6.forEach((_) => {
                Object.values(this.handlers).some((L) =>
                  L.domEventsNeeded.has(_),
                ) &&
                  (L.addEventListener(_, this.onResetRaycaster),
                  R.addEventListener(_, this.onResetRaycaster));
              }),
              L.addEventListener("wheel", this.onMouseWheelPreventScroll),
              L.addEventListener("touchmove", this.onTouchMovePreventScroll);
          }
          deactivate() {
            let { scene: _, domElement: L } = this.eventContext;
            (this.isEnable = !1),
              (L.style.cursor = ""),
              Object.values(this.handlers).forEach((_) => _.disconnect()),
              _.traverseEntity((_) => {
                _.removeEventListener("requestRender", this.requestRender);
              }),
              S6.forEach((_) => {
                L.removeEventListener(_, this.onResetRaycaster);
              }),
              L.removeEventListener("touchmove", this.onTouchMovePreventScroll),
              L.removeEventListener("wheel", this.onMouseWheelPreventScroll);
          }
          reset() {
            this.deactivate(), this.activate();
          }
          updateUseWindowEvents(_) {
            let L = this.isEnable;
            L && this.deactivate(),
              (this.eventContext.useWindowEvents = _),
              L && this.activate();
          }
        },
        S9 = class {
          constructor(_, L, R, N, z) {
            (this._aspect = 1),
              (this._renderer = _),
              (this._camera = L),
              (this._frameSize = new iT().copy(R)),
              (this._editorSize = new iT().copy(N)),
              (this._aspect = L.aspect),
              (this._fov = z ?? L.fov);
          }
          set frameSize(_) {
            this._frameSize.copy(_);
          }
          updateRenderer() {
            this._renderer &&
              this._renderer.setSize(this._frameSize.x, this._frameSize.y);
          }
          updateViewport() {
            if (
              !this._renderer ||
              !this._camera ||
              "PerspectiveCamera" !== this._camera.cameraType
            )
              return;
            let _ = this._frameSize.x,
              L = this._frameSize.y,
              R = this._editorSize.y;
            (this._aspect = _ / L),
              L <= R && (this._camera.zoom *= R / L),
              this._renderer.setViewport(0, 0, _, L);
          }
          updateCamera() {
            if (this._camera) {
              if ("PerspectiveCamera" === this._camera.cameraType) {
                let _ = this._frameSize.y,
                  L = this._editorSize.y,
                  R = this._fov;
                if (_ > L)
                  R *= (_ / L) * (1 - (((_ - 1080) / 1080) * 14 + 1) / 100);
                (this._camera.aspect = this._aspect),
                  (this._camera.fov = R),
                  this._camera.updateProjectionMatrix();
              } else
                this._camera.setViewplaneSize(
                  this._frameSize.x,
                  this._frameSize.y,
                );
            }
          }
          setCamera(_) {
            (this._camera = _), (this._aspect = _.aspect), (this._fov = _.fov);
          }
          revert() {
            let _ = window.innerWidth,
              L = window.innerHeight;
            this._renderer &&
              (this._renderer.setViewport(0, 0, _, L),
              this._renderer.setSize(_, L)),
              this._camera &&
                ((this._camera.aspect = _ / L),
                (this._camera.fov = this._fov),
                this._camera.setViewplaneSize(_, L),
                this._camera.updateProjectionMatrix());
          }
        },
        S7 =
          "varying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}",
        Ae = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
uniform lowp sampler2D cocBuffer;uniform vec2 texelSize;uniform float scale;
#if PASS == 1
uniform vec4 kernel64[32];
#else
uniform vec4 kernel16[8];
#endif
varying vec2 vUv;void main(){
#ifdef FOREGROUND
vec2 CoCNearFar=texture2D(cocBuffer,vUv).rg;float CoC=CoCNearFar.r*scale;
#else
float CoC=texture2D(cocBuffer,vUv).g*scale;
#endif
if(CoC==0.0){gl_FragColor=texture2D(inputBuffer,vUv);}else{
#ifdef FOREGROUND
vec2 step=texelSize*max(CoC,CoCNearFar.g*scale);
#else
vec2 step=texelSize*CoC;
#endif
#if PASS == 1
vec4 acc=vec4(0.0);for(int i=0;i<32;++i){vec4 kernel=kernel64[i];vec2 uv=step*kernel.xy+vUv;acc+=texture2D(inputBuffer,uv);uv=step*kernel.zw+vUv;acc+=texture2D(inputBuffer,uv);}gl_FragColor=acc/64.0;
#else
vec4 maxValue=texture2D(inputBuffer,vUv);for(int i=0;i<8;++i){vec4 kernel=kernel16[i];vec2 uv=step*kernel.xy+vUv;maxValue=max(texture2D(inputBuffer,uv),maxValue);uv=step*kernel.zw+vUv;maxValue=max(texture2D(inputBuffer,uv),maxValue);}gl_FragColor=maxValue;
#endif
}}`,
        At = class extends sQ {
          constructor(_ = !1, L = !1) {
            super({
              name: "BokehMaterial",
              defines: { PASS: _ ? "2" : "1" },
              uniforms: {
                kernel64: new oz(null),
                kernel16: new oz(null),
                inputBuffer: new oz(null),
                cocBuffer: new oz(null),
                texelSize: new oz(new iT()),
                scale: new oz(1),
              },
              blending: 0,
              depthWrite: !1,
              depthTest: !1,
              fragmentShader: Ae,
              vertexShader: S7,
            }),
              (this.toneMapped = !1),
              L && (this.defines.FOREGROUND = "1"),
              this.generateKernel();
          }
          set inputBuffer(_) {
            this.uniforms.inputBuffer.value = _;
          }
          setInputBuffer(_) {
            this.uniforms.inputBuffer.value = _;
          }
          set cocBuffer(_) {
            this.uniforms.cocBuffer.value = _;
          }
          setCoCBuffer(_) {
            this.uniforms.cocBuffer.value = _;
          }
          get scale() {
            return this.uniforms.scale.value;
          }
          set scale(_) {
            this.uniforms.scale.value = _;
          }
          getScale(_) {
            return (this.uniforms.scale.value = _);
          }
          setScale(_) {
            this.uniforms.scale.value = _;
          }
          generateKernel() {
            let _ = new Float32Array(128),
              L = new Float32Array(32),
              R = 0,
              N = 0;
            for (let z = 0; z < 80; ++z) {
              let F = 2.39996323 * z,
                U = Math.sqrt(z) / Math.sqrt(80),
                k = U * Math.cos(F),
                Y = U * Math.sin(F);
              z % 5 == 0
                ? ((L[N++] = k), (L[N++] = Y))
                : ((_[R++] = k), (_[R++] = Y));
            }
            let z = [],
              F = [];
            for (let L = 0; L < 128; )
              z.push(new iV(_[L++], _[L++], _[L++], _[L++]));
            for (let _ = 0; _ < 32; )
              F.push(new iV(L[_++], L[_++], L[_++], L[_++]));
            (this.uniforms.kernel64.value = z),
              (this.uniforms.kernel16.value = F);
          }
          setTexelSize(_, L) {
            this.uniforms.texelSize.value.set(_, L);
          }
          setSize(_, L) {
            this.uniforms.texelSize.value.set(1 / _, 1 / L);
          }
        };
      function WS(_, L, R) {
        return Math.min(Math.max((_ + L) / (L - R), 0), 1);
      }
      var Ai = `#include <common>
#include <packing>
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
uniform float focusDistance;uniform float focusRange;uniform float cameraNear;uniform float cameraFar;varying vec2 vUv;float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}void main(){float depth=readDepth(vUv);
#ifdef PERSPECTIVE_CAMERA
float viewZ=perspectiveDepthToViewZ(depth,cameraNear,cameraFar);float linearDepth=viewZToOrthographicDepth(viewZ,cameraNear,cameraFar);
#else
float linearDepth=depth;
#endif
float signedDistance=linearDepth-focusDistance;float magnitude=smoothstep(0.0,focusRange,abs(signedDistance));gl_FragColor.rg=magnitude*vec2(step(signedDistance,0.0),step(0.0,signedDistance));}`,
        Ar = class extends sQ {
          constructor(_) {
            super({
              name: "CircleOfConfusionMaterial",
              defines: { DEPTH_PACKING: "0" },
              uniforms: {
                depthBuffer: new oz(null),
                focusDistance: new oz(0),
                focusRange: new oz(0),
                cameraNear: new oz(0.3),
                cameraFar: new oz(1e3),
              },
              blending: 0,
              depthWrite: !1,
              depthTest: !1,
              fragmentShader: Ai,
              vertexShader: S7,
            }),
              (this.toneMapped = !1),
              (this.uniforms.focalLength = this.uniforms.focusRange),
              this.adoptCameraSettings(_);
          }
          get near() {
            return this.uniforms.cameraNear.value;
          }
          get far() {
            return this.uniforms.cameraFar.value;
          }
          set depthBuffer(_) {
            this.uniforms.depthBuffer.value = _;
          }
          set depthPacking(_) {
            (this.defines.DEPTH_PACKING = _.toFixed(0)),
              (this.needsUpdate = !0);
          }
          setDepthBuffer(_, L = 3200) {
            (this.depthBuffer = _), (this.depthPacking = L);
          }
          get focusDistance() {
            return this.uniforms.focusDistance.value;
          }
          set focusDistance(_) {
            this.uniforms.focusDistance.value = _;
          }
          get worldFocusDistance() {
            var _;
            return -(this.focusDistance * ((_ = this.near) - this.far) - _);
          }
          set worldFocusDistance(_) {
            this.focusDistance = WS(-_, this.near, this.far);
          }
          getFocusDistance(_) {
            this.uniforms.focusDistance.value = _;
          }
          setFocusDistance(_) {
            this.uniforms.focusDistance.value = _;
          }
          get focalLength() {
            return this.focusRange;
          }
          set focalLength(_) {
            this.focusRange = _;
          }
          get focusRange() {
            return this.uniforms.focusRange.value;
          }
          set focusRange(_) {
            this.uniforms.focusRange.value = _;
          }
          get worldFocusRange() {
            var _;
            return -(this.focusRange * ((_ = this.near) - this.far) - _);
          }
          set worldFocusRange(_) {
            this.focusRange = WS(-_, this.near, this.far);
          }
          getFocalLength(_) {
            return this.focusRange;
          }
          setFocalLength(_) {
            this.focusRange = _;
          }
          adoptCameraSettings(_) {
            _ &&
              ((this.uniforms.cameraNear.value = _.near),
              (this.uniforms.cameraFar.value = _.far),
              _ instanceof sK
                ? (this.defines.PERSPECTIVE_CAMERA = "1")
                : delete this.defines.PERSPECTIVE_CAMERA,
              (this.needsUpdate = !0));
          }
        },
        An = `#include <common>
#include <dithering_pars_fragment>
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec4 sum=texture2D(inputBuffer,vUv0);sum+=texture2D(inputBuffer,vUv1);sum+=texture2D(inputBuffer,vUv2);sum+=texture2D(inputBuffer,vUv3);gl_FragColor=sum*0.25;
#include <encodings_fragment>
#include <dithering_fragment>
}`,
        Aa = class extends sQ {
          constructor(_ = new iT()) {
            super({
              name: "KawaseBlurMaterial",
              uniforms: {
                inputBuffer: new oz(null),
                texelSize: new oz(new iT()),
                halfTexelSize: new oz(new iT()),
                kernel: new oz(0),
                scale: new oz(1),
              },
              blending: 0,
              depthWrite: !1,
              depthTest: !1,
              fragmentShader: An,
              vertexShader:
                "uniform vec2 texelSize;uniform vec2 halfTexelSize;uniform float kernel;uniform float scale;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vec2 dUv=(texelSize*vec2(kernel)+halfTexelSize)*scale;vUv0=vec2(uv.x-dUv.x,uv.y+dUv.y);vUv1=vec2(uv.x+dUv.x,uv.y+dUv.y);vUv2=vec2(uv.x+dUv.x,uv.y-dUv.y);vUv3=vec2(uv.x-dUv.x,uv.y-dUv.y);gl_Position=vec4(position.xy,1.0,1.0);}",
            }),
              (this.toneMapped = !1),
              this.setTexelSize(_.x, _.y);
          }
          set inputBuffer(_) {
            this.uniforms.inputBuffer.value = _;
          }
          setInputBuffer(_) {
            this.inputBuffer = _;
          }
          get scale() {
            return this.uniforms.scale.value;
          }
          set scale(_) {
            this.uniforms.scale.value = _;
          }
          getScale() {
            return this.uniforms.scale.value;
          }
          setScale(_) {
            this.uniforms.scale.value = _;
          }
          getKernel() {
            return null;
          }
          get kernel() {
            return this.uniforms.kernel.value;
          }
          set kernel(_) {
            this.uniforms.kernel.value = _;
          }
          setKernel(_) {
            this.kernel = _;
          }
          setTexelSize(_, L) {
            this.uniforms.texelSize.value.set(_, L),
              this.uniforms.halfTexelSize.value.set(_, L).multiplyScalar(0.5);
          }
          setSize(_, L) {
            let R = this.uniforms;
            R.texelSize.value.set(1 / _, 1 / L),
              R.halfTexelSize.value.copy(R.texelSize.value).multiplyScalar(0.5);
          }
        },
        Ao = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
uniform float opacity;varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=opacity*texel;
#include <encodings_fragment>
}`,
        Al = class extends sQ {
          constructor() {
            super({
              name: "CopyMaterial",
              uniforms: { inputBuffer: new oz(null), opacity: new oz(1) },
              blending: 0,
              depthWrite: !1,
              depthTest: !1,
              fragmentShader: Ao,
              vertexShader: S7,
            }),
              (this.toneMapped = !1);
          }
          set inputBuffer(_) {
            this.uniforms.inputBuffer.value = _;
          }
          setInputBuffer(_) {
            this.uniforms.inputBuffer.value = _;
          }
          getOpacity(_) {
            return this.uniforms.opacity.value;
          }
          setOpacity(_) {
            this.uniforms.opacity.value = _;
          }
        },
        Ah = `varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;
#if THREE_REVISION < 143
#define luminance(v) linearToRelativeLuminance(v)
#endif
#if EDGE_DETECTION_MODE != 0
varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;
#endif
#if EDGE_DETECTION_MODE == 1
#include <common>
#endif
#if EDGE_DETECTION_MODE == 0 || PREDICATION_MODE == 1
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}vec3 gatherNeighbors(){float p=readDepth(vUv);float pLeft=readDepth(vUv0);float pTop=readDepth(vUv1);return vec3(p,pLeft,pTop);}
#elif PREDICATION_MODE == 2
uniform sampler2D predicationBuffer;vec3 gatherNeighbors(){float p=texture2D(predicationBuffer,vUv).r;float pLeft=texture2D(predicationBuffer,vUv0).r;float pTop=texture2D(predicationBuffer,vUv1).r;return vec3(p,pLeft,pTop);}
#endif
#if PREDICATION_MODE != 0
vec2 calculatePredicatedThreshold(){vec3 neighbours=gatherNeighbors();vec2 delta=abs(neighbours.xx-neighbours.yz);vec2 edges=step(PREDICATION_THRESHOLD,delta);return PREDICATION_SCALE*EDGE_THRESHOLD*(1.0-PREDICATION_STRENGTH*edges);}
#endif
#if EDGE_DETECTION_MODE != 0
uniform sampler2D inputBuffer;
#endif
void main(){
#if EDGE_DETECTION_MODE == 0
const vec2 threshold=vec2(DEPTH_THRESHOLD);
#elif PREDICATION_MODE != 0
vec2 threshold=calculatePredicatedThreshold();
#else
const vec2 threshold=vec2(EDGE_THRESHOLD);
#endif
#if EDGE_DETECTION_MODE == 0
vec3 neighbors=gatherNeighbors();vec2 delta=abs(neighbors.xx-vec2(neighbors.y,neighbors.z));vec2 edges=step(threshold,delta);if(dot(edges,vec2(1.0))==0.0){discard;}gl_FragColor=vec4(edges,0.0,1.0);
#elif EDGE_DETECTION_MODE == 1
float l=luminance(texture2D(inputBuffer,vUv).rgb);float lLeft=luminance(texture2D(inputBuffer,vUv0).rgb);float lTop=luminance(texture2D(inputBuffer,vUv1).rgb);vec4 delta;delta.xy=abs(l-vec2(lLeft,lTop));vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}float lRight=luminance(texture2D(inputBuffer,vUv2).rgb);float lBottom=luminance(texture2D(inputBuffer,vUv3).rgb);delta.zw=abs(l-vec2(lRight,lBottom));vec2 maxDelta=max(delta.xy,delta.zw);float lLeftLeft=luminance(texture2D(inputBuffer,vUv4).rgb);float lTopTop=luminance(texture2D(inputBuffer,vUv5).rgb);delta.zw=abs(vec2(lLeft,lTop)-vec2(lLeftLeft,lTopTop));maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges.xy*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);
#elif EDGE_DETECTION_MODE == 2
vec4 delta;vec3 c=texture2D(inputBuffer,vUv).rgb;vec3 cLeft=texture2D(inputBuffer,vUv0).rgb;vec3 t=abs(c-cLeft);delta.x=max(max(t.r,t.g),t.b);vec3 cTop=texture2D(inputBuffer,vUv1).rgb;t=abs(c-cTop);delta.y=max(max(t.r,t.g),t.b);vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}vec3 cRight=texture2D(inputBuffer,vUv2).rgb;t=abs(c-cRight);delta.z=max(max(t.r,t.g),t.b);vec3 cBottom=texture2D(inputBuffer,vUv3).rgb;t=abs(c-cBottom);delta.w=max(max(t.r,t.g),t.b);vec2 maxDelta=max(delta.xy,delta.zw);vec3 cLeftLeft=texture2D(inputBuffer,vUv4).rgb;t=abs(c-cLeftLeft);delta.z=max(max(t.r,t.g),t.b);vec3 cTopTop=texture2D(inputBuffer,vUv5).rgb;t=abs(c-cTopTop);delta.w=max(max(t.r,t.g),t.b);maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);
#endif
}`,
        Au = `uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;
#if EDGE_DETECTION_MODE != 0
varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;
#endif
void main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,0.0);vUv1=vUv+texelSize*vec2(0.0,-1.0);
#if EDGE_DETECTION_MODE != 0
vUv2=vUv+texelSize*vec2(1.0,0.0);vUv3=vUv+texelSize*vec2(0.0,1.0);vUv4=vUv+texelSize*vec2(-2.0,0.0);vUv5=vUv+texelSize*vec2(0.0,-2.0);
#endif
gl_Position=vec4(position.xy,1.0,1.0);}`,
        Ap = { COLOR: 2 },
        Af = class extends sQ {
          constructor(_ = new iT(), L = Ap.COLOR) {
            super({
              name: "EdgeDetectionMaterial",
              defines: {
                THREE_REVISION: "149".replace(/\D+/g, ""),
                LOCAL_CONTRAST_ADAPTATION_FACTOR: "2.0",
                EDGE_THRESHOLD: "0.1",
                DEPTH_THRESHOLD: "0.01",
                PREDICATION_MODE: "0",
                PREDICATION_THRESHOLD: "0.01",
                PREDICATION_SCALE: "2.0",
                PREDICATION_STRENGTH: "1.0",
                DEPTH_PACKING: "0",
              },
              uniforms: {
                inputBuffer: new oz(null),
                depthBuffer: new oz(null),
                predicationBuffer: new oz(null),
                texelSize: new oz(_),
              },
              blending: 0,
              depthWrite: !1,
              depthTest: !1,
              fragmentShader: Ah,
              vertexShader: Au,
            }),
              (this.toneMapped = !1),
              (this.edgeDetectionMode = L);
          }
          set depthBuffer(_) {
            this.uniforms.depthBuffer.value = _;
          }
          set depthPacking(_) {
            (this.defines.DEPTH_PACKING = _.toFixed(0)),
              (this.needsUpdate = !0);
          }
          setDepthBuffer(_, L = 3200) {
            (this.depthBuffer = _), (this.depthPacking = L);
          }
          get edgeDetectionMode() {
            return Number(this.defines.EDGE_DETECTION_MODE);
          }
          set edgeDetectionMode(_) {
            (this.defines.EDGE_DETECTION_MODE = _.toFixed(0)),
              (this.needsUpdate = !0);
          }
          getEdgeDetectionMode() {
            return this.edgeDetectionMode;
          }
          setEdgeDetectionMode(_) {
            this.edgeDetectionMode = _;
          }
          get localContrastAdaptationFactor() {
            return Number(this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR);
          }
          set localContrastAdaptationFactor(_) {
            (this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR = _.toFixed("6")),
              (this.needsUpdate = !0);
          }
          getLocalContrastAdaptationFactor() {
            return this.localContrastAdaptationFactor;
          }
          setLocalContrastAdaptationFactor(_) {
            this.localContrastAdaptationFactor = _;
          }
          get edgeDetectionThreshold() {
            return Number(this.defines.EDGE_THRESHOLD);
          }
          set edgeDetectionThreshold(_) {
            (this.defines.EDGE_THRESHOLD = _.toFixed("6")),
              (this.defines.DEPTH_THRESHOLD = (0.1 * _).toFixed("6")),
              (this.needsUpdate = !0);
          }
          getEdgeDetectionThreshold() {
            return this.edgeDetectionThreshold;
          }
          setEdgeDetectionThreshold(_) {
            this.edgeDetectionThreshold = _;
          }
          get predicationMode() {
            return Number(this.defines.PREDICATION_MODE);
          }
          set predicationMode(_) {
            (this.defines.PREDICATION_MODE = _.toFixed(0)),
              (this.needsUpdate = !0);
          }
          getPredicationMode() {
            return this.predicationMode;
          }
          setPredicationMode(_) {
            this.predicationMode = _;
          }
          set predicationBuffer(_) {
            this.uniforms.predicationBuffer.value = _;
          }
          setPredicationBuffer(_) {
            this.uniforms.predicationBuffer.value = _;
          }
          get predicationThreshold() {
            return Number(this.defines.PREDICATION_THRESHOLD);
          }
          set predicationThreshold(_) {
            (this.defines.PREDICATION_THRESHOLD = _.toFixed("6")),
              (this.needsUpdate = !0);
          }
          getPredicationThreshold() {
            return this.predicationThreshold;
          }
          setPredicationThreshold(_) {
            this.predicationThreshold = _;
          }
          get predicationScale() {
            return Number(this.defines.PREDICATION_SCALE);
          }
          set predicationScale(_) {
            (this.defines.PREDICATION_SCALE = _.toFixed("6")),
              (this.needsUpdate = !0);
          }
          getPredicationScale() {
            return this.predicationScale;
          }
          setPredicationScale(_) {
            this.predicationScale = _;
          }
          get predicationStrength() {
            return Number(this.defines.PREDICATION_STRENGTH);
          }
          set predicationStrength(_) {
            (this.defines.PREDICATION_STRENGTH = _.toFixed("6")),
              (this.needsUpdate = !0);
          }
          getPredicationStrength() {
            return this.predicationStrength;
          }
          setPredicationStrength(_) {
            this.predicationStrength = _;
          }
          setSize(_, L) {
            this.uniforms.texelSize.value.set(1 / _, 1 / L);
          }
        },
        Am = `#include <common>
#include <packing>
#include <dithering_pars_fragment>
#define packFloatToRGBA(v) packDepthToRGBA(v)
#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;
#if THREE_REVISION < 143
#define luminance(v) linearToRelativeLuminance(v)
#endif
#if THREE_REVISION >= 137
vec4 sRGBToLinear(const in vec4 value){return vec4(mix(pow(value.rgb*0.9478672986+vec3(0.0521327014),vec3(2.4)),value.rgb*0.0773993808,vec3(lessThanEqual(value.rgb,vec3(0.04045)))),value.a);}
#endif
float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}float getViewZ(const in float depth){
#ifdef PERSPECTIVE_CAMERA
return perspectiveDepthToViewZ(depth,cameraNear,cameraFar);
#else
return orthographicDepthToViewZ(depth,cameraNear,cameraFar);
#endif
}FRAGMENT_HEADvoid main(){FRAGMENT_MAIN_UVvec4 color0=texture2D(inputBuffer,UV);vec4 color1=vec4(0.0);FRAGMENT_MAIN_IMAGEgl_FragColor=color0;
#ifdef ENCODE_OUTPUT
#include <encodings_fragment>
#endif
#include <dithering_fragment>
}`,
        Ag = {
          FRAGMENT_HEAD: "FRAGMENT_HEAD",
          FRAGMENT_MAIN_UV: "FRAGMENT_MAIN_UV",
          FRAGMENT_MAIN_IMAGE: "FRAGMENT_MAIN_IMAGE",
          VERTEX_HEAD: "VERTEX_HEAD",
          VERTEX_MAIN_SUPPORT: "VERTEX_MAIN_SUPPORT",
        },
        Av = class extends sQ {
          constructor(_, L, R, N, z = !1) {
            super({
              name: "EffectMaterial",
              defines: {
                THREE_REVISION: "149".replace(/\D+/g, ""),
                DEPTH_PACKING: "0",
                ENCODE_OUTPUT: "1",
              },
              uniforms: {
                inputBuffer: new oz(null),
                depthBuffer: new oz(null),
                resolution: new oz(new iT()),
                texelSize: new oz(new iT()),
                cameraNear: new oz(0.3),
                cameraFar: new oz(1e3),
                aspect: new oz(1),
                time: new oz(0),
              },
              blending: 0,
              depthWrite: !1,
              depthTest: !1,
              dithering: z,
            }),
              (this.toneMapped = !1),
              _ && this.setShaderParts(_),
              L && this.setDefines(L),
              R && this.setUniforms(R),
              this.adoptCameraSettings(N);
          }
          set inputBuffer(_) {
            this.uniforms.inputBuffer.value = _;
          }
          setInputBuffer(_) {
            this.uniforms.inputBuffer.value = _;
          }
          get depthBuffer() {
            return this.uniforms.depthBuffer.value;
          }
          set depthBuffer(_) {
            this.uniforms.depthBuffer.value = _;
          }
          get depthPacking() {
            return Number(this.defines.DEPTH_PACKING);
          }
          set depthPacking(_) {
            (this.defines.DEPTH_PACKING = _.toFixed(0)),
              (this.needsUpdate = !0);
          }
          setDepthBuffer(_, L = 3200) {
            (this.depthBuffer = _), (this.depthPacking = L);
          }
          setShaderParts(_) {
            return (
              (this.fragmentShader = Am.replace(
                Ag.FRAGMENT_HEAD,
                _.get(Ag.FRAGMENT_HEAD),
              )
                .replace(Ag.FRAGMENT_MAIN_UV, _.get(Ag.FRAGMENT_MAIN_UV))
                .replace(
                  Ag.FRAGMENT_MAIN_IMAGE,
                  _.get(Ag.FRAGMENT_MAIN_IMAGE),
                )),
              (this.vertexShader =
                "uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;VERTEX_HEADvoid main(){vUv=position.xy*0.5+0.5;VERTEX_MAIN_SUPPORTgl_Position=vec4(position.xy,1.0,1.0);}"
                  .replace(Ag.VERTEX_HEAD, _.get(Ag.VERTEX_HEAD))
                  .replace(
                    Ag.VERTEX_MAIN_SUPPORT,
                    _.get(Ag.VERTEX_MAIN_SUPPORT),
                  )),
              (this.needsUpdate = !0),
              this
            );
          }
          setDefines(_) {
            for (let L of _.entries()) this.defines[L[0]] = L[1];
            return (this.needsUpdate = !0), this;
          }
          setUniforms(_) {
            for (let L of _.entries()) this.uniforms[L[0]] = L[1];
            return this;
          }
          setExtensions(_) {
            for (let L of ((this.extensions = {}), _)) this.extensions[L] = !0;
            return this;
          }
          get encodeOutput() {
            return void 0 !== this.defines.ENCODE_OUTPUT;
          }
          set encodeOutput(_) {
            this.encodeOutput !== _ &&
              (_
                ? (this.defines.ENCODE_OUTPUT = "1")
                : delete this.defines.ENCODE_OUTPUT,
              (this.needsUpdate = !0));
          }
          isOutputEncodingEnabled(_) {
            return this.encodeOutput;
          }
          setOutputEncodingEnabled(_) {
            this.encodeOutput = _;
          }
          get time() {
            return this.uniforms.time.value;
          }
          set time(_) {
            this.uniforms.time.value = _;
          }
          setDeltaTime(_) {
            this.uniforms.time.value += _;
          }
          adoptCameraSettings(_) {
            _ &&
              ((this.uniforms.cameraNear.value = _.near),
              (this.uniforms.cameraFar.value = _.far),
              _ instanceof sK
                ? (this.defines.PERSPECTIVE_CAMERA = "1")
                : delete this.defines.PERSPECTIVE_CAMERA,
              (this.needsUpdate = !0));
          }
          setSize(_, L) {
            let R = this.uniforms;
            R.resolution.value.set(_, L),
              R.texelSize.value.set(1 / _, 1 / L),
              (R.aspect.value = _ / L);
          }
          static get Section() {
            return Ag;
          }
        },
        Ay = `#include <common>
#if THREE_REVISION < 143
#define luminance(v) linearToRelativeLuminance(v)
#endif
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#ifdef RANGE
uniform vec2 range;
#elif defined(THRESHOLD)
uniform float threshold;uniform float smoothing;
#endif
varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);float l=luminance(texel.rgb);
#ifdef RANGE
float low=step(range.x,l);float high=step(l,range.y);l*=low*high;
#elif defined(THRESHOLD)
l=smoothstep(threshold,threshold+smoothing,l);
#endif
#ifdef COLOR
gl_FragColor=vec4(texel.rgb*l,l);
#else
gl_FragColor=vec4(l);
#endif
}`,
        Ab = class extends sQ {
          constructor(_ = !1, L = null) {
            super({
              name: "LuminanceMaterial",
              defines: { THREE_REVISION: "149".replace(/\D+/g, "") },
              uniforms: {
                inputBuffer: new oz(null),
                threshold: new oz(0),
                smoothing: new oz(1),
                range: new oz(null),
              },
              blending: 0,
              depthWrite: !1,
              depthTest: !1,
              fragmentShader: Ay,
              vertexShader: S7,
            }),
              (this.toneMapped = !1),
              (this.colorOutput = _),
              (this.luminanceRange = L);
          }
          set inputBuffer(_) {
            this.uniforms.inputBuffer.value = _;
          }
          setInputBuffer(_) {
            this.uniforms.inputBuffer.value = _;
          }
          get threshold() {
            return this.uniforms.threshold.value;
          }
          set threshold(_) {
            this.smoothing > 0 || _ > 0
              ? (this.defines.THRESHOLD = "1")
              : delete this.defines.THRESHOLD,
              (this.uniforms.threshold.value = _);
          }
          getThreshold() {
            return this.threshold;
          }
          setThreshold(_) {
            this.threshold = _;
          }
          get smoothing() {
            return this.uniforms.smoothing.value;
          }
          set smoothing(_) {
            this.threshold > 0 || _ > 0
              ? (this.defines.THRESHOLD = "1")
              : delete this.defines.THRESHOLD,
              (this.uniforms.smoothing.value = _);
          }
          getSmoothingFactor() {
            return this.smoothing;
          }
          setSmoothingFactor(_) {
            this.smoothing = _;
          }
          get useThreshold() {
            return this.threshold > 0 || this.smoothing > 0;
          }
          set useThreshold(_) {}
          get colorOutput() {
            return void 0 !== this.defines.COLOR;
          }
          set colorOutput(_) {
            _ ? (this.defines.COLOR = "1") : delete this.defines.COLOR,
              (this.needsUpdate = !0);
          }
          isColorOutputEnabled(_) {
            return this.colorOutput;
          }
          setColorOutputEnabled(_) {
            this.colorOutput = _;
          }
          get useRange() {
            return null !== this.luminanceRange;
          }
          set useRange(_) {
            this.luminanceRange = null;
          }
          get luminanceRange() {
            return this.uniforms.range.value;
          }
          set luminanceRange(_) {
            null !== _ ? (this.defines.RANGE = "1") : delete this.defines.RANGE,
              (this.uniforms.range.value = _),
              (this.needsUpdate = !0);
          }
          getLuminanceRange() {
            return this.luminanceRange;
          }
          setLuminanceRange(_) {
            this.luminanceRange = _;
          }
        },
        Aw = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#ifdef MASK_PRECISION_HIGH
uniform mediump sampler2D maskTexture;
#else
uniform lowp sampler2D maskTexture;
#endif
#if MASK_FUNCTION != 0
uniform float strength;
#endif
varying vec2 vUv;void main(){
#if COLOR_CHANNEL == 0
float mask=texture2D(maskTexture,vUv).r;
#elif COLOR_CHANNEL == 1
float mask=texture2D(maskTexture,vUv).g;
#elif COLOR_CHANNEL == 2
float mask=texture2D(maskTexture,vUv).b;
#else
float mask=texture2D(maskTexture,vUv).a;
#endif
#if MASK_FUNCTION == 0
#ifdef INVERTED
mask=step(mask,0.0);
#else
mask=1.0-step(mask,0.0);
#endif
#else
mask=clamp(mask*strength,0.0,1.0);
#ifdef INVERTED
mask=1.0-mask;
#endif
#endif
#if MASK_FUNCTION == 2
gl_FragColor=vec4(mask*texture2D(inputBuffer,vUv).rgb,mask);
#else
gl_FragColor=mask*texture2D(inputBuffer,vUv);
#endif
}`,
        AS = class extends sQ {
          constructor(_ = null) {
            super({
              name: "MaskMaterial",
              uniforms: {
                maskTexture: new oz(_),
                inputBuffer: new oz(null),
                strength: new oz(1),
              },
              blending: 0,
              depthWrite: !1,
              depthTest: !1,
              fragmentShader: Aw,
              vertexShader: S7,
            }),
              (this.toneMapped = !1),
              this.setColorChannel(0),
              this.setMaskFunction(0);
          }
          set inputBuffer(_) {
            this.uniforms.inputBuffer.value = _;
          }
          setInputBuffer(_) {
            this.uniforms.inputBuffer.value = _;
          }
          set maskTexture(_) {
            (this.uniforms.maskTexture.value = _),
              delete this.defines.MASK_PRECISION_HIGH,
              1009 !== _.type && (this.defines.MASK_PRECISION_HIGH = "1"),
              (this.needsUpdate = !0);
          }
          setMaskTexture(_) {
            this.maskTexture = _;
          }
          set colorChannel(_) {
            (this.defines.COLOR_CHANNEL = _.toFixed(0)),
              (this.needsUpdate = !0);
          }
          setColorChannel(_) {
            this.colorChannel = _;
          }
          set maskFunction(_) {
            (this.defines.MASK_FUNCTION = _.toFixed(0)),
              (this.needsUpdate = !0);
          }
          setMaskFunction(_) {
            this.maskFunction = _;
          }
          get inverted() {
            return void 0 !== this.defines.INVERTED;
          }
          set inverted(_) {
            this.inverted && !_
              ? delete this.defines.INVERTED
              : _ && (this.defines.INVERTED = "1"),
              (this.needsUpdate = !0);
          }
          isInverted() {
            return this.inverted;
          }
          setInverted(_) {
            this.inverted = _;
          }
          get strength() {
            return this.uniforms.strength.value;
          }
          set strength(_) {
            this.uniforms.strength.value = _;
          }
          getStrength() {
            return this.strength;
          }
          setStrength(_) {
            this.strength = _;
          }
        },
        AA = `#define sampleLevelZeroOffset(t, coord, offset) texture2D(t, coord + offset * texelSize)
#if __VERSION__ < 300
#define round(v) floor(v + 0.5)
#endif
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
uniform lowp sampler2D areaTexture;uniform lowp sampler2D searchTexture;uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}vec2 decodeDiagBilinearAccess(in vec2 e){e.r=e.r*abs(5.0*e.r-5.0*0.75);return round(e);}vec4 decodeDiagBilinearAccess(in vec4 e){e.rb=e.rb*abs(5.0*e.rb-5.0*0.75);return round(e);}vec2 searchDiag1(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 searchDiag2(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);coord.x+=0.25*texelSize.x;vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;e=decodeDiagBilinearAccess(e);coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 areaDiag(const in vec2 dist,const in vec2 e,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE_DIAG,AREATEX_MAX_DISTANCE_DIAG)*e+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.x+=0.5;texCoord.y+=AREATEX_SUBTEX_SIZE*offset;return texture2D(areaTexture,texCoord).rg;}vec2 calculateDiagWeights(const in vec2 texCoord,const in vec2 e,const in vec4 subsampleIndices){vec2 weights=vec2(0.0);vec4 d;vec2 end;if(e.r>0.0){d.xz=searchDiag1(texCoord,vec2(-1.0,1.0),end);d.x+=float(end.y>0.9);}else{d.xz=vec2(0.0);}d.yw=searchDiag1(texCoord,vec2(1.0,-1.0),end);if(d.x+d.y>2.0){vec4 coords=vec4(-d.x+0.25,d.x,d.y,-d.y-0.25)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.xy=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).rg;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).rg;c.yxwz=decodeDiagBilinearAccess(c.xyzw);vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.z);}d.xz=searchDiag2(texCoord,vec2(-1.0,-1.0),end);if(sampleLevelZeroOffset(inputBuffer,texCoord,vec2(1,0)).r>0.0){d.yw=searchDiag2(texCoord,vec2(1.0),end);d.y+=float(end.y>0.9);}else{d.yw=vec2(0.0);}if(d.x+d.y>2.0){vec4 coords=vec4(-d.x,-d.x,d.y,d.y)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.x=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).g;c.y=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(0,-1)).r;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).gr;vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.w).gr;}return weights;}float searchLength(const in vec2 e,const in float offset){vec2 scale=SEARCHTEX_SIZE*vec2(0.5,-1.0);vec2 bias=SEARCHTEX_SIZE*vec2(offset,1.0);scale+=vec2(-1.0,1.0);bias+=vec2(0.5,-0.5);scale*=1.0/SEARCHTEX_PACKED_SIZE;bias*=1.0/SEARCHTEX_PACKED_SIZE;return texture2D(searchTexture,scale*e+bias).r;}float searchXLeft(in vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x>end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(-2.0,0.0)*texelSize+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.0)+3.25;return texelSize.x*offset+texCoord.x;}float searchXRight(vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x<end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(2.0,0.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.5)+3.25;return-texelSize.x*offset+texCoord.x;}float searchYUp(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.y>end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=-vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.0)+3.25;return texelSize.y*offset+texCoord.y;}float searchYDown(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;i++){if(!(texCoord.y<end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.5)+3.25;return-texelSize.y*offset+texCoord.y;}vec2 area(const in vec2 dist,const in float e1,const in float e2,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE)*round(4.0*vec2(e1,e2))+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.y=AREATEX_SUBTEX_SIZE*offset+texCoord.y;return texture2D(areaTexture,texCoord).rg;}void detectHorizontalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){
#if !defined(DISABLE_CORNER_DETECTION)
vec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,1)).r;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).r;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,-2)).r;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,-2)).r;weights*=clamp(factor,0.0,1.0);
#endif
}void detectVerticalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){
#if !defined(DISABLE_CORNER_DETECTION)
vec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(1,0)).g;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).g;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(-2,0)).g;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(-2,1)).g;weights*=clamp(factor,0.0,1.0);
#endif
}void main(){vec4 weights=vec4(0.0);vec4 subsampleIndices=vec4(0.0);vec2 e=texture2D(inputBuffer,vUv).rg;if(e.g>0.0){
#if !defined(DISABLE_DIAG_DETECTION)
weights.rg=calculateDiagWeights(vUv,e,subsampleIndices);if(weights.r==-weights.g){
#endif
vec2 d;vec3 coords;coords.x=searchXLeft(vOffset[0].xy,vOffset[2].x);coords.y=vOffset[1].y;d.x=coords.x;float e1=texture2D(inputBuffer,coords.xy).r;coords.z=searchXRight(vOffset[0].zw,vOffset[2].y);d.y=coords.z;d=round(resolution.xx*d+-vPixCoord.xx);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.zy,vec2(1,0)).r;weights.rg=area(sqrtD,e1,e2,subsampleIndices.y);coords.y=vUv.y;detectHorizontalCornerPattern(weights.rg,coords.xyzy,d);
#if !defined(DISABLE_DIAG_DETECTION)
}else{e.r=0.0;}
#endif
}if(e.r>0.0){vec2 d;vec3 coords;coords.y=searchYUp(vOffset[1].xy,vOffset[2].z);coords.x=vOffset[0].x;d.x=coords.y;float e1=texture2D(inputBuffer,coords.xy).g;coords.z=searchYDown(vOffset[1].zw,vOffset[2].w);d.y=coords.z;d=round(resolution.yy*d-vPixCoord.yy);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.xz,vec2(0,1)).g;weights.ba=area(sqrtD,e1,e2,subsampleIndices.x);coords.x=vUv.x;detectVerticalCornerPattern(weights.ba,coords.xyxz,d);}gl_FragColor=weights;}`,
        AM = class extends sQ {
          constructor(_ = new iT(), L = new iT()) {
            super({
              name: "SMAAWeightsMaterial",
              defines: {
                MAX_SEARCH_STEPS_INT: "16",
                MAX_SEARCH_STEPS_FLOAT: "16.0",
                MAX_SEARCH_STEPS_DIAG_INT: "8",
                MAX_SEARCH_STEPS_DIAG_FLOAT: "8.0",
                CORNER_ROUNDING: "25",
                CORNER_ROUNDING_NORM: "0.25",
                AREATEX_MAX_DISTANCE: "16.0",
                AREATEX_MAX_DISTANCE_DIAG: "20.0",
                AREATEX_PIXEL_SIZE: "(1.0 / vec2(160.0, 560.0))",
                AREATEX_SUBTEX_SIZE: "(1.0 / 7.0)",
                SEARCHTEX_SIZE: "vec2(66.0, 33.0)",
                SEARCHTEX_PACKED_SIZE: "vec2(64.0, 16.0)",
              },
              uniforms: {
                inputBuffer: new oz(null),
                searchTexture: new oz(null),
                areaTexture: new oz(null),
                resolution: new oz(L),
                texelSize: new oz(_),
              },
              blending: 0,
              depthWrite: !1,
              depthTest: !1,
              fragmentShader: AA,
              vertexShader:
                "uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;void main(){vUv=position.xy*0.5+0.5;vPixCoord=vUv*resolution;vOffset[0]=vUv.xyxy+texelSize.xyxy*vec4(-0.25,-0.125,1.25,-0.125);vOffset[1]=vUv.xyxy+texelSize.xyxy*vec4(-0.125,-0.25,-0.125,1.25);vOffset[2]=vec4(vOffset[0].xz,vOffset[1].yw)+vec4(-2.0,2.0,-2.0,2.0)*texelSize.xxyy*MAX_SEARCH_STEPS_FLOAT;gl_Position=vec4(position.xy,1.0,1.0);}",
            }),
              (this.toneMapped = !1);
          }
          set inputBuffer(_) {
            this.uniforms.inputBuffer.value = _;
          }
          setInputBuffer(_) {
            this.uniforms.inputBuffer.value = _;
          }
          get searchTexture() {
            return this.uniforms.searchTexture.value;
          }
          set searchTexture(_) {
            this.uniforms.searchTexture.value = _;
          }
          get areaTexture() {
            return this.uniforms.areaTexture.value;
          }
          set areaTexture(_) {
            this.uniforms.areaTexture.value = _;
          }
          setLookupTextures(_, L) {
            (this.searchTexture = _), (this.areaTexture = L);
          }
          get orthogonalSearchSteps() {
            return Number(this.defines.MAX_SEARCH_STEPS_INT);
          }
          set orthogonalSearchSteps(_) {
            let L = Math.min(Math.max(_, 0), 112);
            (this.defines.MAX_SEARCH_STEPS_INT = L.toFixed("0")),
              (this.defines.MAX_SEARCH_STEPS_FLOAT = L.toFixed("1")),
              (this.needsUpdate = !0);
          }
          setOrthogonalSearchSteps(_) {
            this.orthogonalSearchSteps = _;
          }
          get diagonalSearchSteps() {
            return Number(this.defines.MAX_SEARCH_STEPS_DIAG_INT);
          }
          set diagonalSearchSteps(_) {
            let L = Math.min(Math.max(_, 0), 20);
            (this.defines.MAX_SEARCH_STEPS_DIAG_INT = L.toFixed("0")),
              (this.defines.MAX_SEARCH_STEPS_DIAG_FLOAT = L.toFixed("1")),
              (this.needsUpdate = !0);
          }
          setDiagonalSearchSteps(_) {
            this.diagonalSearchSteps = _;
          }
          get diagonalDetection() {
            return void 0 === this.defines.DISABLE_DIAG_DETECTION;
          }
          set diagonalDetection(_) {
            _
              ? delete this.defines.DISABLE_DIAG_DETECTION
              : (this.defines.DISABLE_DIAG_DETECTION = "1"),
              (this.needsUpdate = !0);
          }
          isDiagonalDetectionEnabled() {
            return this.diagonalDetection;
          }
          setDiagonalDetectionEnabled(_) {
            this.diagonalDetection = _;
          }
          get cornerRounding() {
            return Number(this.defines.CORNER_ROUNDING);
          }
          set cornerRounding(_) {
            let L = Math.min(Math.max(_, 0), 100);
            (this.defines.CORNER_ROUNDING = L.toFixed("4")),
              (this.defines.CORNER_ROUNDING_NORM = (L / 100).toFixed("4")),
              (this.needsUpdate = !0);
          }
          setCornerRounding(_) {
            this.cornerRounding = _;
          }
          get cornerDetection() {
            return void 0 === this.defines.DISABLE_CORNER_DETECTION;
          }
          set cornerDetection(_) {
            _
              ? delete this.defines.DISABLE_CORNER_DETECTION
              : (this.defines.DISABLE_CORNER_DETECTION = "1"),
              (this.needsUpdate = !0);
          }
          isCornerRoundingEnabled() {
            return this.cornerDetection;
          }
          setCornerRoundingEnabled(_) {
            this.cornerDetection = _;
          }
          setSize(_, L) {
            let R = this.uniforms;
            R.texelSize.value.set(1 / _, 1 / L), R.resolution.value.set(_, L);
          }
        },
        AE = new sZ(),
        AT = null,
        AC = class {
          constructor(_ = "Pass", L = new n2(), R = AE) {
            (this.name = _),
              (this.renderer = null),
              (this.scene = L),
              (this.camera = R),
              (this.screen = null),
              (this.rtt = !0),
              (this.needsSwap = !0),
              (this.needsDepthTexture = !1),
              (this.enabled = !0);
          }
          get renderToScreen() {
            return !this.rtt;
          }
          set renderToScreen(_) {
            if (this.rtt === _) {
              let L = this.getFullscreenMaterial();
              null !== L && (L.needsUpdate = !0), (this.rtt = !_);
            }
          }
          setRenderer(_) {
            this.renderer = _;
          }
          isEnabled() {
            return this.enabled;
          }
          setEnabled(_) {
            this.enabled = _;
          }
          get fullscreenMaterial() {
            return null !== this.screen ? this.screen.material : null;
          }
          set fullscreenMaterial(_) {
            let L = this.screen;
            null !== L
              ? (L.material = _)
              : (((L = new sH(
                  (function () {
                    if (null === AT) {
                      let _ = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]),
                        L = new Float32Array([0, 0, 2, 0, 0, 2]);
                      void 0 !== (AT = new sP()).setAttribute
                        ? (AT.setAttribute("position", new sh(_, 3)),
                          AT.setAttribute("uv", new sh(L, 2)))
                        : (AT.addAttribute("position", new sh(_, 3)),
                          AT.addAttribute("uv", new sh(L, 2)));
                    }
                    return AT;
                  })(),
                  _,
                )).frustumCulled = !1),
                null === this.scene && (this.scene = new n2()),
                this.scene.add(L),
                (this.screen = L));
          }
          getFullscreenMaterial() {
            return this.fullscreenMaterial;
          }
          setFullscreenMaterial(_) {
            this.fullscreenMaterial = _;
          }
          getDepthTexture() {
            return null;
          }
          setDepthTexture(_, L = 3200) {}
          render(_, L, R, N, z) {
            throw Error("Render method not implemented!");
          }
          setSize(_, L) {}
          initialize(_, L, R) {}
          dispose() {
            for (let _ of Object.keys(this)) {
              let L = this[_];
              if (null !== L && "function" == typeof L.dispose) {
                if (L instanceof n2 || L === this.renderer) continue;
                this[_].dispose();
              }
            }
          }
        },
        AP = class extends AC {
          constructor(_, L = !0) {
            super("CopyPass"),
              (this.fullscreenMaterial = new Al()),
              (this.needsSwap = !1),
              (this.renderTarget = _),
              void 0 === _ &&
                ((this.renderTarget = new iH(1, 1, {
                  minFilter: 1006,
                  magFilter: 1006,
                  stencilBuffer: !1,
                  depthBuffer: !1,
                })),
                (this.renderTarget.texture.name = "CopyPass.Target")),
              (this.autoResize = L);
          }
          get resize() {
            return this.autoResize;
          }
          set resize(_) {
            this.autoResize = _;
          }
          get texture() {
            return this.renderTarget.texture;
          }
          getTexture() {
            return this.renderTarget.texture;
          }
          setAutoResizeEnabled(_) {
            this.autoResize = _;
          }
          render(_, L, R, N, z) {
            (this.fullscreenMaterial.inputBuffer = L.texture),
              _.setRenderTarget(this.renderToScreen ? null : this.renderTarget),
              _.render(this.scene, this.camera);
          }
          setSize(_, L) {
            this.autoResize && this.renderTarget.setSize(_, L);
          }
          initialize(_, L, R) {
            void 0 !== R &&
              ((this.renderTarget.texture.type = R),
              1009 !== R
                ? (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH =
                    "1")
                : 3001 === _.outputEncoding &&
                  (this.renderTarget.texture.encoding = 3001));
          }
        },
        AD = class extends AC {
          constructor() {
            super("ClearMaskPass", null, null), (this.needsSwap = !1);
          }
          render(_, L, R, N, z) {
            let F = _.state.buffers.stencil;
            F.setLocked(!1), F.setTest(!1);
          }
        },
        AO = new iz(),
        AL = class extends AC {
          constructor(_ = !0, L = !0, R = !1) {
            super("ClearPass", null, null),
              (this.needsSwap = !1),
              (this.color = _),
              (this.depth = L),
              (this.stencil = R),
              (this.overrideClearColor = null),
              (this.overrideClearAlpha = -1);
          }
          setClearFlags(_, L, R) {
            (this.color = _), (this.depth = L), (this.stencil = R);
          }
          getOverrideClearColor() {
            return this.overrideClearColor;
          }
          setOverrideClearColor(_) {
            this.overrideClearColor = _;
          }
          getOverrideClearAlpha() {
            return this.overrideClearAlpha;
          }
          setOverrideClearAlpha(_) {
            this.overrideClearAlpha = _;
          }
          render(_, L, R, N, z) {
            let F = this.overrideClearColor,
              U = this.overrideClearAlpha,
              k = _.getClearAlpha(),
              Y = null !== F,
              X = U >= 0;
            Y
              ? (AO.copy(_.getClearColor(AO)), _.setClearColor(F, X ? U : k))
              : X && _.setClearAlpha(U),
              _.setRenderTarget(this.renderToScreen ? null : L),
              _.clear(this.color, this.depth, this.stencil),
              Y ? _.setClearColor(AO, k) : X && _.setClearAlpha(k);
          }
        },
        AR = class extends ig {
          constructor(_, L = -1, R = -1, N = 1) {
            super(),
              (this.resizable = _),
              (this.base = new iT(1, 1)),
              (this.preferred = new iT(L, R)),
              (this.target = this.preferred),
              (this.s = N);
          }
          get width() {
            let { base: _, preferred: L, scale: R } = this;
            return -1 !== L.width
              ? L.width
              : -1 !== L.height
                ? Math.round(L.height * (_.width / Math.max(_.height, 1)))
                : Math.round(_.width * R);
          }
          set width(_) {
            this.preferredWidth = _;
          }
          get height() {
            let { base: _, preferred: L, scale: R } = this;
            return -1 !== L.height
              ? L.height
              : -1 !== L.width
                ? Math.round(
                    L.width / Math.max(_.width / Math.max(_.height, 1), 1),
                  )
                : Math.round(_.height * R);
          }
          set height(_) {
            this.preferredHeight = _;
          }
          getWidth() {
            return this.width;
          }
          getHeight() {
            return this.height;
          }
          get scale() {
            return this.s;
          }
          set scale(_) {
            this.s !== _ &&
              ((this.s = _),
              this.preferred.setScalar(-1),
              this.dispatchEvent({ type: "change" }),
              this.resizable.setSize(this.base.width, this.base.height));
          }
          getScale() {
            return this.scale;
          }
          setScale(_) {
            this.scale = _;
          }
          get baseWidth() {
            return this.base.width;
          }
          set baseWidth(_) {
            this.base.width !== _ &&
              ((this.base.width = _),
              this.dispatchEvent({ type: "change" }),
              this.resizable.setSize(this.base.width, this.base.height));
          }
          getBaseWidth() {
            return this.base.width;
          }
          setBaseWidth(_) {
            this.base.width !== _ &&
              ((this.base.width = _),
              this.dispatchEvent({ type: "change" }),
              this.resizable.setSize(this.base.width, this.base.height));
          }
          get baseHeight() {
            return this.base.height;
          }
          set baseHeight(_) {
            this.base.height !== _ &&
              ((this.base.height = _),
              this.dispatchEvent({ type: "change" }),
              this.resizable.setSize(this.base.width, this.base.height));
          }
          getBaseHeight() {
            return this.baseHeight;
          }
          setBaseHeight(_) {
            this.baseHeight = _;
          }
          setBaseSize(_, L) {
            (this.base.width !== _ || this.base.height !== L) &&
              (this.base.set(_, L),
              this.dispatchEvent({ type: "change" }),
              this.resizable.setSize(this.base.width, this.base.height));
          }
          get preferredWidth() {
            return this.preferred.width;
          }
          set preferredWidth(_) {
            this.preferred.width !== _ &&
              ((this.preferred.width = _),
              this.dispatchEvent({ type: "change" }),
              this.resizable.setSize(this.base.width, this.base.height));
          }
          getPreferredWidth() {
            return this.preferredWidth;
          }
          setPreferredWidth(_) {
            this.preferredWidth = _;
          }
          get preferredHeight() {
            return this.preferred.height;
          }
          set preferredHeight(_) {
            this.preferred.height !== _ &&
              ((this.preferred.height = _),
              this.dispatchEvent({ type: "change" }),
              this.resizable.setSize(this.base.width, this.base.height));
          }
          getPreferredHeight() {
            return this.preferredHeight;
          }
          setPreferredHeight(_) {
            this.preferredHeight = _;
          }
          setPreferredSize(_, L) {
            (this.preferred.width !== _ || this.preferred.height !== L) &&
              (this.preferred.set(_, L),
              this.dispatchEvent({ type: "change" }),
              this.resizable.setSize(this.base.width, this.base.height));
          }
          copy(_) {
            this.base.set(_.getBaseWidth(), _.getBaseHeight()),
              this.preferred.set(_.getPreferredWidth(), _.getPreferredHeight()),
              this.dispatchEvent({ type: "change" }),
              this.resizable.setSize(this.base.width, this.base.height);
          }
          static get AUTO_SIZE() {
            return -1;
          }
        },
        AI = !1,
        AB = class {
          constructor(_ = null) {
            (this.originalMaterials = new Map()),
              (this.material = null),
              (this.materials = null),
              (this.materialsBackSide = null),
              (this.materialsDoubleSide = null),
              (this.materialsFlatShaded = null),
              (this.materialsFlatShadedBackSide = null),
              (this.materialsFlatShadedDoubleSide = null),
              this.setMaterial(_),
              (this.meshCount = 0),
              (this.replaceMaterial = (_) => {
                if (_.isMesh) {
                  let L;
                  if (_.material.flatShading)
                    switch (_.material.side) {
                      case 2:
                        L = this.materialsFlatShadedDoubleSide;
                        break;
                      case 1:
                        L = this.materialsFlatShadedBackSide;
                        break;
                      default:
                        L = this.materialsFlatShaded;
                    }
                  else
                    switch (_.material.side) {
                      case 2:
                        L = this.materialsDoubleSide;
                        break;
                      case 1:
                        L = this.materialsBackSide;
                        break;
                      default:
                        L = this.materials;
                    }
                  this.originalMaterials.set(_, _.material),
                    _.isSkinnedMesh
                      ? (_.material = L[2])
                      : _.isInstancedMesh
                        ? (_.material = L[1])
                        : (_.material = L[0]),
                    ++this.meshCount;
                }
              });
          }
          setMaterial(_) {
            if ((this.disposeMaterials(), (this.material = _), null !== _)) {
              let L = (this.materials = [_.clone(), _.clone(), _.clone()]);
              for (let R of L)
                (R.uniforms = Object.assign({}, _.uniforms)), (R.side = 0);
              (L[2].skinning = !0),
                (this.materialsBackSide = L.map((L) => {
                  let R = L.clone();
                  return (
                    (R.uniforms = Object.assign({}, _.uniforms)),
                    (R.side = 1),
                    R
                  );
                })),
                (this.materialsDoubleSide = L.map((L) => {
                  let R = L.clone();
                  return (
                    (R.uniforms = Object.assign({}, _.uniforms)),
                    (R.side = 2),
                    R
                  );
                })),
                (this.materialsFlatShaded = L.map((L) => {
                  let R = L.clone();
                  return (
                    (R.uniforms = Object.assign({}, _.uniforms)),
                    (R.flatShading = !0),
                    R
                  );
                })),
                (this.materialsFlatShadedBackSide = L.map((L) => {
                  let R = L.clone();
                  return (
                    (R.uniforms = Object.assign({}, _.uniforms)),
                    (R.flatShading = !0),
                    (R.side = 1),
                    R
                  );
                })),
                (this.materialsFlatShadedDoubleSide = L.map((L) => {
                  let R = L.clone();
                  return (
                    (R.uniforms = Object.assign({}, _.uniforms)),
                    (R.flatShading = !0),
                    (R.side = 2),
                    R
                  );
                }));
            }
          }
          render(_, L, R) {
            let N = _.shadowMap.enabled;
            if (((_.shadowMap.enabled = !1), AI)) {
              let N = this.originalMaterials;
              for (let z of ((this.meshCount = 0),
              L.traverse(this.replaceMaterial),
              _.render(L, R),
              N))
                z[0].material = z[1];
              this.meshCount !== N.size && N.clear();
            } else {
              let N = L.overrideMaterial;
              (L.overrideMaterial = this.material),
                _.render(L, R),
                (L.overrideMaterial = N);
            }
            _.shadowMap.enabled = N;
          }
          disposeMaterials() {
            if (null !== this.material)
              for (let _ of this.materials
                .concat(this.materialsBackSide)
                .concat(this.materialsDoubleSide)
                .concat(this.materialsFlatShaded)
                .concat(this.materialsFlatShadedBackSide)
                .concat(this.materialsFlatShadedDoubleSide))
                _.dispose();
          }
          dispose() {
            this.originalMaterials.clear(), this.disposeMaterials();
          }
          static get workaroundEnabled() {
            return AI;
          }
          static set workaroundEnabled(_) {
            AI = _;
          }
        },
        AN = class extends AC {
          constructor(_, L, R = null) {
            super("RenderPass", _, L),
              (this.needsSwap = !1),
              (this.clearPass = new AL()),
              (this.overrideMaterialManager = null === R ? null : new AB(R)),
              (this.ignoreBackground = !1),
              (this.skipShadowMapUpdate = !1),
              (this.selection = null);
          }
          get renderToScreen() {
            return super.renderToScreen;
          }
          set renderToScreen(_) {
            (super.renderToScreen = _), (this.clearPass.renderToScreen = _);
          }
          get overrideMaterial() {
            let _ = this.overrideMaterialManager;
            return null !== _ ? _.material : null;
          }
          set overrideMaterial(_) {
            let L = this.overrideMaterialManager;
            null !== _
              ? null !== L
                ? L.setMaterial(_)
                : (this.overrideMaterialManager = new AB(_))
              : null !== L &&
                (L.dispose(), (this.overrideMaterialManager = null));
          }
          getOverrideMaterial() {
            return this.overrideMaterial;
          }
          setOverrideMaterial(_) {
            this.overrideMaterial = _;
          }
          get clear() {
            return this.clearPass.enabled;
          }
          set clear(_) {
            this.clearPass.enabled = _;
          }
          getSelection() {
            return this.selection;
          }
          setSelection(_) {
            this.selection = _;
          }
          isBackgroundDisabled() {
            return this.ignoreBackground;
          }
          setBackgroundDisabled(_) {
            this.ignoreBackground = _;
          }
          isShadowMapDisabled() {
            return this.skipShadowMapUpdate;
          }
          setShadowMapDisabled(_) {
            this.skipShadowMapUpdate = _;
          }
          getClearPass() {
            return this.clearPass;
          }
          render(_, L, R, N, z) {
            let F = this.scene,
              U = this.camera,
              k = this.selection,
              Y = U.layers.mask,
              X = F.background,
              Q = _.shadowMap.autoUpdate,
              K = this.renderToScreen ? null : L;
            null !== k && U.layers.set(k.getLayer()),
              this.skipShadowMapUpdate && (_.shadowMap.autoUpdate = !1),
              (this.ignoreBackground ||
                null !== this.clearPass.overrideClearColor) &&
                (F.background = null),
              this.clearPass.enabled && this.clearPass.render(_, L),
              _.setRenderTarget(K),
              null !== this.overrideMaterialManager
                ? this.overrideMaterialManager.render(_, F, U)
                : _.render(F, U),
              (U.layers.mask = Y),
              (F.background = X),
              (_.shadowMap.autoUpdate = Q);
          }
        },
        Az = class extends AC {
          constructor(
            _,
            L,
            {
              resolutionScale: R = 1,
              width: N = AR.AUTO_SIZE,
              height: z = AR.AUTO_SIZE,
              renderTarget: F,
            } = {},
          ) {
            super("DepthPass"),
              (this.needsSwap = !1),
              (this.renderPass = new AN(_, L, new nH({ depthPacking: 3201 })));
            let U = this.renderPass;
            (U.skipShadowMapUpdate = !0), (U.ignoreBackground = !0);
            let k = U.getClearPass();
            (k.overrideClearColor = new iz(16777215)),
              (k.overrideClearAlpha = 1),
              (this.renderTarget = F),
              void 0 === this.renderTarget &&
                ((this.renderTarget = new iH(1, 1, {
                  minFilter: 1003,
                  magFilter: 1003,
                  stencilBuffer: !1,
                })),
                (this.renderTarget.texture.name = "DepthPass.Target"));
            let Y = (this.resolution = new AR(this, N, z, R));
            Y.addEventListener("change", (_) =>
              this.setSize(Y.baseWidth, Y.baseHeight),
            );
          }
          get texture() {
            return this.renderTarget.texture;
          }
          getTexture() {
            return this.renderTarget.texture;
          }
          getResolution() {
            return this.resolution;
          }
          getResolutionScale() {
            return this.resolution.scale;
          }
          setResolutionScale(_) {
            this.resolution.scale = _;
          }
          render(_, L, R, N, z) {
            let F = this.renderToScreen ? null : this.renderTarget;
            this.renderPass.render(_, F);
          }
          setSize(_, L) {
            let R = this.resolution;
            R.setBaseSize(_, L), this.renderTarget.setSize(R.width, R.height);
          }
        };
      new Float32Array([
        255 / 256 / 16777216,
        255 / 256 / 65536,
        255 / 256 / 256,
        255 / 256,
      ]);
      var AF = {
          SKIP: 0,
          ADD: 1,
          ALPHA: 2,
          AVERAGE: 3,
          COLOR_BURN: 4,
          COLOR_DODGE: 5,
          DARKEN: 6,
          DIFFERENCE: 7,
          EXCLUSION: 8,
          LIGHTEN: 9,
          MULTIPLY: 10,
          DIVIDE: 11,
          NEGATION: 12,
          NORMAL: 13,
          OVERLAY: 14,
          REFLECT: 15,
          SCREEN: 16,
          SOFT_LIGHT: 17,
          SUBTRACT: 18,
        },
        AU = new Map([
          [AF.SKIP, null],
          [
            AF.ADD,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return min(x+y,1.0)*opacity+x*(1.0-opacity);}",
          ],
          [
            AF.ALPHA,
            "vec3 blend(const in vec3 x,const in vec3 y,const in float opacity){return y*opacity+x*(1.0-opacity);}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){float a=min(y.a,opacity);return vec4(blend(x.rgb,y.rgb,a),max(x.a,a));}",
          ],
          [
            AF.AVERAGE,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return(x+y)*0.5*opacity+x*(1.0-opacity);}",
          ],
          [
            AF.COLOR_BURN,
            "float blend(const in float x,const in float y){return(y==0.0)?y:max(1.0-(1.0-x)/y,0.0);}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}",
          ],
          [
            AF.COLOR_DODGE,
            "float blend(const in float x,const in float y){return(y==1.0)?y:min(x/(1.0-y),1.0);}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}",
          ],
          [
            AF.DARKEN,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return min(x,y)*opacity+x*(1.0-opacity);}",
          ],
          [
            AF.DIFFERENCE,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return abs(x-y)*opacity+x*(1.0-opacity);}",
          ],
          [
            AF.EXCLUSION,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return(x+y-2.0*x*y)*opacity+x*(1.0-opacity);}",
          ],
          [
            AF.LIGHTEN,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return max(x,y)*opacity+x*(1.0-opacity);}",
          ],
          [
            AF.MULTIPLY,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return x*y*opacity+x*(1.0-opacity);}",
          ],
          [
            AF.DIVIDE,
            "float blend(const in float x,const in float y){return(y>0.0)?min(x/y,1.0):1.0;}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}",
          ],
          [
            AF.NEGATION,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return(1.0-abs(1.0-x-y))*opacity+x*(1.0-opacity);}",
          ],
          [
            AF.NORMAL,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return y*opacity+x*(1.0-opacity);}",
          ],
          [
            AF.OVERLAY,
            "float blend(const in float x,const in float y){return(x<0.5)?(2.0*x*y):(1.0-2.0*(1.0-x)*(1.0-y));}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}",
          ],
          [
            AF.REFLECT,
            "float blend(const in float x,const in float y){return(y==1.0)?y:min(x*x/(1.0-y),1.0);}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}",
          ],
          [
            AF.SCREEN,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return(1.0-(1.0-x)*(1.0-y))*opacity+x*(1.0-opacity);}",
          ],
          [
            AF.SOFT_LIGHT,
            "float blend(const in float x,const in float y){return(y<0.5)?(2.0*x*y+x*x*(1.0-2.0*y)):(sqrt(x)*(2.0*y-1.0)+2.0*x*(1.0-y));}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}",
          ],
          [
            AF.SUBTRACT,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return max(x+y-1.0,0.0)*opacity+x*(1.0-opacity);}",
          ],
        ]),
        Ak = class extends ig {
          constructor(_, L = 1) {
            super(), (this.f = _), (this.opacity = new oz(L));
          }
          getOpacity() {
            return this.opacity.value;
          }
          setOpacity(_) {
            this.opacity.value = _;
          }
          get blendFunction() {
            return this.f;
          }
          set blendFunction(_) {
            (this.f = _), this.dispatchEvent({ type: "change" });
          }
          getBlendFunction() {
            return this.blendFunction;
          }
          setBlendFunction(_) {
            this.blendFunction = _;
          }
          getShaderCode() {
            return AU.get(this.blendFunction);
          }
        },
        Aj = { NONE: 0, DEPTH: 1, CONVOLUTION: 2 },
        AG = class extends ig {
          constructor(
            _,
            L,
            {
              attributes: R = Aj.NONE,
              blendFunction: N = AF.SCREEN,
              defines: z = new Map(),
              uniforms: F = new Map(),
              extensions: U = null,
              vertexShader: k = null,
            } = {},
          ) {
            super(),
              (this.name = _),
              (this.renderer = null),
              (this.attributes = R),
              (this.fragmentShader = L),
              (this.vertexShader = k),
              (this.defines = z),
              (this.uniforms = F),
              (this.extensions = U),
              (this.blendMode = new Ak(N)),
              this.blendMode.addEventListener("change", (_) =>
                this.setChanged(),
              );
          }
          getName() {
            return this.name;
          }
          setRenderer(_) {
            this.renderer = _;
          }
          getDefines() {
            return this.defines;
          }
          getUniforms() {
            return this.uniforms;
          }
          getExtensions() {
            return this.extensions;
          }
          getBlendMode() {
            return this.blendMode;
          }
          getAttributes() {
            return this.attributes;
          }
          setAttributes(_) {
            (this.attributes = _), this.setChanged();
          }
          getFragmentShader() {
            return this.fragmentShader;
          }
          setFragmentShader(_) {
            (this.fragmentShader = _), this.setChanged();
          }
          getVertexShader() {
            return this.vertexShader;
          }
          setVertexShader(_) {
            (this.vertexShader = _), this.setChanged();
          }
          setChanged() {
            this.dispatchEvent({ type: "change" });
          }
          setDepthTexture(_, L = 3200) {}
          update(_, L, R) {}
          setSize(_, L) {}
          initialize(_, L, R) {}
          dispose() {
            for (let _ of Object.keys(this)) {
              let L = this[_];
              if (null !== L && "function" == typeof L.dispose) {
                if (L instanceof n2 || L === this.renderer) continue;
                this[_].dispose();
              }
            }
          }
        };
      function G2(_, L, R) {
        for (let N of L) {
          let L = "$1" + _ + N.charAt(0).toUpperCase() + N.slice(1),
            z = RegExp("([^\\.])(\\b" + N + "\\b)", "g");
          for (let _ of R.entries())
            null !== _[1] && R.set(_[0], _[1].replace(z, L));
        }
      }
      var AV = class extends AC {
          constructor(_, ...L) {
            super("EffectPass"),
              (this.fullscreenMaterial = new Av(null, null, null, _)),
              (this.effects = L.sort((_, L) => L.attributes - _.attributes)),
              (this.skipRendering = !1),
              (this.uniformCount = 0),
              (this.varyingCount = 0),
              (this.minTime = 1),
              (this.maxTime = Number.POSITIVE_INFINITY);
          }
          get encodeOutput() {
            return this.fullscreenMaterial.encodeOutput;
          }
          set encodeOutput(_) {
            this.fullscreenMaterial.encodeOutput = _;
          }
          get dithering() {
            return this.fullscreenMaterial.dithering;
          }
          set dithering(_) {
            let L = this.fullscreenMaterial;
            (L.dithering = _), (L.needsUpdate = !0);
          }
          verifyResources() {
            let _ = this.renderer.capabilities,
              L = Math.min(_.maxFragmentUniforms, _.maxVertexUniforms);
            this.uniformCount > L &&
              console.warn(
                "The current rendering context doesn't support more than " +
                  L +
                  " uniforms, but " +
                  this.uniformCount +
                  " were defined",
              ),
              (L = _.maxVaryings),
              this.varyingCount > L &&
                console.warn(
                  "The current rendering context doesn't support more than " +
                    L +
                    " varyings, but " +
                    this.varyingCount +
                    " were defined",
                );
          }
          updateMaterial() {
            let _ = Av.Section,
              L = new Map([
                [_.FRAGMENT_HEAD, ""],
                [_.FRAGMENT_MAIN_UV, ""],
                [_.FRAGMENT_MAIN_IMAGE, ""],
                [_.VERTEX_HEAD, ""],
                [_.VERTEX_MAIN_SUPPORT, ""],
              ]),
              R = new Map(),
              N = new Map(),
              z = new Map(),
              F = new Set(),
              U = 0,
              k = 0,
              Y = 0,
              X = !1,
              Q = !1;
            for (let _ of this.effects)
              if (_.blendMode.blendFunction === AF.SKIP)
                Y |= _.getAttributes() & Aj.DEPTH;
              else if ((Y & _.getAttributes() & Aj.CONVOLUTION) != 0)
                console.error("Convolution effects cannot be merged", _);
              else {
                Y |= _.getAttributes();
                let K = (function (_, L, R, N, z, F, U) {
                  let k = new Map([
                      ["fragment", L.getFragmentShader()],
                      ["vertex", L.getVertexShader()],
                    ]),
                    Y =
                      void 0 !== k.get("fragment") &&
                      /mainImage/.test(k.get("fragment")),
                    X =
                      void 0 !== k.get("fragment") &&
                      /mainUv/.test(k.get("fragment")),
                    Q = [],
                    K = [],
                    J = !1,
                    $ = !1;
                  if (void 0 === k.get("fragment"))
                    console.error("Missing fragment shader", L);
                  else if (X && (U & Aj.CONVOLUTION) != 0)
                    console.error(
                      "Effects that transform UV coordinates are incompatible with convolution effects",
                      L,
                    );
                  else if (Y || X) {
                    let ee = /(?:\w+\s+(\w+)\([\w\s,]*\)\s*{[^}]+})/g,
                      er = Av.Section;
                    if (X) {
                      let L = `	${_}MainUv(UV);
`;
                      R.set(
                        er.FRAGMENT_MAIN_UV,
                        R.get(er.FRAGMENT_MAIN_UV) + L,
                      ),
                        (J = !0);
                    }
                    if (
                      null !== k.get("vertex") &&
                      /mainSupport/.test(k.get("vertex"))
                    ) {
                      let L = `	${_}MainSupport(`;
                      (L += /mainSupport *\([\w\s]*?uv\s*?\)/.test(
                        k.get("vertex"),
                      )
                        ? `vUv);
`
                        : `);
`),
                        R.set(
                          er.VERTEX_MAIN_SUPPORT,
                          R.get(er.VERTEX_MAIN_SUPPORT) + L,
                        ),
                        (Q = Q.concat(
                          [
                            ...k
                              .get("vertex")
                              .matchAll(/(?:varying\s+\w+\s+(\w*))/g),
                          ].map((_) => _[1]),
                        )),
                        (K = K.concat(Q).concat(
                          [...k.get("vertex").matchAll(ee)].map((_) => _[1]),
                        ));
                    }
                    (K = (K = (K = K.concat(
                      [...k.get("fragment").matchAll(ee)].map((_) => _[1]),
                    )).concat(
                      [...L.defines.keys()].map((_) =>
                        _.replace(/\([\w\s,]*\)/g, ""),
                      ),
                    )).concat([...L.uniforms.keys()])),
                      L.uniforms.forEach((L, R) =>
                        F.set(_ + R.charAt(0).toUpperCase() + R.slice(1), L),
                      ),
                      L.defines.forEach((L, R) =>
                        z.set(_ + R.charAt(0).toUpperCase() + R.slice(1), L),
                      ),
                      G2(_, K, z),
                      G2(_, K, k);
                    let en = L.blendMode;
                    if ((N.set(en.blendFunction, en), Y)) {
                      let L = `${_}MainImage(color0, UV, `;
                      (U & Aj.DEPTH) != 0 &&
                        /MainImage *\([\w\s,]*?depth[\w\s,]*?\)/.test(
                          k.get("fragment"),
                        ) &&
                        ((L += "depth, "), ($ = !0)),
                        (L += `color1);
	`);
                      let N = _ + "BlendOpacity";
                      F.set(N, en.opacity),
                        (L += `color0 = blend${en.blendFunction}(color0, color1, ${N});

	`),
                        R.set(
                          er.FRAGMENT_MAIN_IMAGE,
                          R.get(er.FRAGMENT_MAIN_IMAGE) + L,
                        ),
                        (L = `uniform float ${N};

`),
                        R.set(er.FRAGMENT_HEAD, R.get(er.FRAGMENT_HEAD) + L);
                    }
                    R.set(
                      er.FRAGMENT_HEAD,
                      R.get(er.FRAGMENT_HEAD) +
                        k.get("fragment") +
                        `
`,
                    ),
                      null !== k.get("vertex") &&
                        R.set(
                          er.VERTEX_HEAD,
                          R.get(er.VERTEX_HEAD) +
                            k.get("vertex") +
                            `
`,
                        );
                  } else
                    console.error(
                      "The fragment shader contains neither a mainImage nor a mainUv function",
                      L,
                    );
                  return { varyings: Q, transformedUv: J, readDepth: $ };
                })("e" + U++, _, L, R, N, z, Y);
                if (
                  ((k += K.varyings.length),
                  (X = X || K.transformedUv),
                  (Q = Q || K.readDepth),
                  null !== _.extensions)
                )
                  for (let L of _.extensions) F.add(L);
              }
            let K = /\bblend\b/g;
            for (let N of R.values()) {
              let R = N.getShaderCode().replace(K, `blend${N.blendFunction}`);
              L.set(
                _.FRAGMENT_HEAD,
                L.get(_.FRAGMENT_HEAD) +
                  R +
                  `
`,
              );
            }
            if ((Y & Aj.DEPTH) != 0) {
              if (Q) {
                let R = `float depth = readDepth(UV);

	`;
                L.set(_.FRAGMENT_MAIN_IMAGE, R + L.get(_.FRAGMENT_MAIN_IMAGE));
              }
              this.needsDepthTexture = null === this.getDepthTexture();
            } else this.needsDepthTexture = !1;
            if (X) {
              let R = `vec2 transformedUv = vUv;
`;
              L.set(_.FRAGMENT_MAIN_UV, R + L.get(_.FRAGMENT_MAIN_UV)),
                N.set("UV", "transformedUv");
            } else N.set("UV", "vUv");
            L.forEach((_, L, R) =>
              R.set(
                L,
                _.trim().replace(
                  /^#/,
                  `
#`,
                ),
              ),
            ),
              (this.uniformCount = z.size),
              (this.varyingCount = k),
              (this.skipRendering = 0 === U),
              (this.needsSwap = !this.skipRendering),
              this.fullscreenMaterial
                .setShaderParts(L)
                .setExtensions(F)
                .setUniforms(z)
                .setDefines(N);
          }
          recompile() {
            this.updateMaterial(), this.verifyResources();
          }
          getDepthTexture() {
            return this.fullscreenMaterial.depthBuffer;
          }
          setDepthTexture(_, L = 3200) {
            for (let R of ((this.fullscreenMaterial.depthBuffer = _),
            (this.fullscreenMaterial.depthPacking = L),
            this.effects))
              R.setDepthTexture(_, L);
          }
          render(_, L, R, N, z) {
            for (let R of this.effects) R.update(_, L, N);
            if (!this.skipRendering || this.renderToScreen) {
              let z = this.fullscreenMaterial;
              (z.inputBuffer = L.texture),
                (z.time += N),
                _.setRenderTarget(this.renderToScreen ? null : R),
                _.render(this.scene, this.camera);
            }
          }
          setSize(_, L) {
            for (let R of (this.fullscreenMaterial.setSize(_, L), this.effects))
              R.setSize(_, L);
          }
          initialize(_, L, R) {
            for (let N of ((this.renderer = _), this.effects))
              N.initialize(_, L, R),
                N.addEventListener("change", (_) => this.handleEvent(_));
            this.updateMaterial(),
              this.verifyResources(),
              void 0 !== R &&
                1009 !== R &&
                (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH =
                  "1");
          }
          dispose() {
            for (let _ of (super.dispose(), this.effects)) _.dispose();
          }
          handleEvent(_) {
            "change" === _.type && this.recompile();
          }
        },
        AH = [
          new Float32Array([0, 0]),
          new Float32Array([0, 1, 1]),
          new Float32Array([0, 1, 1, 2]),
          new Float32Array([0, 1, 2, 2, 3]),
          new Float32Array([0, 1, 2, 3, 4, 4, 5]),
          new Float32Array([0, 1, 2, 3, 4, 5, 7, 8, 9, 10]),
        ],
        AW = class extends AC {
          constructor({
            resolutionScale: _ = 0.5,
            width: L = AR.AUTO_SIZE,
            height: R = AR.AUTO_SIZE,
            kernelSize: N = AK.LARGE,
          } = {}) {
            super("KawaseBlurPass"),
              (this.renderTargetA = new iH(1, 1, {
                minFilter: 1006,
                magFilter: 1006,
                stencilBuffer: !1,
                depthBuffer: !1,
              })),
              (this.renderTargetA.texture.name = "Blur.Target.A"),
              (this.renderTargetB = this.renderTargetA.clone()),
              (this.renderTargetB.texture.name = "Blur.Target.B");
            let z = (this.resolution = new AR(this, L, R, _));
            z.addEventListener("change", (_) =>
              this.setSize(z.baseWidth, z.baseHeight),
            ),
              (this.blurMaterial = new Aa()),
              (this.ditheredBlurMaterial = new Aa()),
              (this.ditheredBlurMaterial.uniforms.scale =
                this.blurMaterial.uniforms.scale),
              (this.ditheredBlurMaterial.dithering = !0),
              (this.dithering = !1),
              (this.kernelSize = N);
          }
          getResolution() {
            return this.resolution;
          }
          get width() {
            return this.resolution.width;
          }
          set width(_) {
            this.resolution.preferredWidth = _;
          }
          get height() {
            return this.resolution.height;
          }
          set height(_) {
            this.resolution.preferredHeight = _;
          }
          get scale() {
            return this.blurMaterial.scale;
          }
          set scale(_) {
            this.blurMaterial.scale = _;
          }
          getScale() {
            return this.blurMaterial.scale;
          }
          setScale(_) {
            this.blurMaterial.scale = _;
          }
          getKernelSize() {
            return this.kernelSize;
          }
          setKernelSize(_) {
            this.kernelSize = _;
          }
          getResolutionScale() {
            return this.resolution.scale;
          }
          setResolutionScale(_) {
            this.resolution.scale = _;
          }
          render(_, L, R, N, z) {
            let F = this.scene,
              U = this.camera,
              k = this.renderTargetA,
              Y = this.renderTargetB,
              X = AH[this.kernelSize],
              Q = this.blurMaterial,
              K = L,
              J,
              $;
            for (
              this.fullscreenMaterial = Q, J = 0, $ = X.length - 1;
              J < $;
              ++J
            ) {
              let L = (1 & J) == 0 ? k : Y;
              (Q.kernel = X[J]),
                (Q.inputBuffer = K.texture),
                _.setRenderTarget(L),
                _.render(F, U),
                (K = L);
            }
            this.dithering &&
              ((Q = this.ditheredBlurMaterial), (this.fullscreenMaterial = Q)),
              (Q.kernel = X[J]),
              (Q.inputBuffer = K.texture),
              _.setRenderTarget(this.renderToScreen ? null : R),
              _.render(F, U);
          }
          setSize(_, L) {
            let R = this.resolution;
            R.setBaseSize(_, L);
            let N = R.width,
              z = R.height;
            this.renderTargetA.setSize(N, z),
              this.renderTargetB.setSize(N, z),
              this.blurMaterial.setSize(N, z),
              this.ditheredBlurMaterial.setSize(N, z);
          }
          initialize(_, L, R) {
            void 0 !== R &&
              ((this.renderTargetA.texture.type = R),
              (this.renderTargetB.texture.type = R),
              1009 !== R
                ? ((this.blurMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1"),
                  (this.ditheredBlurMaterial.defines.FRAMEBUFFER_PRECISION_HIGH =
                    "1"))
                : 3001 === _.outputEncoding &&
                  ((this.renderTargetA.texture.encoding = 3001),
                  (this.renderTargetB.texture.encoding = 3001)));
          }
          static get AUTO_SIZE() {
            return AR.AUTO_SIZE;
          }
        },
        AY = class extends AC {
          constructor({
            width: _ = AR.AUTO_SIZE,
            height: L = AR.AUTO_SIZE,
            renderTarget: R,
            luminanceRange: N,
            colorOutput: z,
          } = {}) {
            super("LuminancePass"),
              (this.fullscreenMaterial = new Ab(z, N)),
              (this.needsSwap = !1),
              (this.renderTarget = R),
              void 0 === this.renderTarget &&
                ((this.renderTarget = new iH(1, 1, {
                  minFilter: 1006,
                  magFilter: 1006,
                  stencilBuffer: !1,
                  depthBuffer: !1,
                })),
                (this.renderTarget.texture.name = "LuminancePass.Target"),
                (this.renderTarget.texture.generateMipmaps = !1));
            let F = (this.resolution = new AR(this, _, L));
            F.addEventListener("change", (_) =>
              this.setSize(F.baseWidth, F.baseHeight),
            );
          }
          get texture() {
            return this.renderTarget.texture;
          }
          getTexture() {
            return this.renderTarget.texture;
          }
          getResolution() {
            return this.resolution;
          }
          render(_, L, R, N, z) {
            (this.fullscreenMaterial.inputBuffer = L.texture),
              _.setRenderTarget(this.renderToScreen ? null : this.renderTarget),
              _.render(this.scene, this.camera);
          }
          setSize(_, L) {
            let R = this.resolution;
            R.setBaseSize(_, L), this.renderTarget.setSize(R.width, R.height);
          }
          initialize(_, L, R) {
            void 0 !== R &&
              1009 !== R &&
              (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH =
                "1");
          }
        },
        AX = class extends AC {
          constructor(_, L) {
            super("MaskPass", _, L),
              (this.needsSwap = !1),
              (this.clearPass = new AL(!1, !1, !0)),
              (this.inverse = !1);
          }
          get inverted() {
            return this.inverse;
          }
          set inverted(_) {
            this.inverse = _;
          }
          get clear() {
            return this.clearPass.enabled;
          }
          set clear(_) {
            this.clearPass.enabled = _;
          }
          getClearPass() {
            return this.clearPass;
          }
          isInverted() {
            return this.inverted;
          }
          setInverted(_) {
            this.inverted = _;
          }
          render(_, L, R, N, z) {
            let F = _.getContext(),
              U = _.state.buffers,
              k = this.scene,
              Y = this.camera,
              X = this.clearPass,
              Q = this.inverted ? 0 : 1,
              K = 1 - Q;
            U.color.setMask(!1),
              U.depth.setMask(!1),
              U.color.setLocked(!0),
              U.depth.setLocked(!0),
              U.stencil.setTest(!0),
              U.stencil.setOp(F.REPLACE, F.REPLACE, F.REPLACE),
              U.stencil.setFunc(F.ALWAYS, Q, 4294967295),
              U.stencil.setClear(K),
              U.stencil.setLocked(!0),
              this.clearPass.enabled &&
                (this.renderToScreen
                  ? X.render(_, null)
                  : (X.render(_, L), X.render(_, R))),
              this.renderToScreen
                ? _.setRenderTarget(null)
                : (_.setRenderTarget(L), _.render(k, Y), _.setRenderTarget(R)),
              _.render(k, Y),
              U.color.setLocked(!1),
              U.depth.setLocked(!1),
              U.stencil.setLocked(!1),
              U.stencil.setFunc(F.EQUAL, 1, 4294967295),
              U.stencil.setOp(F.KEEP, F.KEEP, F.KEEP),
              U.stencil.setLocked(!0);
          }
        },
        Aq = class extends AC {
          constructor(_, L = "inputBuffer") {
            super("ShaderPass"),
              (this.fullscreenMaterial = _),
              (this.inputBufferUniform = null),
              this.setInput(L);
          }
          setInput(_) {
            if (
              ((this.inputBufferUniform = null),
              null !== this.fullscreenMaterial)
            ) {
              let L = this.fullscreenMaterial.uniforms;
              void 0 !== L &&
                void 0 !== L[_] &&
                (this.inputBufferUniform = L[_]);
            }
          }
          render(_, L, R, N, z) {
            null !== this.inputBufferUniform &&
              null !== L &&
              (this.inputBufferUniform.value = L.texture),
              _.setRenderTarget(this.renderToScreen ? null : R),
              _.render(this.scene, this.camera);
          }
          initialize(_, L, R) {
            void 0 !== R &&
              1009 !== R &&
              (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH =
                "1");
          }
        },
        AQ = class {
          constructor() {
            (this.previousTime = 0),
              (this.currentTime = 0),
              (this.delta = 0),
              (this.fixedDelta = 1e3 / 60),
              (this.elapsed = 0),
              (this.timescale = 1),
              (this.fixedDeltaEnabled = !1),
              (this.autoReset = !1);
          }
          setFixedDeltaEnabled(_) {
            return (this.fixedDeltaEnabled = _), this;
          }
          isAutoResetEnabled(_) {
            return this.autoReset;
          }
          setAutoResetEnabled(_) {
            return (
              "u" > typeof document &&
                void 0 !== document.hidden &&
                (_
                  ? document.addEventListener("visibilitychange", this)
                  : document.removeEventListener("visibilitychange", this),
                (this.autoReset = _)),
              this
            );
          }
          getDelta() {
            return 0.001 * this.delta;
          }
          getFixedDelta() {
            return 0.001 * this.fixedDelta;
          }
          setFixedDelta(_) {
            return (this.fixedDelta = 1e3 * _), this;
          }
          getElapsed() {
            return 0.001 * this.elapsed;
          }
          getTimescale() {
            return this.timescale;
          }
          setTimescale(_) {
            return (this.timescale = _), this;
          }
          update(_) {
            return (
              this.fixedDeltaEnabled
                ? (this.delta = this.fixedDelta)
                : ((this.previousTime = this.currentTime),
                  (this.currentTime = void 0 !== _ ? _ : performance.now()),
                  (this.delta = this.currentTime - this.previousTime)),
              (this.delta *= this.timescale),
              (this.elapsed += this.delta),
              this
            );
          }
          reset() {
            return (
              (this.delta = 0),
              (this.elapsed = 0),
              (this.currentTime = performance.now()),
              this
            );
          }
          handleEvent(_) {
            document.hidden || (this.currentTime = performance.now());
          }
          dispose() {
            this.setAutoResetEnabled(!1);
          }
        },
        AZ = class {
          constructor(
            _ = null,
            {
              depthBuffer: L = !0,
              stencilBuffer: R = !1,
              multisampling: N = 0,
              frameBufferType: z,
            } = {},
          ) {
            (this.renderer = null),
              (this.inputBuffer = this.createBuffer(L, R, z, N)),
              (this.outputBuffer = this.inputBuffer.clone()),
              (this.copyPass = new AP()),
              (this.depthTexture = null),
              (this.passes = []),
              (this.timer = new AQ()),
              (this.autoRenderToScreen = !0),
              this.setRenderer(_);
          }
          get multisampling() {
            return this.inputBuffer.samples || 0;
          }
          set multisampling(_) {
            let L = this.inputBuffer,
              R = this.multisampling;
            R > 0 && _ > 0
              ? ((this.inputBuffer.samples = _),
                (this.outputBuffer.samples = _),
                this.inputBuffer.dispose(),
                this.outputBuffer.dispose())
              : R !== _ &&
                (this.inputBuffer.dispose(),
                this.outputBuffer.dispose(),
                (this.inputBuffer = this.createBuffer(
                  L.depthBuffer,
                  L.stencilBuffer,
                  L.texture.type,
                  _,
                )),
                (this.inputBuffer.depthTexture = this.depthTexture),
                (this.outputBuffer = this.inputBuffer.clone()));
          }
          getTimer() {
            return this.timer;
          }
          getRenderer() {
            return this.renderer;
          }
          setRenderer(_) {
            if (((this.renderer = _), null !== _)) {
              let L = _.getSize(new iT()),
                R = _.getContext().getContextAttributes().alpha,
                N = this.inputBuffer.texture.type;
              for (let z of (1009 === N &&
                3001 === _.outputEncoding &&
                ((this.inputBuffer.texture.encoding = 3001),
                (this.outputBuffer.texture.encoding = 3001),
                this.inputBuffer.dispose(),
                this.outputBuffer.dispose()),
              (_.autoClear = !1),
              this.setSize(L.width, L.height),
              this.passes))
                z.initialize(_, R, N);
            }
          }
          replaceRenderer(_, L = !0) {
            let R = this.renderer,
              N = R.domElement.parentNode;
            return (
              this.setRenderer(_),
              L &&
                null !== N &&
                (N.removeChild(R.domElement), N.appendChild(_.domElement)),
              R
            );
          }
          createDepthTexture() {
            let _ = (this.depthTexture = new nJ());
            return (
              (this.inputBuffer.depthTexture = _),
              this.inputBuffer.dispose(),
              this.inputBuffer.stencilBuffer
                ? ((_.format = 1027), (_.type = 1020))
                : (_.type = 1014),
              _
            );
          }
          deleteDepthTexture() {
            if (null !== this.depthTexture)
              for (let _ of (this.depthTexture.dispose(),
              (this.depthTexture = null),
              (this.inputBuffer.depthTexture = null),
              this.inputBuffer.dispose(),
              this.passes))
                _.setDepthTexture(null);
          }
          createBuffer(_, L, R, N) {
            let z = this.renderer,
              F = null === z ? new iT() : z.getDrawingBufferSize(new iT()),
              U = new iH(F.width, F.height, {
                minFilter: 1006,
                magFilter: 1006,
                stencilBuffer: L,
                depthBuffer: _,
                type: R,
              });
            return (
              N > 0 &&
                ((U.ignoreDepthForMultisampleCopy = !1), (U.samples = N)),
              1009 === R &&
                null !== z &&
                3001 === z.outputEncoding &&
                (U.texture.encoding = 3001),
              (U.texture.name = "EffectComposer.Buffer"),
              (U.texture.generateMipmaps = !1),
              U
            );
          }
          addPass(_, L) {
            let R = this.passes,
              N = this.renderer,
              z = N.getDrawingBufferSize(new iT()),
              F = N.getContext().getContextAttributes().alpha,
              U = this.inputBuffer.texture.type;
            if (
              (_.setRenderer(N),
              _.setSize(z.width, z.height),
              _.initialize(N, F, U),
              this.autoRenderToScreen &&
                (R.length > 0 && (R[R.length - 1].renderToScreen = !1),
                _.renderToScreen && (this.autoRenderToScreen = !1)),
              void 0 !== L ? R.splice(L, 0, _) : R.push(_),
              this.autoRenderToScreen && (R[R.length - 1].renderToScreen = !0),
              _.needsDepthTexture || null !== this.depthTexture)
            ) {
              if (null === this.depthTexture) {
                let L = this.createDepthTexture();
                for (_ of R) _.setDepthTexture(L);
              } else _.setDepthTexture(this.depthTexture);
            }
          }
          removePass(_) {
            let L = this.passes,
              R = L.indexOf(_);
            -1 !== R &&
              L.splice(R, 1).length > 0 &&
              (null !== this.depthTexture &&
                (L.reduce((_, L) => _ || L.needsDepthTexture, !1) ||
                  (_.getDepthTexture() === this.depthTexture &&
                    _.setDepthTexture(null),
                  this.deleteDepthTexture())),
              this.autoRenderToScreen &&
                R === L.length &&
                ((_.renderToScreen = !1),
                L.length > 0 && (L[L.length - 1].renderToScreen = !0)));
          }
          removeAllPasses() {
            let _ = this.passes;
            this.deleteDepthTexture(),
              _.length > 0 &&
                (this.autoRenderToScreen &&
                  (_[_.length - 1].renderToScreen = !1),
                (this.passes = []));
          }
          render(_) {
            let L = this.renderer,
              R = this.copyPass,
              N = this.inputBuffer,
              z = this.outputBuffer,
              F = !1,
              U,
              k,
              Y;
            for (let X of (void 0 === _ && (_ = this.timer.update().getDelta()),
            this.passes))
              X.enabled &&
                (X.render(L, N, z, _, F),
                X.needsSwap &&
                  (F &&
                    ((R.renderToScreen = X.renderToScreen),
                    (U = L.getContext()),
                    (k = L.state.buffers.stencil).setFunc(
                      U.NOTEQUAL,
                      1,
                      4294967295,
                    ),
                    R.render(L, N, z, _, F),
                    k.setFunc(U.EQUAL, 1, 4294967295)),
                  (Y = N),
                  (N = z),
                  (z = Y)),
                X instanceof AX ? (F = !0) : X instanceof AD && (F = !1));
          }
          setSize(_, L, R) {
            let N = this.renderer;
            if (void 0 === _ || void 0 === L) {
              let R = N.getSize(new iT());
              (_ = R.width), (L = R.height);
            }
            N.setSize(_, L, R);
            let z = N.getDrawingBufferSize(new iT());
            for (let _ of (this.inputBuffer.setSize(z.width, z.height),
            this.outputBuffer.setSize(z.width, z.height),
            this.passes))
              _.setSize(z.width, z.height);
          }
          reset() {
            let _ = this.timer.isAutoResetEnabled();
            this.dispose(),
              (this.autoRenderToScreen = !0),
              this.timer.setAutoResetEnabled(_);
          }
          dispose() {
            for (let _ of this.passes) _.dispose();
            (this.passes = []),
              null !== this.inputBuffer && this.inputBuffer.dispose(),
              null !== this.outputBuffer && this.outputBuffer.dispose(),
              this.deleteDepthTexture(),
              this.copyPass.dispose(),
              this.timer.dispose();
          }
        },
        AK = { MEDIUM: 2, LARGE: 3 },
        AJ = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D map;
#else
uniform lowp sampler2D map;
#endif
uniform float intensity;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=clamp(texture2D(map,uv)*intensity,0.0,1.0);}`,
        A$ = class extends AG {
          constructor({
            blendFunction: _ = AF.SCREEN,
            luminanceThreshold: L = 0.9,
            luminanceSmoothing: R = 0.025,
            resolutionScale: N = 0.5,
            intensity: z = 1,
            width: F = AR.AUTO_SIZE,
            height: U = AR.AUTO_SIZE,
            kernelSize: k = AK.LARGE,
          } = {}) {
            super("BloomEffect", AJ, {
              blendFunction: _,
              uniforms: new Map([
                ["map", new oz(null)],
                ["intensity", new oz(z)],
              ]),
            }),
              (this.renderTarget = new iH(1, 1, {
                minFilter: 1006,
                magFilter: 1006,
                stencilBuffer: !1,
                depthBuffer: !1,
              })),
              (this.renderTarget.texture.name = "Bloom.Target"),
              (this.renderTarget.texture.generateMipmaps = !1),
              (this.uniforms.get("map").value = this.renderTarget.texture),
              (this.luminancePass = new AY({
                renderTarget: this.renderTarget,
                colorOutput: !0,
              })),
              (this.luminanceMaterial.threshold = L),
              (this.luminanceMaterial.smoothingFactor = R),
              (this.blurPass = new AW({
                resolutionScale: N,
                width: F,
                height: U,
                kernelSize: k,
              }));
            let Y = this.blurPass.getResolution();
            Y.addEventListener("change", (_) =>
              this.setSize(Y.baseWidth, Y.baseHeight),
            );
          }
          get texture() {
            return this.renderTarget.texture;
          }
          getTexture() {
            return this.renderTarget.texture;
          }
          get resolution() {
            return this.blurPass.resolution;
          }
          getResolution() {
            return this.blurPass.resolution;
          }
          getBlurPass() {
            return this.blurPass;
          }
          getLuminancePass() {
            return this.luminancePass;
          }
          get luminanceMaterial() {
            return this.luminancePass.fullscreenMaterial;
          }
          getLuminanceMaterial() {
            return this.luminancePass.fullscreenMaterial;
          }
          get width() {
            return this.resolution.width;
          }
          set width(_) {
            this.resolution.preferredWidth = _;
          }
          get height() {
            return this.resolution.height;
          }
          set height(_) {
            this.resolution.preferredHeight = _;
          }
          get dithering() {
            return this.blurPass.dithering;
          }
          set dithering(_) {
            this.blurPass.dithering = _;
          }
          get kernelSize() {
            return this.blurPass.kernelSize;
          }
          set kernelSize(_) {
            this.blurPass.kernelSize = _;
          }
          get distinction() {
            return console.warn(this.name, "distinction was removed"), 1;
          }
          set distinction(_) {
            console.warn(this.name, "distinction was removed");
          }
          get intensity() {
            return this.uniforms.get("intensity").value;
          }
          set intensity(_) {
            this.uniforms.get("intensity").value = _;
          }
          getIntensity() {
            return this.intensity;
          }
          setIntensity(_) {
            this.intensity = _;
          }
          getResolutionScale() {
            return this.resolution.scale;
          }
          setResolutionScale(_) {
            this.resolution.scale = _;
          }
          update(_, L, R) {
            let N = this.renderTarget;
            this.luminancePass.enabled
              ? (this.luminancePass.render(_, L, N),
                this.blurPass.render(_, N, N))
              : this.blurPass.render(_, L, N);
          }
          setSize(_, L) {
            let R = this.resolution;
            R.setBaseSize(_, L),
              this.renderTarget.setSize(R.width, R.height),
              this.luminancePass.resolution.copy(R);
          }
          initialize(_, L, R) {
            this.blurPass.initialize(_, L, R),
              void 0 !== R &&
                ((this.renderTarget.texture.type = R),
                3001 === _.outputEncoding &&
                  (this.renderTarget.texture.encoding = 3001));
          }
        },
        A0 = class extends AG {
          constructor({
            blendFunction: _ = AF.NORMAL,
            brightness: L = 0,
            contrast: R = 0,
          } = {}) {
            super(
              "BrightnessContrastEffect",
              "uniform float brightness;uniform float contrast;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=inputColor.rgb+vec3(brightness-0.5);if(contrast>0.0){color/=vec3(1.0-contrast);}else{color*=vec3(1.0+contrast);}outputColor=vec4(min(color+vec3(0.5),1.0),inputColor.a);}",
              {
                blendFunction: _,
                uniforms: new Map([
                  ["brightness", new oz(L)],
                  ["contrast", new oz(R)],
                ]),
              },
            );
          }
          get brightness() {
            return this.uniforms.get("brightness").value;
          }
          set brightness(_) {
            this.uniforms.get("brightness").value = _;
          }
          getBrightness(_) {
            return this.brightness;
          }
          setBrightness(_) {
            this.brightness = _;
          }
          get contrast() {
            return this.uniforms.get("contrast").value;
          }
          set contrast(_) {
            this.uniforms.get("contrast").value = _;
          }
          getContrast(_) {
            return this.contrast;
          }
          setContrast(_) {
            this.contrast = _;
          }
        },
        A2 = class extends AG {
          constructor(_ = AF.NORMAL) {
            super(
              "ColorAverageEffect",
              "void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=vec4(vec3(average(inputColor.rgb)),inputColor.a);}",
              { blendFunction: _ },
            );
          }
        },
        A4 = class extends AG {
          constructor({
            blendFunction: _ = AF.NORMAL,
            offset: L = new iT(0.001, 5e-4),
          } = {}) {
            super(
              "ChromaticAberrationEffect",
              "varying vec2 vUvR;varying vec2 vUvB;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec2 ra=texture2D(inputBuffer,vUvR).ra;vec2 ba=texture2D(inputBuffer,vUvB).ba;outputColor=vec4(ra.x,inputColor.g,ba.x,max(max(ra.y,ba.y),inputColor.a));}",
              {
                vertexShader:
                  "uniform vec2 offset;varying vec2 vUvR;varying vec2 vUvB;void mainSupport(const in vec2 uv){vec2 shift=offset*vec2(1.0,aspect);vUvR=uv+shift;vUvB=uv-shift;}",
                blendFunction: _,
                attributes: Aj.CONVOLUTION,
                uniforms: new Map([["offset", new oz(L)]]),
              },
            );
          }
          get offset() {
            return this.uniforms.get("offset").value;
          }
          set offset(_) {
            this.uniforms.get("offset").value = _;
          }
          getOffset() {
            return this.offset;
          }
          setOffset(_) {
            this.offset = _;
          }
        },
        A5 = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D nearColorBuffer;uniform mediump sampler2D farColorBuffer;
#else
uniform lowp sampler2D nearColorBuffer;uniform lowp sampler2D farColorBuffer;
#endif
uniform lowp sampler2D nearCoCBuffer;uniform float scale;void mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){vec4 colorNear=texture2D(nearColorBuffer,uv);vec4 colorFar=texture2D(farColorBuffer,uv);float CoCNear=texture2D(nearCoCBuffer,uv).r;CoCNear=min(CoCNear*scale,1.0);vec4 result=inputColor*(1.0-colorFar.a)+colorFar;result=mix(result,colorNear,CoCNear);outputColor=result;}`,
        A8 = class extends AG {
          constructor(
            _,
            {
              blendFunction: L = AF.NORMAL,
              worldFocusDistance: R,
              worldFocusRange: N,
              focusDistance: z = 0,
              focalLength: F = 0.1,
              focusRange: U = F,
              bokehScale: k = 1,
              width: Y = AR.AUTO_SIZE,
              height: X = AR.AUTO_SIZE,
            } = {},
          ) {
            super("DepthOfFieldEffect", A5, {
              blendFunction: L,
              attributes: Aj.DEPTH,
              uniforms: new Map([
                ["nearColorBuffer", new oz(null)],
                ["farColorBuffer", new oz(null)],
                ["nearCoCBuffer", new oz(null)],
                ["scale", new oz(1)],
              ]),
            }),
              (this.camera = _),
              (this.renderTarget = new iH(1, 1, {
                minFilter: 1006,
                magFilter: 1006,
                stencilBuffer: !1,
                depthBuffer: !1,
              })),
              (this.renderTarget.texture.name = "DoF.Intermediate"),
              (this.renderTarget.texture.generateMipmaps = !1),
              (this.renderTargetMasked = this.renderTarget.clone()),
              (this.renderTargetMasked.texture.name = "DoF.Masked.Far"),
              (this.renderTargetNear = this.renderTarget.clone()),
              (this.renderTargetNear.texture.name = "DoF.Bokeh.Near"),
              (this.uniforms.get("nearColorBuffer").value =
                this.renderTargetNear.texture),
              (this.renderTargetFar = this.renderTarget.clone()),
              (this.renderTargetFar.texture.name = "DoF.Bokeh.Far"),
              (this.uniforms.get("farColorBuffer").value =
                this.renderTargetFar.texture),
              (this.renderTargetCoC = this.renderTarget.clone()),
              (this.renderTargetCoC.texture.name = "DoF.CoC"),
              (this.renderTargetCoCBlurred = this.renderTargetCoC.clone()),
              (this.renderTargetCoCBlurred.texture.name = "DoF.CoC.Blurred"),
              (this.uniforms.get("nearCoCBuffer").value =
                this.renderTargetCoCBlurred.texture),
              (this.cocPass = new Aq(new Ar(_)));
            let Q = this.cocMaterial;
            (Q.focusDistance = z),
              (Q.focusRange = U),
              void 0 !== R && (Q.worldFocusDistance = R),
              void 0 !== N && (Q.worldFocusRange = N),
              (this.blurPass = new AW({
                kernelSize: AK.MEDIUM,
                width: Y,
                height: X,
              }));
            let K = this.blurPass.getResolution();
            K.addEventListener("change", (_) =>
              this.setSize(K.getBaseWidth(), K.getBaseHeight()),
            ),
              (this.maskPass = new Aq(new AS(this.renderTargetCoC.texture)));
            let J = this.maskPass.fullscreenMaterial;
            (J.maskFunction = 1),
              (J.colorChannel = 1),
              (this.bokehNearBasePass = new Aq(new At(!1, !0))),
              (this.bokehNearBasePass.fullscreenMaterial.cocBuffer =
                this.renderTargetCoCBlurred.texture),
              (this.bokehNearFillPass = new Aq(new At(!0, !0))),
              (this.bokehNearFillPass.fullscreenMaterial.cocBuffer =
                this.renderTargetCoCBlurred.texture),
              (this.bokehFarBasePass = new Aq(new At(!1, !1))),
              (this.bokehFarBasePass.fullscreenMaterial.cocBuffer =
                this.renderTargetCoC.texture),
              (this.bokehFarFillPass = new Aq(new At(!0, !1))),
              (this.bokehFarFillPass.fullscreenMaterial.cocBuffer =
                this.renderTargetCoC.texture),
              (this.target = null),
              (this.bokehScale = k);
          }
          get cocTexture() {
            return this.renderTargetCoC.texture;
          }
          get cocMaterial() {
            return this.cocPass.fullscreenMaterial;
          }
          get circleOfConfusionMaterial() {
            return this.cocMaterial;
          }
          getCircleOfConfusionMaterial() {
            return this.circleOfConfusionMaterial;
          }
          getBlurPass() {
            return this.blurPass;
          }
          get resolution() {
            return this.blurPass.getResolution();
          }
          getResolution() {
            return this.blurPass.getResolution();
          }
          get bokehScale() {
            return this.uniforms.get("scale").value;
          }
          set bokehScale(_) {
            for (let L of [
              this.bokehNearBasePass,
              this.bokehNearFillPass,
              this.bokehFarBasePass,
              this.bokehFarFillPass,
            ])
              L.fullscreenMaterial.setScale(_);
            this.maskPass.fullscreenMaterial.setStrength(_),
              (this.uniforms.get("scale").value = _);
          }
          getBokehScale() {
            return this.bokehScale;
          }
          setBokehScale(_) {
            this.bokehScale = _;
          }
          getTarget() {
            return this.target;
          }
          setTarget(_) {
            this.target = _;
          }
          calculateFocusDistance(_) {
            let L = this.camera;
            return WS(-L.position.distanceTo(_), L.near, L.far);
          }
          setDepthTexture(_, L = 3200) {
            (this.circleOfConfusionMaterial.depthBuffer = _),
              (this.circleOfConfusionMaterial.depthPacking = L);
          }
          update(_, L, R) {
            let N = this.renderTarget,
              z = this.renderTargetCoC,
              F = this.renderTargetCoCBlurred,
              U = this.renderTargetMasked;
            if (null !== this.target) {
              let _ = this.calculateFocusDistance(this.target);
              this.circleOfConfusionMaterial.focusDistance = _;
            }
            this.cocPass.render(_, null, z),
              this.blurPass.render(_, z, F),
              this.maskPass.render(_, L, U),
              this.bokehFarBasePass.render(_, U, N),
              this.bokehFarFillPass.render(_, N, this.renderTargetFar),
              this.bokehNearBasePass.render(_, L, N),
              this.bokehNearFillPass.render(_, N, this.renderTargetNear);
          }
          setSize(_, L) {
            let R = this.resolution;
            R.setBaseSize(_, L);
            let N = R.width,
              z = R.height,
              F = [
                this.cocPass,
                this.blurPass,
                this.maskPass,
                this.bokehNearBasePass,
                this.bokehNearFillPass,
                this.bokehFarBasePass,
                this.bokehFarFillPass,
              ];
            F.push(this.renderTargetCoC, this.renderTargetMasked),
              F.forEach((R) => R.setSize(_, L)),
              (F = [
                this.renderTarget,
                this.renderTargetNear,
                this.renderTargetFar,
                this.renderTargetCoCBlurred,
              ]).forEach((_) => _.setSize(N, z)),
              [
                this.bokehNearBasePass,
                this.bokehNearFillPass,
                this.bokehFarBasePass,
                this.bokehFarFillPass,
              ].forEach((_) => _.fullscreenMaterial.setSize(N, z));
          }
          initialize(_, L, R) {
            [
              this.cocPass,
              this.maskPass,
              this.bokehNearBasePass,
              this.bokehNearFillPass,
              this.bokehFarBasePass,
              this.bokehFarFillPass,
            ].forEach((N) => N.initialize(_, L, R)),
              this.blurPass.initialize(_, L, 1009),
              void 0 !== R &&
                ((this.renderTarget.texture.type = R),
                (this.renderTargetNear.texture.type = R),
                (this.renderTargetFar.texture.type = R),
                (this.renderTargetMasked.texture.type = R),
                3001 === _.outputEncoding &&
                  ((this.renderTarget.texture.encoding = 3001),
                  (this.renderTargetNear.texture.encoding = 3001),
                  (this.renderTargetFar.texture.encoding = 3001),
                  (this.renderTargetMasked.texture.encoding = 3001)));
          }
        };
      new iq(), new rw();
      var A9 = class extends AG {
        constructor({
          blendFunction: _ = AF.NORMAL,
          hue: L = 0,
          saturation: R = 0,
        } = {}) {
          super(
            "HueSaturationEffect",
            "uniform vec3 hue;uniform float saturation;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=vec3(dot(inputColor.rgb,hue.xyz),dot(inputColor.rgb,hue.zxy),dot(inputColor.rgb,hue.yzx));float average=(color.r+color.g+color.b)/3.0;vec3 diff=average-color;if(saturation>0.0){color+=diff*(1.0-1.0/(1.001-saturation));}else{color+=diff*-saturation;}outputColor=vec4(min(color,1.0),inputColor.a);}",
            {
              blendFunction: _,
              uniforms: new Map([
                ["hue", new oz(new iq())],
                ["saturation", new oz(R)],
              ]),
            },
          ),
            (this.hue = L);
        }
        get saturation() {
          return this.uniforms.get("saturation").value;
        }
        set saturation(_) {
          this.uniforms.get("saturation").value = _;
        }
        getSaturation() {
          return this.saturation;
        }
        setSaturation(_) {
          this.saturation = _;
        }
        get hue() {
          return Math.acos((3 * this.uniforms.get("hue").value.x - 1) / 2);
        }
        set hue(_) {
          let L = Math.sin(_),
            R = Math.cos(_);
          this.uniforms
            .get("hue")
            .value.set(
              (2 * R + 1) / 3,
              (-Math.sqrt(3) * L - R + 1) / 3,
              (Math.sqrt(3) * L - R + 1) / 3,
            );
        }
        getHue() {
          return this.hue;
        }
        setHue(_) {
          this.hue = _;
        }
      };
      new iz();
      var A7 = `void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 noise=vec3(rand(uv*time));
#ifdef PREMULTIPLY
outputColor=vec4(min(inputColor.rgb*noise,vec3(1.0)),inputColor.a);
#else
outputColor=vec4(noise,inputColor.a);
#endif
}`,
        Mt = class extends AG {
          constructor({
            blendFunction: _ = AF.SCREEN,
            premultiply: L = !1,
          } = {}) {
            super("NoiseEffect", A7, { blendFunction: _ }),
              (this.premultiply = L);
          }
          get premultiply() {
            return this.defines.has("PREMULTIPLY");
          }
          set premultiply(_) {
            this.premultiply !== _ &&
              (_
                ? this.defines.set("PREMULTIPLY", "1")
                : this.defines.delete("PREMULTIPLY"),
              this.setChanged());
          }
          isPremultiplied() {
            return this.premultiply;
          }
          setPremultiplied(_) {
            this.premultiply = _;
          }
        },
        Mi = class extends AG {
          constructor(_ = 30) {
            super(
              "PixelationEffect",
              "uniform bool active;uniform vec2 d;void mainUv(inout vec2 uv){if(active){uv=vec2(d.x*(floor(uv.x/d.x)+0.5),d.y*(floor(uv.y/d.y)+0.5));}}",
              {
                uniforms: new Map([
                  ["active", new oz(!1)],
                  ["d", new oz(new iT())],
                ]),
              },
            ),
              (this.resolution = new iT()),
              (this.d = 0),
              (this.granularity = _);
          }
          get granularity() {
            return this.d;
          }
          set granularity(_) {
            let L = Math.floor(_);
            L % 2 > 0 && (L += 1),
              (this.d = L),
              (this.uniforms.get("active").value = L > 0),
              this.setSize(this.resolution.width, this.resolution.height);
          }
          getGranularity() {
            return this.granularity;
          }
          setGranularity(_) {
            this.granularity = _;
          }
          setSize(_, L) {
            this.resolution.set(_, L),
              this.uniforms
                .get("d")
                .value.setScalar(this.d)
                .divide(this.resolution);
          }
        };
      new iq(), new iq();
      var Mr =
          "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAAQCAYAAACm53kpAAAAeElEQVRYR+2XSwqAMAxEJ168ePEqwRSKhIIiuHjJqiU0gWE+1CQdApcVAMUAuARaMGCX1MIL/Ow13++9lW2s3mW9MWvsnWc/2fvGygwPAN4E8QzAA4CXAB6AHjG4JTHYI1ey3pcx6FHnEfhLDOIBKAmUBK6/ANUDTlROXAHd9EC1AAAAAElFTkSuQmCC",
        Ma =
          "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKAAAAIwCAYAAAABNmBHAAAgAElEQVR4Xuy9CbhlV1ktOvbpq09DkiIkUBI6kxASIH0DlAQiIK1wRfSJTx+i4JX7vKIigs8HXpXvqVcvrcC9agQ7IDTSSWgqCQQliDRBJKkkhDSkqVPNqVOnP+8b//rH3P+eZ+199tlznVTlvVrft7+1T7OaueZY42/m37QALKNk2wHg1pITlB17mC+Pp11W3X/LHyT32vhg48/5SOv+PnwpsHA70JoGlueB1iKApeqzvOzn44GatTB76Xzhd7suBR7+WWADgDEAwwCG/L54b/poDLrHuvvm70Z2Avhsc+PVcxscBU8F8C8ADg5+ipIjD/PlGwfgju8B924E5seARUfLsiNmqQW0IjL8+7L2NYD/7COBzfcCm+aB8SVgdAkYIRCXKyDax4EdAanL5PuNPllNvXDlAHwFgP8AcC2AhRIoDXbsYb48dl5WkVFTE3LGDcC9m4CZCWBuFFgeAZaGAYJQQCRqDHT+McJrVb8zwATUXH02MHYfMHEIGFsAxgjApQqACYQORjtd/B7Axt/z79sC0+cMPgjjlwPwVwHcA+DfAHzTxcVgWBroqMN8+cYBeM71wH0TwKExYHYUWCIAHYRLTlkCYgcIBcAgU/n3qy8GRu4HRgnAOWBkERhddPAJhGJDBxkvw7cqimr+zFM/ZLnZF64cgL8BYD+AWwB8x/dlWuWagHiYL984AJ/0RWBy1AE4AizyM1yxYAcTigW55xMbAkxEiwEdkJ/ZCQxPAiOHgBECcKEC4TBZcKkSv+mTieNcNPNC26mLNsj45QD8LQDTAO4GcJt/7iw2bfoG4WG+vAGwm9ExiEg69zpg/wgwPQLMjgALzn4E4aIzoJjQ9g4024uygkj+pyuAoX0VAIfngOH5NgCHMhAm8Sv2y3XDZeBhNIp8OzJE8OsBzAKYBHAXgDt8/4O+MVT0j4f58o0D8Pxrgf3DwMwIMEPQEYRkNwfgsuuDZLskip0No0gWMD/9HGDoADAkAC4Aw/wsAgZAgs2Z0ABI0GU6IVmKv+f28KDnHxkA/G0A8y6G73N9kOCjXnh/Ebb6OvgwX75xAF5wLTA1VIHPADgMLDj4yIA5AAm6aCUnv4oz46eeDwxNAUMzwJAz4BABSNDFTwSfg7DDKHE23MG5PqIY8A1u/dINs9dBdy8AgnGPM2NfUBrsnw7z5RsH4IXXAAcJviFgluAbygBINnSLWOAjGxJ4pgOKDV0v/OSLKp8iGXBovhLBBOCQM2ACoTOhnYrAdItYbCij5JFzRyIAqRccAnDAQUjg6UNQ7hsMXP0cRQAexss3DsCLCECCLwCQzMcPwUi2MwAScAKbfnY/YRLFQ8DHX+IAJAMSfDkAF13kLvleIjhjQQHxUVS3jjgGpKeeNzYVQEjgUS8k+PghONdhIwAP4+XXBYCHKIJbwJyDTgaIAdCBJx3Q2M8tYAHP9m4df/ylQOsQ0JqtRLCx30K1wtLBggScQOgsKBGcWHAJeOwRC0BSM1mQIKRbhh+Bj98JQP6t4U0APEyXXxcAEnxkQAFwoVUxID9kvQg+c1C7vidRbIDkc24B//hTQGumDcCWA5DgMxASdNIFBUI5pCML8v8API5zfEQx4BudgqiczviSnJhQwCP4BMCGl+wO8+U7AJi/W4O4YS6+pmK/2ciADsAOBhTIIiAJnPB7AvNjP+0AnANaYkAHX2JBAc+tYaJXOqBZv24Vc386XW5dtkHGW+4HFAJonpOe+YYQZAShgKjv3PNvPQaxVoI8zJdfFwASfPzMUwS3Kt1v0UFIlos6oDFdAGFcliMAP/ryAEAGNwQRnDOgLbdlIEwrIs6AZ/QgkMMHQF6ZAKQcJAsSYPwIeAIk9wJgoPK1gi7+PwF4GC/fOAAvIQPSs0URTPBJ/Pp3GSEGRHfBCIQ0xowBtUbcAj7ys5X4Jfu1HIAGQrIgQRXEsAFQIORDFhiDY/rMHmrU4QUgR08AkgUjCAW6CD6CkwBsAIQC4GG6fPMA3OXiNzCg2I9gNCMksmAAoemDzoimFwL48M85AKkiuQVMAAp8CYRRDAt8GQiJ67N6GJODAXAHlsGguscA2AJg1IPGYmxOpBxFWkRN9LsATgIwXnNs/v/5z/9XCf8BO3YAtxbc/46/KDt+5+ea1Yku2VUxHz/z0v24FwMGK1gWsK2OUUxHHdCBeRUB6OxHABr4ZICIBd0QWSF+XRdMTAjgCdTrG9cBNwE4F8CpDkICyYLGsuhFt6zs+gISwUen8zEAjgMw4cfx2H6O/90yAFo84Cbg4ID3/9TfLTt+5+ebnRABkODjx0SwPi5ec/FrYpmqSAxM8Dn60CsqAFI6GfhqAMiDE/gokmvEr0C4PgDkBQm40wE8zMFEUDKEVoxIMLl/KS73mE7H9d+vcKHQQcjwW0Yu9nP8m8sAmOIBuWY6wP2/4s0ezjjg8TuvaR6ABJ70vxUApGrm7EbGE+i472BAB+WHfqHS/eoAaEwY2E9+wLSXTqhI7CXgnB6LCoOJ4BiST+hTnG0HcCwAglCx3ARoZEVFXnBPp/O/A/hXACc7CPs9/i1lAOyIB+RDX+P9/+pbQjjjAMfv/PL6AFDs1wFAgs/9fgKfgdE/ZEpuiQlbwAde6QAMBgiRmsSwA9BY0JfjovGRDBMH4TlcXGhcBOc6HkF0gjPhZgchxTLZMAci/04W/B6Ab3t09EPXcPyflgFwRTwgJ2MN9/8bf5qFM67x+B/aW4XQz42FeL0YrRyikztUFw0704mf9kXgxhOAqc3AAsPyRxxQCs/PdXOFY0W1KHy3QIUGtx+6vdnx1vsB+dsTncm2AogglFgVEAlUWrOMB2RyEmMCGQ/Y7/HvKns6tfGAnJQ+r/9b76oJZ1zD8WdyQjYBh8aBhVEHjELouQ8ukQ7VRSCJAALwkr+sALhnGzDD3JAJYJHg9uhoi4bx8ytkWUtvHT/7+Zc4dw1uZ3612fH2dkQf7yxIEEockwkJQn4IQoq8unhAhmPRKKFx0uv4K8ueTs94wD7u//VX9ghn7OP4c+4G7h8HpseB+dF2AKlFLwuAIZ8jD6NPrOhAffmfA9/ZBuzZCkyRWSeqBCWyoYGQ5yQrBpDbum/ME1HoPo0XEkSD2zlfbna8q6+EUJcTCxKEtHL5EQjP6BEPyIgYAZBvYt3xHyx7OqvGA65y/7/9wVXCGVc5/sl7qxD66dEqiYgRzAqhN1A4CBNAAlDyAFI+iZ9/N3DLJuC+jcDUBmCWyUnOrmTYCMIOkNclLg0B8/RsNLg9+UvNjnd1APLmmQpFHyEBROuWACQT8nN+H/GAvY7/VNnT6SsesMf13/CpahGnZzhjj+PPmwX2MYdDIfQexWyBAwEUOQDrRDN/98p3A7dvAO6fAA5sqHJDBEAyoUVGkwEd6HR12XU4kwzfl6fCXTZzjy57vvnR513X7Hj7AyDvggAUi9EyFgiZqNxPQF6345nOWbD1HQ/Y5fpvuLa/2+82/vNHgAPDFQDnhoF5j2C2qBWCI8bw1eRw5CL5l94L3DEOTI4DB8Y9OWmsEu/zBJ3rgsaybqBob/7A4C7jtWcooRrczr+u2fH2D0AOQgAUCxKEP7aGgLy64+m6KdjWFA9Yc/03/Osa4glrjr+AupqHz1sEs0cxG0BC9HIePLoit9eNkVf9L+DuUWByDJgaq4ybGYLPAWgiXmLedUE7dwC7saL7CqfPKXi4NYdaykCD410bAHlDEsNiwZ9wAPYbkJcfz6T2gm3N8YDZ9d/wHxUA+739fPwXPrSKYGb+BuP3jAFDElFH9HIWwbzCIGkBr/or4J4RYO8oMOW6ZVcAuvi1Cgoha04BCwT5gfMKHm7NoRde2+x41w5A3hQZkADk5+cGiAeMx3+/7AENFA8Yrv/G71cAXFM4Yzj+otOAaQLQA0gZxaIIZtMDFTigKJV8H9Iq6aZ59ZXAvSPAvpEKgBTtBODcSCWCZeRYtpzrmLyeGNCAyFl1v+Hei8qeb370Rdc2O97BAMi7EgB/2QG41nhAHU9LuWAbOB7Qr//GPRUA13r7Gv9FZwIMoVcEswEwfDoimEP0shKKtIphaZQAXv1+YM+wA3DEdcvRKkGJADQQEsQuhi1Tjt95vBsh5nx2IO59SsHDrTmUOStNjndwAAqEry0IyCMICkOyiuIBNwBvPFQQT7gBuPjc9oRYAIHyOEL4vIFEYVNaOou5vCGE/tV/A0wOVcnpzI47NOri3QFIBpSeaSDUdYLOSWvYImSGgftpJDa4MWJbAGxivGUA5MAOc0Be6eVLj7/4Mk+hzCOYPYpZDBiNkLh+G/M3yFyv/ltgL3W3YQfgcFUhgRY2PwY+Z7/EhAR1SFyXCOb57r28QfQBsJQBMn5D4y0HYLPje9Cd7RIC0PM3EiMofF4gVCBp1P840ix/gyz56r+vAMjk9Gl375iB4+CzveuZdLkkEPJ8ZEfX/6R73vOjzT5Si9hucLxHAVg4PwJgRwh9CKOXK8YA4ZEqKZXSQWh5P+5AftXfA/uGKvYjCKn72cctbFrZNECka5L5CPwIPtMH3TVz17MLB5gdLgA2Nd6jACycHwLQxFEUSR5ASvARDB0h9AQb9bXIgCGk6lUfAPYTgEPAITKgg1BObk58srTJgG58WMkWMaAbQQT1nc8rHGANAJsc71EAFs4PAagQestgC1lsBJ4BMCSOK6dDUcwqqaFiQr/0QeAAAdjy+jBiQQeeMSBZT3nCPUDIa9z+/MIB1gCwyfEeBWDh/BCAeQSzgkjFfGLBBD5nxQ4DxN0wv3hVxX5TBGDwL5obxvVA5YqYL5BeMLd66YYxJpRB0gK+96LCAdYAsMnxHgVg4fwIgMrhUPKQ2C+Bz0PmBTqBMQehAbDlIjj4F80KJguSVZ0FuXpjoCOgXawLjALhbT9eOMAuAGxqvEcBWDg/l1IE05Ed0ygZnyHdz0VwCqEPIfNyx0QQvvLDFQCp+8nfZk5und8tXwIgWcHSNX0N2CJmnAl3v6RwgNnhl17T7HiPArBwfghAS7mV/hey2JS9FvM3BLpUUi1YwDRMXvkRYJoAlAh2l0dcZ04s6JUTDIjyBcrl4yDc/dLCAdYAsMnxHgVg4fxwKVwJgGEJNmWtxpQMpX9on2eRhVA+O56AjMfnP+e3Xvf3NwG4xIPTleiY55bpGh6UbafNU0l0z0p+5Jh5HqYJ6b51nP6XP8cx12XNHQVgIQB/bFPVg2OC7Q+WgVFWng/FvtWLI06uWh5oguKEcXVS/9sEAF//VGD7t4ETDgJbF4CNi8CGZWBs2fPL/H6Vwp2KEtVk4fJ+v/EIYPN9wKa5qu+IncfPwXHVZe/aOL3EbwS7xv8A1rQvnO0j8PArTgTGZ4BxFv9mIxhOCGsv+0OPYDRghcLfkWkEuq0+G00x4OtfDGz+d2DbHmDLjL8si8AYP/7CGIAiEEMTG92zXqSbH+d9R2aA0XnvO+JjthiIrOVDHHPOkBrzUQAWAPsZp3oPDpa/Xag6EVkLBK+5rAnJC3/nYk/APD704WiEAV8OTHwX2LQH2DgFbJgFNrBhjd8r79deGoEwsllgNBOzy8CdjweG9wBj08AIAci2D6HafmyAk4/Z7SJ72hGYRwFYAMDLTwOGp4FRFgD3HhzqRGQiyeurqOdG6r0Rm8IEZjzRlkiqCWoEgK8Axm4BJu4HJhyAbFhDxmbDGnZO4j0SgLGDkpibgEq66TJw/1nA0F5gdLpq+zDqFfd5LMeWqu5HNST0uJOIllg+qgMWgI+HPv0xwLA3gWHpW2sC441gCECbmKziaGrnUdMO4aHeh6MxAP4SMHI7ML4HGD8AjHvHJGNAgpDgY/ck3stipRemvVhc+uASMPUEYGh/9dIRgGx8Y+MNbR/00uVtH0wEx94j/v0oAxaA8Ed+GBieAYZZg5kADC0QWGOFzGJlcGPzl1BxNLXD8sk4xftwNAbA/wwM3wGMUmxOOQBnHXzetIYvibonmSiuYTNjriVg7glAiwBk0fNZH6+PmX9P6kfNmCXGpftJ7TgKwBIAnln14BAAYxMYm5C6RjCyCoOyr0qkD/c+HI0B8DXA8N3AyCQwesD1VQKH7EcASm1Q+y4CkN9pUKiVF5nLvy+fBbTUd8QBaH1HvNBROiZvfsNnrF4kcvPwpdsBLBeU18Nf7AB23Dp4ecHC8oBgUlJJecLS+7+WOpE3gbE+HKw+yoevCYkMGKqPJrdEKARutaFYRs1fiEZ0wP8CDN8LDO8FRqYq3W10pgKgfYLaYCzootgA6KXaTA90y374TKB1sBozy77xHFZ536utRgAmEaw6g5kUSFZwSXnA330qsOlfgHMPDlZesLA8IOjoLypPWHj/11EnCiVwkz7kAExtsGraYUWdSDX5TmsagL8KDBGA7Bd30JsW0oWivnEOQNP7yGTSBR101AlZSUtGyfgZDkCWY1HnJdcBVe6325hTvelg2CQjZNDygG/2An0j1wKnL6y9vGBheUC8prQ8YeH9X39OVQSc7Mc6fCaKvAeHdCIVf4yMYCynTpX+nb97NJmlSQb8r8DQHm9YOFUZTKOzoXGhs6AxF0HIexcLBvWBuiHN8s2ne98R3qc6L4Vyb2oBVjfm9MIFHbjDCh6kPOBbQoG+oW8CO5bWVl6wsDwgfr20PGHh/X/1iaEIuDcCTIW/1Q4rFv8OnYiW3c+W2iKwUjKbyjQNwL1uuR6sAEgDgq1brXOmV81PxhNB6DUDBSYzQJwFtz623XcktX1Q1VWKaTF/zZhVazBVYA1tX5MazsGvobwe/jQr0Ne6BTh5uf/ygoXlAfG60vKEhff/rSe1i4DnTWDUACY1guFTDqLYdCBvf6DJYSMYATBfOx1kLfj1v1axH10nQ3Sd0GUkBnTfpemtBJgseIKQAHLQcVxa2TnuMW0Aqui5es8xBIegVdVVE8VhzHnLh65WMB9An+X18K6aAn2tO4ETl6vqbKuVFywsDwhevqg8YeH93/Rk70JE90nowxZbIJjvS3WYNSGUwGHJTpPxwwcbBuBrgRYBeKACn7VtpdUu/c0NJxO9BIxcKu4TTODzbkonPLoaL0vyUQRb2y8HsL1ckfWzMeuFi40Qezqi+yiPhyt7FOjr6/gCFwgP7Xb5vssTFt7/nQRg6MGRWmDRoeyTlpgw68GRTwgZgo1gGmXAX6/8dtaylSKY/koyID9BhzML3q1gAos2AcOrZYSoq/pJp1VtODRm9Z3LS/7WjVkvXOzEtOpKyGrlAT+4SoG+VY8vBGCvy/dVnrDw/vee65NBJiAjBIVcAJQjOm+DkCZEeiGAMw6sAwDZsJrAdhFM9rPGhd4904Co5oVuCZPV6kD40Ec6+9W8dBTBsfdc3nkpvnB82fp2RPcs79dHgb51LA9ofsDV6vut5/3PnxcAmLVBiDqgevDaJLkYrpuQxzcNwN8AWgIgRbB8loEBzXDwl4cGiDGft58SCOWGedgjvOJ+bPvgRkiuA+ZjzhnQQOiFNVbloa7l/fos0LdO5QENgEXlCfs8Qbf7HyMA3QVjYihYhLENgjX9y/qwxQmRU/asfd0ZcLU2CHVGyusJQLKfVi98CS12T5f7iECkHpsMkAhCF8+nshWH2I/jXsOYO144GV/9ApAIrS3vt4YCfetQHtAA2G+/4PW4/2PPbzMgmUMi2NoeSCRxIt2/FvuxWURIWCXg357gfTjEDNIHnTRXRCpH5ugKwGl3HpMBXQc0v6WLYVm/5limj04rG762K2uYY9jBkr9+rI03NL5ZbczS/dJ+LQyoga4o77fGAn0NlwdMAOy3vl/T938KAcj121z8Bn+Y9eWQJRz8Y6kNagDh2ey5EvxjxQD8TWdAuneCCO4An1vw5vdzQMmdktwq7pLZQR+dM34+ZumAxvY1Y04uqOAJ6FsExzeto7zfAAX6GiwPaLWR1lrfr8n7f/Rl3QGzmsis+/uO71V9OFgP2gpPhgr7TGRqRUT6dyvr4aIs/pm/2zVUNbBSv6G8e5pEv0Cvec7Po7+bTtjlBRlkvAMBkDeQyvsNWKCvofKACYBrre/X1P0/oWEAnnFD1YdjhtXxR73mX10FfCHHE9pVWcGAI/S0gKsfA2y+twrFZw6Hxf/F0Pk8Ri/kpGSnMuDx5T0iACgQHioo0NdAecBUHW6QdsV2/cL7v/Cyqr5gnc42CCOcfX1VIZ/V8We9IDmTzVXwPDJiXuKXPxtDBma8+lzP4WAgKkPxCUAPE4v5GzEuMX0PYJPLhB6FJsc7MAMmkVxaYC/K9gG+F1++8AQ7Gwbgk78I7GFpXgIwFiRXOwaJZPUbiR0yCUDRk+cHf+YpwMj9HgfI8ClGPyvsSiH0WSKRuYlitLb/zHM/JOSs5C/YIC9cMQDZr/dwxgOW9gtGYUBi0wA8l304vDQvAchilFbpIBQhZ7Ejq6ZQ0/Yhil8y4j89Axie9DAsD6FX9HOK3QtROTFkviN83kG4felIY8DCeLrSeMDSfsEovAECUFsTjHD+tcB+tkFgcXKvBRir7qtFl9owmO4Xy/1G3bAFfPrZHorFNWBFwHjQAFctIghj2kBarw06If/+MM9ZqTN6DgsDojCerjQesLRfMApvoGkAWh8Ob/tgAPSKWCp8ngNQtadjmTdltvNvn3peFYhgQQgh+iUmEaUAUoXM1yRLmWuFLaE9Z+XIAWBhPF1pPGBpv2AU3kDTALzwmqo6qtVh9kJErAudABia38TC5wJgS2xIhAwBn3yhByL4EhzXfRXxYsDTJ4IvrNN2JFMxZcBzVo4cABbG05XGA5b2C0bhDTQNQLZBYH1AVsQSAAU+imI1obHyblnjG/kJk3U8BHz8xVUQAhnQIl5CyNgKAGp5LKSSCoAySh5Jj79vTagcxUaIBeRNe79g9gq+DXig4wGzy+PONfT7RWFA4noAkGXZVAhcBckJQgNgrLiaNb3paIDo1vHHX+oA9LQBi4DxJcOUPJUnTgU2NJUyROs8irGARxQAC+PpCtsFd40H/AEf0gMQkLgeACT41PiGoLOKqyrJq3K/Ya9mNyr5FusN/uPLPIeDa8Bc+w3rtyl4VFHaMZc3i9RWBM9jjzgAFsbTFbYLRmm/YBTeQNMAtD4cBKDXBTQGdAB2MGBo8SCLmEuS1AFVAJ3A/NhPt0PoCcA8bSDG76XI7aySg6JYuGfKwJHFgH0E5B3ueMCe/Y4L+xVHAOZ+9EHcEgQgwbeiEYx6jwTdz4qfu7EhEJqxGqruf/RnHIAEnxgwBM0aC8aUAYWNBRCmoIll4HTqO122QcZbrgMWxtMVtgvuOx6wa7/jwhtoGoDWh4MBJ16WN4lfr8AqI0TVV1O1fa9BbQzovkAy4Ed+NgCQUSxZCFWvCOaOFREXyUwZOPIA2GdA3uGOB6wPaOz+QPv5S+MA3OXiN9aclghW+d3IgupBF2pPqxcxGenDPxfSRh2ASiKKiVP2PaZScvAKoA0VDc6cOlIB2GdA3uGOB1zR77iwX/F6AFB9ONSOQW0frA50sILVcckWJyIDSgwPAVcJgFbYuZ3FJvAlEHbJ3IsgJLGedeBIA+AAAXmHOx6wo99xYb/i9QKg2iAIfDJEJHqj4SExbEty0gkdhB/6P9oZbBZIGiKYVb9GKaN50lRHBLOvhDxh/5EKwDUG5B3ueMB2QGM/grb7/6wHAPNGMAY+GSGUjC52VX2f2CD4+HO0gqkZfegXKgBaHkcWtS0AWii9xG1ImrLlN5XR8L8fmQD05BVrmEENmpYSP9QX+KHiqj2/82+HqqDWwnbBRfGATdzAegGwru2DpRq7Mzq2fpAf0Nq0Rl2wBXzglZ4yUAPAmDSVWDBPHQjLcgTqOZ6zUvdKHh4ruDCerox/Dnu7YqwXAC1NI/QcEQuK6WK/kdgCTGC0PYAP/KIDMBgglq+hIkrOfsaCviLSofcJgJ5AdM7kkSaCj/HqQKVIGvD4swF8bcBjmzjsaQ2H5D/6acBd9wALB4DFWWB5AVherMp4GKIYEOp7+26UF0aSfT/xYuDG7wDjrIpAERytXf2vajj7ueryQXSFl10K/ON3gIWDwCLvjfGB8Z54O+Ee4ve6513uB2R1yzsqC+twbC8HcNVhfAeaBuDP/TvwtS3A/ePAIfYFVlPq2HHTuyulZCTlhbjhETF5yxTQGgPGhoHhIWC4VSXGD3n0tLkMHXHxu+YyB+MlPwDuZs5K6FlsbCzdVO9DuKfkHM8AEkP7B8fOkwDcD+B7np42+JkGOvKdAL4E4K8P0zvQdET0b14D3DgB3D0B7B8HZka9WzrD88N6sFm+YcUjrn7E1ZDvMtF9DBgeAYaHgSGB0PNHCD4BLwLRsByAyX/ij0/dDUxuqlIG5hix7eFhvLcOVUAtyPSydAFmOQNe6EYGV/9ZESiKgIEgtbaD/gHALQC4ovY5r5KwtjOU/XfTAHzzLuCmIeDuMWDvKHBwpMoN0WQzNtAaYSs0K4ZlOSAjGG9kPjCBRwZ0ABKEBJexYAZEAU3A7Oi1BeDym4EDnjQ1TwCGWMW8MXcKks0YOyZNlQOQjcgYIUHllEzYQ0ktm+r6oz8G4F4AXwXwRd8/kO9A0wB8y65KmPxgGJgcqYJTKYpTv2CCzyddQJRDOjKivn+Deh8BF8BnwBtaCUA+YYEyAU8h+c6Az9gNHHRmrgOgmDA3jHQ+iWupCeUAvNSrA9HNwqx+muk9nJVNg/CTfrmbAPwbgK8D+PcHkIibjob5o13A3XypWsAkG1cPA9PDFQDZM1id0i1KxsWfOrKnAFXlifCFFMMRcASigOcs2MGAIfE9iWXplS6On7UbmPaUUTXQrgsVMzcRj5Folg2V5ayUA5BWYKwOxKUafnosWjcJwk+7W5F2EKvlE3xcXaNYfiCYsGkA/smuqug6hcleAnAImPbO6YwRpMgjCAVAm/yQmKTv5hNsAf/i7SyNBSl2a8Qv/4/M1yF+BZSYlNQCnnVrpbC+mToAACAASURBVJcaI7sOSEY2NpaDXLqpR+vE/OVksDgImgGgghHoYJbTWc7oJtFWc65/cg2AYvh2ALsB3AzgVv95nS/f4QdsIkT9T3cBrGtITWZfC5hqtQHInsEGQn3UDDvEDEY/ICf7SxMOrAg8T+c00JGkvHGd2DABUYZIAONzCUDppCFhSukCBsLQrFtZe/IixYQpSyEoJoqnuPWrVRAubQh83HNlZB23z7j1ywmj6CIIqUPxw2Xeu9bx2jx10wz4Z7sqTYZaDD8EIDuoE3hMVEphWg66JIp90k0sBxBcy+iPIIaT1RtEsHS/yIAqw+VSNPWQfe5tlVEk8auXgVa5BUsEJuT5uoliAbE5AGotmIAjCPnR9xDG3TQernYAUupTdBGEFMf83OkApHG+XlvTAPwfuyrgSZOhas3u6cwTsUBVn2gTwyFMi8wjHZAA1M9fYGHDULJD1m8Cpa8fRxDad+l+Ykf/3XNvd11U+qiL39SxXevSsshdDFvgbI1O2AwAtRZMZzTBRuDFjxe1Xg8QEIB8yyj5yYIUxfQIkfkIRnmHCM712JoG4FsdgHHp3ACoMH2G6jM4lWzoQarSvwQ6MSB/vporVaFkh+mCLlpVR8Z+dqDZLoDOpHSiQeAFDkBjPrlgCHgCUaFifg67H/9uYjn4Ai1vpTERTAASBaoQJBAKeNqHlL6mwPDZYAOROag/EYRkPX34MwHIvzW9rQcA+TLpI22G7EcQKlJGsYIJhC6ClUMiXfBTbFUQAej6nPS/OuAl9pOOqIc2BLzg++3VmWgIEUz82cRuCAtLIHQQm0gO52uOAb22sC3JEWgRfPpZf2sQBQIgLydPEIFGwPEj8MlF2bSbsulghLftqsCXq9HGgHysznrGgi5qzTUTFH8FLhAUn3hIJwCN0HLncw37qaF2zoYvuKNivmQIuUNc7GvWt6sHNs26twA6vhyq8NEMAHlyntFrDCcQehyaPTl+FwAbXDcmAKMRThakEk8Q8kPg8SPL0qzLBl+A9QCgR6uZGs3vfHz8TtBZvkgGQrEPBVAUg2Sij50QAOjiVKI3saADJRm7dSLYWfSFDkCem/dhZeMy9pPY5QvSDYQyUJoDIK8qMezh3wY6fSL49PcGgCAA8pScJLIgAUYQEmz8RPA17StvGoBv39W24eREiBoNQSgWNI1HBkdgxJSw1AI+dFIbgOYmkjimQ1r6XXC3rAbCHycAgytohf8vsB/r2KRaRq7zpZ+D37HMX0s3DDcCUGLYaw53MJ4YUODzusqlGCQAOQCejuxA8UULUkxIwAmMAp8Wa3qkN/R9W+sBwOhIEPjk5SLr8HeKFbTQfb77csPIMHGl/4MPbReslPhNe4+MiTpi9AFGV4nI7MfvagNQLh/pfrYnDAS8aJQ42A2w4em2cAyWQUuJVQTGWLs1uL7DG9J1RjhA+jvYk4t3KXeMqijpzrud4At9z3XtP16yGfjKZmCGooYh1tZzvv8xXPFl4PoJYC97k9FlwZWD+Azi/deMZWeP13eQCGEyoERudChIjbb3mJYwH7V0QIKuCwj/gfMj0asn2I0FXRSHXfL/iRkNgLyeVj8ccMY//J1fyxzTAXT2+xoQViKYD/1hDqLxPiYxTgSvQrphphG97tz4Slqafnj7uk1kIQDZrvWTw8B3jwEW+RLxPgSiCERdPwPR7+wCPg/gulFgfruDkOMQkFc5x84e708JAMmCuRNBXi4TIg5CGRzGiBGE/D4E/C2r2vcAYJoify62i0aJSMhB+2IHoNwu0fkcjQ85pu3ack5nIBREqneYFyWLkAXIJHESe00Cyx5QyeL6F/tyEcDcrOW2n7fX8df0mME+/vQ/PQjhoy3gzo3AISYf80MQaQx1peH9wb7v2mrtmCBkIMMejp3jIJD1MsaxaMZ8v5N/67INAsB3BAYU4JL4DSo1J15AFPAEwuQHZJzkKfUAtOHLJSOQRWndBYQvCQA01cfnNopfsaCJaD2baBn79QjSTiOEP1EcawIpkq2kegBTNgHWEpOKF8Uwq2NRFPM4AqCf46/rA2U9/uVDvurB01zvAJpiiwOl3fEeciCGF+Ij11f+QkbSfMPfIzqw57mEFZ9Dl3Ps5HXWAYByHJAJKV7N+s0cCQQhwSlfm4lGZ0KB8C/rABgZUS6ZHITBSEhCowUYAAksF7cStWREyxRwtuPpOlgw+5s9sq6OaIJIIlUgEhA1edoTgHxa9HVw5jibZNF+j/9yGQA/7pbujZ4bwv2+cWB6tFo0NzYnkxFA+cvEAo43VBoEo2e+48EMXEOmD9F6xhCE8RwZEJ80VblKvDlmzwicfqy93/o+8K8TwB2jVSgW138FrJQTXBNlnJgmrjZwanow9CBP/rL9wF0jwAGWDtFyoN9PHutnIHT05mPXz93dMGQAPniJsjiBXiTbxDZFMF9NLUPQxKR5qezz1Y6/YZDH0D6GkdAkYJIvRalAdHAMmPZoYhb6NhDWvEyf/ma737CXN7R1ZC7hUbPgcFgqt/ZZjADnM1xqEVhYBpb4CUk5UsL7jQvj///5buDrLeCOEeD+YQchYwG9VIfyg1NaZszFiCH6DkRGLze5/dgk8IMWcMCjdCiCzR8od1B8OTwvJM8JEShFut1fzMhi+eRJr6LI7hYP2M/xVLwKNoZjUTwRMAQQmYyhWGQxsSADOflZ4kukj7PhZ75bETjBpkAGahMkcrGgwhsXeCyBHBj1wmOBQwvAwqKzoFeRV8ZaerjKYAuirmPY/o9X7q5Cyr7fAvYMAftCPGAEoYlBiVtFwLjtp2U4irj7yOANbi+crHyrfCbTquJV44O0F1FrwQGIMZFqdQDyP/gGSZ8TC0ZRRsOlVzzgasd/u+zpMByLehAfCgMQCDyGZJHFCCgLZ2f8mgI5qauEcVx9e5vACTgCTwEMWr5TdIpWKJb5MvrnoocDswvAPAG4VLGg6UKeqmi4iuDz4er30oX0FP7u5moMvIf7W8B+jwlUNAzFnlZCIhvGFRCeWzrgXSSIBreXTFZSgVLHAp4UHOFuociEEsn2PJwl/XEk0dzfSojeerFg1IOo5BKAveIBex1P67lgUzgWQaJwLAKRH04i14ItgDKEtGsRnWx49b2Vkk9wUefTGrKCF7R0JxZMqxN8cmPAxWcAcxGABKEAKPA5u9lEaAbCmKMI+sDN1X3z+ro24wEZFc0VEE64ABgT180PF9ZdBcDb6JpqcPtPk+1ACbmKjJnllwyuILunEAWjZHkBsrsRUnfD0qEiC5IJfyisgMhzWhcP2O14Ro4WbASgAMQJ48SJwchmBCDFa8qpyBbSP7OvU4PQ0p2W7+LSnSJUFOrI4V7w5IoBTQQTfJ6oTSYk2mQcpGRyH2syGjIF6EM3V/fM++C1CfwUExhCsmzCaQT43lZC3e1hBpEHh36XEqrB7Scmq5dV0XZxmV8WuDFzAF9iwhow9seAGoBcGtKjqAc+1l9rLb/1igesO55ysmCrC8ei6IxRMAKTWNBi6Xw98xNTFUi0jEcmpYgRAPhddpVi9OIEPP5cYD4CcLkCooHPwaW9kV+iwWrQHT8uA1fd3F7DFvgUHUP2k8jTiogAqLoxFpDgbMj9jXSuN7i9dLIdaxzBp5XVBMIMgFEnFAPKT9qPd6A9BIGI7MfPmf4U+40HzI8nWgq2PBxL4FEkjKJixGRRFyQQPzzd1iAUzCAQas1YOmAEoFjwkecDC/PAwhKw6CxIkCXwOdVJLxTobMjBdyIgfvimNvNJ7Evf4jWtdnRYD1YNGVuG93VWuWs4Jf+mlZCCZxwP/cnJ6mXVKk2+tK8lQQVHRTGc64SDAZB3Ey3JcxyACkToJx4wHl+YwqloGDICmYmTFgMQFBET8yyYzyAG/AfWX8mCGQg0BTRoHwt9KVaPE/HQ890AIfgWK+CRAaMRYnVdxHbhdY8Wslw1V93UDsmPIj9GxgiAioRRMIJNvoti+SW/Ikd0gwAU8+XxJcbGITJPDvI6XdCFREFSknTB83xka40H1PGF9dnycCxFwygkK0bASJQSVAbAYeD98xUAe5U3jKIwBosSgNsuABYogl3/IwgFPrOIg1Xc4ZrpAsSrvruykl2ucykapkMMh4CExD5DwJfWAYAxwk4MKPAJgOIjGSEGwuCakRhemw6Yv0UUwRf7L00L9pnsNx6Qx4feY4O8pDEcixOjsoTKKpMYjSFYYjOC8Eq3Wnnr0YYS+0Tmi2HysrPGLqwASNYzBnT2Mz2QD91laxLB0gs12GAh81cf/o/OcHyJ+qj0S/zxnhUZbSyYWaL8+Rq2S29wowiWkJPan4MvgrDDGAlRe7KIywDIgR3meEDWg9HbJgApNTkXo8o0i7oVgxnEgFr8F7jEdnU5GvqfJQKQKyEOPlsNIQvyvupAGHS/Okv4qv9oh+PHxMLk8ggBCRxvAmEN+AiEzz2iQfQBeNmkh4K52hJBKOaNe/FSLobLRXCz43rQnu2yi9oMSMDxs2jo8303ERz1wsCGZECF4kd3DwEYYwJjhoNlQrgIjlYodbBPrwMAZfEmyzcIv27gs6XDzC/IR1DOgA9a6DRz4wZAsZ+LYXvQYsHoD4ziOFklna6YD3+nnU6dZ7bGDAcBUImIAmEUw/zbJ1i/scGNDJiLXmle3RhQ+l/aq57gUQCWzwwBKPeLsZ/LFrGg/ShRXAe64Ajkv30kALAjF8R11Dy3K7KRwJcsUTaqWScARou3w/INVnCH+A36n8RvM3nB5XP4oD6DATBYwGb5ajlOLOh6X8JaBKRG77+7ygGYp1bn+V25/01AzBnwQ1ypanD7KWfA1QDYC3zJIj7KgOUzc9nFbetX/r+O5biwNhyX5uSEDr5o0xsJwLp8/m4A7GaJUv/j3/5+HQFYJ3oFPPkho/hNeqBcMkcB2BAA6XrxmMBkfFAci/m0JpwzXw0TXvXtzrz+PKc/Ml/ugzM9MDqCAbz/keVjjGcQA/YLvjoguo1mRslRI6RwfsiA5nqhL5D6nscF8gfTdfxpS+/hLzvWfzMQCoB1Fq/8b3VWaPIDZqsRV64DALsZHVHs1gEvsqFAeBSApQC8pHK90Oql4UEAyvCwNeGcBXNLOPMLftgZsI75ouUr9ousp2TEyIJ/sU4AzC1e+WIFshyAHPZREVwItrrD3wGAhibTYBhxVpe/xePyrNBuWaoNp3DgFwC81O+RAepK/a5Lfe51jxr7JwA83nPXYgq1asl0yX5N48+f4VEGLATlK1vAo5YB1gBSRmsM+NFE57lcfPD5pPFWCJImtyvGgGfOAacBYO59zFglgHgPefZsXV6/gPXBYeC0RVgyJNOGYuJjPka9eHWgjL9bWzhWk0/n/wPn+k8bgFNmgYcsVflZnBRmIShtJM/m7JGibGBoOIIez9wKPP4AcNpylfbNlGfdI+9NjBjz8JVzppckZuJ+dBw4aQ44drk6j1LIY9JkPD7P4s2lwVEGLHwJnncscNIh4Nh5YMsSsHm5ndOu1BGFThJ8/K6JrZtoslST2+XHA6ftB05ZAE5crgAups5TfaL6EF+UyIif3gAcOwtsXep82eIYY9JkXpMgMp/AeZQBC2b8OduBYw8C2+aALQvARgJwGZhY7swEzbNa88IRvAVO1qkF91J36DNOBE7eD2yfB45fqphLnevzdGeBKBfL8UX5/CZgyyyweRHYsFwxYHzRNK6oetSBMDLjUQAWTPqPngpsnQK2zgKbCMAlYMMSME4ALrcnR6JYQIwsoUnjpDRstOLy7cBJB4CHUGwuAtuW2nUDVH1EFUhycSwWjGD64mZg0xywcaECoI0z5P3X5P6nWlHdgHgUgAUAfOYOYMtBYNMssHEe2LgITBCADkIzSJZXpCOnIg25uPrhgnupO/TyhwLHHwSOmwW2LVSik2pCrDsQskzNIBGIpBdGI+VfNgMb5oENCxX4yPRjPj4xaJ0+WGeEHRXBDUz2Mx4FbDoIbJypADixUAFwzAFI8KUJChMV2SUaAGc1cE/xFJef3FYRti64nkqWDrqqEhbrsm5zvZCdPCd8nHzJOLZuABRz9hTHZwPL7LnLnoNMIY2VyaKcjtZLHOAbNgNPngKe4BacfGF1pnydD+hphQ/8XV5UiEueLGnDN1tWXj/3/4cTwAUzwGPcRcFJiDpPt3FLmf5vjwE2HAQ2zPrEzDv7OQg5OSM+ScYQy5Xbo8465u/ZfLTJ7fKHAdumKxVh8wKwealSE6inEoSy2MWCdbUHIghv3AqMzwHji9VLZuDzD8cXxxWZs5c7apmW0fMBnIHKn5X7d6I5npvRz94O7LgXuGIReJSb+Xl1tzqflybwRwqf9i97BQRWomWJQ7oZVFtJoqDX/b/oGODsvcBTATB9gsfGqmzdjtVz+G+PAyamgYmZCoDjFE2anCVg1CeJwOMnTRB/DmUINVkkgia3y08BtkwDW+YqAFJFMD1VAAw6XG61R31O9/fdrcDYPDDmY0zjc1UjivBuAMx1QdMB+WAYXU8dhEU16dOSkppbcHFSrng8MHwnsGMPcN5ypURHp2xMIa7zDz2z8Gn/kVe0YomO0wEwBYKujL7v/zHA6C3AxfOVh58g5AsZxx4fZM7sf3h6BcDxWWeGBZ+cMEFiwGEHHRnDzun7ONHs/djkRgBunql0VDOSHIDU3cxSD4aEajhFXS4H4S1bgVGN0V8we7E0Fh9jVDG6Obr1LJMRwn+kOCaTEYT0dsfqZHXl/p7PrLi9wIY7gO0H2yAgCAWCWCowKrYE8nMLn/a7PQn9X7zIJPPkCcK+758y7x7guNsB6l98gZjLLYet3Ay5n0sv4R+fCYxPA2MOwLEAQLIDPyP8uBg2cRYmzFweAYilKkn+OC8/Fdh0CNhEA4nGA40kd6FES13WLO8v1qHKAfh9B+DoYjU2Ak/js/8NAIwg7OUb7LCC+WAfB4CpBJoIiTRNRmS1l13kqWh3Adv2A8cdqqp1MB+aIOSxWv6pq5D2kkIAvt8rF7BLJksN/jMqfa7v+7/Ak4B3A6ceqpasKMq5akAmlLWY37t8ZW97PDB2qALg2BxgAFwANEGcnI5JcrDZRPlkaXL4u1KJUAfAjbTQ59x6dSvdLPXAgGYshZWR6JIRaXB/NwFI8C1WwLMXzMeSwLfcXuKrA2G+wrLCDcN/IIg4ERRn0qvyySAQX6mG1XuA4fuAbTOVwktRRr2MLCoQyvEZ/UY/WwjAj3jtFJZkU79g1ghkgEBf98+0Umb/3A2M3lkBl/fOcdMok2EjkZyv8773LAfgHDDKjwNwxEUw9yailpwdxBAEYhBbAuGzG3aKkQEJwAkCkOCjlb7Y6SYyf2UwlAS+vKYnAXjfNmDEX7DEfA5CjUcsnzvbu1nDtUMmCDkRZEEyGdlAk6G6lQTSa6m0MP6HuY73AxNTlcJLZ6WOJYC5/CNxLpHMgdKIKNl69Qvu6/75AjHOiTU87gKOOViJb748BKCWrnK/maTA+58AjM0Ao7PA6Lx/xBAupoYDC9okBRAmPdBZ47lNA/DhwMRsxX7mPgl+SrmK5EaRNRslXFQ9CKB9DkADn79cZtkHFkysJ103eBbqlh97DpmTQTYgk9VNxu+xYbXKU3lhFoJPOgdFGY+lPkgQxokkgF9Xgj4AvfoFs84eX4Ke9x9fIC+tRfDxvvniif358sSir2LCj5wNjBKAc8CIi2AxxLCzIAGY9L7AhGIKgpATw4l8wToB0JjPrfTkp+SLQbHrOqm5jNyajS6VCMIpApDAWwQ4LrGgXqzIfnq5cv0vN0ZXHTInME5GBNLb1DGdOYQsI7AfGKFjlgqve8wJwG4T+fuFAFytXzCLb+VgWnH/fIGYfc46Hs7iHC8ZkPcdXx4VfVXJw8+cA4wIgM6AHSLKWZCTESfLfg7WsIyRF3ckiRQ+HACXkwHptyP4KHrpJvKVGnOhRF9eBF9wE0mUEogz2wC+WGI/vVxiQQIxAs9+rmHA6E1YFYB8DJwQMZl0OrLZ++i7sfT8zroYHLS9df4RACWKxSZvLXzG/fQLZqk2gqn2/vUCUQ9UZaM9wDaPeSPrC4A5C1KV+NITKwCS/SiCR/jRBDlLmP7nHynsxno1IPwJSyRpbiMADXzuPDYfZfBTEoAmcuVQdiaW0zwXwQsCYDYmMaDA1wG8TBSvaoR0G77EcGSET6hjOvVApfRPAUN0zjr45JzVcSqiTxD+VeGzXku/4Nr7JwDJOkxFIwt6j6+RqUrlkO4bXzp1gCAAv04AzgLDDsBhKugLFUvQUhTwCEKbnKCw14HwJ9cDgGQ9WegRgDI8XEcVEDvAl7lVlglAgi+I4CR+Zf1mLGgMmDFhBGFfDCicRJFERviSABjLS7FC0MFKMU+07wOPE0kGvaoQgGvtF9z1/iODkwn3VWoEXxres5ib9xx1wZufBAwLgAQexbAD0JiQwJOuJBA68/H3Zhk6+3CifqqwWNMKN8wjKgbk6gWJgC+FMaBb5vJVmsUbV2vCqo3cRWZcCIACoax53+ulkqNd7iqOcU1WcC9cxEm5kQBUdZ+sTnSL/jEtTWngi21jhJNJBivZBukXvOL+yYBkcOqxKjJ4AGgxzMrBVwdAMmHrZOAYF2l6y/mwV6xD17zmWo6MbRyeWtOHwxJ91IIhr6rqZS70DPPLXDVUrfBwzHKr1EUp6/h0T/6L/GcCqslt4IhoTcwdAqDSs7I60WQH6R329pHuFyuXDJmEjuOSbdB+wSvuP5bGUjmsA5XoUvcvBXKKAQnApUdXwah0b8jXR2YzJTsC0ZHB33FL+2yiX3h/1YeD1fFZGT81g/H6yqkVa9YEpqMhTADle8erHA6t7Mh6j4ZBXdBGjFyO4CSIm9wGBiBvgqxwIAJQlXIyEJLyI/i0SkAG/FbhaEr6BXfcv+5dLKhCg4z1C1HEBJ8+BODQGZXfk/quAZC6ketAZEQCTWAU8PIJt0fgwHzZvVWNaKqi7JLOmtDWFy42g1FxH/XfqGkII0C+a0tnDkfsGxQjn3VPsk7tXmuy+Xp0JhtoJosAaFcUAJUYKiYJxcqHqKAH9rPlG2cMrmCUbMX9guMLpGTcCMKDlZGhMK8IPnPIn1X5PA2AwegwEEYmDGBMjOI5whGQP3NPBT7VJlRNaKvF4t2IWHbDErtDlSk1p4lJ7/zd246tglGZryIfrFhQ7pU8WCAX0ZENG+57U14Z4YrCeLrSxXdev6TfLwrbxT7znMrfKQXfHLQCnyvmRIv0Q3430ezMmL98P393G3wqz6am1NYzzoGn+svqRmTAU2citctqAX/2EI8F9ACEmLHXLZGoFxtSl2xyK2bAYwrj6Xr12+1noL/jUTCD9vvFrn6u0v1/nvGkaoVBAQi0eummMAuXQHMWJAA7gCixG8U0gFfcXdlBKk4Z6zELgAJfZEKrxpC1xOIl/+Sk7jkcdYlSco90y9+gK6vJrRiADD0piad7RuFo3udNCgft94vCdrGXn+tujgV3QAcHLcFnroelivHkchEL8ue0uQ74S3eubAITS3IQhKkMRjBMokgWG3L//2z3VSnP4VDgQWxUEEUxAZFHL0eR3HDfm3IRbDHkBfF0zy4EIKNhSvr9goGEBdvTz/MIYQLQdVsTwRTFDj5jQmdArRDYJQNDSs961R3tPhx5NXoVgoxleHnarjohgLec3D2HI492yQNvIwvqO9fJm9zKGbAwnu6FhaP5pFuMg/b7tTbpBdvTz68cz/zI8azVj8iAHTqgmFHXDUB89R2dtaC7tUGw4kDOgFb0R2wYRDGZ8g9O8aU4XwPOczhiwGlMjqqLWiFYGu570wADFsbTvaxg8nkow7E8nM/atfKzln6/1mS4YHv6BQ4+Z0BbqHcd0NwwYbVD3+1yWhXJxPBrbq8AqE/XApSqAxiBV2MZ/54DMOZwKE00rnDUWcR5KiV/brjtSAMALIyn+/mCyeehjIYp6fdrvVELth8RAClyHXxmhPi6r1m8FM0ucgk8+y4RHC1kAK/5XgW+2hZYofafWcPq1B5AqDqEYsQ3nepR2gqhV2yiol1COkD0C+aOaoGx4aL7DQCwMJ7uVwomn4fm7VrX2u/XAlELth+5sHPtN+l/Ap6sX2dCsZ/phZkIJgv9l++1wbcq+2WFv2NXIjNKAPzuw7MUAV8DTuynFIEsQy83RgTAhiv+NgBABaQOGE/3mwWTLwAqHnaQfr9GnwUbARgDNBUlkpzQboyYCyYDYdILdf0l4NduW9kGoa4geNdazLElKoA3Prx7DofiETtC6XvE7hGEzJlpcis3Qgrj6d5UOJoYDcMglrX2+y0NPtl5UZUjkfx/Hqbecoe0OZzdF1gHQrln9Bhee4s3f3Zxm4MvAk9VSFdUIw0i+Q2PaBtISiBSSFgCYMjMW00MP7pwvvLDmwFgQTzdHxcOSGvBg/b7ZRZByWYAlOERluKM3Ra9CKWc0q73dTBhMFT4ZwIw9l5Lrpes+HjeBiGCUOKXeuBvPcKTiEIOR0f+RhDBMYi0Lhea4GTaa5NbOQAVDzhgPB1La5RssV3rIP1+7yy5OAADoAchEHBkFbKfGRpiweAPtMs5IFNokyOGk/7rAYC9OhBFwNXVY1at5tftCBHaWVS2AJdEcEinrDNC+Lumiyc1B8AB4+muLARAXTDCWvr93lR4/Z0Xt6ODFQkj8WtumEwHTKDLQejAfN3uds/dfjoQdatGLxb8jQBAYz6/boxiFgAVudzNIc2/s3xLk1szAORoB4yn+2DhaATAGJCtbpkCYq9+v4V+aBgAQ4i66XtaC85YkDog/zdZvzUgfN1N7a633Xqv6fe9msDIHfNaB6Ay2JRE1AHAEDIfI5nzZCLeN4Nbm9yaA+CA8XSsul6yqV0rJ2WQfr+splCyCYBR/HJyKX4phs0PKBZ0lqOYTpvniAiUAmAd+HKjo1cvDjHgr+3wPJQsVCymUZrPMuRsRBDG4AQCsunyJtFGHwAAIABJREFUcc0BUJlxQoH62q8ST8cggpKNAFRGwCD9fkuvbwAkyGgJE3C+Nz1P1q9/T3F1EZBxvZh50s6AEYC5yyUHXt5/Q8zI5/KrAmAIkkipkyGPYwXz1aRT8v5ZO6jJrRyAvKOvNXlLazsXs9bo/ztc29Pohgotp5J49Rcj/pzfIwGS//3OM4CNd1dpntQpFUmjEH4LYIgnyn/OLjL8FeDGhwJbNgFjI8DIEDA8BAy1PFK7FSKf43cNKrvHx+8C/vmxwMgmYHgEaA35J0StpvvzL/nP8RbLAfhyT207TChgDRiu/ZL9DsfWNABvYzbhCDBKoBAk/pEobGWTqp819hzQ1/0k0PoaMDEJbJjxVZFgDad0SaUO5LksWVj+XScDmw5UEUDJ6U4d0nVbC91S3ovfVHp5al64cgC+k7mZAP768KCA0WD3A/ieLz090CDceVmlAuhBljLgrfcAw6PAyDAwPFwBkCAbItM4a/FiNtERjBl76W9ffD2AbwJDdwFj+6syImRXrd5Y2FjIYcnzWPLEqnsfC0zsr6qBMQmfIDR/pyJ6xMhKyMrSDiKD2xja6TADTt0/AGAs1KcAUCFrOLF6tbtiRVFavT/wuMCa7MfVTlH098YBeBcwNAIMEYAUlS4uBULOmK3LCnwOPANlEIOSoF9+C4DvVoWXhvdWZVOYqWgi3vOXDUQhgieB0EElViMYJ08HxqeqnG8D4IIDkAzo51DKQQJvBKUmKACzbM4+5hUivwrgiwC4LzvjmgCh6nBcgiMTcv9Abo0D8E6g5eCjfpUA6AxoQIzgi8ALmWwC4z//DxcPPwBak8DQFDB8yJPpPZHeGCyC0KN5DFCByfh9/+OAsekKgEzCTwD047X0SCPM1IYQjCv2E/MJoGVwUUQoPboq0MdqkWVn7RtDDMahB4g+P6qhXFpjVtkDtRGA2nKjos7IyOyHFUbIrXe0FXsTuzIYfNb4O2M3ATGIYQOmPn6hG6gi3eUkQQAeAIYOAUOzALMVh2pAlESqGFBAXAYOMQVjxll03iO/yYKRAT0FQXkwZkjp1pz51LO2XAT3KtD3AIAwj4Wg05kfiuUHYlsXAJLVnP0INLM0OYFx78AzcRySeTsw2AJueI+Dj2Fne4EWKz5MA0MzDkCCkAByUWqsJzarEanzj2zXwjEGFHuGY+pYsMojzZL1G9EBexXou339IRBrC3lJGmNDuSHX+w7WC4Cm6wWxm8DngLTImgC8pBcGBuTXf/1fXnyTugnFwxTQOgi0CECyIFlsvvJfEnh0mhsYI/s5uxFYi1xZof7oOqSAawwYjRGBzYGXbtWXaCIrlvHUagX6SP/ruMVYCEbEqECXAMjfree2HgA0ESur1/0vtnNwGSsG0RsZME20/+/XWH6Mugk/yngPAGy5GDYALjiIHIgRUIrsZjM7Ax+BSx1S4pfffQVIep8dL7dMDsTGjJB+CvQxTHmdtrw4l0CovFruC2NOe975egDQsCXRK/eK634JhBK90q2C7I1i+Gt0jxF40k1cPJAB7UP2m3MGJAAFQrGei9iUTH9yBUDTHfU3B5+BOIKQ43BWtNtPcWIOzEZE8FoK9K0DCGNxLi3FqaKA9gTgeoFwPQAoI0OulWT11oEwiFz7cwbErzNxWtEYBB+VY76Vh4DWrH8IOoGQ7Ocg1CqMRLPltmxvs1/SHaP4dcAJePYyyUCRIzrTB8tE8FoL9DUMwl61kQQ87Rmy2PS2rgB0a1ci18RudEJH57OsY02y/+83/sZdBKr4FXQTApBvprGgQCg9UEAM+h9F6ugJDkC3gJPBEvRGrYoYCBX9IxEcS5K4i6cZAHIw8oXQ4mLBb35YH5d7OekadtTV1UZSjaEIPH4nQzYNwgjAHNwDuWGYpZc7lzPfX1cQur5oBorfzDf+zi0yVTuSkuxBI2Q+PhQDIUEnMLo1TBCZLufGw/ixbQa0KB8CTODjPohdY78IQmfDjmW7Yo/doAX6GqIiAtDHaYswSmeMubV81kp11L6hy2PdAcgblfslOKC1IiKRmyRxZgV/8++DS8BFrxXi5Hd/U6MeSKdqEsEKhpBRsgRMbAtuG4KU/+9ry5brzP/lPVMv1EPOQegharrVcgZUhVHFxNPcp9VFtlOWkL437C0WABWypFRGsV0sb5Hn2zYBwvUGoKl10v1knDgo0y7XA8Pfv0UACnjaK33Co9gJQAOe64FkNvtZAHQdjz9v2Nz2GSa3jYej2W3KGuZ9ixGdIVSoKT13B2s5AHkGheST6qn0erHv5AIgAAU+LVfw/wq3CEAV7clBKDDGZG9/5oVXx/oyYARczcqH5GyH8eFplTawFvAtrtXLGpNrQDGbejupB3omlIHQGc/ErzOcGSRs8zrhAbbuL1Tco/JfbLlNwHOmi2kIcs3owbdwNpYtynDQhsFcgvuG9/YapGFvYX22zZcAU0/GwA2LJ/4AmGF9mwEbBu98Y3cMF+uAGQCj2HVp3BbPuo3IlqxAy5wHAq4OfARmEBXGfNIBa0BIsG0ecwC67merHgRpZLwocrWaovuTxew/V0txJQ2DWeae3WAGbdhb2DB4+wRw7w5g8Qpv88liyGtoWHzMi4C9fAEHbBi8kwUKu2xNAdBxaGBLbJdZux1LwAGECYAEm6wyfpelJrEgFnRDxESwgyUxIUsVMwjVy5AYO0bG89Auu1/5BF38KqjBHlUAYXsteNCGwTeWNuwtk4JMkrlzGNizA1hm69g1Nix+zDOBW0aBeRZZGqBh8M4emfWNADDT+zqMjQyESdQFHfDbZECCLRgdHeCTe8CBaKJY1rDnBRCIAuGW4TYAZeFG8ZuMkGiQ1IEwGCJtHZBmy1obBsvVMnDD3jIAerti3LEBOMjGcOpa3WfD4ic9t6oveDtLfw7QMHjnH6wPAybW6yaG4+8D4HIQfvtDIVtLejpBFsVvUI7NIBHw3DUjRzL3rDVtsYPOkAScuX3coNDynT2VYJCkn+PjqvUD8hVbS8NgjphGxcANe8sAGNoVY/824BCBtIaGxRe8pLKZdpMkTvXiJ2toGHzSNHDPScAyq3er4qPyGaNc7JCRXWLT2TjwGmCOeQashq6+qSpZmp8vojQpheF58ncdZVjLnjWPHr4VWKTKxrHGUqq97qXu3jp0wPy+eEC/DYNZsZAO6IEb9pY9lNCuGPcNV830ZmkM9dmw+OKfbdcXvJMPdY0Ng0/7GnDXKcDMccBS7MwdKz8KCAKQIgY0MWGCtr4TOHAasMwOkTqf6unyuLykfd254nkb7qsw/iVg7jhgmSX31Vpd9yRHeLx+zRhjEGRbB6wDYT8NdymyubzDzCCGfpMJWfSRYfr9HP/aMgBm7YoxNQHMbQHm+ID6aFh8yS93tAvGQb7da2gYfPoXgbtPAqaPA+a3AEubgGU1RM6B060fgkRoCzj+TcD+04CFE4BldZdRc4/YxlxgjJMewSiwN1zWfsOngdljq3EmY08vm5i/7j5yIMqpvupKyGoNg9lngYosl9wY/0dZdrMzYl8Ne8sAWNOu2MA3zw/F2CoNiy99XbvftrcLriz6PhsGn3U9cM9xMODObQYWCMANwPJ49UliuW6SaqqBn/gGYP8pwPyJwNIxwDK76ahDeN6uXYCuYyABkEza4LbpY5WEWdSLxjF26/dQB0SJ6r4ByAN6NQxmkWcqrnQ00x1DEDJFjR8CcNWGvWVPp6ZdMQ6OVOCb3wAscPJ6NCy+7PerkP5Q3tBY1PrT9tEw+JwbgPu2AlNbgVkCcCOwtAFYcgAuiwWlM/XqDjMEbP9t4MB2YO54YJFMo/5gHIcALV1TRZ17FXOhPtvgtvkqf9H4kvHDlyKK4l6VzvVSBF22uwjOb7pbw+CfcwBSkyeFEHAUx/yw9JTyEbo27C17Ol3aFWNuAlgIn9QxO2tYfNlbK6MvaxeMRYquvL9rTcPgJ30TuH8LcHAzMOugX3QALo21WXBZLEHwRF1OgHS2eOgbgIPHA7PHAezNu7QFWFZ7JnXJ5rnqxHEulvlzwyVNN3+wern5Yovl7SXLGwvn4riLWO4fgMRJXcPd/+pmOymELEhRzBxJAo9gVL4kwVnbsLccgHEpWi3epocCAMeBRU5eTcPiy/6qtl0wpvhA+2gYfO7NwOQm4OBGYGaDs+5ExYDGgqP+ccAkINaVpB8GTv4d4OBxwNw2YGFrxYCmV0YxLNYheCXau7EhV3ga3Lb8g4+R45uoGLADgHWqhsBXA8K1AZADyRvuvtkBSArh+i9DsQhCOtf0UUgW/7aiYW/Z0+nRrhizoxXwFhyAi5y4rGHxU66qAFhT3rDSIVdpGHzencDejcDBDcDsBDBP1uX1CMJRwFiQIBzxieL3KIY1YW5MPOxNwLRb8gs0aghAss1GZ1O+SFHsdRPt0i/PLHu++dFb/x4mXfhcbWxhfCtYMFr/uWvKxfDaAcg7ipPCvFOVpuo3HrCjYW/ZA+rRrti6TS6MVQ+L4NPH2nx698GnXF0BsKa8Iab4dFZpGHz+JLBvApieqAA4J8CPOQuOBBAOV0CUYbIskRkAecrvAdNbXc/aDCxSpyT4CEIyTgRgneiLIp3nP6fs+a4A4N8B8/48CUC+ZGJA29fpuLmxJW+5h5kNFg2jiWHSi0r0Uv4pCoZsxw8DUfnhd4Vk0XGdGvaWPaBV2hVjdjgA0BlpkQ/K9bmn/HOVqtClvKEBqlfD4AtmgP3jDsBxB6DA7tdbcvYzJvQJkii2n4NOeMpbgJktbYPGACiF3wFoEx1ZMNe/4jnPLXu+KwD4t/5SO/iMBcXuesHylyACMBPDgzGg7opM8mEHIGdwrfGA1rC37AH10a64Yr4APvvOSdwEPOVbKxu+K2pdKRTmdI3dqkPPVgbSTBGAY8AsATjWniBdx0QxJylOFCcr6HBiw1P/CDgU3EgEIMW52M8YkLolQRddIN1AyKWiBretf9MJQN6HsaCPxe4rvgDdHOcOxDIAcmDFDXvLnk4f7Yqt63gEIB/Yoj+4p9xaAbBHeUPM8qF2aRh84QQwNQYcGgdmx4C50WqCFngNsgSvQ+Dxu4MuiawhwIAXVk1O+e/A7CZgThY1dcno1nHL2oDIyZULpBsAFTBZ9pjT0QQgn2V6ufRicS8QRgbs5ZYpEsENDejBfpoLrwAOjgIzZMBRZ0AHoUC+SOA56xJwNlEyTFw5FxBPeWvlzpnbANCdQ1eSGTRybMuydgMggVBsKmtYoC6Mt8znZxsZMLzAxoAOvsh+ydDqtXx4FIDl8L/omQ7A0QqA82S/ERdTI22mNfaTuBIIxR4BhKe+y61punQC+MytI/Zz/c9EuvyBeetLAfGZ5WOMZ9j2/gqABB1fMLsHAVBqhfTcyH5d9MByEdzs+B50Z7voGZX+NzNSsd8cwUcG5ASRKYbdHRNYwhhDIHRgGmO0gFP+HJh15jOXjnyKblVT5Cbfoq+yJOszF8P8+VnNPlICkMAzds/YLxlYznrJwIpO6egTPMqA5ZNDAB6iCCYAyYBcBqTRQ0e4630SxZyQJQIvMJ8mSeLrYe+p/GzGfnTpEIBy6US/out+K1wg+brs88rHmDOgAVCMnrEfxxMte1Mt6j7u9zzKgIXzczEBOJIB0BnCJoqgIfDEhM58SWzJEPGJe9hfVH42un/Mfxl9bgSiBySIBWnAJBDGEDAB8QWFA8wO3/a+wH4+rg4RLPYLul8tCI8CsJmJMQAOuwFC9qMI9g9Z0CxhZz65K0wfFBPqu7PEyVdWAOTHVlTcpxhXHZLz1w0ZA6EDLhkCskRf0sw4dRYC0PQ/vVSRAYPo7QCdj7GqVOSMeBSAzUzMxZcDMwLgcKX/zbv45SQlHXDIgagJc+bjZBqAWhUoH/Y+B2D0J7rFa6LYDRmzomsAaOeKqxEvbWacHQB08JkRIteSXiSBLYJOLB+X4xrzAzY7vgfd2S4RAKkDDgPzNEAIxMASSWF38WsgkuXLyXTRSRCe/DduSZMBMwe6ObTd8JBj24Aot07uDObPP9XsIzUGFPs5+JJ/M6oT4buxHv9X7BeY8KgOWDg/Z58GTC9Xq5FxTXOw9c3Cm6k5fPcjgbHbgAlvVG2tH1T3Oavoq6BlniZ+12n5u/2sDbOvasqoFg8x2Lnbcd1GdhSAhXN+7qMrAC4sA8sORJ6yHwD28z+Ft4fdv8UyqUDrDmCEBcpZ39kLS6aq9l4D2rLb/KYsFTPWdfbvh86vQu2s1K/K+zIjTsXIVQ9a59Egs4Y6sZfIA/EcSp/jEXv8BWcAhxaA+SVgSQAkGAMICcwVlNLlqTc9Gbv/HAA7MrL4+f1VlXwrUq7SvCoyGcrrWpGhuur2fNGYwM8YT67hT3s1LaZvqn5MLM0bzmHMmIFSgdFNj/mIBct63NhFZwEzDsBFgpDPeanNgATfCtGsX9TIKwNrg9tuVkhlng7TI/YArX1VkXKrEe1l2SynN1RCsFJsqnQv3UIMxhwIRjU5AGN9QUteVz3BUAvahuNgjC3HxLAND7nBp/cgONXF5wCz8xUDGgCjKPbvevlzcKUHH2ag6cnYzepYBB9Zi2FxDJdjoXJv1WDFiLJ6MKqKZUzoQFTfj2HmwTKcTpVWvcxHKm6kKgoORAEvVclPD6NdzLXpMT8IYNPcLV7yJGB2AVhYrAC4SNA5AxKM9ryDPE5fs6eeVKWGZ2M3S3MQfEyJUKV8L1ZpJXpVJ9pLilmlAxWkVJHKwIhjjD9TtVXVm1HdOy/pJiaMFRWM+bo0rWl4yM1N7oPhTJecC8wRgAttBjQWdBBGESwgSiV0Pb9DRgu0TY19N+M1mRKh8niqFx3rRDsLqjgl9yaGXT80vcL1wnE252PAZCzAHQCoiqoW3yYWFIt664fUpKaREr1NPakH6XkuOQ+YDwy4FMSwgU8GSRSz0UJx3Vx/5vFNbrs/EiLRY+v4ACITww6iJEodQKwBIyBRv9vwhKzUW6z66TUGEwhDS3ezqusAyNxnJn8xa1KRPSFts9YfFB/QDZcAm78CnDBT5U8rCqjfc3yh8Gn/hGd/MsKf1+QzYJ4891Jye13iy1cAE9cDJ+6FpYrEkidxDN3OtXR+FwBGMezoMmxJLOumAuD4J4rxJrfdH/XCoLGFVKiUbw+LAPQqWWaMMLrd6/+JycSIm85w9lOpt1j1MwAwFTiqAWEUxeYH5ENn/jInUVHeMXQ/f/jRePvCa4DhTwLHfBc4frGqqaNJzLPw6iZxV+HTplFGvZrXZT45N39+HW3TujlZv8D6fp8HRq8Dts9XIOR5YtakgBgdrrrt5Qsq8Ssd0BhQ4HMwmVitAWHAY/LbLDQNQDaTVJ8Q6W4qVB51OOqDZDPVB3TLOBepW5jmqaLbec3jGgBGMSxvvemDYkQ9GoKF1ShUCSKCqBeQrvmfVZPC1keBjXcCmw911tTJ8q5XgOLaQgA+x/OdWA2EGZ98gbjleTHdQHQN+2iwls3nK3/Zhj3VeQhovYzdxmArSwQgDRA3QiSCJUrTnjfl4KozRCSCCeYmt90EoJJbVCk/1+FiCwFZxLk4dRfLFia6x8LbYkD9v9cXtLG6+O4AYQRfrgPygVIcqyhTXcWFOJH8fh3rz7EKwnUArq8mcGwK2MCC1i7WY7Zenh56feHT/jE3yliE4TZncd636gPFCKWavGhcRx2J+cvs9MlSw0Ty3cCm+c7n0G0MExdW4BMIbTXE9UCynvyCCX+Ovm4gbByA/xisVgJPpXrzLj4EoRJjJIZrWHArS9iprK+KcefgiyB0XVKGjOmCmW9xhRVMUSyRFnNeFGEdI2q+/HFXclkp9WsAbgTG9wGj08CI64WxRk/OTDcUAvBHXSLQxcVCDMQSWbzv+1e7WVbz+k5w2tJtsbcCYV6WJY7hmAsDA7r1Sz3OgOgoM+KTOJbcjSI5yGIaNE1uuwlAAU/MF+tF5/0sIghVLdVdM2S0bSzHx2Mi+FTxXf8X925NC4BycK8QwfmgVX1LlcFiykEMcL2BndJJ7aQfijKfxLGDwAhByM7aC5U4qwPzNwufNnNuOH4VZaCPlPo2AahqFqoPVFc14ga2m+WEEL0cAz9kdPrOmMu8r1o/rTsXz7f9oswFs+jO6LAqkvC3Ggg5Fg6mwW03CUI6X12h8lyfcz3QHqr3DIl64DbqaQKc9mI87QXACD6vpJqY0EVxz2CEyCI5eMSGX2e7VtI5J4yTRyZhscrvt1nQuivOAaNLlYESwcySgiVbr37Bfd0/u31yEgg2FVaiPCeVOguqAfGov0iR0R9JABJ0bnwk9nMxw+fOh55EbgRhzozrBUA1polN9CLwok5HEEUQBjFMQB7D+j656PW+IrJ8O/bBCo4sGFdGejqiyYCx3mKe9/JtTiBvmI5OFiTisg9LtJFF7gZGDrUbHKs79+hyu5hSaUvh1foFr3r/6vZJCiXgCDwVVFJ7MVmRLsrGltuFCc68yFdACMDAflwR4QM3HPoKgIExt4gz42SuaQb8hBOE2oZmlu+KFlKR3QSssMJxDPWbbjpfLoJrxG8CYT8MKGZSVTCxYFTIb84nkCxCIPLDiby30gXFghaF4c2ReR466Uu2fvoFr3r/fKAEFxvpqMcd9yonIrkuK5LLV7MVCM+/uDJCyIC2J8a0z1iwqyESgMl15Sa33QKgmtPEBnp11mwuXgO70Ud4DHWzfgDYC3zBEOk7HlA6XKyHQzb8HgGoCSQLqsxorIy1Bxie7Wx0rFaf+wr9Xv32C+56/7HbJ5VHtRYT+GJrsehHcya57PyKAQk6+vBkBZPpjPEExlwU59awg3C24W6KBsC6tqHR+MidyVG3i3rdAnAsH2T093XT+zLr197MTA80h3SfsZP2UqpCrPQ46oF317VrpeiKXTJ9MhMLkgGdCacKG/mupV9w1/vnwyGgCDCKWzJe3lqsyzLWZWe6/kc/oKzgKH4jC7oolhdC4jiuzM0WPo+cPQ2AsX1obFCTO5Jzn566PwbReiwnfTWjI4KvDoh1juh+aT+WKSYD3i8Aql2rJk+VsVQly5kkddv2FvHT61icqO7Fr71/IkLNXOi0FQjV0046oBy6wZ922Q95ICqDEaL4XWw3COcf9Mw73DFB9AqE6wZAAS8XuzGQIDKf+oVkqxt00ttAc+YT0PJ9qRFSB8xoye5Xu1ZVeCSgCLbYLVNswoncHxoeLwCzBGjBNki/4BX3z9lXgUCyIIGmhova83cRgO5Te9yLgP3MfmsBS8xs8/U67ePQOqy9umBUruDchqo8sHSd3PMfT5ifo+ack8eFHI6QEcnT5GvdOnVdXof+ptJ+BVPWceiaRHA8Us/nkACo8mzqlqmWrbFDppT5A5UIZm7CPA2Vgm3QfsEd909kKIqB1qJAKCBG8ZstZz3xHOAAiwmpDIdng1maZQAkZzsHZ537YfQrwNyxoQ+HakrnS0h1mUA1C96TdJTmORyhC3oeqdwROi+GDhkFI6bYNrcNDEDeAkXwQizPRpmnIs3OdqZPSaRFUcbchHlgie6agq2kX7Dd/+d8lUJVXuUzk8ERmS+2vfd4uvN2VOV5rSwb0y3JhgIh9wJeN3YMQCIgR78Q+nDEVYBYZUrUpbXFnM7COSdf7N4IPvtDnT2BY/h8Chh10MXQeYGS+7GGjaQiABpuNIFiECnzdWJMIUHcazLptC7YivsF8/7FgLFMqpiQL5TuNbKfA/DC46rqqAbAwIKWK+timRUBEiNGsOQsyQm+Gpjd4n046hbT84KPuYjOmHHyp92gcgDS2OoIuVIeh/xyUkaVwyEWdLrewHE3uBUDcKIwnq40HpDXL+n3CzbaKdguel5VnFJl2awaghLQBTzteZ0cjLq2A2n0M6EPh2pC57Wg41poLzZsAZNso0Hw6eVR/J8bF9YjWGmVCpGKwQLBRCcrbiSxNLgVAxCF8XSl8YDHHFPW7xeFBRwv/rGqOKUBkODzqgdWPYAM53vTASMQu4Bx9J+69OHIF+N71F1O1gUB+AsBfFqKC+4Wi4BWX+CYgOTAU36wdMVNVKka3MoBWBhPxyiuko3xkSX9fvGMkqsDlzzHC1N6SQ4DoINOe7KelWWTheziObeKCdARApD1AdVnRH048gKUAmAEYi6Oh4DJV4VoGDWqjq4XLbO5o1jBoimEPhPJmwu9FvnTLgdgYTwd2wyXbMyRKen3i2eXXB245FlVYUpVxUpGiLtmGBlrTEhVUwV8dEkVKAq3MHJ1uzRbRx+OOgDWFX6MsXJU/36lJoEoA2AKvw8+uwTEDIBbStdOs8ddDsDCeDom7ZdszBIs6fcL9ror2C75US9IxJJsEsHdGFBil4yYuUwknofJgF4XcEUfjrz+X7fKo4EJJ//PkMORO6FrVjQMeL5kJhZMMXzLwNZCt1nzDFgYT8cQwpLt4hDON0i/X7ys5OrAJVe0S/ISgFY7j9ZvnQ7I3+lyqpYaL98CWp/N+nDkZdhi6bW8An1kP3fRTLKVWlwF6RZCH2L4zDDR0k1IqeTNb2OQSYNbOQMWxtMxeqtkY6I+ny9VEz6btfb7xc+XXB249AoXv85+tIBVgJJ6n4lf6oV+mfjdDJNMH0wAVFX90GMk1f5TxlS3Fggh92DyN0IORy5665KIfCktsl+K3VsGtpVOWOMiuDCerlSnjQ2rB+n3C+pIBdulz8wqonrNPLKgwKaC5B3s53qhXVq6oDNg6sOhqvqhEr3V2VNLBjmnSSNdrOLJ1zkAu6VPRjFcFz4fXDJ8i45hG94Gt3IGjOFYA8TTlQZ/qGH1oP1+8ZtlT1MAtHK8mQg25zOZUSCLIliWcbw8wfW5Ln04ssqnHX04euiCk6/3de66MPpuAQVZAEFkw2MKFw6a1wEL4+lSBvmAOMhD8vkOkFX77feLNw14YT/ssmc4A6oOdHBEkwXlgjH2k4Nal6wB4fIuX9LzZjAmorNeHMo5Tc0OewHwDTUh9HXxfGJsYkAbAAAgAElEQVS/uvCpoAcew6zBBrdyBlQwwoDxdLZWXLDFkHyF8xGE/fb7xR8XXByAAVC1oB18HQYIT+8uGfP75SCUs1o64he8v4j6cIQ+IqkPhxrBCHjdjBH6AblQkAeY1ondukSiELmsUPpjbyp7XuvDgAXxdNZVvWCLIfmKg6Bbhrjup98v3lVwcQLw8gqA5v9zC9jErutltg8gMxDWWMBaMVkmANWFyEV6R0uH2I1IzW7ypbkQOTP5f2ch9KsFkwp0kQlDAOmxzHpscGuGAQvi6VD4RgmAg/b7xZVlT5MATNXwqQc6KGwf2U2uGV2uzg3D4ua7fDnPwZcKgIdq9GaIBPZb0YdD7hgyIFWMXiH0eQ5vXS5HcMkc++9lz2t9GLAgns7KxxZsCkgdtN8vWD+vYDMAUpcja7lOR9eLVcIP4tcuob/3AOHCdW02VTX62ApB4Mv1v24gnPy9HiH03fJ366KYHYTHsgBBg1s5AxbG0+HLZaOp65i+ln6/YM5EwdYBwGj1cmUkE7+8THLNdAHhwrUOXtcrO/pwhF4cct2oN68BMDCfmsJM/n6PEPoYPp8bH3kCkbtjji2tJJA962YAWBBPZ0WBCrbYsFoOf9pDAiENk179fkuvf9nTXewKcBSjsn7ldonWbgQpx+26otaLIwAlfi2QQSJY3Yjy5i9dmsFM/oEDMM/Z7Uf0RiYUA7J+ToNbOQC3e0WBBm9qLad6HICG1ZK1XB5PoxnuOOIcxSXe/Of8xHV/P+FpwN47gKUpYHmuSve0pKZgCKSq5wqniWE1WZz/xouBm74KTMwBI17lVBXwtWSs+8/vL45Ff3vhpcAnvwos8d48DZX3M2hx9XIAnu0IIO0chu35AOgLL0yuG/jOmwbg028G/mNz1YWdETbm4I5BrFlov+EtD2wIo7l+Atg8D2xY7iw3V5diEqO54mnj6XdMAYcU+6gon7A3NSO2qFjlyZYDkAX6uD5Iam44YaUfVNDNxaJcLIPXcGGpfi6PnZdVD1wPspQBX/wl4OaNwN6Jqg+xwrxslcVFuYJblehkcYYZGPS3L20BxueBcS8nwg5H5kZkx6TQSbXFZcCQKadx5Cz5mPurAFxrRaa17pAR2PFC+ElSHKQ/0QjQcgCyGyM9v3SnsDBRJgL6msWCf6IfWeUJac8UFlpY8500DcCfvgb43hiwZwyYVhd2D/VSrKGAmIDnBkiafEcN9cprHgKMzgNjS1V7rRjRlceyrqif6KAkMgXIM+6tAnDl+zSL36O9+U8p9jGHQo285/2XA/AnXeNnKAorDXH/AILwbSvLEz6Ql2+cAf/3XcCdw8DkKHBwpOpFbE2wadzIdyh3jjNQirYWEwYq+/zJwMh8pf+xKNSwM6DZMmzNRRbM2K+2Ii6TlFrAWfd5V3i/F7IgT2LBF5LbIdkqxLPWvtzlAGQ3RpU3Y7AiixMxLOUB2t7pKQ8M0qCTnp8HkojJgNqaMEJesQv4AR3Iw8DB4QqAs+6SWRiqgJgY0HVDAdBA4Ba4xN7ndlSFAAjAYX4IPO5dBDMAdS2i+Jx7XTf1eEdTDfgAQnR34p/wQkRmjNAoByDT/ugFphXAmjAEn8qaPQAgZCs0lSckCNmVigEbFMsPBBE3DcBX7gLuawH7hoAD7EM8DMw48AhATrjtQwiXoqkTEwWd7LOneXNCbz6Tiq/TInb2M8ZzIFrTQbGiy92oGz7pXl/7jvdAJnb2470IbB3T77Sai+hyAP5voTqW6sKwFAc/TAdc5+3dvcsTrvPVYSK4SQb8xV3+6IaAqSHg0FDVh3iOIFTIFxtit9orL5Z/LD1Q4s+B8OnHVuXwhhdd5DoLGsgCCJ04q66X/Ju/vSaeAxDPvbdtmdtKDV90gVEPIl/xySkviOhmAEjrlzSkwj40SlQZYZ39I+8JBMx8mZryhOsKwqYB+KpdVSDFvhYwPVR9BD7uyX4SwRS59nNI+bRck/DzJ05v12M0nY8fAk8iWL5BB5qASPGRCi8EVjzv3mqpkC9ACrrwhKukB67GhpqRRowQMqCiYbj8oOoHeUWpdYIBAUj8c8WjrjyhNIJ1unzjDPjqXdUjJAAP8TMEzLYq9uOHICQALe/EwWe+QgddAqCzzD8+vgIgg0qp+5nYjaDzCgjmnCYone0klqP4JSgvvK+6LoFPoFMlkPGh+0rPWta4RHTNJJQz4M8EAGoNTPVU8opS64CC9zoAWTFChcq7lCdch6s3L4J/2QFIEBKA1P9mHIBmhPh3Ai354RyAAmWsR/PRs6vOR8Z8FMPS97yxtIlYgVB/I7jC0rIKSfLXF1EEB+BFFjQ3jCLA49OWsRTTEPzvzQEwry7VrZ5KwzAQAPssT9jw1dcHgCrORQCS/bgn+1HsCYQSveaHkzvGv1scgU/6R55Y1YIxhvOm1EZekQWl8wVDxJgwc88QiJc6AKX/meHDawX9z16M/Em7bO8Q08GBP/jEkAEVjMBoAFWXUjRA3KtNwOBXW3EkAZhrALktpC6lKtTV4OU7RHB+3kHWgv/zrnYZl2kCkF4uF8MGQGc+MqEYUCA0n1tkwxbw4ScHAHr71Q7W4++c8czwcBAmHVB/c7Bcek9b3FuwbdD/kjGWgzJjQ3thGmVA3jhfOyU+RxB6FamOFp8NrhsTgLy8Cpzm5QlVptAU+6CiNgXCaIQ0BcDYV8b0P4pi30vfIxD5+w72C9aliegW8MHzqrmh/meuFhYi0pKbs6D9fsh/n1XFMrYMbPgUByCZz6J+uEknDA9AornWFRb01WZEsACoHhOqyC7wdetT0QAK2KqOb5MCUvPyhLE0oQxzqaYNXL5xBvyVXe12vByLADjXAvgxBvSPGFGMIjCmJbEW8HfntxtQmxT0cmxp9UPAdKAZ1upA6EB7qgDo6oCUxXRtPVSpAwJpnUhuxAqWCCYK1MBExZljY5S8SYr+pxAFAuBayhNG26jw8usCQLX0SAAkwwcAEngyQizaXoziIli+Oe7/9kJvNk1LmBMe9ECO3XRB7aPeF0EYHNVPdT8gj016YBcWtBfBVYJuz7mF7VgGY/pO8f5WdQ1/7U67nIKNS7j0wIbDPFZsyNHHY7od/xdlEHj8CcC3TgCWHgGAPSxiSdt4312u/8SPAl8/Dlh4pDeZW2PD4J1c9+uyDaIDkgEJQKnTfG/N8nUAmu5HUnMW5ARbPfEuIHy/ACjRK7FL5pOR4RaxgTHofKl8r/S1ZWBnAGDKefbn3AFIPRPXB7sFiVQimKVgGdl5ooNwLQ1/1U+DQGSXQ9r5Evy1q9rZbP1lGQDZsPpzI8APHgXgod7qUx11YtBbFzC+/C+BL7SAWwhgdoLkONSLqy5oLogYft3ZI1F7EAC+phsAnekokhP4HIzml/PvthQWmPB9LJ7jxkcSr14jWj4/0wFlgJD5eoDw6fe4DzAYPHokWhHJZ3TFSkn4h7YOSOBwEtiMTv1aY0uktFYTmI2/43EMQmCuAJmUE0gmVD8EFdPpdnxhVhqzDr8F4NMtYM9Jfg98EVTeNu9Q2OFZBX7vr9vtgm/lcezczZ61ZNN8DCvilYCdPXqNDQpAlfGTKm0M6AA0PTAyoMSx64cRfPQHXsniOTI+fEWDFGp+Qb9BeySRBV2kpl0QxxGAlHDmkI56X6z+EP7UDYSdRgh/IouwIZ36lHabBE0GJ0r10Rgb/xA/tt/j/6aMAf+7R4CxzuBXWRGULwBfIrY6UNfpvLae7n0I+LO/reoLMqiVMbW38oUhkNkQIzZO7tIweGePcmWlAFTjAYHPVGwXxWoLYblEDkLuTT8MDPhXLJ4jALpaJB+ggU6xfgJknT7IKXIQXh4Y0FZCog+wxiUTwSkXUbSMV1rB/A31OXWuFpPUda/mRHKi1e6U+hA7Zq7l+A+UAfDtHg/LrptkQpZ727cRWOL9542Pa3rOvuOqagUltgtmJM08j4/PILbIDKz6w5PAHsbraTnMGdZWIwIzxIfeK0rn578J3LAVuH8CODRahV/FFQ/1IumIvXP1QudNfyNT8oVqcHviPcBd48A0g2RDuoDqHdb2SalZAdG9dnfDkAE0gXnH5ijWCDbKCq5/MRiV0QD8HgHQ63jG0hdsLGxA3x9Bw1Asli7hO3BwApgng/Gjvq01IHrXJ7q3Cz7E++YziF2rs1ZLZ+8H9jJsSoECWXj6igmR87aLgfbGq4GvbgLu2gjsHwdmCEIPSI1h+SkCRjpfUC3iNWcpoRrcnrYbuGsUOMBo7QBCxSTG/igxVcBIVGPWM1h1JYQPnyKNExGZMDIJ9b66eEBGxPDY1Y5nv+GCjfGAxD+DDpiawphABWZPjwNzNLAEIH4XCH0M7/5c93bBfI8Yk2cgVAdvdT10ifDkBWC/r9lGH51NhIsnsWHOfPmEUKT94WeAG8eAO8aAfWPAwVEHISNQlKQUglJjJExqC+H6Nq93kOpUg9szbwLuHa66QzFWkaFieXxi6hgVHOMCYGRuJ+5V4jYJIDKI9KlsAvFDq8QDrnb8NWVPh9EwdFkQ79TlSMIsN0Mi5s9MoOGno4U6f3YAvefL7Y7rvdoFLxOANSA8f7xSgWmd0kCQbmZ6mTLEnJ0UqWLhUkxlrBn6n3wWuGkYuGukCsufGq2iojnRFpafsU7MDxErJuZhYCsJosHtWTcBe1oeq+hxigJgXBrMmTBPnJKLrr+VED54ibHYvZos8sO+DNcrHrDX8YVVyglAKud0LtMjFPtNMz6QLDY7VomLJd671AEH4Xu+3g7nWq28ISvX58/hguOBg8vtFQvV/hEzxfqOevuTfpjri8vAWz8L3NYCfjBc6ZYHmBcitnFd06pxyb8W4gPlgonBqffTtdTg9pybqiVNBssyUsdUD7eGO9amnf3sXtxQipl7Wg/sD4A8AwHIyZMYky50Tp/xgN2OL8y051qw2hXzwRCEdT2nmck1RxHG+w5jeO9NFQBpR6ldMIMXlFWgVndqF2dVFsJzuOgRwMElB6DcI6rznemD0RnbwQiSRS3g7Z+tVIl7PC9kahiYZm6IizuLigliT/VoUog+p8P9l3wJ7qGEanB77k3VczroUToWLCsABud4ypaLCUoxf9i/9w9ADiICULrQRWuIB6w7nuZrwaZwLBGwClSqSyz3AhHbaRGEFGOmC44D72UVgjW2C2Z4lIF4ArjodODQcqUGqAxfcpG4mJVuVqcL5tbs2z/veV0tYK/nhTAqesYNHdO5PCJZos+WuzxHJIViuXFyJxupNLg976ZK2lizUKodilGUgzyGhokF8yw5Mf+qRkjdjfuDtwkkm7DTkNaBaQ2ox1q3eMD8+B6O3H6em8Kx1Ccx9ptWl9iYIUAAWrI3I3nHgPdOtsO5eOuxXXBdj0V1vOL/so3Cxef60tlSpYwveKf0pAu6ohfdJ8k4CUqgvr5jV6VGTBKALeCAh+VbZLTnh5gu6D44A6H8cVlkNK95O1WkBrfn31R5HSy+JCwPplAxRegE/2T+AloGncNmbQyogUQx/KwB4gHj8YWNTwRAOW0FIIIndoqNkTAxz/bd09XDGLBdMM6/pLKi5whAX60gCK2ujxzEAqGL2pQ1Jis5AJEAFHvTujYAKjRf+SEugm1d2COQLU/DAwQ44caEw8AtZzSIPgAvuKkdrWMM6M7xCMBoiBn4YpCE2NCfxWAA5MEuwvCCEICwlnhAHV+YORfDsWJGgPpMKwg1b9QpFnzHbD2BK2JGul9s8KkYW17vLALQRTCBpzXZpS4gtCXXMAkduuAy8E7PijPWprXJ5CR38ygw1fJDohh2BlRAgq2OeN7uTWc1D0AFNtmL54ESBsCaJcLkDajxj5ZXRiCIGA0waDwgjy8sk5+HY+X9ppUbJSCp6TnFCMXwny1WAFQ8rUAc2wUrRL6mXTAefWnFfnz3FpbagQKLAqAzoZjAKkkpXkNO5GCEvOMLFXOnnC4xIKOjnQGNdWSM+GqHQGd7JSsxUf+JzQLwhTdV4je1nQvr1MkPGtlf9yP2Dy+gAqZ6rQytfvdHSDxgLwBF8AmAYjHWluEDiKGMiqOVvtejXTBOuRSYJwDJAARgZAGWL9Nk+IM3SzgTydE4eec1nZHbtDaNAf1Dpd/SMx2END6kD0oXtFhBXmcY+OY6AFChnKnzl7NfdMR3qCAae2B+VVMYXASvDs3/X/zHJZcB84vuiqABEo0QPnhnwqQLyRURmZBPytnwHde0M1vN2lR6picoKULaxHDIEdHkW2iWg4/7b5zb7DSQAVd0/griV2JYojfpwRGEYsGBrOBmx/OgP5sAKANkcbFzNWTRnX/GSGImMYH/LYlk+gGvdT+bW+SWH+Ig1GqL5QeTtR2EYj5LVHfjw/ZDwL8yJ6TB7UU3VVoTjTYxYDK+Ivv7dzNAZIxpZSiU8jjKgIWTcykZkBawDBBnQdMr5QeTKI5iWCB09AmEb7+ucnOQ/aTPWn6wuzyS4u+R0Ob6CUGqJpIDA97AdqINbgRgBJ69CG4Jp6q/ckjXqB/RKla4WpkO2ODgHoynigA0JiLwaNiEt95YQKJ4FRC+7brKzRH9jZbN6iJYuSHm9I5iOAOhHNJfZkh+gxsBKPbLu3+JgaWDdojhMO5kkDWSlNTg4B6MpyIAjf3IggJgMD4MCARjFMU9QCgAykhSKnUCYHB9JB0wy5aTRUxmup4h+Q1uAmDs+hpXgFLnB6ULONOn5xACNJqxghsc3IPxVBGAiQG9aLeilWUJW1FvVXEN0TKp1C6At19TMSCBpz1dHtT/JH7N9yaxp6QkF73KBxYIr10nAMproB44qQGTj6sjUrtOFPtLeFQHLES9AdDFrq1E6M13MaxVCTNAXNFThIylLcor40zxtgDAPKuVwDMrOKw+SBTbtR2MND7sZwC7Qvm4wqHa4T/uIrhb+7n0EgbQdTijoyg+agWXT8llDsAFWr/B8qP1K7bT0pvtVwHhW6+t2C/m8svvZlawi2CKe37nhFtapkDnILRqBQA+v04AjMyn79EIkXO/DnzyCBwVweX4wxs9B4rRZgyPVFqykgDd+5JSpBU5r0vHyHz+jsc3ub0KABsZMCyQgeExKyFPVIz3lmcM6OfPAGCADYPE67Jfs6h7G0o+xvi7oyK4cLZfOgpsXwC2Lq9MwuuVERonKn4nSJrcXnQKcM7dwMMXgYcsVxkSebJgzOWPqdB1ad2f3gpsnwK2LXWeR9m3danUIV1lBSCPArBwtp+7DThuBti6UDWDmWA/DvXk8LRptfPtNUlihYZTOPCi04GH3wFsnwGOW6iAs5n3GeJJ+KLoE+9VDClQ8R6vOQHYegDYwuY3S6H/iJ8jb11ck0q9Qhoc9QMWgPBZJwFbpoFN88DGRWBiqQIgWyJY3lPozaGJ1KTEPh36zpTkJrcXPRE44S7g+Cng2DlgyyKwaclfFoIwvCwx9Zn3Q1DmIPx/2/sSaMuusszvjfXq1ZRUElJkKsBEGQyYhJCBSkUqAW1tsBdpuxEVaBzowXZqe1g90G2LotjQdmMjKqtBxQERdAWUAkUlZNBGkQRNyIAEMAkxpFKpqjfUG3t9//m/c/+737njPq9uVeqcte66b7jnnn32/s6///3v//++Tz0dmD0KzC4DM6vAFpd/0L3Gh6yTDgnvLwKzAWDGiH/ThcC2OWDrErB1pRgQisIQhAa+AED+HEEY6uNLyrRnZLSl6tSbrgLOeBQ44yiw8ziwfaV4UGbdegmA5QMTLFlqsfn7XecDW+eAmePAltXiXnkuZSBkRcm4UGXtU2uo3xsAZgz6y54JzMwDWzkgBOAqMMVBCSAUObh8QuN/CiTgcWAuyWhL1amvvBbY+VgxbW477paa7gIBqCnUrbUBiQuhAKDUot13IbBlDtiyBEyvtO5VDxvvVfxW/JkWNFrCeK8NAGsY7BsvKQC4hQCkJNaKy2LRIsg6SJ3IQSe1onKKC2CsOYMeN+0Dtj0ObDsGbFsEZmWp5S74g2Ir2uA22BScAJGA+dJFwPQ8ML0ETAUAkgDTPq9zdK/+sMWpPF19NxYwA4g3PtsHxAE4SQC6FdSgmGWRRIJLZJll8EGKjHiX1jwaN10HzD4BbD0GzC4WrsKMW2pNobZoCu6CLCDfCTqzgg6sr+wFphaAKQfgZHKvpRSYg7HN5XCL2AbAZwPrZGaj6ippXhgn0kqmU1woxnHedg5AATuWHig2FE1uVRwoxoX+Wcbg89S3AqCKPONcCi8oPtVP+9++G3j+oSK2xRBFDElUxbTS+3nvc4FpDsjxllXQoJg8FgdCQoGJJTTicLcQ6vPL6wbg9cDM4cJv27oAzFA5ky9/UOSvmg8oP86n0dICBn25JwjARWDSAUgBHN6vfdbv10AbARh8X91vDM2ss+NvAECKPVLCsHoyUgRqrlbnRwB933OBc+4DXrIC0IEmiLnE75di8HsyAcjzWUVGUi6uICMpVwwJVMXdeOk3XAxc+Hng+vV2esAYw+sWoP31r3eLcLwQBeQUrEHh4Jo2h4vDmJPuAyMLGAeEn7uqbgB+I7DlSWBGCwe31Gb9aL20kGDb/EGRxY6WTz8f2wtM8l4pgL1SgM8esHCvsuylME4nn9cfQLtldg6TZ0kUKorAfij23vAPCmqp3fcCl60XFINid1PlZrf41/dnApB6wSQjutUfIDJR8CGIQOwWEH7DywpKrWc8CFzqRLHkVYrB2jS2FQH5vkuBycXCAlIUUAAkCM2iRBA6+ARCe7DjYmQduLYTleiQ/XTTS4DpI+6nLhZW2nzVCEBaMLd+soIGqjD1ampdugiYWCpeBKA9bBJC9ActAk8LES26SqsftInLZ44dQif4Igdhym5WLrPDyuYH/7HTCNwDnPko8LXrBccjQaioe6BiKad3+QY/MGTH6rS3OBvCnQDuAIyqhiDkQ9RX+29yE3on8IwjxQPI8zkTiApGU3oVkD/4fGDieAuAdMw5MFQjEgg1DYsUku+a3uI0TGBfV7PotwHwaOEmbHEATvuDIutni6UAQoFRIFRYhfe/dhEw7tbe9Of0Si1g8HkrwRcevDajz07gIJ7n05rYyWIpb4ya/7vv8PRdFpj/LXDmkQLAnA4jCCOlTBRN/rFMAJKgkkVHpGUjySSBSFeg7/azqk8EgbSEq8UDRACLKDXSyaQ7Br//DcA4LSCtwnKhTEkQcmAIQhtM+Uaajl0uS9NatITXWzpzfcdNB4DpY+6nBgDaCtanYLN6fCj4u1ay0QIqtML/EYC61wSA9tAJeP6eWsAoDysFpg1eB0HIQRCIIkVeCqQf/05P3WCB+UPA+CPAzvmCaFWDKEuYcl1yMN+Y2dckqGTeHPEvvWDSNhOAfbefX0A6rS8CUw8X9066bFIfdqMHJID++DJgLACQumyc3gyAEYRRKFCLD1eu5ODLF6QvXedx0w3A1BwwxdAJLTXjd8seQnGrZ9bPFxLyA7WIKON63tYtCQBN/sv9QPm6BkLp0vl9t/m6ietR6fbyBA4gnXtORwRRpNnTtPpW6gWLH83lKqcOFTEnDiKtoHwy8RNFhrefyeztbnrBfbWfgttsP+kIyO32ELD1cHHvInrlvWs6TsnB7qAUlg/suFtAWkE55zYQ0QpqcALoNCXTEt7A3KoaDwGQfqoAOEUBa7fUbKctltwCajVbxvSiyvoasM0BaBKwwdKb9fN7NfcqBWGiSWykWXER0umeacUEonQgCKRfIgDFjya5yq8Wfsfs8dYgiuMxgpAg/vnMzu6mF0z6Zj5APdvPQec0TEosnvQosGOhaLuIYvnwEYSithE52F1XFAA0p5yigD4otCqygFKnpHUpLYP0OcKURYv6Mj4MNR433QhM0gL6QongawOg+6rl9CswKoSkEIxPyTsuAPigCYBmAXVfYcVf+n0SRYw6dP1YwNgHsgSajiJP429RrpWOM6cxDiJB6NINM4w7LbUGMQUwB/M9mZ3dSy+YVG0EoBiDBST5ddZ+PkCsAiIlQZDa3LVatJ0WXG2PbL98AB+4omB3oP/HgTUhmGgBfRqWf2TTrUSjExDSP/qWzQDgfAFAWyzR8rkFtDAKX75jo6nUguZxZ8NByHbvvqBQ36T1swcsBaBAGGRg40Ir+rt9WUDhQ5ZAU7Es2e9LLzglqHRxNkbeuW+oQRRls5jaMjnK0a9ecNf2R4LAwO829kQB3LTtEYQPUwzQAWgW0AGo8AQH0ljp/V17pm0KRcEifGuNOnocO1rACQbKPXhs8TtNwVr5uh+n6Zf3wDgu29g2FdMtOc8B6PdpFj08ZFrplw+ZA5FTvAQQ0/BT36FPDkRqBT9Jag7xYlQItY0f88j78sZzCcKPZlrAQfSCK9uvB4h577SCotUiEJ8opq8IQFl/PUBPEoBLxbRE62LSqG4dFB8r5bHcOtiOQSqT5T7RKzYDgJx+BUCCTxZQCwhaQc9oKcEnEBKknj5FsJ1LAPo9xoWWPWDy+6IIoqbeaO0VA+zHB0zxIQDKkn1GgtXiRxMIAx0Vn0Db+lkuFjLRCt5WEwD71Qvu2H5OfekD5FaciQay/GIbFgBXriwAyGmJADR1ck3DwTE3TQ4B0LetzBJErTYAr2BBSI3HTS8tLKBZPo/fWQDZp197Z3scjGb5BDp/L3+njMweB6B83Gj9wj3atOsPWin9WgXCFlVO/3ctf4iD8XkBkH5USlAZlNPZAQqARr5vxu1yjmH0givbX0UQKI63o0Wun/xHuR8E4VnPK5JQLd4VNttTBvK2uoiKOUf/f+GjwMNBh0NMV6J0c0NpcRv7mrYv3kh8/uHxYp+bVpwLp3R7sts2YzouSq3KGa+q7+x7Co4nazAerRKsVlV1QitF59dyyFZaYY0HMu9mWL3gtvZXMbymBIFMZ1ov2h0B+LTLisxgW+Eq5uU92iZ72ud9vvR+4JFp4NjkRh2ONi0OB1/UBCkvEYRhfuNs4OmhhiPKnFQlx6aAjMnSXJUAACAASURBVPjmz1w41nnwO4cCIBvBwZgTAOUHRq3gyDExD4zRGVYEnpm5LqmQc0M5esFt7acFl0SlHiBxuTkYxxdaihUC4QVXFu5FCUD5QtJl85sjGA0ziQxqeu/fem+hw0F2fLLQGxFlYMRvo7v1WmIVtpt1DFkXvOR7LwJ2HSkyoZmEypoVVe8p7b6qEMnidGG/Vl/L2aPOIwuA1pAIQE3DAmFa4j9f7CPaFpCHKujr5xzZesGdHqAqKz5X+FLRAl58le+jui+kTBALMcgZ73CDBkpN2/7+bfcWOhwUyCEAjQTcAVhKdjkPc2RajewKyu/n1//qJcA2uhBMRGXQOcn9U6JIOjXHQqSYOsVoQp1HNgAvz8yny80H5PVz9H6RqVd849WtXQ/zA0Ow2ayGLJ474L0G79vvbulwkJi8BGCg4S01SKqofoNvSIC+5zkhFUupV8rUTpJN06KpaBkFQm5M1HlkA3AyM5/u9Zl38zrk6f0iU6/4hmscgK5ISUtCTowyDqb7UxwsqFJW3fo/vbuIBJEZ1YRgyHwQKNi0KEl1OKTCZJdxtPDn//v8ooaDaVgqFyiTD2IKfcjZS4Fo+7g+HXOPv84jG4DIzKfLzQf8KVfI/FNKrQ6h94tfz+vOA9cGAAbrpylY2SDlVTTt+uCnV3/V3a7DQQAysJAwobZJgUXi78Qayhd812WeiOAZzEyUiAkHMeu5BF5FwZQAWLPwknkLQy9CrPMy8+lIHZFzvN3T+YbV+8X7c64OHHix74V6zIxB+RJ0wQ+UU992tYoFy3fcXcTDxQkoPsCUhFIczKVCegSg5B8A/PILN9ZwxBSxtiKiUAOi7JW0dLTustF8AGbm0/1o3vjjnSGdj+lYlGwdRO8XN+c1wABIoHk6k61yuSCJITq3jDY9Vx0BqK++uwAfX6JkI/hME0SC1EGguiQ+isqcQRLrF6/0jO2w+6FMnZhyZYsQ1W50qOHgPX1NXndtODsfgMwHzMin+0+ZN0S9YOllMzWfLwKQSS396P3iY3kNOLDPM1y065H4gOW3p4uTDkB8zWdb7FgbdDhEgJkCUDRvogTmd/vPv3BVAUBuvylNzAAYi4hisVQnEHoIqWblrxqm4Mx8ujfljT+YjsWBYgIOc0oJPsq1slCpH71fKybJOEoAuuVTRSCnYlmU6P/Z4iSJEcbLv+Yu9/1EAh7JKEXDKxq4ChUiKymRbwjgHdcUWTARgLYXHSr2LOU+BV7MVwzxwOfkOWybYAGZD5iRT0edjpxD6VhcOQ6j94tP51wdOHBdMeXa9OqWRcmWXA1XLUIUH6zyCwlAs3z+YBkfs1u+VIejJEF3ckrjI9T0y/aMA2+/tgAg08VURKT8vbKMUgAMIGzzAcOi5HknHQAz8+l+MW/829KxhtH7tTz+jIMAJPCYMULAWd6fvi+EY9ouoZBM/Kx/4LUBgFLgNC5o16FrE8JJVJgkiFhaQQBv3+dVbMrWVsC8UxFRkjjaVsW2DtRdOJ/vAyohVYK7A+bTvTdj8HlqTMcaRu/XxHkzjgNkIOWuDr8jnYYDKDutgpUhra0uAlAyCCUAK8BXcjBXgLCk/h0D/hcByDxFAdAzoFUqUBYRJTUcMWdPP7ONL6i5bLQeALJRQ+bT/W7G4AuAOXq/lsGdcRgAY+glLkYclJVTsa6ptCX3uQjAKINQstFrAZKIwWxQIhIJuovB/Nx+r2LzFCwlj8Y0evl/MYk0kieVtcvrwGUnHQCVjjVkPl3mItQsIPuElx9G79dOzDgMgGkAWlNyBJn8xKprBRC+zgEo4LWRgcdVcOCjjlNvmx84DrzNAahaFZWLygKWxUNibIhTcPD9BMLLa65bzreAMSGVoXvJ/Cgh1WUfO+XTZS5CDYDs9GH1fnOrIDcAkABTTDCCLYK0Cwi/586WcKJUiEpC8CCBYDsiiSplqUIUmOjf+o2tIiKVUJbgU5uSWl4DWwX4+PcXnrQATBNS+8yny1yEopdcay+930y5YhgAg+9n2OoUeI5TdQer+32fdhmGoOBZanBo+g1yEKU4dYgFSvqB//vZBIBt9RshkTbW8ZZZ2hUgvDL3iU3uux4LSBM0ZD7dPRnTH08VAIfV+2XAOucQAMuVcKfFSD/+IAABsEoGwYAoHZIKEEYxRIHwLS8pUuhjFVs6/ZZhIVWyxVKBBIRXnbQATBNS+8ynI4tBzkEACv+chlUVIKE/5cRGsWmlKfIzudc3APLQSlg3E2OCyVRc1kpU3DgBmKoQsWtlBcswjPu+nfTYtBL+GQdgOf16GCZW6pXlBCqWSgqJypoOAFfXXDifbwFJLvi5HAjlnUsiIe6AjOp4iQNQHRlT2PlgJCUbbc2s+v/hFwFb/q7gm6HlYpBbmTV2sscQyy/qFBj2v0/cAdz/HGD7NDA1AUyOOU+1CwWOewNjKj6/O03F1/WuugW4/XJgfBoYmwDGdH7IxB5kLPIB+I8AfNwZgga5ck2fJbEm8V9zNWPfrasbgMuPAcuseJ8Exsb9FdBhA+7gaQNKB6TfcgCYug+YJT+g89aoBDMmIMScP12uTKj13uDv8zsKig/uJ1uQOsnojm3qB5P5ACRBH3OhPuzzRN9DV88HqQLEWPJnvTy5nm/t/1s4BcuSpRZtGAu4fi+wtBVYEyccrYwn6hF8/FkJp9bKxAKVFsn/d8urgbHPA9NPOEOWl4+2cfoFHhfVrJTZPKHSj5daOtup6JyCpPx8rHWRVQ7WOlrYCMx8AHIzlxkALPD9c0VB+x/A3E/+E2fUYHXdF7KTGwdvTd0AHP9r4PgWYG0KWBdfsBdsMPfPrKKsoL9XAVLAvO2fFylCE4cKliyrDVZNcGS1CqEYhWFiAZV+XntaURdTLmpCEbpchTYLqi6NrkMCzLzt5Xc4HwyJmmkJ+Z73jQOh4NWeDUZiK1K08f0EXt7CMHVawIk7gaVpYJUA9LI1Ao8bzKX1cytoFtFfpdCIWz7rgzHgth8u0oPGDwETc8CEMySUzFaikgtlpW1Ta8JqNba7lVljSRgW+Q6ZP/57WQvj6fydBjXfAjKbgEvMLwWCvhNoipgNpnQshlS4IGFWzIk6ylWwAz93ETLxGWB5ClidLABoIOS7pmGfG+33YAG5mND0G8F4678vkiPJczNOAC4UyQm2N8w94kirFlfIAl7i402d6dbPWWAtrsjOFiuCvAJZOQE0pHTFsckHYDeCvhNgipQNxoAz8/8IPr5nbvH2jd+6AThJAE4AqwTdZKEBLDoDgU4+YVkPHIBoPwareOt/BkDexsMFAFnbzNJYm0IDnVwbt4uyur1kwL7Tp+iZM/08WT9Rc7DHUmuYTr/x+6o4ovvu9fjBbgR9JyA+omwwxvZI5ULg6ZW7y9FPf9QNwKm/CgCcKABovh8ByVy/UCtJq2f+X1yYJPGU27lIZLbuEWDsWBHesZeDz4iURLUWa1TE47LqK12fZmd3OXidFctqm92KatVs1jAEsNv6sdymaa2g8+xUL4I+Pn2beCgbLGWHI/h8G3oTr45iK86POlbBU9yKI/AcfLR+ouQwH9BfmmbLlTHboOnZ/T9+5vaf8FUaAThXsFOQ45mUcgZCWTAxe0UQ+urYMO1/37GtxQmoLCBtRSp30LrDp2SFdzYMgk/R+VNwvwR9mwQDsaspGSfJgYDYNTbp8psCQFJxEIBkQjDrxt8dXCUIY+COH5MVFPi8SOn2n/QYLZ9Gp0cxANIP5IvAkzVzxivRydnKNzBa8fddM84b6AFyAriMF2pajk9kYIeoClXmA3AQgr5NQEHMBqMVFMNaIOayNRL/vhlH3RZwmhbQQUcAasrVVGz4EtjCu/3dfb/ID3PbT7uKAZ/MhcIC0vqRTo4W0IBIEAmEtFwCYqjW03bcmdwBYeoWgetUbrR8snrloiR2drpACf+rD4D9EvTVjIJu7HBV+781X752Czj9lwUZkTEgcPoNPp5Nv4oBRhCG6dd+1DkMz1JIhR1BAHJ7zwqO3fIRRM5tmDK5CoQKsSgOeBYBKFZULTqcB9r6Ni5KYmd3WKDUA0BlhNLM8EbT1QBXBU72aI5ZjUcVOxz7WLkQ8d37vsart/uA6RcPsxNSAtAXHDYNC1AEpf9s01kKwuBwGU7HgVt/1jtD1e60fgQigSe/j5bQp+KYpGB+H62jT7P8/ZypBIC8Dhcx8eY9wF015abhmnoAyJ5WSrKeNgKO9SHxnT/LSasJBim5lRjWBEIVeROInKL1qunybRawLgASdEy74qjaNNzJCgqEEYzBGvK0297mAFSHEIB6ebKDgc8J1ksmV8t29f1en6L5v6cxIK5iK6Xne/5jCTiFcTqVn/r/tWDPWwXnEPTVgIKUHU7ljASawKefIwDpMdRxRB+wFgD+RREDJABpwSzz2c0LfxczVjkVKwaYgtBBezu3SvX08d39P5uO3QKahXMQciourZRAGKZWar/YZ1xXRPe8wQr2AUK7TvbOVTZBXx4MBECRnConUBSFEXT6mf/TK+/qmzAF/0UBOPqBZYF52HrTFCw2LH5G8UCzJEko5nZqmRnPh/uCXmpnVpDTsIPPwKApOaSA2QLDLSHf97iPx0tpISLfz7bl4iFfsUsnj+HZWEeOYDCDnDmCvZkEgedcCjxGseIhBYt3vx049HwMLRh8gA9gh2MoH9ABqKJzxf0McO7XlSAU4HzhYYFq+5D7hwBu/98OQLlIBCKnW39SlXNY+nqeiq2dkQg+gnGPb9/ZpT0lq6MV5D96gLCwgDmCwbdnCvZmCgY/dxy47xxg5SWuUjigYPHFbwA+fyGwfr2rXrMvPB+vp3L3GHCgi9JOHQCkRVPppeUBigXLFymyejYTB4YsgfA20ofRAlYB0FfAlvQqP0/TsX5PLOB5DNu471cmIwiBaRww/F01J+mz2pqChxUMZvpJlmBv3iTocsW4dzewfhkGFix+2febXDAeJO/YEILBB7pU1g8LQFo98QASVGYNQ6DZfEG3fnEqrgLhbf/HV15anbkFNCvohWSl9XPQ2XTM/2s3I4DwPIZwBEDfgitH0Ek6N6x+u/iD7T4g/YdBBYPpWHEaHlqwNw+AQa4Yj54JrJO+aQDB4pt+oCAyYvOPEIQDCgYfeF/9U3AbAMX7ItAlVtAspKZdz5SOlvA2pstxjES3wJ+92NgAGK2gwi78QoVfEhBeQACqNNP1RdoA18kKdgDhxkUI/zKIYDCnqyzB3jwAJnLFOEIW7QEEi1/1Y21ywVglCAcQDD5/Efj7M4CVrZ5AKlkhxeQUaxBI4nvFzxf8IfCVC4HV7cC6ZEX5nen3VX1vAGLZq8ysrvHY+QBwbGfI2E6JpLvdX+ksthpUvQrmX/sVDGZVUJZgb17vJHLFeGQcmCdVb5+Cxd/5xjZ6QzzMLOQBBIOfTV2Ps4HFHQ7CLQUQmUrV0rgKJMsCjsxGAqTn/hzw0EXA4tnAyg5gbTYBorKkUyLnkB9YVhTxu+kT13iccwtwdBewPAus+b2ar9xJAafqfgMQO4dh+J9+BHe5gqZZZzYok1JJUcpaR6bp93P+W/N6p0KuGIemgEWKgPQhWPxdP7NBLhiHKYHUp2DwpZ8rLOD8tmJQVplOLxAqmbRKC6EDYC7/CeCRPcCx3cDSrsISrs04CPm9ArZk55UvKAspYLqPaPdR4/H0g8DRHcDyVr/X6VabLHk2PhjpPVZY7d5xwF6CwS9y/4LbbVyQsEKIufGiKe0p2JvXOx3kinF0GjhOQY+oNRtljji9TQPf/fOV9IZY4Gq4D8Hgy/4W+Oo2YG5bUUy04vUcLCqSJVRWszJbNgxSmMau+q/Ao2cBR88EjtOqbgNWWaTkIFz3YiWrF4nAjtN0nBZrJnU+/8PA3CxwfMYB6LUra3oglL0tps6wlVha5rLiqd9AdDfB4Je6U0s/0BXTDYh80Sr2FOzNA2AXuWIszABL1JaKWq1R+nwGeM17OsoFY5XTVw/B4Cv+Djg0C8xvLYqJCECzgsxmZlq9T8e0XGUyaUizavPtxoFr/zvw2BnA0Z3A8e2FVV3x6c4sqwObckeyhiXAowUSADhD1XhceDMwx37lvU4XxVN2n3rJIocygkr/Vbs7fe+EdBLcfaXXQ3IPWIrpBB6XlnwpR76jYG9e7/SQKzarxM7qJFj8mg8UarMV9IZ4gvNDD8HgKx8HDs8A8zMFAFnPYQPDl0Co2g4fpDZLqKCxT0/7fhJ4fCdwbFvhRiwRgJruCOwUgCpeCvUjZmEFxhfk9W969kW/B8xvKQqnVgg+B6CB0MsI7P70AHgmd2n1NQ0rv7FvALIlVYK73MnQCDLThSGZoDpuP7uCeuX5n8zroB5yxThGnQ0CgyBMxY63Aq/5aBHG6EBviDlOLV0Eg1+0AByZLgbl+HRxnZXJoqqttA4ODovlJZVuSjTQFtq+NwNPbHMAzramdVpVs6wEoPtdNg37wJfvsYiJP9NFqvHY+7vAwjSwxAeNxVO8T6aNVRRRlT6hHrJ0Ovaw0WDJCKng7g86APvNB9wg2JvXO33IFWOBgn8EIf2nRLD4tbe1+AU7yAWbZeskGHwVdd2mgAUCcNKnJgLQrZ/V9/Jnn5JUYmnAE3hCmv3+t8AWQfSzyPK/POOgJgDdsgqA5nfJAvLdLV+bz0kK4RqPZ3wQWJxyAPqDVhZQyQr7gyaXI9axWCFVAGLvRUhV46PgLnUWBs0HbBPszeudPuWKsTRZAJDTo8l8ui/42juL5veQC7ZpsEow+OrZQlqVVuH4FLA8WVyDAOTAmHUQCAWQkOlsQAwDt/9/AE8SgPQpNa07+AhAA6HLXbb5Xr4IaAMfv/eGvP5NzyYA7UGjBWTWjh40v9fSyscHLtaxhJWxFVsNNAXH1khw983+DYPmA5aCvXkdNIBccemfceooAfhAAcA+6A2xLuAGucxrzgKOMexDfV9OwbS2BB/BEoqLSrBoYGgJ3E8qLcIEsP/ngCPuUy7S13L3wb6PU56/m/Xj4Ps0TKCXQA6AXuNeZY3HMz5QANAeND1kwcKXlj6wOZQ+b7R+Pi0PD0DeFAfk590CKg8qncfoFzIRVWVqfFfBhgn25vXOAHLFWCDbvPstBsJZ4LUPt+jdesgFg+qVptWq11bg2gtgfuLiRAAgQeg+oEmsOujsXb5SsAoCIN/3vx04OlNM6Yv0tdx1MKvK7/TFjVmeCD4HQQQhf159eV7/pmc/kwCcKABoeYvR0oept7SEoZQ0Tr1lPuPQFlAtO0nyAcWhpzw/FSjFzGjLx+RGvxzoSeC1hwsA9klvaFN5FAy+9mJgnhaQ0qqagglADo4c9AhCDpJPl5ZommQ8738HcGw6AJBW1VecZv0cePwOY0/wl1lAD/WUCx0mMlDLr8bjmb+Dwp3x4nkDYbD0thIO5aNtfmDi/xGEeRawxhs7Vb/q2huABQJwAlhyy2cC0xoggjAAUCWWAkksOiIY978TmOOqeqqwqAx3WGhHK06n7TDwOcAV/iipPAKjwgrZm2o8nkUA0gKmAHTrp+o9MTrEYvq44o9pZIOtgmu8mafCV72YAKT/RwAy5OPOuVlAAk9Oule6xQRTWUKlWtkU/IvAHAHti5oIwDK841ZPFtCmdr0U8PaC9hVultd4CIC8P2Ztt/m5/qC11TJXlJDGGpfGAmYODgFoCxACkLpuWh3KCgqE8gNVZK4KtxgjJAB/2X1Krao1rfN7CWZf3LSBT4uAEIyWBVpipL7GgwA0AW25GbGENBTRx3rm1M2w39mmrFVwjTd1Kn+VAZALEE5LtIDyMWUBvbLNLGHgd5H/V07BDp7r3uU+Jadgn3ptxekA5MBri0/Wp4wzBjDbCnkMWMqVpE8GJwLQqvfc0pqbkVj5aNk7gbCxgJno30cAjntowtXNaZ1suvSKNhsYTcVKmw9F5xGE+94dfEoP+JYhD/8OC8eIPUsUHokVVKB78XszbzAF4Pvd//PCKVGIpOAr78mn4DZOm8YC1jco+w6EFTDDPJqeCEBZBa5GffVbhmQ8DtZW5TYOvPhXip0GTuu22lTMLSw+aAVl9QhEWjurI/aQiLJkTMLsX9R3r/ymZ73fp1+37OU9hunXSkdl7T3QrhKCtlCM59k2i5CMMSIAGdqxEIwrmptzTsCEut5yilKoJLAcxCq3fe8tLCDBFwO+tKjyuxSCMdYEXoeDrHcHvu0tTwLzmwHA4N/Gh6zNCqqeOSxC2lb8tQSiMwbuqXIqAcjFh2JjBKGJyShQG6ygVbfJegULWBYcMR3rvb6oCRaQwFPgl1M5rR7/JtBZOIZWx/0+s4QeY5z/1/X2tFnAxPpFELaVkdLN8MWGVr4pCBsfMHN8bmTKfCjZ0Ncp456/x58zLzfw6Qf3ABd8pUgEYmqk5bGyek06IQl1bkXScnlN/u8L24Gdx1qVq91KQvrpgwaAAw9p+wnXPw1YjyWMGtDo2ASOFGMU7SIEUzdYD34vMPmXwLbHgdkFYAtlGiim6DpxJtvq9LtlVr/aWKEB8pUXAOOPAFPzwBTZ9r04vdQ9Ts4pAZ3cd+yHxgfMAOH+vcA69/9Uxijmz/AerYpdar1lNSMYzV+vWY/34I8DY58Gph8Bpo8A04vAFEFIknIHohGVR62QhFRSYjQE6qFri2z3iaPAhHNNlxKwArI0Q1IAxwfReacbC5gBPp66/5ICgLKCtqnsrKKlrFZUFPKOr7osMTtdsxzqQRZ93Q1MPARMPllohUxRqkEK6gShOP0S+dY2hlRv99y+ovRi7IiTnTvLqmg6xDPYpqAUgRgsoR7MxgJmgHD/c4E1FXu7FRRbvEgd7evXWlbPpp9EgUjiJpwe6zwOMlvpAWCMVusJYPIYMOlSDZRpoGiNxKzbdIQlXONMWJbGtw4svdgz3El47nzTRvPrrKptAJT6ZrzfintvAJgx4vsvdQvIXK5VYF3sUZxmJUvgA1FOvwF8spKyBtM1y6EepI4LqVMedbEaTp0EIKdPKh5FqYYqSxgo2jgFr13j6XXHnOiSZOeBVSvyC8qC2r05FVvVw9cAMAOA178AWPMp2LJaaekiCPXExwHw660n1oB/niGQazwOkkSepbJ/72I1x4CJ+cJ6lYI1riccrVicUuVSmIW82pkwnHHVOKbFsOozQGkFkwewnBES37ABYMaAX39ZAUCCb82nIlo+40p2gNnvsoKunxH1xGwA/LOzdQOQJPIuHzV2GBg7Cow7AI0l33XfjOsv6oVodes6ISbBsAZMX+kJxU56KY7pkmFVhOciuvTzSt05v0+ryuT/9gDrZNe4wPMsI7VJP3GcP7gUOOdvgL1rRYJ0ZI5IV3hV4/wrGYPPU3/AiRhYusy2K7mU999P+z90ObD7LuBZK0Xdkeq9NSX2+o4HLwfWlopFCC0fgciBMtAFC8CGrYXVoVjnU2G7rTXrzh4kfRzLY1kyGwBoeiGcPiXb5eAzdXWnazPCSScb4j3xfmav8Cx2p50lAMW0VXINitCogl2r9H2dcctWwQxQsn6ZTBbMNtcgdKIbiZj51VcBk38CXPxoQcfCUg8pjcYgZScw/momACnXyr4leBhs5QaBTHpf7X8dMPYJYO8XgAv9e8QJlAZZq8D4xSuANYKPJQn0AR2AHKy1MACKe9nfFI6IEqduEWoHIJ9wlsVKLekoMCa9EAegSTYQeM4TXco2SEMkAHEbBZoj4bbYtdyCVrFqGXgTSxgXYTZeHLi9AMjEQRCVUXP/n4KUaaT8vVTi+Rtg7GPAuYcAWlMCgUVkQfJ2Q12yBvPXMwHImhDWwf81imsTiLSEvHZkr+jY/p9CQRD4p8DOBwteItai05qn31FFdfLlFxYWgCDUIkRkj/TxbCEi/89jfPZ3X2VqYSJQbmUNQY3HQT7hbv2sLoerVwKQHNEEoCsm8R4MhPRjXUGzVEIKIoY7yaEYuY4dgGb5RXruoSgtSCLLarkICQ9f6QNykGjFdjsIBaI4kGlt8W+Rg5g0HJ8qAp47nihAzFpuWtPIMBZJlASILvR6fQ0DCVbJCkJOJCqnk4pGpb99tZ8MopyiKDX7WWDiwYKXiEQOehCrgKh+eJQ+EQHo1Lby/zRlyf8TIbf9XS5ftIb8I92YugH4ay2pLusorl7dAoonWtMwQSTdOFuQSLTGHyIC8kxSIQuA4hwU2WUAoO4/grBcDbsfWElSzg+JCoYDoEGM1ixSkHzgF/wG7y8sIa3J7JPAGWuFJSQIaU01iJHUiYP4e33BrPOHmG/JMaOfTZVYRhwGav87vWKPJ9/rSH4IOGO5sITqg/ggxXs4TOaBAECbeoOsgfl+DrQShFqcEIhyyt0MbMusEkx76iAZXKM8BvXiZAGlF+KaIbaadYpem4aDgpJZQz6YJABV5VcHAJZ0v4FxX6KG5UpYs0KnqjhRuagEVgPglYAl9ciHf8mdUrJh0Qx9vkDBzBywfbkYQIGwahA/kglATsHsDzKA0BATiPyZ4NEDwIeoa/uFYKKXL2f24nQoIgd9R3yQCMTFqwIAfdBWI7+yB5ZLECYLETd85YJl+2YAUNosLIel/xYlu4Jsl6bhNhD6it4WJCvA2Zc4Gxo73RcgJeOqFmGR6rcChLYACyGojmEYdj59KnZ+tIQRhH9IvWA2hiREjDeRI9Cly7fMF3EtWRFawhQIf5IJwE56wdTIYdt7tp9ys1K8JnoJvod9Wn682PNkP4hUy1ndWgstAtBDMLYN5/6PAc5DGNoF4SrZfN+4+IhT8jqwg2Cp8ThIJ5vfSWBXAVCrWN9SMxDK+skaOvhoAc8me654pmUB3f0wyt+E8FyRAGmPlOEoiSD2qgvmAKoOm52fAuiTDHSyIRxx+lI0QxxADubfF5vffMmSajrWlP7nmZ3dSy+4r/ZzAUEHnQ8R70HsXlK+PgJsW68G4XYGZj0EY2EYATCAT6tAhmE0DXcC4faapcwMgAIfLb0kuzT9Qmw5uwAAIABJREFUSi+EfeALkSrpBovbrQDnkm8wAo8/E3i+CCsZ98NCpAp8cUekZyBavI4ET/TnaAk/RQCyAXy6uNSPA0i+wMeB6ePA5HFgZq2wpNGK3FUDAHmv3fSCe7afX8CB4UNEEOolVi/3obastNwJ9cO5BOBKEQMsAcifHWzRAigWWAlCn5K2bQYAOe1KMjTIR2kRUhKVS7IrLia0v+3xwHMZMCbYNP0KfG79zAqK5DxOvyEuWu6VD5KSHy2YAEQAfpaRdl5UkuUctIpBnCIIl4psD03FtIIP1ADAlBuJM47EqqUX3LX9kSBQcuuyftK78xUkHyQ+RLqHZ3Fv1KcgLj5kAQ1s0Qo6IA1nHhNLQzA8ZxvBXuNx8DcS5UYpNnoYxsCnUIqvZo0F3wPTMa7Hv53HOJVbS/l+5bumX7d+5WLE44hxIRJB2NMCqj9ixwuE90svWCaIA6bAp959EKeWChAyA0PTOV2unGMQveCO7bfqHbcS4rJR7Ewqnw5AWhLuImg2uFQAXAVs8RGmntW4+g2hB3P79L/EJ9zGvqrxOPibiVihAOgrWQOf/EBfBcsPNBBqW9Hv6zzGqFzmoXz3B9AePgXiq6bgiv4YOB9QHS8AfpkAFMMjrWAcQA0iO9XJiQyAnos2vV7ESHOOQfWCO7Zf7F40mZFQScRKAYBaSU6vAVcTgN7xXHiUFpDTMK2dFh56912BTiDcvpkATIXzCL4g3WXTZ4jpGfjoF/oihL+fx+0yWUABLwIwtYKKIabgCzHQvi2ggBKn0McEQDaKT5cGkIOo6SuyYzEfjQB0EM5nZgAPoxe8of3sgSqCQM3jkdFLvpRvR13+7UVRuhUFSavNO6otwp88ZZ3+t4M6HLtch6OT9AG/q9cmtf//gV1JDYcnQ2zY6/YakfSrU+Pg1M45NqPt3IEtoM7WFHokyrWKkooglCMWLYjiUXMtK3g8Uzd1WL3gDe3vRRCoUEYCwGtYFxxqgA2E/jI20F5hhmQod98BHNnlxOTig1aGiDanO21yV4DygWuB8YeB6fnC9WEtiKVVKeE0ZGiXWczeJoWMIig5a9V5DA1ANoKDeDylZ9NSXxyAsiKawrQqmCv2HVf5e8aRoxfc1n7xs+khItAUvojvyWryxVcWJZksVSyZoQRA3dcAoHzax4Gj2wtu6FVKM7gMgti02jbV476oUJJs1j/AbA1mQ3Pm8eTRsoZDtR+xZKCiEKmMXTIeXHPGdhYArX8FwG4DGMEnAHIK4yvT58nWC2b73cexaZgWWaEKgU1gjNbPP7PvOYGsUSBkv3hBtmRWNzxjTk9RWktvxp6POj0vARjY9sWkFel8RWxegjIF4RjwAOnZWMPBTGjqvHmszxJOBUD3xyznL2bqROvoP3N3q84jG4C7M/PpcvMBef0cvV9k6hXv+2Yno5QfGArRbaCC0mWv2YtF3ecerNDhkNZIIsXQRv5dlTtGADJSz2gEE1EJQM//026HdIEZLC8B6A0tk0g1Ja8DuzJdphS82QBEZj5dbj7gxZN5er/IZI+67pscgE7QaDOUMyC0Wb8+gXjuR4F5J6YsaXnFhBoAGEVvUhb60jISgCQnoh/OLBgvIrL8v7DdFkEYM5dtNg97tvz5zJqzdfIBmJlPl5sP+DJP5xtW7xffnzeh7H+Z+3+RpkyWT1YxuURJYVtx6T0fCTocouQV85VkHRIGegEuEv/YKpkA/JceVmL8kv6t5/9pu62tfiPWcFQVEa0DZ9WcLJEPwMx8uvfnjT9IgZyj94t/ldeA/S9tMaGa9SNdmsIxbvVscVJ1GScoMt4UPwhAsmMZ0aXzQBsvdGRBjQz0FUpEJRAJQOq4KAnBdz+sfiPJ3bOYn8fsykyVWMfiN3BOzckS+QDMzKe7OW/88aqQzsfE5kH1fvGjeQ0wADodmVGwOeiMsUqHrGOnS4UFy9P/wAEojkEnI+IqOIJQNLgpCXhcmLAtD/D+kgQE235L93tj+YBqgTX9BiCeW/NedT4AmQ+YkU/3sbzxBymQuZhm8g1T+QbV+wWFdjKO/Te2mEFNlCb6gPF708VJ1TXHgKd91GnZpDfi1k/gM2vqU3DUnCuBmNQe3P9vw6pe229KOvB0K1k+ZS+rnrfM2AlA3JMZtah/EZKZT3drxuDz1O/yxAwu9JgJxr3lQfR+8aa8Buy/wdWQZAVl+ZzCrG3q9c/YrkmHy3IRYryAAqAkEBIlopJxNNUbER+fA/H+/+AAdP9PmS9dazicJybm7mlB8nR2dI1HvgVkOlZGPt2nM29GCamcGZjAwlQ+vvrV+8X/zGsAAUiLVPp/wd+zaTMFWw+/kAA0GQQnpCw5mDsAMIrcRB5mC/+MAffTwgfwKY2KfmCZ6ZIkUShrxXxBX4yYaV8Hzmcn13jUA8CMfDqWYeQcSkhVOl8U6uxH7xekrsg49h8oiCENgC5TUG5vKxxT8f2aRtOtcAKQ1s8soPuOVUIwpchNlEEIOyNSIrrvv3hwnckWIZPZsnbcDyzTpvg3lU8mpZQqozyfK74aj3wAKh1LgrsD5tMxiz/nkGD1sHq/YNFOxkEAcuW7oqmXlisuQOT7VV2jwi/kTgj1RkoZhBje8Z83SCAEEJZW0C3gff8tADCt4VASaWIBK0HI9q8BF5yUAMzIp8tNx5Jg9bB6v/jdDPSRns0BWIZeUitIo9IhHmhXTvzCPQddccnZ76U1V/IvC4SBCFyg26DFNg7c++Mhhb6qiCikT7WVUmr6lYn2nRKyrdZ51GMBlZIc07GUBdMjny6XCiUmpA6j94vMZbgBMFo552pu27PXAqXTyAUQcitOQjAm9xX0N9pIwIPmSCmH5QuPqER0L4kDYgp9zOUL6fYxkbZcFceyAreAF3GlV+NRDwAz8uksnT3jiILVSmpWNlhMze+k94vMZfgGAPJeHDjpCrgM01Tdry9OzvmYAzAqLVWIwEShwzbRwwSEn+MqP6bQK5tZlWyhjCCCsC19Xv7gOnBRbgp7cu/5AOyVjqVMmA75dJZ9nHF0yohWNlhMxKnS+0XmMtwAmFq4imnYbrEqNJPc+9kfd62RKh0On8qV9hXZ9askEPgAfI56ziocUgVbzGT28lEtRMoKtg7lBHtznfZNA+CQ+XQWM8k4uglWK/NLYKzS+8U9GReXD0g/Tyvh4Ne17Yb4Zbr6g6y7/aNWcoPpjKRTsJIags5IJwkEAv6en05S6GUBfRWsUExZyVZVQCQwrgN7Wfdd41GPBczIp8ODeXfTSbBa6YYxlY8/p3q/udc3C+jTbtvqt2oadnB2m4oNgMn0W0p+hYWHWbwg9yU/0Kb9EIy+5y2hiCit4UgKyTeAkN8Valk4Le/ldlONRz4AWWBRM6fdIPfHstw/G+SE5rMnVQ/kA5AkLHS0ak7V7reXfhgACaBqDtD3e/nmc5k9kA/A80JReq+U38zGVp3ObJo/BvAOD3dtwiWar9zEHsgHIGlFubqSx7+Jja36anLLcDvvgwA+NDpDfILv+qlzuXwAXuSjrkKemlO2e3U1uWUYnL8dwB/5e2apca9LNv+vsQfyAUheX4VguB+mzIsaG9ntqxhF4Xbe3QD+n7/uHLAW9wQ1tblMRQ/UA0CaHC7plXEh+q4T0OWcfhleYTSHBK0EH/mi+fcRuKQn4I6fWpeoB4AevCz3HOOm9yb3F5mBlZBNclYCj1aRfyfrbgPCTR6AzK+vD4CyglX7jpmN7HY66d1E0ctdIrEEE4wEIMlam+Pk7YF6AMj7EwAVbU82vTerCwhAXopJN9zVI+AYrOeULLZgErY2x8nZA/kAJGWr0naUWdFpy2cT+oCWjpdjLFxE5UzYIBBpEUX5nLnlvAktb76SPVAfAOUHpiAMm96bsVtCAMaKALICMyxDq6cXfycA+b/mOLl6oF4AiqBRIEzBp7/X2Af0+fi1XIioMIlAI+AIPIGPmeROWV3j1Zuvyu2B+gHoFfZiDS2lC0LiY52WUADkQoTTMH1BFSYRdHoRfKSu5v9qrizMHYPT+vx6ARhSuDcAzzmDo5ZGHT1PAKYMwQxME2jiSo/gEwBrrq+u41ZOy++oD4BaCcsXTPiSI3ey8s4KGoG8QwCMFM+0ggQhLR0BF19SXuD/ayakz7uR0/TsMcxg3SjfqWNA0hsrga/ojaq/8WPcC+YIk4Ke4CMSuB2XVht1Oj8zIfXlU8BtU8DhmYRXWdfrdF1fgr3+S8At48CD04DVjXQSDO70PTUnaJ5uOCwsIIFHSSFy1pKPWCDsZxCpw8UVgKSPxLXM937OzxxAljzcPAbcswU4Qh4V3UN8mKoeKm/bu78IfKJQa8VD48CylHQiL3O3/qg5Rf30BKACMtJXjXKQcfBSK8Dfqc3KVCwuN2VFGRnm/yKZtq4Re5ifyQQgM2A+BeB3GHaZBo5MAIue0l7Kt3cC4xhw+5eL7TuCkJk1jBtyerbUfYG5ExjZ/pqrxE5fAOrOq5SmowVIrRp1IyT2R6+fg0bgVYG4CsyZe2UsaiOGKXr4Sfp9k8CxCYAFSKyvXeY1o1BxQux91yMtfsHPutgnnyUuUvhc0ZsgUXib+nVkq6+ZKaABIHsgVZnuwD9sVo66rrR4ImdhLGSQ8zPL/JgBQxeU1ouWkO9PTgDzbgmXxrzMkatl3keivfG5x4r4IRcz5BfkO5vEZ0kgpIfBZ8yKjlL17syy0tMNcOn9dl4Fy6dLFabj1Mpvow9Ify+I4Nlo9Xt+ZqU9VdJpqZh4QDDyxUyYOYJwHDg+DhgI/WUVZl7aSEt93+GO9Ia2iuZKOfA7lhp9JpvAVy61w2mOwO5hmCgMHC1H9O24gu6UD9jP+ZmbtLRaSsei9SL4XDPbAEh/kGQ/pSUcc0lbApFWb67lQUhpVnLBsoKqqZclFMmUtrxPcwxl3X7vOCAtYLSCcugFQmqhdssH7HU+RznjiOlYXA8wqkOfkItTAom+oKygca4ES8jY+N3z7fSG4hfUtp3ihUHruVSsFy1iRvNP+1N7A5BdJACmVpAgZPhGOyCigEjlPLudn7kvFtOxuB4g6OjD8UWLRkCZFRwrLCEXJQQhp2K+37lQeBCRX1A7KPQto1prFEmSYn2mB9EAsO+kYfk8KQhZF8yjVz5gp/MztyOUjiW9bCUhEBhKRCCgSis45uQ/PhX/xfFWMgOnWu2gxB0TF/o0kEZ/kCDM1Ts+3RHYnwVUL6XhDFrAswfIB6w6P1MrTulY0sum1VICglKwCEACqvQFCUK3gHcsFQCM/ILayqP1k9JshVqrncMalOYYvgcGAyCvIwuod8YBJQmZpmGJeyRwkGw4n8jJOJQNw3idLFhMRNB0SgASTJyKoy/4ieXCeFfJBUeV2SoAclFyR0bbm1OHTUiN0/DTAwD7zQeM52dqj8VsGEkVE2jKetG7AEhQ0frJAv6RC0trC1skl+IWlNinGLbSaZg7Mc0xfA8MbgF1LQV1z08A2G8+oM7PVF9Ms2GUE0gQyp+Lwu2yagLgR9ZaYpkSypQ6a6Q2DCqzpkvietXIFdoZfuieGmcOD0DeP0HEbBhNwYPmA/L8zJQsATAKnguEqS+XTqkE4YfWWwCUFZTksYAYwZfIBeN9Tw0cjOwu8gDIZqsoSSvhEeQDiiGYFoyWiSDRypWgi69UP5sc5fIcquSCNeXqe2X9ZAHfM7Khe2pcOB+AT41+aO5iRD3QAHBEHd9ctuiBBoANEkbaAw0AR9r9zcUbADYYGGkPNAAcafc3F28A2GBgpD3QAHCk3d9cvAFgg4GR9kADwJF2f3PxBoANBkbaAw0AR9r9zcUbADYYGGkPNAAcafc3F28A2GBgpD3QAHCk3d9cfOxqYJ2au9RdPtdp/khoEOlglDYT39V1PzQFXLsMXAlgt9PCxJKPbufyf8/KHIPfBPAZABf79Xc5XQ0ZQ1Q7360NbxoHrlsDvs5ZRsgo0une06by6X1mZvtP99PNAp4F4LsBXA5gjw8EGTeqaGF4QhzQF80CX7cAvGIdeDYAfhdZ2sTKUcVrpE7nd31N5gj8e2dIo2osk7NZpMdK0Z19tv+bJ4F9K8D1ACj8yfNSikHeg+5Z969m57Y/8/ZP+dPLKZhP/rcA+AYAF7g1oRUhEMUzFMt6eSJfX78b2DkPfM0i8GIAX+uWlAMppreUUErn8p2gzTl+2flg/sDbTkvIOik+CP20//mzwAXzwDcCuNTPJeFXpEpM6QEjIHm/zTF8D7T5gATYNQCe69aAloRTGulfBESBSYNyxR5g/Bhw7hKwZwl4vk9LnM5JmsBzUyDGAX3B8G23Mz/g9BuUa/0IiutfMkj7zwKmngAuXSvOpUvAWYBtF4BTnspIj/O8zPaf7qdvWITw6eZA0JLQEhKEGgxZhUj/dz3NzSKwbR44exnYvVKcy+mM5Km0JhxInUtrGkmzCPicg3W5LMGkQiZZTm9xS9Z3+4m2o8C5c4X15pTKW2Lb+fCx7WLtjYxzqiql29Icw/dA5SqYf6RTTilg+lYCIXmICKQ4IK9wxfSJY8AZK8CuFWDnanEua9ZTAMsaCog3Dt92O/MvnRGBtGwkqKRmMEkqCaa+2k+0LQDTh4rP88UHj74kF1WaATo9QHQ7mmP4HugYhtEKj4PB6ZQ+FS0hQahpldPya1kXTOqNY8DscgG+HavAttUCvBxInitrkgL4lcO33c7spBdM3kAuSnq2nx9gQfAh4JyVwvrxwel2z3p4aMlzH6DM2z/lT+8aB+Q/OT4EEqckWQSBkGD6EQKQnDCLwBSnYgcf32fXioGUFawC4esyu7CXXnDP9tOCsyD4KLB1rmgvX7zfbu2WG/Jtme0/3U/vKxBNAMoi0KcjkATCN3HOEr3UAjDrwOP71rXixYEkeKMFlSX8ocwR6KUXTJ7AaNE2tF8WfA4Ye7Kw1mwvX/yZn+eKnvcrfzC6IK/ObP/pfnpfAGQnySoISBqUXyAASS1AK0JfagWYcRDOrAF66TxZQU7jBOEbM0egH71gcgXSFZAV54NQtj9YcNIpbONCyh8Ygi8CVospApDuB63g92W2/3Q/vW8AsqM4gLIKBBIH8bcJwMCNMX68BTqBb8s6sGWtsIA6jwDk662ZI9CvXjA5A6NVa2t/IAicnC/aGV+8T74IQPm/AmGuBc+8/VP+9IEAyLslAKMV/LgAyIUInfnjwPQqMOOgI/DstQ5Mr7UAqMF8V2YXDqoXXNl+EQQ6N9v29aKdesUpWJZbAPyPme0/3U8fGIDssDid/pUASCvCaXgJmFguAEfgEXT27gDkuwaUg/nbmSMwjF7whvbLhSDL5TwwvdRqo9oqHzACkCB8U2b7T/fThwIgO01T1IMCoAZxGRhbKoAXQUcQTjkI+a4B5e5FzjGsXvCG9gdqrLGFYrpVG/UuHzBOw2/LaXxzbh43DKeoJwlAHqLndSs4udoCoIBHQE45EPk3DuitmYOQoxdctp8+rFwIWsGFYiFFoLGNchcEQC6e+OJC5J2Z7T/dTx/aApYdJ37AyJK/DIwvFxYvWr0IwEn/H1Opco5sveDUhSAAF4HJpQJkWixp6k2n4IYfMGf0amDHev2I8+l4/UbvNw8Eozw72wJePOJ8und7EkKj9ztKGA1/7WwATo44n45pWI3e7/AAGPWZ2QBkYHCU+XTMfGGQmYIxjd7vqOE0+PXzATjifDrKtTZ6v4MP/MlyRj4AR5xPF+VaqZLJF1UzKdPV6P2eLDDr3I58AI44n07ZMARbo/d78gMubWE+AEecT8e9YOn2Uheu0fs9tUCYD8AR59MpG6bR+z21gKfW1gNAz4geRT5dTEZo9H5PPRDmAzBmRM8BJzqfLiYjSKKr0fs9dYBYDwBHmE9XtRfMsIz04aQZ1+j9npygrA+Akqs8wfl0BCCTWRq935MTYL1aVQ8Ao1zlAnAi8+kEQGZTNXq/vYb75Pt/fQAcUT5dBGCj93vyAaxXi+oDoFLyT3A+3Rcavd9eY3xS/z8fgCQX/LPR3SOzkon55jg1eyAfgD8M4NcAPD6aDmBtB1e4NMDNcer1QD4AbwbwxwDe4UvRE9wHZG1gNSXDLlwLNcep1QP5APxzzwj9IIAPnXhT5ORc5EYCA9HNcWr1QD4AmRH6FQBMTSZZH98ZmD5Bh5g1FopiNns1x6nTA/kAvAfAEwDudnI+EvQxPfkEzYfaCXRSBluQMB7YHKdGD+QDsBNBH/9+AkAobqTADGK7Inw1x8nfA/kA7EXQt8kgrGAGMfBxZ5Cv5ji5eyAfgL0I+r68uR0QmUFoBQU8vfNvzXHy9kA9AORoMw7CdGQCjoUZDwL4kv/+8OZ1gJhBIjGDgMh3vTavBc035/RAPgD7JegjODfhiMwgoqeJwNPPTaB6Ezq/hq+sB4AcXeXEP+ZhGVo9vRimIQD5v5oPAZCupgDI9wg8/qz/1Xz55usyeyAfgMMQ9GU2Op4eAchpOIJQQEz/VuPlm6/K7IH6AMjgGzdl6QtyX5jWjpQFevF3lq3xf6yhrOlIAUgQCojR8gmE+l9Nl2++JrMH6gEgR5UA5KYsc+AZmCbQCDi+IvgEQMob1XBEAHIajgBMLV+0kCdws6aGu3zqfkV9AGTwjftg3JRVVRAtHQEXX/wbAcoXP5d5CID8GoJKvqDAloKOoIz/y7x8c3pmD4zhaqwjRzCYyQg5gr2ZgsFTLweWr8XQgsXjbwLWrnNtMlKgNoLBmZAa7PTCAuYIBlMvlWQswwr2UlUw45jdDSx8HbD+Ctd+HVCwePKbgJV9aASDM8Yg59TWFDysYPBtmYK91IbNOHaPA/M7gUXKXA4hWDz79cA8+W0aweCMURj+1HYfcBjBYO54MMY3tGDv8I3nmWSHOzYOLJ0LLPGXAQWLz3oB8MQUsEa16kYwOG8whjh74yJkUMFgbsNlCfYO0epwissVY34bsHw2sEIRkAEEi/dcU0SP5qhF1ggG5w3GEGdXr4L5134Fg4kAjuDQgr1DtDqcUmZETwArZwAru4BVqsv0KVh8/o3F4v0QXZBGMDhvMIY4u3MYhv95Zh+Cu1xBcxuOU/HfeDIq5cv7FuwdotXhlCBXjOXZAnyrO4BV6in0IVh8wStLuWCsUAyvEQzOG5ABz+4eB+R/ewnu/kOP/3G/l4kJTERlljQtIot2e53/IwO2OPl4FLtcnCqAp9cahT56CBZf+LpSLhhz1N5qBIPzBmTAs/sLRHcTDKbiNHdBGGymOC/3hglEvgjAnoK9A7Y4+XgiV4zVWYDAs/etxaubYPFFP1QkLtCIP8neaASD8wZkwLP7AyC/tJNg8L/xLNBu+YBdBXsHbHEFAINcMVamgdWZAoRrfPdXm8KitLdmgYveWAq+2y7iMqfuRjA4b1AGOLt/APJLqwSD3+y5T1yI0AoSbAxMMzGV1o8/My2ro2DvAK2t+GgiV4zj4+3AIwDXtwBrVJeuECze+9aW4Dut4PxkIhYsdetGMDhvoDqcPRgA+SWp4O4veQ5Uv/mAGwR78+6rQq4Yq9PAOi2fA4/vBkKudKVU7VZw77uKvWFuZbtcMNb5v0YwOG9g+jx7cADyi6Pg7gccgIxlcA5TKhaD01yYKBmVFpBZMfx/m2Bvny3t8LGqoqTliZbVI+gMgHwnMAnCIFi897cLAAZ6QyzFzzSCwXkD1OPs4QDIL5XgLmk5JHk/SD5gKdibd38VcsVYGmuBTaAzEHLHgyCcaokB7/1IkUET5IKxwF5pBIPzBqbPs4cHIC/AaeqvPL9pmHxAE+zts6VdLCD/lcgVY3UyWD0Bj1ZwqgCggXA7sPfWAoAJvaEtZBrB4Lyx6efsPADyCtmCvf00s/NnOsgVY3m8BTRZPZuGBUACdArY+5lWDqGmYbIrLHEx0ggG5w1OH2fnA7CPizQfaXqgUw80AGywMdIeaAA40u5vLt4AsMHASHugAeBIu7+5eAPABgMj7YEGgCPt/ubiDQAbDIy0BxoAjrT7m4s3AGwwMNIeaAA40u5vLt4AsMHASHugAeBIu7+5eAPABgMj7YEGgCPt/ubiDQAbDIy0B8ZYNMbkX+ZekpuIiOQrPar+xs889HJg6jZg5jAwvVZ8B+ll9PlO5/Fc/o+ECjnHfi8zYfkvM5ulmp4qJXVqx5deD4zfAkw/CGxdAZgoHfuh131QkaI5hu8Bs4Ds8B0AWLnIRGCBsFfn87JffDMwdjOw5R5g8giwZa34jnQQUwDo99wBfJ4TM7COiNdlaj2rA/jeV/vfDeATAP4UGH8I2Lrc6gc+SHqY4oMZ74VSKM0xfA+UUzB/oBUUCKMl6zSQ/PsXqZD5KQC/A0w/DEwcAcYXgYnVwppwADuBkefnCim90FmBWXwnK87Uen53BI8sbuwqaz9p5UgnQhBS+ZN1zE8Ak0utviCwq8DI8/nx5hi+Bzb4gJzKZE1SEFZZgS9/2pWR/gTAJ4HJQ8DEMWB8ARhfBsaWCwDquwQKvvNgHXvOcYVbPFJPkw+dDxC/W1Y4tWDpw/Rlgo4lo1T4/KxTihDNpJwj3/UiMLXemprjffC7eWpzDN8DlYsQDiKtVxzEqoHkyX9HRizW+nIgaQnvAiaeBCbmC0s4tgSMu2rMePAR9X252jXklaTFU108K0MHav/nvJ6ZxVVk9OI7GR2IZoGQNc/HgbHgIwqILIVujuF7oOMqWFawCoRxkfEIB5CWgkREBCNf9wMTc8A4QciBWyoGz16rwNgaML5eWKpctYZL3N+TWLX0gvtuP0HHk2n16JDyxXmVhfU0qywbJbr5GSuXKxA/sV5Y9UYWdnjwyS3qKKgarWA69Wg6fjQOIK0HadnIjPVFB+AiME4AuiUkCFnESyCSkmAuU7Cjm15wX+2X2ifBRn9A8mKcW2UFjULVQcgVDl80u40SYh763FfvquhLCxitoBYUsoJfjXKttByMq9CKcHn4sPuCbgXNJwyWkECcz5Q376UX3LNncZyQAAADEklEQVT9fFgIJs6lBBwtn3Tt6FpIz4RWnuQxPh2XIGzm4CwQ9hWIFgBTK0gQHiIAJddKq0ELQh+KL1qUR4MvSEsoENIKrgALHNiMox+94K7tl9qnnMio8MSf6SNwGpYVjCDk/Ju7isq496fCqX0BkDeqlWwKwic1gAQSpzGREnFgREz01eALLvvq2Kfi45m6cf3qBXdsfxRbJMho8dimqOhEK8cXQRr9QVpvPoDNMXQP9A3ACELFxPh+jACkP0fLIKFCCRRqKuPUdqjlC9o07JZwKVNHeBC94DQcZO0XAAkmgotAk9QYrR9f/BvByYfMSATDVMzwTXMM3QMDAVAgVHCZ7/MaQK4QZUHiNCbBQlqUw74YCb7gcmYkelC9YFlwvVv7RRAorTuBkECU9asCID9/x9B935zYzyKkqpfiNHxcA0gLQgvBAaPVkCqm3h2AtC5m/RyEqzw/4xhGL3hD++MmslgqCbgUfLKAcRrmTlBzDN0DA1tAXUlWcDm1IOIIJAjlT/Fd05lbFQFwjdtgGcewesFt7Rc/Gx8iWjUCjGCT1YvWT1MwgUqrf3NG45tTbcu0aximWx9xENcEQHGbcYAEwtSXSqY0gnCdgeuMI0cvuGx/FUGgFhwEYrR80QckWN+X0fjm1DwAWv8RgJFilJZBznz0pQg+AZAAlVWh1GvGka0XzB0cCQi30aSGVa9AF62fLOB7MhrfnJoPwPER59Px+o3e76mL5Kwp2G57xPl0kxc3er+nLvyKtLmhfUC78RHn081ONnq/pzcAR5xPR9mRRu/31IVgvgUccT4dNaobvd/TGYAjzqejumqj93s6A3DE+XRUg2VSCjdaGr3fUw+I+VPwiPPpqJjO8J1Nw43e7ymHwHoAKMFd7QErAeEE5NNJMb3R+z3lsGcNzgfgiPPpomJ6o/d76oGwPgCOKJ8uKqY3er+nKwBHmE+noqRG7/fUA199U/AI8+kEwEbv93QHoEhZTnA+nYqSGr3fBoAtaiqBUImdm5hPJwA2er+nKwBHnE+X1gUzSbnR+z11wPj/AeCpPDD3t7rvAAAAAElFTkSuQmCC",
        Mo = { LOW: 0, MEDIUM: 1, HIGH: 2, ULTRA: 3 },
        Ml = class extends AG {
          constructor({
            preset: _ = Mo.MEDIUM,
            edgeDetectionMode: L = Ap.COLOR,
            predicationMode: R = 0,
          } = {}) {
            let N, z;
            super(
              "SMAAEffect",
              "uniform sampler2D weightMap;varying vec2 vOffset0;varying vec2 vOffset1;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 a;a.x=texture2D(weightMap,vOffset0).a;a.y=texture2D(weightMap,vOffset1).g;a.wz=texture2D(weightMap,uv).rb;vec4 color=inputColor;if(dot(a,vec4(1.0))>=1e-5){bool h=max(a.x,a.z)>max(a.y,a.w);vec4 blendingOffset=vec4(0.0,a.y,0.0,a.w);vec2 blendingWeight=a.yw;movec(bvec4(h),blendingOffset,vec4(a.x,0.0,a.z,0.0));movec(bvec2(h),blendingWeight,a.xz);blendingWeight/=dot(blendingWeight,vec2(1.0));vec4 blendingCoord=blendingOffset*vec4(texelSize,-texelSize)+uv.xyxy;color=blendingWeight.x*texture2D(inputBuffer,blendingCoord.xy);color+=blendingWeight.y*texture2D(inputBuffer,blendingCoord.zw);}outputColor=color;}",
              {
                vertexShader:
                  "varying vec2 vOffset0;varying vec2 vOffset1;void mainSupport(const in vec2 uv){vOffset0=uv+texelSize*vec2(1.0,0.0);vOffset1=uv+texelSize*vec2(0.0,1.0);}",
                blendFunction: AF.NORMAL,
                attributes: Aj.CONVOLUTION | Aj.DEPTH,
                uniforms: new Map([["weightMap", new oz(null)]]),
              },
            ),
              arguments.length > 1 &&
                ((N = arguments[0]),
                (z = arguments[1]),
                arguments.length > 2 && (_ = arguments[2]),
                arguments.length > 3 && (L = arguments[3])),
              (this.renderTargetEdges = new iH(1, 1, {
                minFilter: 1006,
                stencilBuffer: !1,
                depthBuffer: !1,
              })),
              (this.renderTargetEdges.texture.name = "SMAA.Edges"),
              (this.renderTargetWeights = this.renderTargetEdges.clone()),
              (this.renderTargetWeights.texture.name = "SMAA.Weights"),
              (this.uniforms.get("weightMap").value =
                this.renderTargetWeights.texture),
              (this.clearPass = new AL(!0, !1, !1)),
              (this.clearPass.overrideClearColor = new iz(0)),
              (this.clearPass.overrideClearAlpha = 1),
              (this.edgeDetectionPass = new Aq(new Af())),
              (this.edgeDetectionMaterial.edgeDetectionMode = L),
              (this.edgeDetectionMaterial.predicationMode = R),
              (this.weightsPass = new Aq(new AM()));
            let F = new a6();
            (F.onLoad = () => {
              let _ = new iG(N);
              (_.name = "SMAA.Search"),
                (_.magFilter = 1003),
                (_.minFilter = 1003),
                (_.generateMipmaps = !1),
                (_.needsUpdate = !0),
                (_.flipY = !0),
                (this.weightsMaterial.searchTexture = _);
              let L = new iG(z);
              (L.name = "SMAA.Area"),
                (L.magFilter = 1006),
                (L.minFilter = 1006),
                (L.generateMipmaps = !1),
                (L.needsUpdate = !0),
                (L.flipY = !1),
                (this.weightsMaterial.areaTexture = L),
                this.dispatchEvent({ type: "load" });
            }),
              F.itemStart("search"),
              F.itemStart("area"),
              void 0 !== N && void 0 !== z
                ? (F.itemEnd("search"), F.itemEnd("area"))
                : "u" > typeof Image &&
                  ((N = new Image()),
                  (z = new Image()),
                  N.addEventListener("load", () => F.itemEnd("search")),
                  z.addEventListener("load", () => F.itemEnd("area")),
                  (N.src = Mr),
                  (z.src = Ma)),
              this.applyPreset(_);
          }
          get edgesTexture() {
            return this.renderTargetEdges.texture;
          }
          getEdgesTexture() {
            return this.edgesTexture;
          }
          get weightsTexture() {
            return this.renderTargetWeights.texture;
          }
          getWeightsTexture() {
            return this.weightsTexture;
          }
          get edgeDetectionMaterial() {
            return this.edgeDetectionPass.fullscreenMaterial;
          }
          get colorEdgesMaterial() {
            return this.edgeDetectionMaterial;
          }
          getEdgeDetectionMaterial() {
            return this.edgeDetectionMaterial;
          }
          get weightsMaterial() {
            return this.weightsPass.fullscreenMaterial;
          }
          getWeightsMaterial() {
            return this.weightsMaterial;
          }
          setEdgeDetectionThreshold(_) {
            this.edgeDetectionMaterial.edgeDetectionThreshold = _;
          }
          setOrthogonalSearchSteps(_) {
            this.weightsMaterial.orthogonalSearchSteps = _;
          }
          applyPreset(_) {
            let L = this.edgeDetectionMaterial,
              R = this.weightsMaterial;
            switch (_) {
              case Mo.LOW:
                (L.edgeDetectionThreshold = 0.15),
                  (R.orthogonalSearchSteps = 4),
                  (R.diagonalDetection = !1),
                  (R.cornerDetection = !1);
                break;
              case Mo.MEDIUM:
                (L.edgeDetectionThreshold = 0.1),
                  (R.orthogonalSearchSteps = 8),
                  (R.diagonalDetection = !1),
                  (R.cornerDetection = !1);
                break;
              case Mo.HIGH:
                (L.edgeDetectionThreshold = 0.1),
                  (R.orthogonalSearchSteps = 16),
                  (R.diagonalSearchSteps = 8),
                  (R.cornerRounding = 25),
                  (R.diagonalDetection = !0),
                  (R.cornerDetection = !0);
                break;
              case Mo.ULTRA:
                (L.edgeDetectionThreshold = 0.05),
                  (R.orthogonalSearchSteps = 32),
                  (R.diagonalSearchSteps = 16),
                  (R.cornerRounding = 25),
                  (R.diagonalDetection = !0),
                  (R.cornerDetection = !0);
            }
          }
          setDepthTexture(_, L = 3200) {
            (this.edgeDetectionMaterial.depthBuffer = _),
              (this.edgeDetectionMaterial.depthPacking = L);
          }
          update(_, L, R) {
            this.clearPass.render(_, this.renderTargetEdges),
              this.edgeDetectionPass.render(_, L, this.renderTargetEdges),
              this.weightsPass.render(
                _,
                this.renderTargetEdges,
                this.renderTargetWeights,
              );
          }
          setSize(_, L) {
            this.edgeDetectionMaterial.setSize(_, L),
              this.weightsMaterial.setSize(_, L),
              this.renderTargetEdges.setSize(_, L),
              this.renderTargetWeights.setSize(_, L);
          }
          dispose() {
            let { searchTexture: _, areaTexture: L } = this.weightsMaterial;
            null !== _ && null !== L && (_.dispose(), L.dispose()),
              super.dispose();
          }
          static get searchImageDataURL() {
            return Mr;
          }
          static get areaImageDataURL() {
            return Ma;
          }
        },
        Mh = `uniform float offset;uniform float darkness;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){const vec2 center=vec2(0.5);vec3 color=inputColor.rgb;
#if VIGNETTE_TECHNIQUE == 0
float d=distance(uv,center);color*=smoothstep(0.8,offset*0.799,d*(darkness+offset));
#else
vec2 coord=(uv-center)*vec2(offset);color=mix(color,vec3(1.0-darkness),dot(coord,coord));
#endif
outputColor=vec4(color,inputColor.a);}`,
        Mc = { DEFAULT: 0, ESKIL: 1 },
        Md = class extends AG {
          constructor({
            blendFunction: _ = AF.NORMAL,
            technique: L = Mc.DEFAULT,
            eskil: R = !1,
            offset: N = 0.5,
            darkness: z = 0.5,
          } = {}) {
            super("VignetteEffect", Mh, {
              blendFunction: _,
              defines: new Map([["VIGNETTE_TECHNIQUE", L.toFixed(0)]]),
              uniforms: new Map([
                ["offset", new oz(N)],
                ["darkness", new oz(z)],
              ]),
            });
          }
          get technique() {
            return Number(this.defines.get("VIGNETTE_TECHNIQUE"));
          }
          set technique(_) {
            this.technique !== _ &&
              (this.defines.set("VIGNETTE_TECHNIQUE", _.toFixed(0)),
              this.setChanged());
          }
          get eskil() {
            return this.technique === Mc.ESKIL;
          }
          set eskil(_) {
            this.technique = _ ? Mc.ESKIL : Mc.DEFAULT;
          }
          getTechnique() {
            return this.technique;
          }
          setTechnique(_) {
            this.technique = _;
          }
          get offset() {
            return this.uniforms.get("offset").value;
          }
          set offset(_) {
            this.uniforms.get("offset").value = _;
          }
          getOffset() {
            return this.offset;
          }
          setOffset(_) {
            this.offset = _;
          }
          get darkness() {
            return this.uniforms.get("darkness").value;
          }
          set darkness(_) {
            this.uniforms.get("darkness").value = _;
          }
          getDarkness() {
            return this.darkness;
          }
          setDarkness(_) {
            this.darkness = _;
          }
        };
      function ar(_, L, R, N) {
        var z;
        return (z = _ + (L - _) * 0.75) + (R + (N - R) * 0.75 - z) * 0.875;
      }
      new Float32Array(3),
        new Float32Array(3),
        new Float32Array(3),
        new Float32Array(3),
        new Float32Array(3),
        new Float32Array(3),
        new Float32Array([0, 0, 0]),
        new Float32Array([1, 0, 0]),
        new Float32Array([1, 1, 0]),
        new Float32Array([1, 1, 1]),
        new Float32Array([0, 0, 0]),
        new Float32Array([1, 0, 0]),
        new Float32Array([1, 0, 1]),
        new Float32Array([1, 1, 1]),
        new Float32Array([0, 0, 0]),
        new Float32Array([0, 0, 1]),
        new Float32Array([1, 0, 1]),
        new Float32Array([1, 1, 1]),
        new Float32Array([0, 0, 0]),
        new Float32Array([0, 1, 0]),
        new Float32Array([1, 1, 0]),
        new Float32Array([1, 1, 1]),
        new Float32Array([0, 0, 0]),
        new Float32Array([0, 1, 0]),
        new Float32Array([0, 1, 1]),
        new Float32Array([1, 1, 1]),
        new Float32Array([0, 0, 0]),
        new Float32Array([0, 0, 1]),
        new Float32Array([0, 1, 1]),
        new Float32Array([1, 1, 1]),
        new Float32Array(2),
        new Float32Array(2),
        new Float32Array([0, -0.25, 0.25, -0.125, 0.125, -0.375, 0.375]),
        new Float32Array([0, 0]),
        new Float32Array([0.25, -0.25]),
        new Float32Array([-0.25, 0.25]),
        new Float32Array([0.125, -0.125]),
        new Float32Array([-0.125, 0.125]),
        new Uint8Array([0, 0]),
        new Uint8Array([3, 0]),
        new Uint8Array([0, 3]),
        new Uint8Array([3, 3]),
        new Uint8Array([1, 0]),
        new Uint8Array([4, 0]),
        new Uint8Array([1, 3]),
        new Uint8Array([4, 3]),
        new Uint8Array([0, 1]),
        new Uint8Array([3, 1]),
        new Uint8Array([0, 4]),
        new Uint8Array([3, 4]),
        new Uint8Array([1, 1]),
        new Uint8Array([4, 1]),
        new Uint8Array([1, 4]),
        new Uint8Array([4, 4]),
        new Uint8Array([0, 0]),
        new Uint8Array([1, 0]),
        new Uint8Array([0, 2]),
        new Uint8Array([1, 2]),
        new Uint8Array([2, 0]),
        new Uint8Array([3, 0]),
        new Uint8Array([2, 2]),
        new Uint8Array([3, 2]),
        new Uint8Array([0, 1]),
        new Uint8Array([1, 1]),
        new Uint8Array([0, 3]),
        new Uint8Array([1, 3]),
        new Uint8Array([2, 1]),
        new Uint8Array([3, 1]),
        new Uint8Array([2, 3]),
        new Uint8Array([3, 3]),
        ar(0, 0, 0, 0),
        new Float32Array([0, 0, 0, 0]),
        ar(0, 0, 0, 1),
        new Float32Array([0, 0, 0, 1]),
        ar(0, 0, 1, 0),
        new Float32Array([0, 0, 1, 0]),
        ar(0, 0, 1, 1),
        new Float32Array([0, 0, 1, 1]),
        ar(0, 1, 0, 0),
        new Float32Array([0, 1, 0, 0]),
        ar(0, 1, 0, 1),
        new Float32Array([0, 1, 0, 1]),
        ar(0, 1, 1, 0),
        new Float32Array([0, 1, 1, 0]),
        ar(0, 1, 1, 1),
        new Float32Array([0, 1, 1, 1]),
        ar(1, 0, 0, 0),
        new Float32Array([1, 0, 0, 0]),
        ar(1, 0, 0, 1),
        new Float32Array([1, 0, 0, 1]),
        ar(1, 0, 1, 0),
        new Float32Array([1, 0, 1, 0]),
        ar(1, 0, 1, 1),
        new Float32Array([1, 0, 1, 1]),
        ar(1, 1, 0, 0),
        new Float32Array([1, 1, 0, 0]),
        ar(1, 1, 0, 1),
        new Float32Array([1, 1, 0, 1]),
        ar(1, 1, 1, 0),
        new Float32Array([1, 1, 1, 0]),
        ar(1, 1, 1, 1),
        new Float32Array([1, 1, 1, 1]);
      var Mu = class {
          constructor(_, L) {
            (this.enabled = !1),
              (this.effect = new _(L)),
              Object.defineProperty(this, "opacity", {
                enumerable: !0,
                set(_) {
                  this.effect.blendMode.opacity.value = _;
                },
                get() {
                  return this.effect.blendMode.opacity.value;
                },
              }),
              Object.defineProperty(this, "blendFunction", {
                enumerable: !0,
                set(_) {
                  this.effect.blendMode.setBlendFunction(Number(_));
                },
                get() {
                  return this.effect.blendMode.blendFunction;
                },
              }),
              (this.blendFunction = AF.NORMAL);
          }
        },
        Mp = class extends Mu {
          constructor() {
            super(A$), (this.blendFunction = AF.SCREEN);
          }
          set intensity(_) {
            this.effect.intensity = _;
          }
          get intensity() {
            return this.effect.intensity;
          }
          set luminanceThreshold(_) {
            this.effect.luminanceMaterial.threshold = _;
          }
          get luminanceThreshold() {
            return this.effect.luminanceMaterial.threshold;
          }
          set luminanceSmoothing(_) {
            this.effect.luminanceMaterial.smoothing = _;
          }
          get luminanceSmoothing() {
            return this.effect.luminanceMaterial.smoothing;
          }
          set blurScale(_) {
            this.effect.blurPass.scale = _;
          }
          get blurScale() {
            return this.effect.blurPass.scale;
          }
          set kernelSize(_) {
            this.effect.blurPass.kernelSize = _;
          }
          get kernelSize() {
            return this.effect.blurPass.kernelSize;
          }
        },
        Mf = class extends Mu {
          constructor() {
            super(A0);
          }
          set contrast(_) {
            this.effect.uniforms.get("contrast").value = _;
          }
          get contrast() {
            return this.effect.uniforms.get("contrast").value;
          }
          set brightness(_) {
            this.effect.uniforms.get("brightness").value = _;
          }
          get brightness() {
            return this.effect.uniforms.get("brightness").value;
          }
        },
        Mm = class extends Mu {
          constructor() {
            super(A4), (this.effect.offset = new iT(0.01, 0.01));
          }
          set offset(_) {
            this.effect.offset.set(_[0] / 1e3, _[1] / 1e3);
          }
          get offset() {
            return [1e3 * this.effect.offset.x, 1e3 * this.effect.offset.y];
          }
        },
        Mg = class extends Mu {
          constructor() {
            super(A2);
          }
        },
        Mv = class extends Mu {
          constructor() {
            super(A9), (this._hue = 0);
          }
          set hue(_) {
            (this._hue = _), this.effect.setHue(_);
          }
          get hue() {
            return this._hue;
          }
          set saturation(_) {
            this.effect.uniforms.get("saturation").value = _;
          }
          get saturation() {
            return this.effect.uniforms.get("saturation").value;
          }
        },
        My = class extends Mu {
          constructor() {
            super(Mt), (this.blendFunction = AF.OVERLAY);
          }
        },
        Mb = class extends Mu {
          constructor() {
            super(Md);
          }
          get eskil() {
            return this.effect.eskil;
          }
          set eskil(_) {
            this.effect.eskil = _;
          }
          get darkness() {
            return this.effect.uniforms.get("darkness").value;
          }
          set darkness(_) {
            this.effect.uniforms.get("darkness").value = _;
          }
          get offset() {
            return this.effect.uniforms.get("offset").value;
          }
          set offset(_) {
            this.effect.uniforms.get("offset").value = _;
          }
        },
        Mw = class extends Mu {
          constructor(_) {
            super(A8, _);
          }
          set focalLength(_) {
            this.effect.circleOfConfusionMaterial.uniforms.focalLength.value =
              _;
          }
          get focalLength() {
            return this.effect.circleOfConfusionMaterial.uniforms.focalLength
              .value;
          }
          set focusDistance(_) {
            this.effect.circleOfConfusionMaterial.uniforms.focusDistance.value =
              _;
          }
          get focusDistance() {
            return this.effect.circleOfConfusionMaterial.uniforms.focusDistance
              .value;
          }
          get bokehScale() {
            return this.effect.bokehScale;
          }
          set bokehScale(_) {
            this.effect.bokehScale = _;
          }
        },
        M_ = class extends Mu {
          constructor() {
            super(Mi);
          }
          get granularity() {
            return this.effect.getGranularity();
          }
          set granularity(_) {
            this.effect.setGranularity(_);
          }
        },
        MS = class extends AC {
          constructor(_, L, R) {
            super("TransmissionPass", _, L),
              (this.copyPass = new AP(R.transmissionRenderTarget)),
              (this.depthPass = new Az(_, L, {
                renderTarget: R.transmissionDepthTarget,
              })),
              (this.needsSwap = !1);
          }
          updatePasses(_) {
            (this.copyPass = new AP(_.transmissionRenderTarget)),
              (this.depthPass = new Az(this.scene, this.camera, {
                renderTarget: _.transmissionDepthTarget,
              }));
          }
          setCamera(_) {
            this.camera = _;
          }
          setScene(_) {
            this.scene = _;
          }
          render(_, L, R) {
            let N = this.camera.layers.mask;
            this.copyPass.render(_, L, R),
              this.camera.layers.disable(3),
              this.depthPass.render(_, L, R),
              (_.shadowMap.needsUpdate = !1),
              (_.shadowMap.autoUpdate = !1);
            let z = this.renderToScreen ? null : L;
            this.camera.layers.set(3),
              _.setRenderTarget(z),
              _.render(this.scene, this.camera),
              (this.camera.layers.mask = N);
          }
        },
        MA = new n2(),
        MT = new sQ({
          transparent: !0,
          vertexShader: `
        void main() {
            gl_Position = vec4(0.0);
        }
    `,
          fragmentShader: `
        void main() {
            gl_FragColor = vec4(0.0);
        }
    `,
        }),
        MC = class extends AC {
          constructor(_, L) {
            super("OpaquePass", _ ?? MA, L),
              (this.hasTransmissionPass = !1),
              (this.clear = !0),
              (this.needsSwap = !1),
              (this.originalMaterials = new Map());
          }
          setCamera(_) {
            this.camera = _;
          }
          setScene(_) {
            this.scene = _ ?? MA;
          }
          getScene() {
            return this.scene;
          }
          render(_, L) {
            this.originalMaterials.clear(),
              this.camera.layers.enable(3),
              this.hasTransmissionPass &&
                this.scene.traverse((_) => {
                  _.layers.isEnabled(3) &&
                    _ instanceof v6 &&
                    (this.originalMaterials.set(_.id, _.material),
                    (_.material = MT));
                }),
              this.camera.layers.enable(8),
              (_.shadowMap.needsUpdate = !0),
              (_.shadowMap.autoUpdate = !0);
            let R = this.renderToScreen ? null : L;
            _.setRenderTarget(R),
              this.clear && _.clear(),
              _.render(this.scene, this.camera),
              this.hasTransmissionPass &&
                this.originalMaterials.forEach((_, L) => {
                  let R = this.scene.getObjectById(L);
                  R && (R.material = _);
                });
          }
        };
      function rI(_, L) {
        return L && L.enabled && _.push(L.effect), _;
      }
      var A6 = (_) => (Object.values(AF).includes(_) ? _ : AF.NORMAL),
        MD = class extends ig {
          constructor(_) {
            super(),
              (this.postprocessingState = pR.defaultData),
              (this._scene = new n2()),
              (this._camera = new bj()),
              (this.effects = new Map()),
              (this._renderToScreen = !0),
              (this.clock = new oE()),
              (this.renderer = _),
              (this.debug = !1),
              this.effects.set("bloom", new Mp()),
              this.effects.set("chromaticAberration", new Mm()),
              this.effects.set("vignette", new Mb()),
              this.effects.set("noise", new My()),
              this.effects.set("colorAverage", new Mg()),
              this.effects.set("hueSaturation", new Mv()),
              this.effects.set("brightnessContrast", new Mf()),
              this.effects.set("depthOfField", new Mw()),
              this.effects.set("pixelation", new M_()),
              (this.effectComposer = new AZ(this.renderer)),
              (this.opaquePass = new MC(this.scene, this.camera)),
              (this.transmissionPass = new MS(
                this.scene,
                this.camera,
                this.renderer,
              )),
              (this.helperPass = new MC(void 0, this.camera)),
              (this.helperPass.hasTransmissionPass = !1),
              (this.helperPass.clear = !1),
              (this.helperClearPass = new AL(!1, !0, !1)),
              (this.helperPassOnTop = new MC(void 0, this.camera)),
              (this.helperPassOnTop.hasTransmissionPass = !1),
              (this.helperPassOnTop.clear = !1),
              this._initCopyPass(),
              this._initSmaa(),
              this._initPasses();
          }
          get scene() {
            return this._scene;
          }
          set scene(_) {
            (this._scene = _),
              this.opaquePass.setScene(_),
              this.transmissionPass.setScene(_);
          }
          set sceneHelpers(_) {
            this.helperPass.setScene(_);
          }
          get sceneHelpers() {
            return this.helperPass.getScene();
          }
          set sceneHelpersOnTop(_) {
            this.helperPassOnTop.setScene(_);
          }
          get sceneHelpersOnTop() {
            return this.helperPassOnTop.getScene();
          }
          get camera() {
            return this._camera;
          }
          set camera(_) {
            (this._camera = _),
              this.opaquePass.setCamera(_),
              this.transmissionPass.setCamera(_),
              this.helperPass.setCamera(_),
              this.helperPassOnTop.setCamera(_);
          }
          setTransmissionPassEnabled(_) {
            (this.transmissionPass.enabled = _),
              (this.opaquePass.hasTransmissionPass = _);
          }
          disableHelpers() {
            (this.helperPass.enabled = !1),
              (this.helperClearPass.enabled = !1),
              (this.helperPassOnTop.enabled = !1);
          }
          enableHelpers() {
            (this.helperPass.enabled = !0),
              (this.helperClearPass.enabled = !0),
              (this.helperPassOnTop.enabled = !0);
          }
          _initSmaa() {
            let _ = new Ml({ preset: Mo.ULTRA, edgeDetectionMode: Ap.COLOR }),
              n = () => {
                _.removeEventListener("load", n),
                  this.dispatchEvent({ type: "smaaloaded" });
              };
            _.addEventListener("load", n),
              (_.edgeDetectionMaterial.predicationMode = 1),
              (_.edgeDetectionMaterial.edgeDetectionThreshold = 0.05),
              (_.edgeDetectionMaterial.predicationThreshold = 0.002),
              (_.edgeDetectionMaterial.predicationScale = 1),
              (this.smaaPass = new AV(this.camera, _));
          }
          _initPasses() {
            if (
              (this.uvEffectPass?.dispose(),
              this.effectPass?.dispose(),
              this.effectComposer.removeAllPasses(),
              this.transmissionPass.updatePasses(this.renderer),
              this.effectComposer.addPass(this.opaquePass),
              this.effectComposer.addPass(this.transmissionPass),
              this.postprocessingState.enabled)
            ) {
              let _ = [this.effects.get("pixelation")].reduce(rI, []);
              _.length > 0 &&
                ((this.uvEffectPass = new AV(this.camera, ..._)),
                this.effectComposer.addPass(this.uvEffectPass));
              let L = [
                this.effects.get("chromaticAberration"),
                this.effects.get("bloom"),
                this.effects.get("colorAverage"),
                this.effects.get("hueSaturation"),
                this.effects.get("brightnessContrast"),
                this.effects.get("vignette"),
                this.effects.get("noise"),
              ].reduce(rI, []);
              L.length > 0 &&
                ((this.effectPass = new AV(this.camera, ...L)),
                this.effectComposer.addPass(this.effectPass));
            }
            this.effectComposer.addPass(this.helperPass),
              this.effectComposer.addPass(this.helperClearPass),
              this.effectComposer.addPass(this.helperPassOnTop),
              this.effectComposer.addPass(this.smaaPass);
          }
          _initCopyPass() {
            if (this._savePass) return;
            let _ = new iT();
            this.renderer.getDrawingBufferSize(_),
              (this._rt = new iH(_.x, _.y, {
                depthBuffer: !1,
                stencilBuffer: !1,
                wrapS: 1e3,
                wrapT: 1e3,
              })),
              (this._rt.samples = 0),
              (this._savePass = new AP(this._rt, !1)),
              (this._savePass.renderToScreen = !1);
          }
          get renderToScreen() {
            return this._renderToScreen;
          }
          set renderToScreen(_) {
            if (this._renderToScreen === _) return;
            let L = this.effectComposer;
            L &&
              (!0 === _
                ? (L.removePass(this._savePass),
                  (L.passes[L.passes.length - 1].renderToScreen = !0),
                  (L.autoRenderToScreen = !0))
                : ((L.autoRenderToScreen = !1),
                  (L.passes[L.passes.length - 1].renderToScreen = !1),
                  (this._savePass.renderToScreen = !1),
                  this.postprocessingState.enabled ||
                    (this._savePass.needsDepthTexture = !0),
                  L.addPass(this._savePass)),
              (this._renderToScreen = _));
          }
          get texture() {
            return this._rt && this._rt.texture;
          }
          get renderTarget() {
            return this._rt;
          }
          updatePostprocessing(_) {
            let { enabled: L, ...R } = _,
              N = !1;
            for (let _ of (L !== this.postprocessingState.enabled && (N = !0),
            Object.entries(R))) {
              let L = _[1],
                R = this.effects.get(_[0]);
              if (R)
                for (let [_, z] of (R.enabled !== L.enabled && (N = !0),
                (R.enabled = L.enabled),
                Object.entries(L)))
                  "blendFunction" === _
                    ? (R.blendFunction = A6(z))
                    : (R[_] = z);
            }
            (this.postprocessingState = _), N && this._initPasses();
          }
          render() {
            this.effectComposer.render(this.clock.getDelta());
          }
          setScissor(_, L, R, N) {
            _ instanceof iV
              ? (this.effectComposer.inputBuffer.scissor.set(
                  _.x,
                  _.y,
                  _.z,
                  _.w,
                ),
                this.effectComposer.outputBuffer.scissor.set(
                  _.x,
                  _.y,
                  _.z,
                  _.w,
                ))
              : (this.effectComposer.inputBuffer.scissor.set(_, L, R, N),
                this.effectComposer.outputBuffer.scissor.set(_, L, R, N));
            let z = this.renderer.getPixelRatio();
            this.effectComposer.inputBuffer.scissor.multiplyScalar(z),
              this.effectComposer.outputBuffer.scissor.multiplyScalar(z),
              this.renderer.setScissor(_, L, R, N);
          }
          setScissorTest(_) {
            (this.effectComposer.inputBuffer.scissorTest = _),
              (this.effectComposer.outputBuffer.scissorTest = _),
              this.renderer.setScissorTest(_);
          }
          setViewport(_, L, R, N) {
            _ instanceof iV
              ? (this.effectComposer.inputBuffer.viewport.copy(_),
                this.effectComposer.outputBuffer.viewport.copy(_))
              : (this.effectComposer.inputBuffer.viewport.set(_, L, R, N),
                this.effectComposer.outputBuffer.viewport.set(_, L, R, N));
          }
          resize(_, L, R) {
            if ((this.effectComposer.setSize(_, L, R), this._rt)) {
              let R = this.renderer.getPixelRatio();
              this._rt.setSize(_ * R, L * R);
            }
          }
          dispose() {
            this.uvEffectPass?.dispose(),
              this.effectPass?.dispose(),
              this.effectComposer.dispose();
          }
        },
        MO = new iG(),
        ML = class extends v0 {
          constructor(_) {
            super(_),
              (this._pixelRatio = this.getPixelRatio()),
              (this.viewportWidth = 1),
              (this.viewportHeight = 1),
              (this.resolution = new iT()),
              (this.pipeline = new MD(this)),
              (this.overrideTransmission = _?.overrideTransmission),
              (this.autoClear = !1);
            let L = this.setPixelRatio.bind(this),
              R = this.setSize.bind(this),
              N = this.getContext();
            if (N && "drawingBufferColorSpace" in N)
              try {
                N.drawingBufferColorSpace = "display-p3";
              } catch (_) {
                console.warn(_);
              }
            (this.setPixelRatio = (_) => {
              (this._pixelRatio = _), L(_);
            }),
              (this.setSize = (_, L, N = !0) => {
                (this.viewportWidth !== _ || this.viewportHeight !== L) &&
                  ((this.viewportWidth = _),
                  (this.viewportHeight = L),
                  R(_, L, N),
                  this.normalRenderTarget?.setSize(
                    _ * this._pixelRatio,
                    L * this._pixelRatio,
                  ),
                  this.transmissionRenderTarget?.setSize(
                    (_ * this._pixelRatio) / 2,
                    (L * this._pixelRatio) / 2,
                  ),
                  this.transmissionDepthTarget?.setSize(
                    (_ * this._pixelRatio) / 2,
                    (L * this._pixelRatio) / 2,
                  ),
                  this.pipeline.resize(_, L, N));
              }),
              (this._superDispose = this.dispose),
              (this.dispose = this._currentDispose);
          }
          createTransmissionRenderTarget() {
            void 0 === this.transmissionRenderTarget &&
              ((this.transmissionRenderTarget = new iH(
                (this.viewportWidth * this._pixelRatio) / 2,
                (this.viewportHeight * this._pixelRatio) / 2,
                {
                  generateMipmaps: !0,
                  minFilter: 1008,
                  magFilter: 1006,
                  wrapS: 1001,
                  wrapT: 1001,
                  depthBuffer: !1,
                },
              )),
              (this.transmissionDepthTarget = new iH(
                (this.viewportWidth * this._pixelRatio) / 2,
                (this.viewportHeight * this._pixelRatio) / 2,
                { minFilter: 1003, magFilter: 1003, depthBuffer: !1 },
              )));
          }
          createNormalRenderTarget() {
            void 0 === this.normalRenderTarget &&
              (this.normalRenderTarget = new iH(
                this.viewportWidth * this._pixelRatio,
                this.viewportHeight * this._pixelRatio,
                {
                  generateMipmaps: !1,
                  minFilter: 1003,
                  magFilter: 1003,
                  type: 1015,
                  depthTexture: new nJ(
                    this.viewportWidth * this._pixelRatio,
                    this.viewportHeight * this._pixelRatio,
                  ),
                },
              ));
          }
          renderNormal(_, L) {
            this.normalRenderTarget &&
              (this.setClearColor(0),
              L.layers.enable(8),
              L.layers.disable(0),
              L.layers.disable(3),
              this.setRenderTarget(this.normalRenderTarget),
              this.clear(),
              L instanceof bj
                ? (ws.uniforms.depthContrast.value = (L.far - L.near) / 1e4)
                : (ws.uniforms.depthContrast.value = 1),
              (_.overrideMaterial = ws),
              this.render(_, L),
              this.setClearColor(_.bgColor, _.bgColor.a),
              this.setRenderTarget(null),
              (_.overrideMaterial = _.wireframeState ? wa : null),
              L.layers.enable(0),
              L.layers.enable(3));
          }
          renderSplineScene(_, L, R, N, z) {
            this.setClearColor(_.bgColor, _.bgColor.a),
              R.penumbraSize.forEach((_, L) => {
                yF.penumbraSize.value[L] = _;
              }),
              (yF.pixelRatioNode.value = this.getPixelRatio()),
              0 !== this.resolution.x && 0 !== this.resolution.y
                ? yF.resolution.value.set(this.resolution.x, this.resolution.y)
                : yF.resolution.value.set(
                    this.viewportWidth * this._pixelRatio,
                    this.viewportHeight * this._pixelRatio,
                  ),
              void 0 !== this.overrideNormal
                ? ((yF.normalRenderTarget.value = this.overrideNormal),
                  (yF.normalRenderTargetDepth.value = MO))
                : _.needsNormal() &&
                  (this.createNormalRenderTarget(),
                  (yF.normalRenderTarget.value =
                    this.normalRenderTarget.texture),
                  (yF.normalRenderTargetDepth.value =
                    this.normalRenderTarget.depthTexture),
                  this.renderNormal(_, L));
            let F = !1;
            if (void 0 !== this.overrideTransmission)
              (yF.transmissionRenderTarget.value = this.overrideTransmission),
                (yF.transmissionRenderTargetDepth.value = MO),
                this.pipeline.setTransmissionPassEnabled(!1);
            else {
              let L = _.needsTransmission();
              L &&
                (void 0 === this.transmissionRenderTarget && (F = !0),
                this.createTransmissionRenderTarget(),
                (yF.transmissionRenderTarget.value =
                  this.transmissionRenderTarget.texture),
                (yF.transmissionRenderTargetDepth.value =
                  this.transmissionDepthTarget.texture)),
                this.pipeline.setTransmissionPassEnabled(L);
            }
            L.layers.enable(3),
              L.layers.enable(8),
              (this.pipeline.sceneHelpers = N),
              (this.pipeline.sceneHelpersOnTop = z),
              (this.pipeline.scene = _),
              (this.pipeline.camera = L),
              F && this.pipeline.transmissionPass.updatePasses(this),
              this.pipeline.postprocessingState !== _.postprocessing &&
                this.pipeline.updatePostprocessing(_.postprocessing),
              void 0 !== this.clearAlphaOverride &&
                this.setClearAlpha(this.clearAlphaOverride),
              (_.overrideMaterial = _.wireframeState ? wa : null),
              this.pipeline.render();
          }
          _currentDispose() {
            this._superDispose(),
              this.pipeline.dispose(),
              this.transmissionRenderTarget?.dispose(),
              this.transmissionDepthTarget?.dispose(),
              this.normalRenderTarget?.dispose(),
              this.normalRenderTarget?.depthTexture?.dispose();
          }
        },
        MI = class {
          get sharedAssets() {
            return this.shared;
          }
          constructor(_, L = {}) {
            (this.shared = new xq(_.shared, L)),
              (this.scene = new wh(_.scene, this.sharedAssets)),
              this.scene.switchActiveCamera(this.scene.activeCamera);
          }
          reset(_, L) {
            this.scene.clearScene(),
              this.sharedAssets.reset(_.shared),
              this.scene.resetAfterClear(_.scene, this.sharedAssets);
          }
          dispose() {
            this.scene.dispose(), this.shared.dispose();
          }
          gc() {
            this.shared.geometryCache.startGc(),
              this.shared.geometryCache2.startGc(),
              this.scene.traverseEntity((_) => {
                _ instanceof xZ && _.markGeometryAsReachable(this.shared);
              }),
              this.shared.geometryCache.endGc(),
              this.shared.geometryCache2.endGc();
          }
        },
        MB = class {
          constructor({ x: _ = 10, y: L = 10 }) {
            this._startTime = 0;
            let R = document.getElementById("spe-perfs");
            R
              ? (this.element = R)
              : ((this.element = document.createElement("div")),
                document.body.appendChild(this.element),
                (this.element.style.position = "absolute"),
                (this.element.style.zIndex = "10000"),
                (this.element.style.fontFamily = "monospace"),
                (this.element.style.background = "black"),
                (this.element.style.color = "white"),
                (this.element.style.padding = "10px"),
                (this.element.style.opacity = "0.5"),
                (this.element.style.fontSize = "11px"),
                this.element.setAttribute("id", "spe-perfs")),
              (this.element.style.left = `${_}px`),
              (this.element.style.top = `${L}px`);
          }
          dispose() {
            this.element.parentElement?.removeChild(this.element);
          }
          start() {
            this._startTime = performance.now();
          }
          end() {
            let _ = performance.now() - this._startTime;
            this.element.innerHTML = _.toFixed(3) + " ms";
          }
        };
      function Cf(_) {
        return _ instanceof x$
          ? "SubdivObject"
          : "NonParametricGeometry" === _.geometry.type
            ? "NonParametric"
            : "Mesh";
      }
      var Mz = dd(is(), 1),
        MF = new iT(),
        MU = class {
          constructor(_, { renderOnDemand: L = !0 } = {}) {
            (this._viewportMode = 1),
              (this._viewportWidth = window.innerWidth),
              (this._viewportHeight = window.innerHeight),
              (this._proxyObjectCache = new Map()),
              (this._lastTime = performance.now()),
              (this.time = performance.now()),
              (this.dt = 0),
              (this._skipRender = !1),
              (this.renderOnDemand = !0),
              (this.disposed = !1),
              (this.requestRender = () => {
                this._skipRender = !1;
              }),
              (this.render = (_) => {
                this._renderer &&
                  ((this._rafId = requestAnimationFrame(this.render)),
                  (this.time = _),
                  (this.dt = this.time - this._lastTime),
                  (this._lastTime = this.time),
                  this._perfs?.start(),
                  (this.renderOnDemand && this._skipRender) ||
                    ((this._skipRender = this._controls?.update(this.dt) ?? !0),
                    this._eventManager &&
                      (this._eventManager.isEnable ||
                        this._eventManager.activate(),
                      this._eventManager.handlers.Follow.onAnimationFrameDamping(),
                      this._eventManager.handlers.LookAt.onAnimationFrameDamping(),
                      (this._eventManager.handlers.Start.hasVideoAction ||
                        this._eventManager.handlers.Basic.hasVideoAction ||
                        this._eventManager.handlers.Conditional
                          .hasVideoAction) &&
                        (this._skipRender = !1)),
                    this._scene &&
                      this._camera &&
                      (this._scene.pathConstraints.applyConstraints(
                        this._scene,
                      ),
                      this._renderer.renderSplineScene(
                        this._scene,
                        this._camera,
                        this._sharedAssetsManager,
                      )),
                    this._perfs?.end()));
              }),
              (this._resize = Qd(() => {
                this._renderer &&
                  (1 === this._viewportMode &&
                    this._frameView &&
                    (this._frameView.frameSize = MF.set(
                      this._viewportWidth,
                      this._viewportHeight,
                    )),
                  this._renderer.setSize(
                    this._viewportWidth,
                    this._viewportHeight,
                    !1,
                  ),
                  this._camera &&
                    (this._frameView?.updateCamera(),
                    "PerspectiveCamera" === this._camera.cameraType &&
                      (this._camera.aspect =
                        this._viewportWidth / this._viewportHeight),
                    this._camera.updateProjectionMatrix()),
                  this.requestRender());
              }, 10)),
              (this.canvas = _),
              (this.renderOnDemand = L),
              window.location.search.includes("perfs") &&
                (this._perfs = new MB({ x: 10, y: 10 })),
              _.addEventListener("pointerdown", xE, !0),
              _.addEventListener("pointerdown", Gm, !0),
              _.addEventListener("pointermove", Gm, !0),
              _.addEventListener("pointerup", Xc, !0),
              _.addEventListener("pointercancel", Xc, !0),
              _.addEventListener("pointerleave", Xc, !0),
              window.addEventListener("keydown", SE, !0),
              window.addEventListener("keyup", wE, !0);
          }
          async load(_, L) {
            let R;
            (R =
              "The Spline Runtime only accepts .splinecode files that are generated from Spline export panel."),
              _.endsWith(".spline")
                ? console.warn(
                    R +
                      " The .spline files are only meant to be used by the Editor.",
                  )
                : _.endsWith(".splinecode") || console.warn(R),
              (this.disposed = !1);
            let N = await (await fetch(_, L)).arrayBuffer();
            await this.start(N);
          }
          async start(_, { interactive: L = !0 } = {}) {
            let R;
            if (this.disposed) return;
            let N = await R2(_);
            (this._data = N),
              N.version &&
                (0, Mz.default)(N.version, "0.9.291") > 0 &&
                console.warn(
                  "Your .splinecode file is more recent than the library. Please upgrade @splinetool/runtime to the latest version.",
                ),
              await Promise.all(
                [
                  Yb(N) && dC(),
                  ((R = !1),
                  N.scene.objects.traverse((_, L) => {
                    "Mesh" === L.type &&
                      "SubdivGeometry" === L.geometry.type &&
                      (R = !0);
                  }),
                  R && rC()),
                  N.scene.environment.usePhysics && ET(),
                  Gb(N) && EC(),
                ].filter(Boolean),
              ),
              this._eventManager && this._eventManager.deactivate(),
              this._controls && this._controls.dispose(),
              this._scene?.dispose();
            let z = new MI(N);
            if (
              ((this._scene = z.scene),
              (this._sharedAssetsManager = z.sharedAssets),
              (this._camera = this._scene.activeCamera),
              window.location.search.includes("merge-geometries"))
            ) {
              let _ = performance.now();
              !(function (_, L) {
                let R, N;
                let z =
                    ((R = {}),
                    L.traverseEntity((L) => {
                      if (
                        !L.visible ||
                        !(L instanceof v6) ||
                        "Mesh" !== L.type ||
                        Array.isArray(L.material) ||
                        (L.states && Object.keys(L.states).length)
                      )
                        return;
                      let N = L.parent;
                      for (; N; ) {
                        if (
                          N instanceof v6 &&
                          L.states &&
                          Object.keys(L.states).length
                        )
                          return;
                        N = N.parent;
                      }
                      let z = L.material.uuid,
                        F = _.shared.materials[z];
                      if (F) {
                        if (!fU.isMergable(F)) return;
                      } else {
                        let R = _.scene.objects.get(L.uuid)?.data;
                        if (
                          R &&
                          "material" in R &&
                          "string" != typeof R.material
                        ) {
                          if (!fU.isMergable(R.material)) return;
                          z = fU.getHash(R.material);
                        }
                      }
                      R[z] || (R[z] = {});
                      let U = R[z][Cf(L)];
                      if (U) {
                        if ((U.push(L), L.cloner))
                          for (let _ of L.cloner.children) U.push(_);
                      } else if (((R[z][Cf(L)] = [L]), L.cloner))
                        for (let _ of L.cloner.children) R[z][Cf(L)].push(_);
                    }),
                    R),
                  F =
                    ((N = 0),
                    Object.values(z).forEach((_) => {
                      Object.values(_).forEach((_) => {
                        let L = _.length;
                        L > N && (N = L);
                      });
                    }),
                    N),
                  U = Array(F),
                  k = 0,
                  Y = Array(F),
                  X = 0,
                  Q = Array(F),
                  K = 0,
                  J = Array(F),
                  $ = 0;
                for (let [_, R] of Object.entries(z))
                  for (let N of Object.values(R)) {
                    if (
                      ((X = 0),
                      (K = 0),
                      N.forEach((_) => {
                        _ instanceof v6 &&
                          ((Y[X++] = _.geometry.clone()), (Q[K++] = _));
                      }),
                      K < 2)
                    )
                      continue;
                    for (let _ = 0; _ < K; _++)
                      Q[_].updateWorldMatrix(!0, !1),
                        Y[_].applyMatrix4(Q[_].matrixWorld),
                        0 > Q[_].matrixWorld.determinant() &&
                          (function (_) {
                            let L;
                            if (_.index)
                              for (let R = 0; R < _.index.array.length; R += 3)
                                (L = _.index.array[R]),
                                  (_.index.array[R] = _.index.array[R + 2]),
                                  (_.index.array[R + 2] = L);
                          })(Y[_]);
                    let R = no(Y.slice(0, X), !1);
                    if (R) {
                      let N;
                      "SubdivObject" === _ &&
                        console.warn("Turning subdiv object into mesh"),
                        ((N = new sH(R, Q[0].material)).castShadow =
                          Q[0].castShadow),
                        (N.receiveShadow = Q[0].receiveShadow),
                        L.add(N);
                      let y = (_) => {
                        for (let L of (($ = 0), _))
                          L.children && y(L.children),
                            L instanceof v6 &&
                              (Array.isArray(L.material) ||
                                (z[L.material.uuid] &&
                                  z[L.material.uuid][Cf(L)] &&
                                  z[L.material.uuid][Cf(L)].length > 1) ||
                                (J[$++] = L));
                        for (let _ = 0; _ < $; _++) L.attach(J[_]);
                      };
                      for (let _ = 0; _ < K; _++) {
                        let L = Q[_];
                        y(L.children), (U[k++] = L);
                      }
                    }
                  }
                for (let _ = 0; _ < k; _++) U[_].removeFromParent();
              })(N, z.scene),
                console.log(
                  "Merged geometries in ",
                  performance.now() - _,
                  " ms",
                );
            }
            if (
              (Yb(N) &&
                this._scene.traverse((_) => {
                  ei(_) && _.recomputeBoolean();
                }),
              this._sharedAssetsManager.setRequestRender(() => {
                this.requestRender(),
                  this._scene?.traverse((_) => {
                    _ instanceof bM && _.pendingMediaLoad && _.update();
                  });
              }),
              Gb(N) &&
                (function (_) {
                  if (_.scene.environment.usePhysics) return !0;
                  let L = !1;
                  return (
                    _.scene.objects.traverse((_, R) => {
                      for (let _ of R.events)
                        if (
                          !0 !== _.data.disabled &&
                          "GameControl" === _.data.type &&
                          _.data.collisionEnabled
                        ) {
                          L = !0;
                          break;
                        }
                    }),
                    L
                  );
                })(N))
            ) {
              let _ = Object.keys(N.shared.fonts)
                .map((_) => this._sharedAssetsManager.getFont(_))
                .map((_) => _.loadingPromise);
              await Promise.all(_);
            }
            if (
              (this._scene.rewriteEventsBeforeGoToPlayMode(),
              ly(N.scene, this._scene, this._sharedAssetsManager),
              this._renderer ||
                ((this._renderer = new ML({
                  canvas: this.canvas,
                  antialias: !1,
                  alpha: !0,
                  stencil: !1,
                  depth: !1,
                  powerPreference: "high-performance",
                })),
                this._renderer.setPixelRatio(window.devicePixelRatio),
                this._renderer.pipeline.addEventListener(
                  "smaaloaded",
                  this.requestRender,
                ),
                (this._renderer.shadowMap.enabled = !0),
                (this._renderer.shadowMap.type = N.scene.environment
                  .ambientLight.softShadows
                  ? 1
                  : 2),
                aP(N.scene.environment.ambientLight.softShadowQuality)),
              this._frameView)
            )
              this._frameView.setCamera(this._camera);
            else {
              let _ = Object.values(N.frames)[0];
              "fullscreen" === _.preset
                ? ((this._viewportMode = 1),
                  this.canvas.parentElement &&
                    ((this._viewportWidth =
                      this.canvas.parentElement.clientWidth || 300),
                    (this.canvas.style.width = "100%")),
                  this.canvas.parentElement &&
                    ((this._viewportHeight =
                      this.canvas.parentElement.clientHeight || 150),
                    (this.canvas.style.height = "100%")))
                : ((this._viewportMode = 2),
                  (this._viewportWidth = _.size[0]),
                  (this._viewportHeight = _.size[1]),
                  (this.canvas.style.width = `${this._viewportWidth}px`),
                  (this.canvas.style.height = `${this._viewportHeight}px`)),
                this._renderer.setSize(
                  this._viewportWidth,
                  this._viewportHeight,
                  !1,
                ),
                (this._frameView = new S9(
                  this._renderer,
                  this._camera,
                  new iT(this._viewportWidth, this._viewportHeight),
                  new iT(window.innerWidth, window.innerHeight),
                ));
            }
            if (
              (L &&
                (this._scene.updateMatrixWorld(!0),
                (this._controls = new Sl(
                  N,
                  this._scene,
                  this._renderer,
                  this.requestRender,
                  this._sharedAssetsManager,
                  !0,
                )),
                (this._eventManager = new S8(
                  this._renderer,
                  this._scene,
                  this._camera,
                  N.scene.publish.stopRaycast,
                  N.scene.publish.preventScroll,
                  N.scene.publish.preventTouchScroll,
                  N.scene.publish.hideCursor,
                  this._sharedAssetsManager,
                  this.requestRender,
                  this._controls,
                  !0,
                ))),
              this._resize(),
              !this._resizeObserver && this.canvas.parentElement)
            ) {
              let _ = !0;
              (this._resizeObserver = new ResizeObserver(() => {
                if (_) {
                  _ = !1;
                  return;
                }
                (this._viewportWidth = this.canvas.clientWidth),
                  (this._viewportHeight = this.canvas.clientHeight),
                  this._resize();
              })),
                this._resizeObserver.observe(this.canvas.parentElement);
            }
            void 0 === this._rafId
              ? this.render(performance.now())
              : this.requestRender();
          }
          findObjectById(_) {
            let L = this._scene?.getObjectByProperty("uuid", _);
            return this._createProxyObject(L);
          }
          findObjectByName(_) {
            let L = this._scene?.getObjectByName(_);
            return this._createProxyObject(L);
          }
          getSplineEvents() {
            return this._eventManager?.handlers.Spline.splineEvents;
          }
          emitEvent(_, L) {
            (this.findObjectById(L) || this.findObjectByName(L))?.emitEvent(_);
          }
          emitEventReverse(_, L) {
            (
              this.findObjectById(L) || this.findObjectByName(L)
            )?.emitEventReverse(_);
          }
          addEventListener(_, L) {
            this.canvas.addEventListener(_, L);
          }
          removeEventListener(_, L) {
            this.canvas.removeEventListener(_, L);
          }
          setZoom(_) {
            this._controls?.orbitControls instanceof S1 &&
              this._controls?.orbitControls.zoomOut(_);
          }
          get eventManager() {
            return this._eventManager;
          }
          get controls() {
            return this._controls;
          }
          setSize(_, L) {
            (this._viewportWidth = _),
              (this._viewportHeight = L),
              (this._viewportMode = 2),
              this._resize();
          }
          setBackgroundColor(_) {
            let { r: L, g: R, b: N, a: z } = { r: 0, g: 0, b: 0, a: 1 },
              F = new ys(L, R, N, z);
            try {
              F.setStyle(_);
            } catch {
              console.error("This is not a valid css color", _);
            }
            this._scene?.setBackgroundColor(F), this.requestRender();
          }
          dispose() {
            var _;
            (this.disposed = !0),
              this._eventManager?.deactivate(),
              this._scene?.dispose(),
              this._sharedAssetsManager?.dispose(),
              this._rafId && cancelAnimationFrame(this._rafId),
              this._proxyObjectCache.forEach((_) => {
                I0.unsubscribe(_);
              }),
              this._renderer?.dispose(),
              this._sharedAssetsManager?.dispose(),
              this._resizeObserver &&
                (this._resizeObserver.disconnect(),
                (this._resizeObserver = void 0)),
              (this.canvas.style.width = ""),
              (this.canvas.style.height = ""),
              this.canvas.removeAttribute("width"),
              this.canvas.removeAttribute("height"),
              this._frameView && (this._frameView = void 0),
              this._controls?.dispose(),
              (_ = this.canvas).removeEventListener("pointerdown", xE, !0),
              _.removeEventListener("pointerdown", Gm, !0),
              _.removeEventListener("pointermove", Gm, !0),
              _.removeEventListener("pointerup", Xc, !0),
              _.removeEventListener("pointercancel", Xc, !0),
              _.removeEventListener("pointerleave", Xc, !0),
              window.removeEventListener("keydown", SE, !0),
              window.removeEventListener("keyup", wE, !0);
          }
          get data() {
            return this._data;
          }
          _createProxyObject(_) {
            if (null == _) return;
            if (this._proxyObjectCache.has(_.uuid))
              return this._proxyObjectCache.get(_.uuid);
            let L = I0(
              {
                name: _.name,
                uuid: _.uuid,
                visible: _.visible,
                intensity: _.intensity,
                position: _.position,
                rotation: _.rotation,
                scale: _.scale,
                emitEvent(L) {
                  _.dispatchEvent({ type: "userEvent", eventName: L });
                },
                emitEventReverse(L) {
                  _.dispatchEvent({
                    type: "userEvent",
                    eventName: L,
                    reverse: !0,
                  });
                },
              },
              (L, R) => {
                "object" != typeof _[L] &&
                  Object.getOwnPropertyDescriptor(_, L)?.writable &&
                  (_[L] = R),
                  this.requestRender(),
                  _.updateMatrix();
              },
            );
            return this._proxyObjectCache.set(_.uuid, L), L;
          }
        };
    },
  },
]);
